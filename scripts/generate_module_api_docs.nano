# Generate API Documentation from Module Reflection (NanoLang)
# Usage:
#   ./bin/nanoc scripts/generate_module_api_docs.nano -o bin/generate_module_api_docs
#   ./bin/generate_module_api_docs <module.nano> <output.md>

extern fn get_argc() -> int
extern fn get_argv(index: int) -> string
import "modules/std/fs.nano" as fs
import "modules/std/json/json.nano" as json
import "modules/std/process.nano" as proc
from "modules/std/collections/stringbuilder.nano" import StringBuilder, sb_new, sb_append, sb_append_line, sb_to_string

fn extract_module_name(path: string) -> string {
    let filename: string = (fs.basename path)
    let flen: int = (str_length filename)
    if (and (> flen 5) (== (str_substring filename (- flen 5) 5) ".nano")) {
        return (str_substring filename 0 (- flen 5))
    }
    return filename
}

shadow extract_module_name {
    assert (== (extract_module_name "modules/sdl/sdl.nano") "sdl")
    assert (== (extract_module_name "stdlib/log.nano") "log")
    assert (== (extract_module_name "foo") "foo")
}

fn get_string_field(obj: json.Json, key: string) -> string {
    return (json.get_string obj key)
}

shadow get_string_field {
    let root: json.Json = (json.parse "{\"name\":\"x\"}")
    assert (== (get_string_field root "name") "x")
    (json.free root)
}

fn get_bool_field(obj: json.Json, key: string) -> bool {
    let it: json.Json = (json.get obj key)
    if (== it 0) { return false }
    let out: bool = (json.as_bool it)
    (json.free it)
    return out
}

shadow get_bool_field {
    let root: json.Json = (json.parse "{\"ok\":true}")
    assert (== (get_bool_field root "ok") true)
    (json.free root)
}

fn format_value(item: json.Json) -> string {
    if (== item 0) { return "*not available*" }
    return (json.stringify item)
}

shadow format_value {
    let root: json.Json = (json.parse "{\"a\":1,\"b\":true,\"c\":\"x\"}")
    let a: string = (format_value (json.get root "a"))
    let b: string = (format_value (json.get root "b"))
    let c: string = (format_value (json.get root "c"))
    assert (> (str_length a) 0)
    assert (> (str_length b) 0)
    assert (> (str_length c) 0)
    (json.free root)
}

fn append_param_table(sb: StringBuilder, params: json.Json) -> StringBuilder {
    if (not (json.is_array params)) { return sb }
    let count: int = (json.array_size params)
    if (<= count 0) { return sb }

    let mut out: StringBuilder = (sb_append_line sb "**Parameters:**")
    set out (sb_append_line out "| Name | Type |")
    set out (sb_append_line out "|------|------|")

    let mut i: int = 0
    while (< i count) {
        let param: json.Json = (json.get_index params i)
        let pname: string = (get_string_field param "name")
        let ptype: string = (get_string_field param "type")
        set out (sb_append_line out (+ "| `" (+ pname (+ "` | `" (+ ptype "` |")))))
        (json.free param)
        set i (+ i 1)
    }
    set out (sb_append_line out "")
    return out
}

shadow append_param_table {
    let sb: StringBuilder = (sb_new)
    let root: json.Json = (json.parse "{\"params\":[{\"name\":\"x\",\"type\":\"int\"}]}" )
    let arr: json.Json = (json.get root "params")
    let sb2: StringBuilder = (append_param_table sb arr)
    let out: string = (sb_to_string sb2)
    assert (> (str_length out) 0)
    (json.free arr)
    (json.free root)
}

fn generate_functions(exports: json.Json, sb: StringBuilder) -> StringBuilder {
    let mut out: StringBuilder = (sb_append_line sb "### Functions")
    set out (sb_append_line out "")

    let mut found: bool = false
    let count: int = (json.array_size exports)
    let mut i: int = 0
    while (< i count) {
        let entry: json.Json = (json.get_index exports i)
        let kind: string = (get_string_field entry "kind")
        if (== kind "function") {
            let is_pub: bool = (get_bool_field entry "is_public")
            let is_ext: bool = (get_bool_field entry "is_extern")
            if (or is_pub is_ext) {
                set found true
                let signature: string = (get_string_field entry "signature")
                set out (sb_append_line out (+ "#### `" (+ signature "`")))
                set out (sb_append_line out "")
                let params: json.Json = (json.get entry "params")
                set out (append_param_table out params)
                (json.free params)
                let rtype: string = (get_string_field entry "return_type")
                set out (sb_append_line out (+ "**Returns:** `" (+ rtype "`")))
                set out (sb_append_line out "")
                set out (sb_append_line out "")
            }
        }
        (json.free entry)
        set i (+ i 1)
    }

    if (not found) {
        set out (sb_append_line out "*No public functions*")
        set out (sb_append_line out "")
    }
    return out
}

shadow generate_functions {
    let sb: StringBuilder = (sb_new)
    let root: json.Json = (json.parse "{\"exports\":[{\"kind\":\"function\",\"name\":\"f\",\"signature\":\"fn f() -> int\",\"return_type\":\"int\",\"is_public\":true,\"is_extern\":false,\"params\":[]}]}" )
    let exports: json.Json = (json.get root "exports")
    let sb2: StringBuilder = (generate_functions exports sb)
    let out: string = (sb_to_string sb2)
    assert (> (str_length out) 0)
    (json.free exports)
    (json.free root)
}

fn generate_structs(exports: json.Json, sb: StringBuilder) -> StringBuilder {
    let mut out: StringBuilder = (sb_append_line sb "### Structs")
    set out (sb_append_line out "")

    let mut found: bool = false
    let count: int = (json.array_size exports)
    let mut i: int = 0
    while (< i count) {
        let entry: json.Json = (json.get_index exports i)
        let kind: string = (get_string_field entry "kind")
        if (== kind "struct") {
            let is_pub: bool = (get_bool_field entry "is_public")
            if is_pub {
                set found true
                let name: string = (get_string_field entry "name")
                set out (sb_append_line out (+ "#### `struct " (+ name "`")))
                set out (sb_append_line out "")

                let fields: json.Json = (json.get entry "fields")
                if (json.is_array fields) {
                    let fcount: int = (json.array_size fields)
                    if (> fcount 0) {
                        set out (sb_append_line out "**Fields:**")
                        set out (sb_append_line out "| Name | Type |")
                        set out (sb_append_line out "|------|------|")
                        let mut j: int = 0
                        while (< j fcount) {
                            let field: json.Json = (json.get_index fields j)
                            let fname: string = (get_string_field field "name")
                            let ftype: string = (get_string_field field "type")
                            set out (sb_append_line out (+ "| `" (+ fname (+ "` | `" (+ ftype "` |")))))
                            (json.free field)
                            set j (+ j 1)
                        }
                        set out (sb_append_line out "")
                    } else {
                        set out (sb_append_line out "*Opaque struct (no public fields)*")
                        set out (sb_append_line out "")
                    }
                }
                (json.free fields)

                set out (sb_append_line out "")
            }
        }
        (json.free entry)
        set i (+ i 1)
    }

    if (not found) {
        set out (sb_append_line out "*No public structs*")
        set out (sb_append_line out "")
    }
    return out
}

shadow generate_structs {
    let sb: StringBuilder = (sb_new)
    let root: json.Json = (json.parse "{\"exports\":[{\"kind\":\"struct\",\"name\":\"S\",\"is_public\":true,\"fields\":[]}]}" )
    let exports: json.Json = (json.get root "exports")
    let sb2: StringBuilder = (generate_structs exports sb)
    let out: string = (sb_to_string sb2)
    assert (> (str_length out) 0)
    (json.free exports)
    (json.free root)
}

fn generate_enums(exports: json.Json, sb: StringBuilder) -> StringBuilder {
    let mut out: StringBuilder = (sb_append_line sb "### Enums")
    set out (sb_append_line out "")

    let mut found: bool = false
    let count: int = (json.array_size exports)
    let mut i: int = 0
    while (< i count) {
        let entry: json.Json = (json.get_index exports i)
        let kind: string = (get_string_field entry "kind")
        if (== kind "enum") {
            let is_pub: bool = (get_bool_field entry "is_public")
            if is_pub {
                set found true
                let name: string = (get_string_field entry "name")
                set out (sb_append_line out (+ "#### `enum " (+ name "`")))
                set out (sb_append_line out "")

                let variants: json.Json = (json.get entry "variants")
                if (json.is_array variants) {
                    let vcount: int = (json.array_size variants)
                    if (> vcount 0) {
                        set out (sb_append_line out "**Variants:**")
                        let mut j: int = 0
                        while (< j vcount) {
                            let vitem: json.Json = (json.get_index variants j)
                            let vname: string = (cond
                                ((json.is_string vitem) (json.as_string vitem))
                                (else "")
                            )
                            set out (sb_append_line out (+ "- `" (+ vname "`")))
                            (json.free vitem)
                            set j (+ j 1)
                        }
                        set out (sb_append_line out "")
                    }
                }
                (json.free variants)

                set out (sb_append_line out "")
            }
        }
        (json.free entry)
        set i (+ i 1)
    }

    if (not found) {
        set out (sb_append_line out "*No public enums*")
        set out (sb_append_line out "")
    }
    return out
}

shadow generate_enums {
    let sb: StringBuilder = (sb_new)
    let root: json.Json = (json.parse "{\"exports\":[{\"kind\":\"enum\",\"name\":\"E\",\"is_public\":true,\"variants\":[\"A\"]}]}" )
    let exports: json.Json = (json.get root "exports")
    let sb2: StringBuilder = (generate_enums exports sb)
    let out: string = (sb_to_string sb2)
    assert (> (str_length out) 0)
    (json.free exports)
    (json.free root)
}

fn generate_unions(exports: json.Json, sb: StringBuilder) -> StringBuilder {
    let mut out: StringBuilder = (sb_append_line sb "### Unions")
    set out (sb_append_line out "")

    let mut found: bool = false
    let count: int = (json.array_size exports)
    let mut i: int = 0
    while (< i count) {
        let entry: json.Json = (json.get_index exports i)
        let kind: string = (get_string_field entry "kind")
        if (== kind "union") {
            let is_pub: bool = (get_bool_field entry "is_public")
            if is_pub {
                set found true
                let name: string = (get_string_field entry "name")
                set out (sb_append_line out (+ "#### `union " (+ name "`")))
                set out (sb_append_line out "")

                let variants: json.Json = (json.get entry "variants")
                if (json.is_array variants) {
                    let vcount: int = (json.array_size variants)
                    if (> vcount 0) {
                        set out (sb_append_line out "**Variants:**")
                        let mut j: int = 0
                        while (< j vcount) {
                            let vitem: json.Json = (json.get_index variants j)
                            let vname: string = (get_string_field vitem "name")
                            let fields: json.Json = (json.get vitem "fields")
                            if (json.is_array fields) {
                                let fcount: int = (json.array_size fields)
                                if (> fcount 0) {
                                    let mut line: string = (+ "- `" (+ vname "("))
                                    let mut k: int = 0
                                    while (< k fcount) {
                                        let fitem: json.Json = (json.get_index fields k)
                                        let fname: string = (get_string_field fitem "name")
                                        let ftype: string = (get_string_field fitem "type")
                                        if (> k 0) {
                                            set line (+ line ", ")
                                        }
                                        set line (+ line (+ fname (+ ": " ftype)))
                                        (json.free fitem)
                                        set k (+ k 1)
                                    }
                                    set line (+ line ")`")
                                    set out (sb_append_line out line)
                                } else {
                                    set out (sb_append_line out (+ "- `" (+ vname "`")))
                                }
                            } else {
                                set out (sb_append_line out (+ "- `" (+ vname "`")))
                            }
                            (json.free fields)
                            (json.free vitem)
                            set j (+ j 1)
                        }
                        set out (sb_append_line out "")
                    }
                }
                (json.free variants)

                set out (sb_append_line out "")
            }
        }
        (json.free entry)
        set i (+ i 1)
    }

    if (not found) {
        set out (sb_append_line out "*No public unions*")
        set out (sb_append_line out "")
    }
    return out
}

shadow generate_unions {
    let sb: StringBuilder = (sb_new)
    let root: json.Json = (json.parse "{\"exports\":[{\"kind\":\"union\",\"name\":\"U\",\"is_public\":true,\"variants\":[{\"name\":\"Ok\",\"fields\":[]}]}]}" )
    let exports: json.Json = (json.get root "exports")
    let sb2: StringBuilder = (generate_unions exports sb)
    let out: string = (sb_to_string sb2)
    assert (> (str_length out) 0)
    (json.free exports)
    (json.free root)
}

fn generate_opaque_types(exports: json.Json, sb: StringBuilder) -> StringBuilder {
    let mut out: StringBuilder = (sb_append_line sb "### Opaque Types")
    set out (sb_append_line out "")

    let mut found: bool = false
    let count: int = (json.array_size exports)
    let mut i: int = 0
    while (< i count) {
        let entry: json.Json = (json.get_index exports i)
        let kind: string = (get_string_field entry "kind")
        if (== kind "opaque") {
            set found true
            let name: string = (get_string_field entry "name")
            set out (sb_append_line out (+ "- `opaque type " (+ name "`")))
        }
        (json.free entry)
        set i (+ i 1)
    }

    if (== found true) {
        set out (sb_append_line out "")
    } else {
        set out (sb_append_line out "*No opaque types*")
        set out (sb_append_line out "")
    }
    return out
}

shadow generate_opaque_types {
    let sb: StringBuilder = (sb_new)
    let root: json.Json = (json.parse "{\"exports\":[{\"kind\":\"opaque\",\"name\":\"T\"}]}" )
    let exports: json.Json = (json.get root "exports")
    let sb2: StringBuilder = (generate_opaque_types exports sb)
    let out: string = (sb_to_string sb2)
    assert (> (str_length out) 0)
    (json.free exports)
    (json.free root)
}

fn generate_constants(exports: json.Json, sb: StringBuilder) -> StringBuilder {
    let mut out: StringBuilder = (sb_append_line sb "### Constants")
    set out (sb_append_line out "")

    let mut found: bool = false
    let count: int = (json.array_size exports)
    let mut i: int = 0
    while (< i count) {
        let entry: json.Json = (json.get_index exports i)
        let kind: string = (get_string_field entry "kind")
        if (== kind "constant") {
            if (not found) {
                set out (sb_append_line out "| Name | Type | Value |")
                set out (sb_append_line out "|------|------|-------|")
                set found true
            }
            let name: string = (get_string_field entry "name")
            let ctype: string = (get_string_field entry "type")
            let val_item: json.Json = (json.get entry "value")
            let val_str: string = (format_value val_item)
            set out (sb_append_line out (+ "| `" (+ name (+ "` | `" (+ ctype (+ "` | `" (+ val_str "` |")))))))
            (json.free val_item)
        }
        (json.free entry)
        set i (+ i 1)
    }

    if (not found) {
        set out (sb_append_line out "*No constants*")
    }
    set out (sb_append_line out "")
    return out
}

shadow generate_constants {
    let sb: StringBuilder = (sb_new)
    let root: json.Json = (json.parse "{\"exports\":[{\"kind\":\"constant\",\"name\":\"A\",\"type\":\"int\",\"value\":1}]}" )
    let exports: json.Json = (json.get root "exports")
    let sb2: StringBuilder = (generate_constants exports sb)
    let out: string = (sb_to_string sb2)
    assert (> (str_length out) 0)
    (json.free exports)
    (json.free root)
}

fn generate_api_docs(module_path: string, output_path: string) -> bool {
    let module_name: string = (extract_module_name module_path)

    (println (+ "Generating API docs for " (+ module_name "...")))

    let json_path: string = (+ "/tmp/nanolang_reflect_" (+ module_name ".json"))
    let cmd: string = (+ "NANO_MODULE_PATH=./modules perl -e 'alarm 60; exec @ARGV' ./bin/nanoc " (+ module_path (+ " --reflect " json_path)))

    let result: proc.Output = (proc.run cmd)
    if (!= result.code 0) {
        (println "Error: Reflection failed")
        (println result.stderr)
        return false
    }

    if (not (fs.file_exists json_path)) {
        (println "Error: Reflection output not found")
        return false
    }

    let json_text: string = (fs.file_read json_path)
    let root: json.Json = (json.parse json_text)
    if (not (json.is_object root)) {
        (println "Error: Invalid JSON output")
        return false
    }

    let exports: json.Json = (json.get root "exports")
    if (not (json.is_array exports)) {
        (println "Error: JSON missing exports array")
        (json.free exports)
        (json.free root)
        return false
    }

    let sb: StringBuilder = (sb_new)
    let mut out: StringBuilder = (sb_append_line sb (+ "# " (+ module_name " API Reference")))
    set out (sb_append_line out "")
    set out (sb_append_line out "*Auto-generated from module reflection*")
    set out (sb_append_line out "")
    set out (sb_append_line out "")

    set out (generate_functions exports out)
    set out (generate_structs exports out)
    set out (generate_enums exports out)
    set out (generate_unions exports out)
    set out (generate_opaque_types exports out)
    set out (generate_constants exports out)

    let markdown: string = (sb_to_string out)
    (fs.file_write output_path markdown)

    (json.free exports)
    (json.free root)
    (println (+ "âœ“ Generated " output_path))
    return true
}

fn cli_main() -> int {
    let argc: int = (get_argc)
    if (< argc 3) {
        (println "Usage: generate_module_api_docs <module.nano> <output.md>")
        return 0
    }

    let module_path: string = (get_argv 1)
    let output_path: string = (get_argv 2)

    if (generate_api_docs module_path output_path) {
        return 0
    }
    return 1
}

fn main() -> int {
    return (cli_main)
}

shadow main {
    # Avoid running CLI path in tests (would spawn compiler)
    assert (== 1 1)
}


shadow cli_main {
    # CLI uses extern argv/argc; ensure it is callable
    assert (== 1 1)
}

shadow generate_api_docs {
    # Avoid recursive compiler invocation in tests
    assert (== 1 1)
}
