#!/usr/bin/env nanoc
# Generate shared compiler schema artifacts for NanoLang
# Replaces gen_compiler_schema.py for Python-free bootstrap

from "std/fs.nano" import read, write, join, file_delete
from "std/json/json.nano" import parse, free, get, is_string, is_object, is_array, array_size, get_index, as_string, as_int, object_has, object_keys

let HEADER_COMMENT: string = "/* AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY. */"
let C_GUARD: string = "NANOLANG_GENERATED_COMPILER_SCHEMA_H"

fn write_if_changed(path: string, content: string) -> int {
    let current: string = (read path)
    if (str_equals current content) {
        return 0
    }
    return (write path content)
}

shadow write_if_changed {
    let test_path: string = "/tmp/nanolang_schema_write_if_changed.txt"
    let content: string = "same"
    assert (== (write_if_changed test_path content) 0)
    assert (== (write_if_changed test_path content) 0)
    let content2: string = "different"
    assert (== (write_if_changed test_path content2) 0)
    (file_delete test_path)
}

# Get token count
fn get_token_count(tokens_json: Json) -> int {
    return (array_size tokens_json)
}

shadow get_token_count {
    let empty: Json = (nl_json_new_array)
    let count: int = (get_token_count empty)
    assert (== count 0)
    (free empty)
}

# Generate NanoLang schema enums
fn gen_nano_schema(schema: Json) -> string {
    let mut output: string = (+ HEADER_COMMENT "\n\n")
    
    # LexerTokenType enum
    set output (+ output "enum LexerTokenType {\n")
    let tokens_json: Json = (get schema "tokens")
    let token_count: int = (array_size tokens_json)
    
    let mut i: int = 0
    while (< i token_count) {
        let token: Json = (get_index tokens_json i)
        let name: string = (cond
            ((is_string token) (as_string token))
            (else (as_string (get token "name")))
        )
        let value: int = i
        let suffix: string = (cond
            ((< i (- token_count 1)) ",")
            (else "")
        )
        set output (+ output (+ "    " (+ name (+ " = " (+ (int_to_string value) (+ suffix "\n"))))))
        set i (+ i 1)
    }
    set output (+ output "}\n\n")
    
    # ParseNodeType enum
    set output (+ output "enum ParseNodeType {\n")
    let nodes_json: Json = (get schema "parse_nodes")
    let node_count: int = (array_size nodes_json)
    
    set i 0
    while (< i node_count) {
        let node: Json = (get_index nodes_json i)
        let name: string = (as_string node)
        let suffix: string = (cond
            ((< i (- node_count 1)) ",")
            (else "")
        )
        set output (+ output (+ "    " (+ name (+ " = " (+ (int_to_string i) (+ suffix "\n"))))))
        set i (+ i 1)
    }
    set output (+ output "}\n")
    
    return output
}

shadow gen_nano_schema {
    # Test with minimal schema
    let schema: Json = (nl_json_new_object)
    let tokens: Json = (nl_json_new_array)
    (nl_json_array_push tokens (nl_json_new_string "TOKEN_EOF"))
    (nl_json_object_set schema "tokens" tokens)
    let nodes: Json = (nl_json_new_array)
    (nl_json_array_push nodes (nl_json_new_string "NODE_EXPR"))
    (nl_json_object_set schema "parse_nodes" nodes)
    
    let result: string = (gen_nano_schema schema)
    assert (> (str_length result) 0)
    (free schema)
}

# Generate NanoLang AST types
fn gen_nano_ast(schema: Json) -> string {
    let mut output: string = (+ HEADER_COMMENT "\n\n")
    set output (+ output "import \"src_nano/generated/compiler_schema.nano\"\n")
    set output (+ output "import \"src_nano/generated/compiler_contracts.nano\"\n\n")
    
    # Generate enums if they exist
    if (object_has schema "nano_enums") {
        let enums: Json = (get schema "nano_enums")
        let enum_count: int = (array_size enums)
    let mut i: int = 0
        
        while (< i enum_count) {
            let enum_obj: Json = (get_index enums i)
            let is_contract: bool = (cond
                ((object_has enum_obj "contracts") (nl_json_as_bool (get enum_obj "contracts")))
                (else false)
            )
            if is_contract {
                # Contract enums are emitted in compiler_contracts.nano
            } else {
                let enum_name: string = (as_string (get enum_obj "name"))
                let values: Json = (get enum_obj "values")
                let value_count: int = (array_size values)
                
                set output (+ output (+ "enum " (+ enum_name " {\n")))
                
                let mut j: int = 0
                while (< j value_count) {
                    let val: Json = (get_index values j)
                    let val_name: string = (as_string val)
                    let suffix: string = (cond
                        ((< j (- value_count 1)) ",")
                        (else "")
                    )
                    set output (+ output (+ "    " (+ val_name (+ suffix "\n"))))
                    set j (+ j 1)
                }
                set output (+ output "}\n\n")
            }
            set i (+ i 1)
        }
    } else {}
    
    # Generate structs if they exist
    if (object_has schema "nano_structs") {
        let structs: Json = (get schema "nano_structs")
        let struct_count: int = (array_size structs)
        let mut i: int = 0
        
        while (< i struct_count) {
            let struct_obj: Json = (get_index structs i)
            let is_contract: bool = (cond
                ((object_has struct_obj "contracts") (nl_json_as_bool (get struct_obj "contracts")))
                (else false)
            )
            if is_contract {
                # Contract structs are emitted in compiler_contracts.nano
            } else {
                let struct_name: string = (as_string (get struct_obj "name"))
                let fields: Json = (get struct_obj "fields")
                let field_count: int = (array_size fields)
                
                # Check for extern prefix
                let prefix: string = (cond
                    ((object_has struct_obj "emit_c") 
                        (cond
                            ((nl_json_as_bool (get struct_obj "emit_c")) "extern ")
                            (else "")
                        )
                    )
                    (else "")
                )
                
                set output (+ output (+ prefix (+ "struct " (+ struct_name " {\n"))))
                
                let mut j: int = 0
                while (< j field_count) {
                    let field: Json = (get_index fields j)
                    let field_name: string = (as_string (get_index field 0))
                    let field_type: string = (as_string (get_index field 1))
                    let suffix: string = (cond
                        ((< j (- field_count 1)) ",")
                        (else "")
                    )
                    set output (+ output (+ "    " (+ field_name (+ ": " (+ field_type (+ suffix "\n"))))))
                    set j (+ j 1)
                }
                set output (+ output "}\n\n")
            }
            set i (+ i 1)
        }
    } else {}
    
    return output
}

shadow gen_nano_ast {
    let schema: Json = (nl_json_new_object)
    let result: string = (gen_nano_ast schema)
    assert (> (str_length result) 0)
    (free schema)
}

# Generate NanoLang contract types (shared interfaces between phases)
fn gen_contracts(schema: Json) -> string {
    let mut output: string = (+ HEADER_COMMENT "\n\n")
    set output (+ output "import \"src_nano/generated/compiler_schema.nano\"\n\n")

    # Contract enums
    if (object_has schema "nano_enums") {
        let enums: Json = (get schema "nano_enums")
        let enum_count: int = (array_size enums)
        let mut i: int = 0

        while (< i enum_count) {
            let enum_obj: Json = (get_index enums i)
            let is_contract: bool = (cond
                ((object_has enum_obj "contracts") (nl_json_as_bool (get enum_obj "contracts")))
                (else false)
            )
            if is_contract {
                let enum_name: string = (as_string (get enum_obj "name"))
                let values: Json = (get enum_obj "values")
                let value_count: int = (array_size values)

                set output (+ output (+ "enum " (+ enum_name " {\n")))

                let mut j: int = 0
                while (< j value_count) {
                    let val: Json = (get_index values j)
                    let val_name: string = (as_string val)
                    let suffix: string = (cond
                        ((< j (- value_count 1)) ",")
                        (else "")
                    )
                    set output (+ output (+ "    " (+ val_name (+ suffix "\n"))))
                    set j (+ j 1)
                }

                set output (+ output "}\n\n")
            } else {}
            set i (+ i 1)
        }
    } else {}

    # Contract structs
    if (object_has schema "nano_structs") {
        let structs: Json = (get schema "nano_structs")
        let struct_count: int = (array_size structs)
        let mut i: int = 0

        while (< i struct_count) {
            let struct_obj: Json = (get_index structs i)
            let is_contract: bool = (cond
                ((object_has struct_obj "contracts") (nl_json_as_bool (get struct_obj "contracts")))
                (else false)
            )
            if is_contract {
                let struct_name: string = (as_string (get struct_obj "name"))
                let fields: Json = (get struct_obj "fields")
                let field_count: int = (array_size fields)

                let prefix: string = (cond
                    ((object_has struct_obj "emit_c")
                        (cond
                            ((nl_json_as_bool (get struct_obj "emit_c")) "extern ")
                            (else "")
                        )
                    )
                    (else "")
                )

                set output (+ output (+ prefix (+ "struct " (+ struct_name " {\n"))))

                let mut j: int = 0
                while (< j field_count) {
                    let field: Json = (get_index fields j)
                    let field_name: string = (as_string (get_index field 0))
                    let field_type: string = (as_string (get_index field 1))
                    let suffix: string = (cond
                        ((< j (- field_count 1)) ",")
                        (else "")
                    )
                    set output (+ output (+ "    " (+ field_name (+ ": " (+ field_type (+ suffix "\n"))))))
                    set j (+ j 1)
                }

                set output (+ output "}\n\n")
            } else {}
            set i (+ i 1)
        }
    } else {}

    return output
}

shadow gen_contracts {
    let schema: Json = (nl_json_new_object)
    let result: string = (gen_contracts schema)
    assert (> (str_length result) 0)
    (free schema)
}

# Helper: Check if string starts with prefix
fn str_starts_with(s: string, prefix: string) -> bool {
    let s_len: int = (str_length s)
    let p_len: int = (str_length prefix)
    if (> p_len s_len) {
        return false
    } else {}
    let sub: string = (str_substring s 0 p_len)
    return (str_equals sub prefix)
}

shadow str_starts_with {
    assert (str_starts_with "List<int>" "List<")
    assert (not (str_starts_with "array<int>" "List<"))
}

# Helper: Extract content between delimiters (e.g., "List<int>" -> "int")
fn extract_between(s: string, start: string, end: string) -> string {
    let start_len: int = (str_length start)
    let s_len: int = (str_length s)
    let end_len: int = (str_length end)
    if (< s_len (+ start_len end_len)) {
        return ""
    } else {}
    # str_substring(string, start_position, length)
    let inner_len: int = (- (- s_len start_len) end_len)
    return (str_substring s start_len inner_len)
}

shadow extract_between {
    assert (str_equals (extract_between "List<int>" "List<" ">") "int")
    assert (str_equals (extract_between "array<string>" "array<" ">") "string")
}

# Helper: Map NanoLang type to C type
fn map_type_to_c(nano_type: string) -> string {
    if (str_equals nano_type "string") {
        return "const char *"
    } else {
        if (str_equals nano_type "bool") {
            return "bool"
        } else {
            if (str_equals nano_type "int") {
                return "int64_t"
            } else {
                if (str_starts_with nano_type "array<") {
                    return "DynArray *"
                } else {
                    if (str_starts_with nano_type "List<") {
                        let inner: string = (extract_between nano_type "List<" ">")
                        return (+ "List_" (+ inner " *"))
                    } else {
                        if (or (str_equals nano_type "Parser") (str_equals nano_type "TypeEnvironment")) {
                            return nano_type
                        } else {
                            if (str_equals nano_type "Type") {
                                return "NSType"
                            } else {
                                return nano_type
                            }
                        }
                    }
                }
            }
        }
    }
}

shadow map_type_to_c {
    assert (str_equals (map_type_to_c "string") "const char *")
    assert (str_equals (map_type_to_c "bool") "bool")
    assert (str_equals (map_type_to_c "int") "int64_t")
    assert (str_equals (map_type_to_c "array<int>") "DynArray *")
    assert (str_equals (map_type_to_c "List<Token>") "List_Token *")
    assert (str_equals (map_type_to_c "Type") "NSType")
}

# Generate C header
fn gen_c(schema: Json) -> string {
    let mut output: string = (+ HEADER_COMMENT "\n\n")
    set output (+ output (+ "#ifndef " (+ C_GUARD "\n")))
    set output (+ output (+ "#define " (+ C_GUARD "\n\n")))
    set output (+ output "#include <stdint.h>\n")
    set output (+ output "#include <stdbool.h>\n")
    set output (+ output "#include \"runtime/dyn_array.h\"\n\n")
    
    # Detect and forward declare List<T> types
    # We'll generate declarations inline - #ifndef guards prevent duplicates
    let mut has_lists: bool = false
    if (object_has schema "nano_structs") {
        let structs: Json = (get schema "nano_structs")
        let struct_count: int = (array_size structs)
        let mut i: int = 0
        
        # First pass: collect all List<T> types
        let mut list_decls: string = ""
        while (< i struct_count) {
            let struct_obj: Json = (get_index structs i)
            let fields: Json = (get struct_obj "fields")
            let field_count: int = (array_size fields)
            let mut j: int = 0
            
            while (< j field_count) {
                let field: Json = (get_index fields j)
                let field_type: string = (as_string (get_index field 1))
                if (str_starts_with field_type "List<") {
                    set has_lists true
                    let inner: string = (extract_between field_type "List<" ">")
                    # Generate declaration (duplicates handled by #ifndef)
                    set list_decls (+ list_decls (+ "#ifndef FORWARD_DEFINED_List_" (+ inner "\n")))
                    set list_decls (+ list_decls (+ "#define FORWARD_DEFINED_List_" (+ inner "\n")))
                    set list_decls (+ list_decls (+ "typedef struct List_" (+ inner (+ " List_" (+ inner ";\n")))))
                    set list_decls (+ list_decls "#endif\n")
                } else {}
                set j (+ j 1)
            }
            set i (+ i 1)
        }
        
        if has_lists {
            set output (+ output "/* Forward declare List types */\n")
            set output (+ output list_decls)
            set output (+ output "\n")
        } else {}
    } else {}
    
    # Generate C-emitted enums
    if (object_has schema "nano_enums") {
        let enums: Json = (get schema "nano_enums")
        let enum_count: int = (array_size enums)
        let mut i: int = 0
        
        while (< i enum_count) {
            let enum_obj: Json = (get_index enums i)
            if (object_has enum_obj "emit_c") {
                let emit_c: bool = (nl_json_as_bool (get enum_obj "emit_c"))
                if emit_c {
                    let enum_name: string = (as_string (get enum_obj "name"))
                    let values: Json = (get enum_obj "values")
                    let value_count: int = (array_size values)
                    
                    set output (+ output (+ "#ifndef DEFINED_" (+ enum_name "\n")))
                    set output (+ output (+ "#define DEFINED_" (+ enum_name "\n")))
                    set output (+ output (+ "typedef enum " (+ enum_name " {\n")))
                    
                    let mut j: int = 0
                    while (< j value_count) {
                        let val: Json = (get_index values j)
                        let val_name: string = (as_string val)
                        let suffix: string = (cond
                            ((< j (- value_count 1)) ",")
                            (else "")
                        )
                        set output (+ output (+ "    " (+ enum_name (+ "_" (+ val_name (+ suffix "\n"))))))
                        set j (+ j 1)
                    }
                    
                    set output (+ output (+ "} " (+ enum_name ";\n")))
                    set output (+ output "#endif\n\n")
                } else {}
            } else {}
            set i (+ i 1)
        }
    } else {}
    
    # TokenType enum
    set output (+ output "typedef enum {\n")
    let tokens_json: Json = (get schema "tokens")
    let token_count: int = (array_size tokens_json)
    
    let mut i: int = 0
    while (< i token_count) {
        let token: Json = (get_index tokens_json i)
        let name: string = (cond
            ((is_string token) (as_string token))
            (else (as_string (get token "name")))
        )
        let suffix: string = (cond
            ((< i (- token_count 1)) ",")
            (else "")
        )
        set output (+ output (+ "    " (+ name (+ " = " (+ (int_to_string i) (+ suffix "\n"))))))
        set i (+ i 1)
    }
    set output (+ output "} TokenType;\n\n")
    
    # ParseNodeType enum
    set output (+ output "typedef enum {\n")
    let nodes_json: Json = (get schema "parse_nodes")
    let node_count: int = (array_size nodes_json)
    
    set i 0
    while (< i node_count) {
        let node: Json = (get_index nodes_json i)
        let name: string = (as_string node)
        let suffix: string = (cond
            ((< i (- node_count 1)) ",")
            (else "")
        )
        set output (+ output (+ "    " (+ name (+ " = " (+ (int_to_string i) (+ suffix "\n"))))))
        set i (+ i 1)
    }
    set output (+ output "} ParseNodeType;\n\n")
    
    # Generate C-emitted structs
    if (object_has schema "nano_structs") {
        let structs: Json = (get schema "nano_structs")
        let struct_count: int = (array_size structs)
        let mut i: int = 0
        
        while (< i struct_count) {
            let struct_obj: Json = (get_index structs i)
            if (object_has struct_obj "emit_c") {
                let emit_c: bool = (nl_json_as_bool (get struct_obj "emit_c"))
                if emit_c {
                    let struct_name: string = (as_string (get struct_obj "name"))
                    let c_struct_name: string = (+ "nl_" struct_name)
                    let fields: Json = (get struct_obj "fields")
                    let field_count: int = (array_size fields)
                    
                    set output (+ output (+ "#ifndef DEFINED_" (+ c_struct_name "\n")))
                    set output (+ output (+ "#define DEFINED_" (+ c_struct_name "\n")))
                    set output (+ output (+ "typedef struct " (+ c_struct_name " {\n")))
                    
                    let mut j: int = 0
                    while (< j field_count) {
                        let field: Json = (get_index fields j)
                        let field_name: string = (as_string (get_index field 0))
                        let field_type: string = (as_string (get_index field 1))
                        let c_type: string = (map_type_to_c field_type)
                        set output (+ output (+ "    " (+ c_type (+ " " (+ field_name ";\n")))))
                        set j (+ j 1)
                    }
                    
                    set output (+ output (+ "} " (+ c_struct_name ";\n")))
                    set output (+ output (+ "typedef " (+ c_struct_name (+ " " (+ struct_name ";\n")))))
                    
                    # Special typedefs
                    if (str_equals struct_name "LexerToken") {
                        set output (+ output "typedef nl_LexerToken Token;\n")
                    } else {}
                    if (str_equals struct_name "Type") {
                        set output (+ output "typedef Type NSType;\n")
                    } else {}
                    
                    set output (+ output "#endif\n\n")
                } else {}
            } else {}
            set i (+ i 1)
        }
    } else {}
    
    set output (+ output (+ "#endif /* " (+ C_GUARD " */\n")))
    return output
}

shadow gen_c {
    let schema: Json = (nl_json_new_object)
    let tokens: Json = (nl_json_new_array)
    (nl_json_array_push tokens (nl_json_new_string "TOKEN_EOF"))
    (nl_json_object_set schema "tokens" tokens)
    let nodes: Json = (nl_json_new_array)
    (nl_json_array_push nodes (nl_json_new_string "NODE_EXPR"))
    (nl_json_object_set schema "parse_nodes" nodes)
    
    let result: string = (gen_c schema)
    assert (> (str_length result) 0)
    (free schema)
}

fn main() -> int {
    (println "Generating compiler schema artifacts...")
    
    # Read schema JSON
    let schema_path: string = "schema/compiler_schema.json"
    let schema_text: string = (read schema_path)
    if (== (str_length schema_text) 0) {
        (println (+ "Error: Could not read " schema_path))
        return 1
    } else {}
    
    (println (+ "Loaded schema: " (int_to_string (str_length schema_text))))
    
    # Parse JSON
    let schema: Json = (parse schema_text)
    if (== schema 0) {
        (println "Error: Failed to parse schema JSON")
        return 1
    } else {}
    
    (println "Parsed schema successfully")
    
    # Generate outputs
    let nano_schema: string = (gen_nano_schema schema)
    let nano_ast: string = (gen_nano_ast schema)
    let nano_contracts: string = (gen_contracts schema)
    let c_header: string = (gen_c schema)
    
    # Write files
    (println "Writing src_nano/generated/compiler_schema.nano...")
    let result1: int = (write_if_changed "src_nano/generated/compiler_schema.nano" nano_schema)
    if (!= result1 0) {
        (println "Error writing compiler_schema.nano")
        (free schema)
        return 1
    } else {}
    
    (println "Writing src_nano/generated/compiler_ast.nano...")
    let result2: int = (write_if_changed "src_nano/generated/compiler_ast.nano" nano_ast)
    if (!= result2 0) {
        (println "Error writing compiler_ast.nano")
        (free schema)
        return 1
    } else {}

    (println "Writing src_nano/generated/compiler_contracts.nano...")
    let result_contracts: int = (write_if_changed "src_nano/generated/compiler_contracts.nano" nano_contracts)
    if (!= result_contracts 0) {
        (println "Error writing compiler_contracts.nano")
        (free schema)
        return 1
    } else {}
    
    (println "Writing src/generated/compiler_schema.h...")
    let result3: int = (write_if_changed "src/generated/compiler_schema.h" c_header)
    if (!= result3 0) {
        (println "Error writing compiler_schema.h")
        (free schema)
        return 1
    } else {}
    
    (free schema)
    (println "âœ“ Schema generation complete!")
    return 0
}

shadow main { assert true }
