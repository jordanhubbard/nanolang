/* =============================================================================
 * proptest - Lightweight property-based testing helpers
 * ============================================================================= */

module proptest

/* =============================================================================
 * TYPES
 * ============================================================================= */

pub struct RunConfig {
    trials: int,
    max_shrink_steps: int,
    discard_limit: int,
    seed: int
}

pub struct PropertyReport {
    name: string,
    passed: bool,
    case_count: int,
    discard_count: int,
    shrink_count: int,
    counterexample: string
}

let PROP_OUTCOME_PASS: int = 0
let PROP_OUTCOME_FAIL: int = 1
let PROP_OUTCOME_DISCARD: int = 2

struct PropOutcome {
    kind: int,
    message: string
}

fn decode_outcome(encoded: string) -> PropOutcome {
    let len: int = (str_length encoded)
    if (<= len 0) {
        return PropOutcome { kind: PROP_OUTCOME_FAIL, message: "" }
    }
    let kind_text: string = (str_substring encoded 0 1)
    let payload_len: int = (- len 1)
    let payload: string = (cond
        ((> payload_len 0) (str_substring encoded 1 payload_len))
        (else "")
    )
    if (== kind_text "P") {
        return PropOutcome { kind: PROP_OUTCOME_PASS, message: payload }
    } else {
        if (== kind_text "D") {
            return PropOutcome { kind: PROP_OUTCOME_DISCARD, message: payload }
        } else {
            return PropOutcome { kind: PROP_OUTCOME_FAIL, message: payload }
        }
    }
}

shadow decode_outcome {
    let pass_outcome: PropOutcome = (decode_outcome "P")
    assert (== pass_outcome.kind PROP_OUTCOME_PASS)
    let discard_outcome: PropOutcome = (decode_outcome (+ "D" "skip"))
    assert (== discard_outcome.kind PROP_OUTCOME_DISCARD)
    assert (== discard_outcome.message "skip")
}

fn prop_is_pass(outcome: PropOutcome) -> bool {
    return (== outcome.kind PROP_OUTCOME_PASS)
}

shadow prop_is_pass {
    assert (prop_is_pass (decode_outcome (prop_pass)))
    assert (not (prop_is_pass (decode_outcome (prop_fail ""))))
}

fn prop_is_fail(outcome: PropOutcome) -> bool {
    return (== outcome.kind PROP_OUTCOME_FAIL)
}

shadow prop_is_fail {
    assert (prop_is_fail (decode_outcome (prop_fail "oops")))
    assert (not (prop_is_fail (decode_outcome (prop_pass))))
}

fn prop_is_discard(outcome: PropOutcome) -> bool {
    return (== outcome.kind PROP_OUTCOME_DISCARD)
}

shadow prop_is_discard {
    assert (prop_is_discard (decode_outcome (prop_discard "skip")))
    assert (not (prop_is_discard (decode_outcome (prop_pass))))
}

pub fn prop_pass() -> string {
    return "P"
}

shadow prop_pass {
    let outcome: PropOutcome = (decode_outcome (prop_pass))
    assert (prop_is_pass outcome)
    assert (not (prop_is_fail outcome))
    assert (not (prop_is_discard outcome))
}

pub fn prop_fail(message: string) -> string {
    return (+ "F" message)
}

shadow prop_fail {
    let outcome: PropOutcome = (decode_outcome (prop_fail "boom"))
    assert (prop_is_fail outcome)
    assert (== outcome.message "boom")
    assert (not (prop_is_pass outcome))
}

pub fn prop_discard(reason: string) -> string {
    return (+ "D" reason)
}

shadow prop_discard {
    let outcome: PropOutcome = (decode_outcome (prop_discard "skip"))
    assert (prop_is_discard outcome)
    assert (== outcome.message "skip")
    assert (not (prop_is_pass outcome))
}

pub struct IntRangeGenerator {
    min: int,
    max: int
}

pub struct IntPairGenerator {
    first: IntRangeGenerator,
    second: IntRangeGenerator
}

pub struct IntArrayGenerator {
    element: IntRangeGenerator,
    max_length: int
}

struct RNG {
    state: int
}

struct IntSample {
    value: int,
    next_rng: RNG
}

struct PairSample {
    first: int,
    second: int,
    next_rng: RNG
}

struct ArraySample {
    values: array<int>,
    next_rng: RNG
}

struct IntShrinkResult {
    value: int,
    steps: int
}

struct PairShrinkResult {
    first: int,
    second: int,
    steps: int
}

struct ArrayShrinkResult {
    values: array<int>,
    steps: int
}

let RNG_MULTIPLIER: int = 48271
let RNG_MODULUS: int = 2147483647

/* =============================================================================
 * CONFIGURATION HELPERS
 * ============================================================================= */

pub fn config_default() -> RunConfig {
    return RunConfig {
        trials: 100,
        max_shrink_steps: 40,
        discard_limit: 200,
        seed: 1
    }
}

shadow config_default {
    let cfg: RunConfig = (config_default)
    assert (> cfg.trials 0)
    assert (> cfg.seed 0)
}

pub fn config(trials: int, max_shrink_steps: int, discard_limit: int, seed: int) -> RunConfig {
    return RunConfig {
        trials: trials,
        max_shrink_steps: max_shrink_steps,
        discard_limit: discard_limit,
        seed: seed
    }
}

shadow config {
    let cfg: RunConfig = (config 5 6 7 8)
    assert (== cfg.trials 5)
    assert (== cfg.max_shrink_steps 6)
}

fn normalize_config(cfg: RunConfig) -> RunConfig {
    let mut trials: int = cfg.trials
    let mut shrink_steps: int = cfg.max_shrink_steps
    let mut discards: int = cfg.discard_limit
    let mut seed: int = cfg.seed
    if (<= trials 0) { set trials 1 }
    if (<= shrink_steps 0) { set shrink_steps 1 }
    if (<= discards 0) { set discards (* trials 2) }
    if (== seed 0) { set seed 1 }
    return RunConfig {
        trials: trials,
        max_shrink_steps: shrink_steps,
        discard_limit: discards,
        seed: seed
    }
}

shadow normalize_config {
    let input: RunConfig = RunConfig { trials: 0, max_shrink_steps: 0, discard_limit: 0, seed: 0 }
    let normalized: RunConfig = (normalize_config input)
    assert (> normalized.trials 0)
    assert (> normalized.discard_limit 0)
}

/* =============================================================================
 * RNG HELPERS
 * ============================================================================= */

fn abs_int(value: int) -> int {
    if (< value 0) {
        return (- 0 value)
    } else {
        return value
    }
}

shadow abs_int {
    assert (== (abs_int -5) 5)
    assert (== (abs_int 4) 4)
}

fn rng_seed(seed: int) -> RNG {
    let mut normalized: int = (% (abs_int seed) RNG_MODULUS)
    if (== normalized 0) { set normalized 1 }
    return RNG { state: normalized }
}

shadow rng_seed {
    let rng: RNG = (rng_seed 0)
    assert (> rng.state 0)
}

fn rng_next(rng: RNG) -> RNG {
    let next_state: int = (% (* rng.state RNG_MULTIPLIER) RNG_MODULUS)
    if (== next_state 0) {
        return RNG { state: 1 }
    } else {
        return RNG { state: next_state }
    }
}

shadow rng_next {
    let next_rng: RNG = (rng_next (rng_seed 5))
    assert (!= next_rng.state 0)
}

fn rng_next_range(rng: RNG, min_value: int, max_value: int) -> IntSample {
    let mut next_rng: RNG = (rng_next rng)
    let mut lo: int = min_value
    let mut hi: int = max_value
    if (> lo hi) {
        let temp: int = lo
        set lo hi
        set hi temp
    }
    let span: int = (+ (- hi lo) 1)
    if (<= span 0) {
        return IntSample { value: lo, next_rng: next_rng }
    }
    let value: int = (+ lo (% next_rng.state span))
    return IntSample { value: value, next_rng: next_rng }
}

shadow rng_next_range {
    let sample: IntSample = (rng_next_range (rng_seed 1) 0 10)
    assert (>= sample.value 0)
    assert (<= sample.value 10)
}

/* =============================================================================
 * GENERATORS
 * ============================================================================= */

pub fn int_range(min_value: int, max_value: int) -> IntRangeGenerator {
    let mut lo: int = min_value
    let mut hi: int = max_value
    if (> lo hi) {
        let temp: int = lo
        set lo hi
        set hi temp
    }
    return IntRangeGenerator { min: lo, max: hi }
}

shadow int_range {
    let gen: IntRangeGenerator = (int_range 5 1)
    assert (== gen.min 1)
    assert (== gen.max 5)
}

pub fn int_pair(first: IntRangeGenerator, second: IntRangeGenerator) -> IntPairGenerator {
    return IntPairGenerator { first: first, second: second }
}

shadow int_pair {
    let gen: IntPairGenerator = (int_pair (int_range 0 0) (int_range 1 1))
    assert (== gen.first.min 0)
    assert (== gen.second.max 1)
}

pub fn int_array(element: IntRangeGenerator, max_length: int) -> IntArrayGenerator {
    let mut length: int = max_length
    if (< length 0) { set length 0 }
    return IntArrayGenerator { element: element, max_length: length }
}

shadow int_array {
    let gen: IntArrayGenerator = (int_array (int_range 0 1) -5)
    assert (== gen.max_length 0)
}

fn sample_int(gen: IntRangeGenerator, rng: RNG) -> IntSample {
    return (rng_next_range rng gen.min gen.max)
}

shadow sample_int {
    let sample: IntSample = (sample_int (int_range 2 2) (rng_seed 3))
    assert (== sample.value 2)
}

fn sample_pair(gen: IntPairGenerator, rng: RNG) -> PairSample {
    let first_sample: IntSample = (sample_int gen.first rng)
    let second_sample: IntSample = (sample_int gen.second first_sample.next_rng)
    return PairSample { first: first_sample.value, second: second_sample.value, next_rng: second_sample.next_rng }
}

shadow sample_pair {
    let gen: IntPairGenerator = (int_pair (int_range 0 0) (int_range 1 1))
    let sample: PairSample = (sample_pair gen (rng_seed 9))
    assert (== sample.first 0)
    assert (== sample.second 1)
}

fn sample_array(gen: IntArrayGenerator, rng: RNG) -> ArraySample {
    let length_sample: IntSample = (rng_next_range rng 0 gen.max_length)
    let mut values: array<int> = []
    let mut current_rng: RNG = length_sample.next_rng
    let mut i: int = 0
    while (< i length_sample.value) {
        let sample: IntSample = (sample_int gen.element current_rng)
        set values (array_push values sample.value)
        set current_rng sample.next_rng
        set i (+ i 1)
    }
    return ArraySample { values: values, next_rng: current_rng }
}

shadow sample_array {
    let gen: IntArrayGenerator = (int_array (int_range 0 0) 0)
    let sample: ArraySample = (sample_array gen (rng_seed 4))
    assert (== (array_length sample.values) 0)
}

/* =============================================================================
 * SHRINK HELPERS
 * ============================================================================= */

fn shrink_int_candidates(value: int) -> array<int> {
    let mut candidates: array<int> = []
    if (== value 0) {
        return candidates
    }
    set candidates (array_push candidates 0)
    let half: int = (/ value 2)
    if (!= half 0) {
        set candidates (array_push candidates half)
    }
    if (> value 0) {
        set candidates (array_push candidates (- value 1))
    } else {
        set candidates (array_push candidates (+ value 1))
    }
    return candidates
}

shadow shrink_int_candidates {
    let values: array<int> = (shrink_int_candidates 8)
    assert (> (array_length values) 0)
}

fn shrink_array_candidates(values: array<int>) -> array<array<int>> {
    let mut candidates: array<array<int>> = []
    let len: int = (array_length values)
    if (== len 0) {
        return candidates
    }
    set candidates (array_push candidates [])
    if (> len 1) {
        set candidates (array_push candidates (array_take values (- len 1)))
    }
    let mut idx: int = 0
    while (< idx len) {
        let element_candidates: array<int> = (shrink_int_candidates (at values idx))
        let mut j: int = 0
        while (< j (array_length element_candidates)) {
            let mut next: array<int> = []
            let mut k: int = 0
            while (< k len) {
                if (== k idx) {
                    set next (array_push next (at element_candidates j))
                } else {
                    set next (array_push next (at values k))
                }
                set k (+ k 1)
            }
            set candidates (array_push candidates next)
            set j (+ j 1)
        }
        set idx (+ idx 1)
    }
    return candidates
}

shadow shrink_array_candidates {
    let arr: array<int> = (array_push [] 4)
    let candidates: array<array<int>> = (shrink_array_candidates arr)
    assert (> (array_length candidates) 0)
}

fn array_take(values: array<int>, new_length: int) -> array<int> {
    let mut result: array<int> = []
    let mut i: int = 0
    while (< i new_length) {
        set result (array_push result (at values i))
        set i (+ i 1)
    }
    return result
}

shadow array_take {
    let arr: array<int> = (array_push (array_push [] 1) 2)
    let taken: array<int> = (array_take arr 1)
    assert (== (array_length taken) 1)
}

fn shrink_int_value(start: int, property: fn(int) -> string, limit: int) -> IntShrinkResult {
    let mut current: int = start
    let mut steps: int = 0
    let mut depth: int = 0
    while (< depth limit) {
        let candidates: array<int> = (shrink_int_candidates current)
        let mut idx: int = 0
        let mut found: bool = false
        while (< idx (array_length candidates)) {
            let candidate: int = (at candidates idx)
            let encoded: string = (property candidate)
            let outcome: PropOutcome = (decode_outcome encoded)
            if (prop_is_fail outcome) {
                set current candidate
                set steps (+ steps 1)
                set found true
                set idx (array_length candidates)
            } else {
                set idx (+ idx 1)
            }
        }
        if (not found) {
            set depth limit
        } else {
            set depth (+ depth 1)
        }
    }
    return IntShrinkResult { value: current, steps: steps }
}

shadow shrink_int_value {
    let result: IntShrinkResult = (shrink_int_value 10 prop_fail_over_three 5)
    assert (>= result.value 3)
}

fn shrink_pair_value(a: int, b: int, property: fn(int, int) -> string, limit: int) -> PairShrinkResult {
    let mut current_a: int = a
    let mut current_b: int = b
    let mut steps: int = 0
    let mut depth: int = 0
    while (< depth limit) {
        let first_candidates: array<int> = (shrink_int_candidates current_a)
        let mut idx: int = 0
        let mut found: bool = false
        while (< idx (array_length first_candidates)) {
            let candidate: int = (at first_candidates idx)
            let encoded: string = (property candidate current_b)
            let outcome: PropOutcome = (decode_outcome encoded)
            if (prop_is_fail outcome) {
                set current_a candidate
                set steps (+ steps 1)
                set found true
                set idx (array_length first_candidates)
            } else {
                set idx (+ idx 1)
            }
        }
        if (not found) {
            let second_candidates: array<int> = (shrink_int_candidates current_b)
            let mut j: int = 0
            while (< j (array_length second_candidates)) {
                let candidate: int = (at second_candidates j)
                let encoded: string = (property current_a candidate)
                let outcome: PropOutcome = (decode_outcome encoded)
                if (prop_is_fail outcome) {
                    set current_b candidate
                    set steps (+ steps 1)
                    set found true
                    set j (array_length second_candidates)
                } else {
                    set j (+ j 1)
                }
            }
        }
        if (not found) {
            set depth limit
        } else {
            set depth (+ depth 1)
        }
    }
    return PairShrinkResult { first: current_a, second: current_b, steps: steps }
}

shadow shrink_pair_value {
    let result: PairShrinkResult = (shrink_pair_value 5 5 prop_fail_sum_over_five 4)
    assert (>= (+ result.first result.second) 5)
}

fn shrink_array_value(values: array<int>, property: fn(array<int>) -> string, limit: int) -> ArrayShrinkResult {
    let mut current: array<int> = values
    let mut steps: int = 0
    let mut depth: int = 0
    while (< depth limit) {
        let candidates: array<array<int>> = (shrink_array_candidates current)
        let mut idx: int = 0
        let mut found: bool = false
        while (< idx (array_length candidates)) {
            let candidate: array<int> = (at candidates idx)
            let encoded: string = (property candidate)
            let outcome: PropOutcome = (decode_outcome encoded)
            if (prop_is_fail outcome) {
                set current candidate
                set steps (+ steps 1)
                set found true
                set idx (array_length candidates)
            } else {
                set idx (+ idx 1)
            }
        }
        if (not found) {
            set depth limit
        } else {
            set depth (+ depth 1)
        }
    }
    return ArrayShrinkResult { values: current, steps: steps }
}

shadow shrink_array_value {
    let arr: array<int> = (array_push (array_push [] 1) 2)
    let result: ArrayShrinkResult = (shrink_array_value arr prop_fail_length_over_one 4)
    assert (>= (array_length result.values) 1)
}

fn prop_fail_over_three(value: int) -> string {
    if (> value 3) {
        return (prop_fail "gt3")
    } else {
        return (prop_pass)
    }
}

shadow prop_fail_over_three {
    assert (not (report_passed (forall_int "gt3" (int_range 0 5) prop_fail_over_three)))
}

fn prop_fail_sum_over_five(a: int, b: int) -> string {
    if (> (+ a b) 5) {
        return (prop_fail "sum")
    } else {
        return (prop_pass)
    }
}

shadow prop_fail_sum_over_five {
    let report: PropertyReport = (forall_int_pair "sum" (int_pair (int_range 0 3) (int_range 0 3)) prop_fail_sum_over_five)
    assert (report_passed report)
}

fn prop_fail_length_over_one(values: array<int>) -> string {
    if (> (array_length values) 1) {
        return (prop_fail "len")
    } else {
        return (prop_pass)
    }
}

shadow prop_fail_length_over_one {
    let gen: IntArrayGenerator = (int_array (int_range 0 1) 2)
    let report: PropertyReport = (forall_int_array_with_config "len" gen prop_fail_length_over_one (config 5 5 5 5))
    assert (report_passed report)
}

fn prop_non_negative_only(x: int) -> string {
    if (>= x 0) {
        return (prop_pass)
    } else {
        return (prop_fail "neg")
    }
}

shadow prop_non_negative_only {
    let report: PropertyReport = (forall_int "nonneg" (int_range 0 2) prop_non_negative_only)
    assert (report_passed report)
}

fn prop_bound_at_negative_five(x: int) -> string {
    if (< x -5) {
        return (prop_fail "bound")
    } else {
        return (prop_pass)
    }
}

shadow prop_bound_at_negative_five {
    let report: PropertyReport = (forall_int_with_config "bound" (int_range -5 -1) prop_bound_at_negative_five (config 2 2 2 2))
    assert (report_passed report)
}

fn prop_pairs_must_match(a: int, b: int) -> string {
    if (== a b) {
        return (prop_pass)
    } else {
        return (prop_fail "mismatch")
    }
}

shadow prop_pairs_must_match {
    let gen: IntPairGenerator = (int_pair (int_range 0 1) (int_range 0 1))
    let report: PropertyReport = (forall_int_pair "pairs" gen prop_pairs_must_match)
    assert (not (report_passed report))
}

fn prop_fail_on_zero_sum(a: int, b: int) -> string {
    if (== (+ a b) 0) {
        return (prop_fail "zero")
    } else {
        return (prop_pass)
    }
}

shadow prop_fail_on_zero_sum {
    let gen: IntPairGenerator = (int_pair (int_range -1 1) (int_range -1 1))
    let report: PropertyReport = (forall_int_pair_with_config "zero" gen prop_fail_on_zero_sum (config 4 4 4 4))
    assert (not (report_passed report))
}

fn prop_fail_length_over_zero(values: array<int>) -> string {
    if (> (array_length values) 0) {
        return (prop_fail "nz")
    } else {
        return (prop_pass)
    }
}

shadow prop_fail_length_over_zero {
    let gen: IntArrayGenerator = (int_array (int_range 0 1) 2)
    let report: PropertyReport = (forall_int_array "zero" gen prop_fail_length_over_zero)
    assert (not (report_passed report))
}

/* =============================================================================
 * REPORT HELPERS
 * ============================================================================= */

pub fn report_passed(report: PropertyReport) -> bool {
    return report.passed
}

shadow report_passed {
    let report: PropertyReport = PropertyReport {
        name: "r",
        passed: true,
        case_count: 1,
        discard_count: 0,
        shrink_count: 0,
        counterexample: ""
    }
    assert (report_passed report)
}

pub fn report_summary(report: PropertyReport) -> string {
    let mut summary: string = report.name
    set summary (+ summary ": ")
    if report.passed {
        set summary (+ summary "PASS")
    } else {
        set summary (+ summary "FAIL")
    }
    set summary (+ summary " (cases=")
    set summary (+ summary (int_to_string report.case_count))
    set summary (+ summary ", discards=")
    set summary (+ summary (int_to_string report.discard_count))
    set summary (+ summary ")")
    if (and (not report.passed) (!= report.counterexample "")) {
        set summary (+ summary " :: ")
        set summary (+ summary report.counterexample)
    }
    return summary
}

shadow report_summary {
    let report: PropertyReport = PropertyReport {
        name: "demo",
        passed: false,
        case_count: 2,
        discard_count: 1,
        shrink_count: 3,
        counterexample: "x=5"
    }
    let summary: string = (report_summary report)
    assert (> (str_length summary) 0)
}

fn format_int_array(values: array<int>) -> string {
    let mut text: string = "["
    let len: int = (array_length values)
    let mut i: int = 0
    while (< i len) {
        if (> i 0) {
            set text (+ text ", ")
        }
        set text (+ text (int_to_string (at values i)))
        set i (+ i 1)
    }
    set text (+ text "]")
    return text
}

shadow format_int_array {
    let arr: array<int> = (array_push [] 3)
    let text: string = (format_int_array arr)
    assert (== text "[3]")
}

fn unary_failure_message(name: string, value: int, message: string) -> string {
    let mut output: string = name
    set output (+ output " failed with x=")
    set output (+ output (int_to_string value))
    if (!= message "") {
        set output (+ output " :: ")
        set output (+ output message)
    }
    return output
}

shadow unary_failure_message {
    let text: string = (unary_failure_message "p" 5 "boom")
    assert (> (str_length text) 0)
}

fn pair_failure_message(name: string, first: int, second: int, message: string) -> string {
    let mut output: string = name
    set output (+ output " failed with (a=")
    set output (+ output (int_to_string first))
    set output (+ output ", b=")
    set output (+ output (int_to_string second))
    set output (+ output ")")
    if (!= message "") {
        set output (+ output " :: ")
        set output (+ output message)
    }
    return output
}

shadow pair_failure_message {
    let text: string = (pair_failure_message "p" 1 2 "err")
    assert (> (str_length text) 0)
}

fn array_failure_message(name: string, values: array<int>, message: string) -> string {
    let mut output: string = name
    set output (+ output " failed with values=")
    set output (+ output (format_int_array values))
    if (!= message "") {
        set output (+ output " :: ")
        set output (+ output message)
    }
    return output
}

shadow array_failure_message {
    let arr: array<int> = (array_push [] 1)
    let text: string = (array_failure_message "p" arr "err")
    assert (> (str_length text) 0)
}

/* =============================================================================
 * PROPERTY RUNNERS
 * ============================================================================= */

fn run_unary_property(name: string, cfg: RunConfig, generator: IntRangeGenerator, property: fn(int) -> string) -> PropertyReport {
    let normalized: RunConfig = (normalize_config cfg)
    let mut rng: RNG = (rng_seed normalized.seed)
    let mut cases: int = 0
    let mut discards: int = 0
    let mut attempts: int = 0
    let limit: int = (+ normalized.trials normalized.discard_limit)
    while (and (< cases normalized.trials) (< attempts limit)) {
        let sample: IntSample = (sample_int generator rng)
        set rng sample.next_rng
        let encoded: string = (property sample.value)
        let outcome: PropOutcome = (decode_outcome encoded)
        if (prop_is_pass outcome) {
            set cases (+ cases 1)
        } else {
            if (prop_is_discard outcome) {
                set discards (+ discards 1)
            } else {
                let shrink: IntShrinkResult = (shrink_int_value sample.value property normalized.max_shrink_steps)
                return PropertyReport {
                    name: name,
                    passed: false,
                    case_count: cases,
                    discard_count: discards,
                    shrink_count: shrink.steps,
                    counterexample: (unary_failure_message name shrink.value outcome.message)
                }
            }
        }
        set attempts (+ attempts 1)
    }
    return PropertyReport {
        name: name,
        passed: true,
        case_count: cases,
        discard_count: discards,
        shrink_count: 0,
        counterexample: ""
    }
}

shadow run_unary_property {
    let cfg: RunConfig = (config 10 5 5 1)
    let report: PropertyReport = (run_unary_property "demo" cfg (int_range 0 2) prop_fail_over_three)
    assert (report_passed report)
}

fn run_pair_property(name: string, cfg: RunConfig, generator: IntPairGenerator, property: fn(int, int) -> string) -> PropertyReport {
    let normalized: RunConfig = (normalize_config cfg)
    let mut rng: RNG = (rng_seed normalized.seed)
    let mut cases: int = 0
    let mut discards: int = 0
    let mut attempts: int = 0
    let limit: int = (+ normalized.trials normalized.discard_limit)
    while (and (< cases normalized.trials) (< attempts limit)) {
        let sample: PairSample = (sample_pair generator rng)
        set rng sample.next_rng
        let encoded: string = (property sample.first sample.second)
        let outcome: PropOutcome = (decode_outcome encoded)
        if (prop_is_pass outcome) {
            set cases (+ cases 1)
        } else {
            if (prop_is_discard outcome) {
                set discards (+ discards 1)
            } else {
                let shrink: PairShrinkResult = (shrink_pair_value sample.first sample.second property normalized.max_shrink_steps)
                return PropertyReport {
                    name: name,
                    passed: false,
                    case_count: cases,
                    discard_count: discards,
                    shrink_count: shrink.steps,
                    counterexample: (pair_failure_message name shrink.first shrink.second outcome.message)
                }
            }
        }
        set attempts (+ attempts 1)
    }
    return PropertyReport {
        name: name,
        passed: true,
        case_count: cases,
        discard_count: discards,
        shrink_count: 0,
        counterexample: ""
    }
}

shadow run_pair_property {
    let cfg: RunConfig = (config 5 3 5 2)
    let report: PropertyReport = (run_pair_property "pair" cfg (int_pair (int_range 0 1) (int_range 0 1)) prop_fail_sum_over_five)
    assert (report_passed report)
}

fn run_array_property(name: string, cfg: RunConfig, generator: IntArrayGenerator, property: fn(array<int>) -> string) -> PropertyReport {
    let normalized: RunConfig = (normalize_config cfg)
    let mut rng: RNG = (rng_seed normalized.seed)
    let mut cases: int = 0
    let mut discards: int = 0
    let mut attempts: int = 0
    let limit: int = (+ normalized.trials normalized.discard_limit)
    while (and (< cases normalized.trials) (< attempts limit)) {
        let sample: ArraySample = (sample_array generator rng)
        set rng sample.next_rng
        let encoded: string = (property sample.values)
        let outcome: PropOutcome = (decode_outcome encoded)
        if (prop_is_pass outcome) {
            set cases (+ cases 1)
        } else {
            if (prop_is_discard outcome) {
                set discards (+ discards 1)
            } else {
                let shrink: ArrayShrinkResult = (shrink_array_value sample.values property normalized.max_shrink_steps)
                return PropertyReport {
                    name: name,
                    passed: false,
                    case_count: cases,
                    discard_count: discards,
                    shrink_count: shrink.steps,
                    counterexample: (array_failure_message name shrink.values outcome.message)
                }
            }
        }
        set attempts (+ attempts 1)
    }
    return PropertyReport {
        name: name,
        passed: true,
        case_count: cases,
        discard_count: discards,
        shrink_count: 0,
        counterexample: ""
    }
}

shadow run_array_property {
    let cfg: RunConfig = (config 3 3 3 3)
    let gen: IntArrayGenerator = (int_array (int_range 0 1) 1)
    let report: PropertyReport = (run_array_property "array" cfg gen prop_fail_length_over_one)
    assert (report_passed report)
}

/* =============================================================================
 * PUBLIC API
 * ============================================================================= */

pub fn forall_int(name: string, generator: IntRangeGenerator, property: fn(int) -> string) -> PropertyReport {
    return (run_unary_property name (config_default) generator property)
}

shadow forall_int {
    let report: PropertyReport = (forall_int "non-negative" (int_range 0 5) prop_non_negative_only)
    assert (report_passed report)
}

pub fn forall_int_with_config(name: string, generator: IntRangeGenerator, property: fn(int) -> string, cfg: RunConfig) -> PropertyReport {
    return (run_unary_property name cfg generator property)
}

shadow forall_int_with_config {
    let cfg: RunConfig = (config 5 5 5 7)
    let report: PropertyReport = (forall_int_with_config "cfg" (int_range -5 -1) prop_bound_at_negative_five cfg)
    assert (report_passed report)
}

pub fn forall_int_pair(name: string, generator: IntPairGenerator, property: fn(int, int) -> string) -> PropertyReport {
    return (run_pair_property name (config_default) generator property)
}

shadow forall_int_pair {
    let gen: IntPairGenerator = (int_pair (int_range 0 1) (int_range 0 1))
    let report: PropertyReport = (forall_int_pair "pair" gen prop_pairs_must_match)
    assert (not (report_passed report))
}

pub fn forall_int_pair_with_config(name: string, generator: IntPairGenerator, property: fn(int, int) -> string, cfg: RunConfig) -> PropertyReport {
    return (run_pair_property name cfg generator property)
}

shadow forall_int_pair_with_config {
    let cfg: RunConfig = (config 3 3 3 9)
    let report: PropertyReport = (forall_int_pair_with_config "pair" (int_pair (int_range 0 1) (int_range 0 1)) prop_fail_on_zero_sum cfg)
    assert (not (report_passed report))
}

pub fn forall_int_array(name: string, generator: IntArrayGenerator, property: fn(array<int>) -> string) -> PropertyReport {
    return (run_array_property name (config_default) generator property)
}

shadow forall_int_array {
    let gen: IntArrayGenerator = (int_array (int_range 0 1) 2)
    let report: PropertyReport = (forall_int_array "array" gen prop_fail_length_over_zero)
    assert (not (report_passed report))
}

pub fn forall_int_array_with_config(name: string, generator: IntArrayGenerator, property: fn(array<int>) -> string, cfg: RunConfig) -> PropertyReport {
    return (run_array_property name cfg generator property)
}

shadow forall_int_array_with_config {
    let cfg: RunConfig = (config 4 4 4 5)
    let gen: IntArrayGenerator = (int_array (int_range 0 1) 1)
    let report: PropertyReport = (forall_int_array_with_config "array" gen prop_fail_length_over_one cfg)
    assert (report_passed report)
}
