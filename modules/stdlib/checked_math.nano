/* =============================================================================
 * Checked Arithmetic Operations for NanoLang
 * =============================================================================
 * SAFETY: These functions check for overflow, underflow, and division by zero.
 * They return Result<int, string> instead of crashing or wrapping silently.
 * 
 * MISRA Rule 12.4 Compliance: All arithmetic operations check for overflow
 * JSF AV Rule 204: Division operations check for zero divisor
 * 
 * Usage:
 *   let result: Result<int, string> = (checked_add 1000000 2000000)
 *   match result {
 *       Ok(v) => (println v.value),
 *       Err(e) => (println e.error)
 *   }
 */

/* Generic Result union for error handling */
union Result<T, E> {
    Ok { value: T },
    Err { error: E }
}

/* =============================================================================
 * CHECKED ADDITION
 * =============================================================================
 * Returns Result.Err if:
 * - Positive overflow: a > 0, b > 0, result < 0
 * - Negative overflow: a < 0, b < 0, result > 0
 */
pub fn checked_add(a: int, b: int) -> Result<int, string> {
    /* Check for positive overflow: a + b > INT64_MAX */
    if (and (> a 0) (> b 0)) {
        let max_int: int = 9223372036854775807
        if (> a (- max_int b)) {
            return Result.Err { error: "Integer overflow in addition" }
        } else {
            (print "")
        }
    } else {
        (print "")
    }
    
    /* Check for negative overflow: a + b < INT64_MIN */
    if (and (< a 0) (< b 0)) {
        let min_int: int = -9223372036854775808
        if (< a (- min_int b)) {
            return Result.Err { error: "Integer underflow in addition" }
        } else {
            (print "")
        }
    } else {
        (print "")
    }
    
    return Result.Ok { value: (+ a b) }
}

shadow checked_add {
    /* Test normal addition - should succeed */
    let r1: Result<int, string> = (checked_add 100 200)
    match r1 {
        Ok(v) => {
            assert (== v.value 300)
        },
        Err(e) => {
            (println "Unexpected error in normal addition")
            assert (== 1 0)
        }
    }
    
    /* Test negative numbers */
    let r3: Result<int, string> = (checked_add -100 50)
    match r3 {
        Ok(v) => {
            assert (== v.value -50)
        },
        Err(e) => {
            (println "Unexpected error in negative addition")
            assert (== 1 0)
        }
    }
}

/* =============================================================================
 * CHECKED SUBTRACTION
 * =============================================================================
 * Returns Result.Err if:
 * - Overflow: a > 0, b < 0, result < 0
 * - Underflow: a < 0, b > 0, result > 0
 */
pub fn checked_sub(a: int, b: int) -> Result<int, string> {
    /* Check for overflow: a - b > INT64_MAX (when b is negative) */
    if (and (> a 0) (< b 0)) {
        let max_int: int = 9223372036854775807
        /* Equivalent to: a > INT64_MAX + b */
        if (> a (+ max_int b)) {
            return Result.Err { error: "Integer overflow in subtraction" }
        } else {
            (print "")
        }
    } else {
        (print "")
    }
    
    /* Check for underflow: a - b < INT64_MIN (when b is positive) */
    if (and (< a 0) (> b 0)) {
        let min_int: int = -9223372036854775808
        /* Equivalent to: a < INT64_MIN + b */
        if (< a (+ min_int b)) {
            return Result.Err { error: "Integer underflow in subtraction" }
        } else {
            (print "")
        }
    } else {
        (print "")
    }
    
    return Result.Ok { value: (- a b) }
}

shadow checked_sub {
    /* Test normal subtraction */
    let r1: Result<int, string> = (checked_sub 300 100)
    match r1 {
        Ok(v) => {
            assert (== v.value 200)
        },
        Err(e) => {
            (println "Unexpected error in normal subtraction")
            assert (== 1 0)
        }
    }
}

/* =============================================================================
 * CHECKED MULTIPLICATION
 * =============================================================================
 * Returns Result.Err if:
 * - Result would overflow INT64_MAX
 * - Result would underflow INT64_MIN
 */
pub fn checked_mul(a: int, b: int) -> Result<int, string> {
    /* Handle zero cases (always safe) */
    if (or (== a 0) (== b 0)) {
        return Result.Ok { value: 0 }
    } else {
        (print "")
    }
    
    let max_int: int = 9223372036854775807
    let min_int: int = -9223372036854775808
    
    /* Check for overflow with same signs */
    if (and (> a 0) (> b 0)) {
        if (> a (/ max_int b)) {
            return Result.Err { error: "Integer overflow in multiplication" }
        } else {
            (print "")
        }
    } else {
        (print "")
    }
    
    if (and (< a 0) (< b 0)) {
        /* Both negative: result positive */
        let pos_a: int = (- 0 a)
        let pos_b: int = (- 0 b)
        if (> pos_a (/ max_int pos_b)) {
            return Result.Err { error: "Integer overflow in multiplication" }
        } else {
            (print "")
        }
    } else {
        (print "")
    }
    
    /* Check for underflow with opposite signs */
    if (or (and (> a 0) (< b 0)) (and (< a 0) (> b 0))) {
        /* One negative: result negative - compute absolute values */
        let mut abs_a: int = a
        if (< a 0) {
            set abs_a (- 0 a)
        } else {
            set abs_a a
        }
        
        let mut abs_b: int = b
        if (< b 0) {
            set abs_b (- 0 b)
        } else {
            set abs_b b
        }
        
        let abs_min: int = (- 0 min_int)
        
        if (> abs_a (/ abs_min abs_b)) {
            return Result.Err { error: "Integer underflow in multiplication" }
        } else {
            (print "")
        }
    } else {
        (print "")
    }
    
    return Result.Ok { value: (* a b) }
}

shadow checked_mul {
    /* Test normal multiplication */
    let r1: Result<int, string> = (checked_mul 100 200)
    match r1 {
        Ok(v) => {
            assert (== v.value 20000)
        },
        Err(e) => {
            (println "Unexpected error in normal multiplication")
            assert (== 1 0)
        }
    }
    
    /* Test zero cases */
    let r3: Result<int, string> = (checked_mul 0 1000000)
    match r3 {
        Ok(v) => {
            assert (== v.value 0)
        },
        Err(e) => {
            (println "Unexpected error in zero multiplication")
            assert (== 1 0)
        }
    }
}

/* =============================================================================
 * CHECKED DIVISION
 * =============================================================================
 * Returns Result.Err if:
 * - Divisor is zero (JSF AV Rule 204)
 * - INT64_MIN / -1 (only case that overflows)
 */
pub fn checked_div(a: int, b: int) -> Result<int, string> {
    /* Check for division by zero - CRITICAL SAFETY CHECK */
    if (== b 0) {
        return Result.Err { error: "Division by zero" }
    } else {
        (print "")
    }
    
    /* Check for overflow: INT64_MIN / -1 = INT64_MAX + 1 (overflow) */
    let min_int: int = -9223372036854775808
    if (and (== a min_int) (== b -1)) {
        return Result.Err { error: "Integer overflow in division (INT64_MIN / -1)" }
    } else {
        (print "")
    }
    
    return Result.Ok { value: (/ a b) }
}

shadow checked_div {
    /* Test normal division */
    let r1: Result<int, string> = (checked_div 100 2)
    match r1 {
        Ok(v) => {
            assert (== v.value 50)
        },
        Err(e) => {
            (println "Unexpected error in normal division")
            assert (== 1 0)
        }
    }
    
    /* Test negative division */
    let r4: Result<int, string> = (checked_div -100 2)
    match r4 {
        Ok(v) => {
            assert (== v.value -50)
        },
        Err(e) => {
            (println "Unexpected error in negative division")
            assert (== 1 0)
        }
    }
}

/* =============================================================================
 * CHECKED MODULO
 * =============================================================================
 * Returns Result.Err if:
 * - Divisor is zero
 * - INT64_MIN % -1 (causes undefined behavior in C)
 */
pub fn checked_mod(a: int, b: int) -> Result<int, string> {
    /* Check for modulo by zero */
    if (== b 0) {
        return Result.Err { error: "Modulo by zero" }
    } else {
        (print "")
    }
    
    /* Check for INT64_MIN % -1 (implementation-defined in C) */
    let min_int: int = -9223372036854775808
    if (and (== a min_int) (== b -1)) {
        /* Technically result is 0, but some platforms UB */
        return Result.Ok { value: 0 }
    } else {
        (print "")
    }
    
    return Result.Ok { value: (% a b) }
}

shadow checked_mod {
    /* Test normal modulo */
    let r1: Result<int, string> = (checked_mod 10 3)
    match r1 {
        Ok(v) => {
            assert (== v.value 1)
        },
        Err(e) => {
            (println "Unexpected error in normal modulo")
            assert (== 1 0)
        }
    }
    
    /* Test INT64_MIN % -1 */
    let r3: Result<int, string> = (checked_mod -9223372036854775808 -1)
    match r3 {
        Ok(v) => {
            assert (== v.value 0)
        },
        Err(e) => {
            (println "Unexpected error in INT64_MIN % -1")
            assert (== 1 0)
        }
    }
}

/* This is a library module - import it to use checked arithmetic operations
 * Example: import "modules/stdlib/checked_math.nano"
 * Then use: checked_add, checked_sub, checked_mul, checked_div, checked_mod
 */

