/* =============================================================================
 * std::math::vector4d Module - 4D Vector Mathematics
 * =============================================================================
 * Useful for homogeneous coordinates (mat4 transforms).
 */

module std_math_vector4d

from "std/math/vector3d.nano" import Vector3D, vec3_new

pub struct Vector4D {
    x: float,
    y: float,
    z: float,
    w: float
}

pub fn vec4_new(x: float, y: float, z: float, w: float) -> Vector4D {
    return Vector4D { x: x, y: y, z: z, w: w }
}

shadow vec4_new {
    let v: Vector4D = (vec4_new 1.0 2.0 3.0 4.0)
    assert (< (abs (- v.x 1.0)) 0.001)
    assert (< (abs (- v.y 2.0)) 0.001)
    assert (< (abs (- v.z 3.0)) 0.001)
    assert (< (abs (- v.w 4.0)) 0.001)
}

pub fn vec4_zero() -> Vector4D {
    return Vector4D { x: 0.0, y: 0.0, z: 0.0, w: 0.0 }
}

shadow vec4_zero {
    let v: Vector4D = (vec4_zero)
    assert (< (abs v.x) 0.001)
    assert (< (abs v.y) 0.001)
    assert (< (abs v.z) 0.001)
    assert (< (abs v.w) 0.001)
}

pub fn vec4_add(a: Vector4D, b: Vector4D) -> Vector4D {
    return Vector4D { x: (+ a.x b.x), y: (+ a.y b.y), z: (+ a.z b.z), w: (+ a.w b.w) }
}

shadow vec4_add {
    let a: Vector4D = (vec4_new 1.0 2.0 3.0 4.0)
    let b: Vector4D = (vec4_new 5.0 6.0 7.0 8.0)
    let result: Vector4D = (vec4_add a b)
    assert (< (abs (- result.x 6.0)) 0.001)
    assert (< (abs (- result.y 8.0)) 0.001)
    assert (< (abs (- result.z 10.0)) 0.001)
    assert (< (abs (- result.w 12.0)) 0.001)
}

pub fn vec4_sub(a: Vector4D, b: Vector4D) -> Vector4D {
    return Vector4D { x: (- a.x b.x), y: (- a.y b.y), z: (- a.z b.z), w: (- a.w b.w) }
}

shadow vec4_sub {
    let a: Vector4D = (vec4_new 5.0 6.0 7.0 8.0)
    let b: Vector4D = (vec4_new 1.0 2.0 3.0 4.0)
    let result: Vector4D = (vec4_sub a b)
    assert (< (abs (- result.x 4.0)) 0.001)
    assert (< (abs (- result.y 4.0)) 0.001)
    assert (< (abs (- result.z 4.0)) 0.001)
    assert (< (abs (- result.w 4.0)) 0.001)
}

pub fn vec4_scale(v: Vector4D, s: float) -> Vector4D {
    return Vector4D { x: (* v.x s), y: (* v.y s), z: (* v.z s), w: (* v.w s) }
}

shadow vec4_scale {
    let v: Vector4D = (vec4_new 1.0 2.0 3.0 4.0)
    let result: Vector4D = (vec4_scale v 2.0)
    assert (< (abs (- result.x 2.0)) 0.001)
    assert (< (abs (- result.y 4.0)) 0.001)
    assert (< (abs (- result.z 6.0)) 0.001)
    assert (< (abs (- result.w 8.0)) 0.001)
}

pub fn vec4_dot(a: Vector4D, b: Vector4D) -> float {
    return (+ (+ (+ (* a.x b.x) (* a.y b.y)) (* a.z b.z)) (* a.w b.w))
}

shadow vec4_dot {
    let a: Vector4D = (vec4_new 1.0 2.0 3.0 4.0)
    let b: Vector4D = (vec4_new 5.0 6.0 7.0 8.0)
    let result: float = (vec4_dot a b)
    assert (< (abs (- result 70.0)) 0.001)
}

pub fn vec4_length(v: Vector4D) -> float {
    return (sqrt (vec4_dot v v))
}

shadow vec4_length {
    let v: Vector4D = (vec4_new 1.0 0.0 0.0 0.0)
    let result: float = (vec4_length v)
    assert (< (abs (- result 1.0)) 0.001)
}

pub fn vec4_normalize(v: Vector4D) -> Vector4D {
    let len: float = (vec4_length v)
    if (> len 0.0) {
        return (vec4_scale v (/ 1.0 len))
    } else {
        return (vec4_zero)
    }
}

shadow vec4_normalize {
    let v: Vector4D = (vec4_new 3.0 0.0 0.0 0.0)
    let result: Vector4D = (vec4_normalize v)
    assert (< (abs (- result.x 1.0)) 0.001)
    assert (< (abs result.y) 0.001)
    assert (< (abs result.z) 0.001)
}

pub fn vec4_from_vec3(v: Vector3D, w: float) -> Vector4D {
    return Vector4D { x: v.x, y: v.y, z: v.z, w: w }
}

shadow vec4_from_vec3 {
    let v3: Vector3D = (vec3_new 1.0 2.0 3.0)
    let result: Vector4D = (vec4_from_vec3 v3 4.0)
    assert (< (abs (- result.x 1.0)) 0.001)
    assert (< (abs (- result.y 2.0)) 0.001)
    assert (< (abs (- result.z 3.0)) 0.001)
    assert (< (abs (- result.w 4.0)) 0.001)
}

pub fn vec4_to_vec3_div_w(v: Vector4D) -> Vector3D {
    if (> (abs v.w) 0.0000001) {
        return (vec3_new (/ v.x v.w) (/ v.y v.w) (/ v.z v.w))
    } else {
        return (vec3_new v.x v.y v.z)
    }
}

shadow vec4_to_vec3_div_w {
    let v: Vector4D = (vec4_new 2.0 4.0 6.0 2.0)
    let result: Vector3D = (vec4_to_vec3_div_w v)
    assert (< (abs (- result.x 1.0)) 0.001)
    assert (< (abs (- result.y 2.0)) 0.001)
    assert (< (abs (- result.z 3.0)) 0.001)
}
