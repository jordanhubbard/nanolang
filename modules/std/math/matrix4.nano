/* =============================================================================
 * std::math::matrix4 Module - 4x4 Matrix Math (float)
 * =============================================================================
 * Row-major storage: m[row*4 + col]
 */

module std_math_matrix4

from "std/math/vector3d.nano" import Vector3D, vec3_new
from "std/math/vector4d.nano" import Vector4D, vec4_new, vec4_to_vec3_div_w

pub struct Mat4 {
    m: array<float>
}

pub fn mat4_identity() -> Mat4 {
    return Mat4 {
        m: [
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0
        ]
    }
}

pub fn mat4_get(m: Mat4, row: int, col: int) -> float {
    return (at m.m (+ (* row 4) col))
}

pub fn mat4_set(m: Mat4, row: int, col: int, v: float) -> Mat4 {
    let mut out: Mat4 = m
    (array_set out.m (+ (* row 4) col) v)
    return out
}

pub fn mat4_mul(a: Mat4, b: Mat4) -> Mat4 {
    let mut out: array<float> = (array_new 16 0.0)
    let mut r: int = 0
    while (< r 4) {
        let mut c: int = 0
        while (< c 4) {
            let mut acc: float = 0.0
            let mut k: int = 0
            while (< k 4) {
                set acc (+ acc (* (mat4_get a r k) (mat4_get b k c)))
                set k (+ k 1)
            }
            (array_set out (+ (* r 4) c) acc)
            set c (+ c 1)
        }
        set r (+ r 1)
    }
    return Mat4 { m: out }
}

pub fn mat4_mul_vec4(m: Mat4, v: Vector4D) -> Vector4D {
    let x: float = (+ (+ (+ (* (mat4_get m 0 0) v.x) (* (mat4_get m 0 1) v.y)) (* (mat4_get m 0 2) v.z)) (* (mat4_get m 0 3) v.w))
    let y: float = (+ (+ (+ (* (mat4_get m 1 0) v.x) (* (mat4_get m 1 1) v.y)) (* (mat4_get m 1 2) v.z)) (* (mat4_get m 1 3) v.w))
    let z: float = (+ (+ (+ (* (mat4_get m 2 0) v.x) (* (mat4_get m 2 1) v.y)) (* (mat4_get m 2 2) v.z)) (* (mat4_get m 2 3) v.w))
    let w: float = (+ (+ (+ (* (mat4_get m 3 0) v.x) (* (mat4_get m 3 1) v.y)) (* (mat4_get m 3 2) v.z)) (* (mat4_get m 3 3) v.w))
    return (vec4_new x y z w)
}

pub fn mat4_translation(tx: float, ty: float, tz: float) -> Mat4 {
    let mut m: Mat4 = (mat4_identity)
    set m (mat4_set m 0 3 tx)
    set m (mat4_set m 1 3 ty)
    set m (mat4_set m 2 3 tz)
    return m
}

pub fn mat4_scale(sx: float, sy: float, sz: float) -> Mat4 {
    return Mat4 {
        m: [
            sx,  0.0, 0.0, 0.0,
            0.0, sy,  0.0, 0.0,
            0.0, 0.0, sz,  0.0,
            0.0, 0.0, 0.0, 1.0
        ]
    }
}

pub fn mat4_rotation_x(angle: float) -> Mat4 {
    let c: float = (cos angle)
    let s: float = (sin angle)
    return Mat4 {
        m: [
            1.0, 0.0, 0.0, 0.0,
            0.0, c,   (- s), 0.0,
            0.0, s,   c,   0.0,
            0.0, 0.0, 0.0, 1.0
        ]
    }
}

pub fn mat4_rotation_y(angle: float) -> Mat4 {
    let c: float = (cos angle)
    let s: float = (sin angle)
    return Mat4 {
        m: [
            c,   0.0, s,   0.0,
            0.0, 1.0, 0.0, 0.0,
            (- s), 0.0, c,   0.0,
            0.0, 0.0, 0.0, 1.0
        ]
    }
}

pub fn mat4_rotation_z(angle: float) -> Mat4 {
    let c: float = (cos angle)
    let s: float = (sin angle)
    return Mat4 {
        m: [
            c,   (- s), 0.0, 0.0,
            s,   c,   0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0
        ]
    }
}

pub fn mat4_transform_point(m: Mat4, p: Vector3D) -> Vector3D {
    let v: Vector4D = (vec4_new p.x p.y p.z 1.0)
    return (vec4_to_vec3_div_w (mat4_mul_vec4 m v))
}

pub fn mat4_transform_dir(m: Mat4, d: Vector3D) -> Vector3D {
    let v: Vector4D = (vec4_new d.x d.y d.z 0.0)
    let r: Vector4D = (mat4_mul_vec4 m v)
    return (vec3_new r.x r.y r.z)
}