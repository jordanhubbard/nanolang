/* =============================================================================
 * std::env
 * =============================================================================
 */

module std_env

/* FFI declarations */
extern fn get_argc() -> int
extern fn get_argv(_index: int) -> string
extern fn nl_os_getenv(_name: string) -> string
extern fn nl_os_setenv(_name: string, _value: string, _overwrite: int) -> int
extern fn nl_os_unsetenv(_name: string) -> int

pub fn get(name: string) -> string {
    let mut val: string = ""
    unsafe {
        set val (nl_os_getenv name)
    }
    return val
}

shadow get {
    let path: string = (get "PATH")
    assert (> (str_length path) 0)
}

pub fn set_env(name: string, value: string) -> int {
    let mut code: int = 0
    unsafe {
        set code (nl_os_setenv name value 1)
    }
    return code
}

shadow set_env {
    let code: int = (set_env "NANOLANG_TEST" "hello")
    assert (== code 0)
    let val: string = (get "NANOLANG_TEST")
    assert (== val "hello")
}

pub fn unset(name: string) -> int {
    let mut code: int = 0
    unsafe {
        set code (nl_os_unsetenv name)
    }
    return code
}

shadow unset {
    (set_env "NANOLANG_TEST2" "world")
    let code: int = (unset "NANOLANG_TEST2")
    assert (== code 0)
}

pub fn args() -> array<string> {
    let mut argc: int = 0
    unsafe {
        set argc (get_argc)
    }
    let mut out: array<string> = []
    let mut i: int = 0

    while (< i argc) {
        let mut arg: string = ""
        unsafe {
            set arg (get_argv i)
        }
        set out (array_push out arg)
        set i (+ i 1)
    }

    return out
}

shadow args {
    let argv: array<string> = (args)
    assert (> (array_length argv) 0)
}

/* Individual argc/argv access (for cases where full array is not needed) */
pub fn argc() -> int {
    let mut count: int = 0
    unsafe {
        set count (get_argc)
    }
    return count
}

shadow argc {
    let count: int = (argc)
    assert (> count 0)
}

pub fn argv(index: int) -> string {
    let mut arg: string = ""
    unsafe {
        set arg (get_argv index)
    }
    return arg
}

shadow argv {
    let arg0: string = (argv 0)
    assert (> (str_length arg0) 0)
}
