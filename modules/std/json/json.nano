/* =============================================================================
 * std::json - JSON parsing/manipulation (cJSON-backed)
 * ============================================================================= */

module std_json

opaque type Json

extern fn nl_json_parse(_text: string) -> Json
extern fn nl_json_free(_json: Json) -> void
extern fn nl_json_stringify(_json: Json) -> string

extern fn nl_json_is_null(_json: Json) -> int
extern fn nl_json_is_bool(_json: Json) -> int
extern fn nl_json_is_number(_json: Json) -> int
extern fn nl_json_is_string(_json: Json) -> int
extern fn nl_json_is_array(_json: Json) -> int
extern fn nl_json_is_object(_json: Json) -> int

extern fn nl_json_as_int(_json: Json) -> int
extern fn nl_json_as_bool(_json: Json) -> int
extern fn nl_json_as_string(_json: Json) -> string

extern fn nl_json_object_has(_obj: Json, _key: string) -> int
extern fn nl_json_get(_obj: Json, _key: string) -> Json
extern fn nl_json_object_keys(_obj: Json) -> array<string>

extern fn nl_json_array_size(_arr: Json) -> int
extern fn nl_json_get_index(_arr: Json, _idx: int) -> Json

extern fn nl_json_new_object() -> Json
extern fn nl_json_new_array() -> Json
extern fn nl_json_new_string(_s: string) -> Json
extern fn nl_json_new_int(_v: int) -> Json
extern fn nl_json_new_bool(_v: int) -> Json
extern fn nl_json_new_null() -> Json

extern fn nl_json_object_set(_obj: Json, _key: string, _val: Json) -> int
extern fn nl_json_array_push(_arr: Json, _val: Json) -> int

pub fn parse(text: string) -> Json {
    return (nl_json_parse text)
}

shadow parse {
    let j: Json = (parse "{\"a\": 1}")
    assert (!= j 0)
    (free j)
}

pub fn free(json: Json) -> void {
    unsafe {
        (nl_json_free json)
    }
}

shadow free {
    let j: Json = (parse "{\"a\": 1}")
    assert (!= j 0)
    (free j)
}

pub fn stringify(json: Json) -> string {
    return (nl_json_stringify json)
}

pub fn is_null(json: Json) -> bool { return (!= (nl_json_is_null json) 0) }
pub fn is_bool(json: Json) -> bool { return (!= (nl_json_is_bool json) 0) }
pub fn is_number(json: Json) -> bool { return (!= (nl_json_is_number json) 0) }
pub fn is_string(json: Json) -> bool { return (!= (nl_json_is_string json) 0) }
pub fn is_array(json: Json) -> bool { return (!= (nl_json_is_array json) 0) }
pub fn is_object(json: Json) -> bool { return (!= (nl_json_is_object json) 0) }

pub fn as_int(json: Json) -> int { return (nl_json_as_int json) }
pub fn as_bool(json: Json) -> bool { return (!= (nl_json_as_bool json) 0) }
pub fn as_string(json: Json) -> string { return (nl_json_as_string json) }

pub fn object_has(obj: Json, key: string) -> bool { return (!= (nl_json_object_has obj key) 0) }
pub fn get(obj: Json, key: string) -> Json { return (nl_json_get obj key) }
pub fn keys(obj: Json) -> array<string> { return (nl_json_object_keys obj) }

pub fn array_size(arr: Json) -> int { return (nl_json_array_size arr) }
pub fn get_index(arr: Json, idx: int) -> Json { return (nl_json_get_index arr idx) }

pub fn new_object() -> Json { return (nl_json_new_object) }
pub fn new_array() -> Json { return (nl_json_new_array) }
pub fn new_string(s: string) -> Json { return (nl_json_new_string s) }
pub fn new_int(v: int) -> Json { return (nl_json_new_int v) }
pub fn new_bool(v: bool) -> Json {
    let iv: int = (cond
        (v 1)
        (else 0)
    )
    return (nl_json_new_bool iv)
}
pub fn new_null() -> Json { return (nl_json_new_null) }

pub fn object_set(obj: Json, key: string, val: Json) -> bool {
    return (!= (nl_json_object_set obj key val) 0)
}

pub fn json_array_push(arr: Json, val: Json) -> bool {
    return (!= (nl_json_array_push arr val) 0)
}

shadow json_array_push {
    let a: Json = (new_array)
    assert (json_array_push a (new_int 1))
    assert (== (array_size a) 1)
    (free a)
}

pub fn get_string(obj: Json, key: string) -> string {
    let it: Json = (get obj key)
    if (== it 0) {
        return ""
    }
    let s: string = (as_string it)
    (free it)
    return s
}

shadow get_string {
    let j: Json = (parse "{\"b\": \"hi\"}")
    assert (== (get_string j "b") "hi")
    assert (== (get_string j "missing") "")
    (free j)
}

pub fn get_int(obj: Json, key: string) -> int {
    let it: Json = (get obj key)
    if (== it 0) {
        return 0
    }
    let v: int = (as_int it)
    (free it)
    return v
}

shadow get_int {
    let j: Json = (parse "{\"a\": 1}")
    assert (== (get_int j "a") 1)
    assert (== (get_int j "missing") 0)
    (free j)
}
