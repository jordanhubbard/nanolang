/* =============================================================================
 * std::collections::StringBuilder Module
 * =============================================================================
 * Efficient string building without O(nÂ²) concatenation.
 * 
 * Usage:
 *   from "std/collections/stringbuilder.nano" import StringBuilder, sb_new, sb_append
 *   let sb: StringBuilder = (sb_new)
 *   let sb2: StringBuilder = (sb_append sb "Hello World")
 *   let result: string = (sb_to_string sb2)
 */

module std_collections_stringbuilder

opaque type NLStringBuilder

extern fn nl_sb_new() -> NLStringBuilder
extern fn nl_sb_with_capacity(_capacity: int) -> NLStringBuilder
extern fn nl_sb_append(_sb: NLStringBuilder, _text: string) -> void
extern fn nl_sb_append_char(_sb: NLStringBuilder, _ch: int) -> void
extern fn nl_sb_clear(_sb: NLStringBuilder) -> void
extern fn nl_sb_length(_sb: NLStringBuilder) -> int
extern fn nl_sb_capacity(_sb: NLStringBuilder) -> int
extern fn nl_sb_to_string(_sb: NLStringBuilder) -> string
extern fn nl_sb_free(_sb: NLStringBuilder) -> void

pub struct StringBuilder {
    handle: NLStringBuilder
}

/* Create a new StringBuilder with default capacity */
pub fn sb_new() -> StringBuilder {
    return StringBuilder { handle: (nl_sb_new) }
}

shadow sb_new {
    let sb: StringBuilder = (sb_new)
    assert (== (sb_length sb) 0)
}

/* Create a new StringBuilder with specific initial capacity */
pub fn sb_with_capacity(capacity: int) -> StringBuilder {
    return StringBuilder { handle: (nl_sb_with_capacity capacity) }
}

shadow sb_with_capacity {
    let sb: StringBuilder = (sb_with_capacity 1024)
    assert (== (sb_capacity sb) 1024)
}

/* Append a string to the StringBuilder (returns same StringBuilder) */
pub fn sb_append(sb: StringBuilder, text: string) -> StringBuilder {
    unsafe {
        (nl_sb_append sb.handle text)
    }
    return sb
}

shadow sb_append {
    let sb1: StringBuilder = (sb_new)
    let sb2: StringBuilder = (sb_append sb1 "Hello")
    assert (== (sb_length sb2) 5)
    assert (== (str_equals (sb_to_string sb2) "Hello") true)
}

/* Append a string with a newline */
pub fn sb_append_line(sb: StringBuilder, text: string) -> StringBuilder {
    let sb2: StringBuilder = (sb_append sb text)
    return (sb_append sb2 "\n")
}

/* Append an integer (converted to string) */
pub fn sb_append_int(sb: StringBuilder, n: int) -> StringBuilder {
    let s: string = (int_to_string n)
    return (sb_append sb s)
}

/* Append a character (ASCII value) */
pub fn sb_append_char(sb: StringBuilder, c: int) -> StringBuilder {
    unsafe {
        (nl_sb_append_char sb.handle c)
    }
    return sb
}

/* Get the current content as a string */
pub fn sb_to_string(sb: StringBuilder) -> string {
    return (nl_sb_to_string sb.handle)
}

/* Get current length */
pub fn sb_length(sb: StringBuilder) -> int {
    return (nl_sb_length sb.handle)
}

pub fn sb_capacity(sb: StringBuilder) -> int {
    return (nl_sb_capacity sb.handle)
}

/* Clear the StringBuilder (reset to empty) */
pub fn sb_clear(sb: StringBuilder) -> StringBuilder {
    unsafe {
        (nl_sb_clear sb.handle)
    }
    return sb
}

/* Check if StringBuilder is empty */
pub fn sb_is_empty(sb: StringBuilder) -> bool {
    return (== (sb_length sb) 0)
}

pub fn sb_free(sb: StringBuilder) -> void {
    unsafe {
        (nl_sb_free sb.handle)
    }
}

/* Build a string from multiple parts efficiently */
pub fn sb_from_parts(parts: array<string>) -> string {
    let sb_start: StringBuilder = (sb_new)
    let count: int = (array_length parts)
    let mut sb: StringBuilder = sb_start
    let mut part_val: string = ""
    let mut idx: int = 0
    while (< idx count) {
        set part_val (at parts idx)
        set sb (sb_append sb part_val)
        set idx (+ idx 1)
    }
    
    return (sb_to_string sb)
}

/* Join strings with a separator */
pub fn sb_join(parts: array<string>, separator: string) -> string {
    let sb_start: StringBuilder = (sb_new)
    let count: int = (array_length parts)
    let mut sb: StringBuilder = sb_start
    let mut part_val: string = ""
    let mut idx: int = 0
    while (< idx count) {
        if (!= idx 0) {
            set sb (sb_append sb separator)
        }
        set part_val (at parts idx)
        set sb (sb_append sb part_val)
        set idx (+ idx 1)
    }
    
    return (sb_to_string sb)
}

/* Repeat a string n times */
pub fn sb_repeat(text: string, n: int) -> string {
    let sb_start: StringBuilder = (sb_new)
    let mut sb: StringBuilder = sb_start
    let mut i: int = 0
    while (< i n) {
        set sb (sb_append sb text)
        set i (+ i 1)
    }
    
    return (sb_to_string sb)
}

/* Build indentation string (spaces) */
pub fn sb_indent(level: int, spaces_per_level: int) -> string {
    let total_spaces: int = (* level spaces_per_level)
    return (sb_repeat " " total_spaces)
}

