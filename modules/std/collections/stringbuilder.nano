/* =============================================================================
 * std::collections::StringBuilder Module
 * =============================================================================
 * Efficient string building without O(nÂ²) concatenation.
 * 
 * Usage:
 *   from "std/collections/stringbuilder.nano" import StringBuilder, sb_new, sb_append
 *   let sb: StringBuilder = (sb_new)
 *   let sb2: StringBuilder = (sb_append sb "Hello World")
 *   let result: string = (sb_to_string sb2)
 */

module std_collections_stringbuilder

opaque type NLStringBuilder

extern fn nl_sb_new() -> NLStringBuilder
extern fn nl_sb_with_capacity(_capacity: int) -> NLStringBuilder
extern fn nl_sb_append(_sb: NLStringBuilder, _text: string) -> void
extern fn nl_sb_append_char(_sb: NLStringBuilder, _ch: int) -> void
extern fn nl_sb_clear(_sb: NLStringBuilder) -> void
extern fn nl_sb_length(_sb: NLStringBuilder) -> int
extern fn nl_sb_capacity(_sb: NLStringBuilder) -> int
extern fn nl_sb_to_string(_sb: NLStringBuilder) -> string
extern fn nl_sb_free(_sb: NLStringBuilder) -> void

pub struct StringBuilder {
    handle: NLStringBuilder
}

/* Create a new StringBuilder with default capacity */
pub fn sb_new() -> StringBuilder {
    return StringBuilder { handle: (nl_sb_new) }
}

shadow sb_new {
    let sb: StringBuilder = (sb_new)
    assert (== (sb_length sb) 0)
}

/* Create a new StringBuilder with specific initial capacity */
pub fn sb_with_capacity(capacity: int) -> StringBuilder {
    return StringBuilder { handle: (nl_sb_with_capacity capacity) }
}

shadow sb_with_capacity {
    let sb: StringBuilder = (sb_with_capacity 1024)
    assert (== (sb_capacity sb) 1024)
}

/* Append a string to the StringBuilder (returns same StringBuilder) */
pub fn sb_append(sb: StringBuilder, text: string) -> StringBuilder {
    unsafe {
        (nl_sb_append sb.handle text)
    }
    return sb
}

shadow sb_append {
    let sb1: StringBuilder = (sb_new)
    let sb2: StringBuilder = (sb_append sb1 "Hello")
    assert (== (sb_length sb2) 5)
    assert (== (== (sb_to_string sb2) "Hello") true)
}

/* Append a string with a newline */
pub fn sb_append_line(sb: StringBuilder, text: string) -> StringBuilder {
    let sb2: StringBuilder = (sb_append sb text)
    return (sb_append sb2 "\n")
}

shadow sb_append_line {
    let sb1: StringBuilder = (sb_new)
    let sb2: StringBuilder = (sb_append_line sb1 "Line 1")
    let sb3: StringBuilder = (sb_append_line sb2 "Line 2")
    assert (== (sb_length sb3) 14)
    assert (== (== (sb_to_string sb3) "Line 1\nLine 2\n") true)
}

/* Append an integer (converted to string) */
pub fn sb_append_int(sb: StringBuilder, n: int) -> StringBuilder {
    let s: string = (int_to_string n)
    return (sb_append sb s)
}

shadow sb_append_int {
    let sb1: StringBuilder = (sb_new)
    let sb2: StringBuilder = (sb_append_int sb1 42)
    assert (== (== (sb_to_string sb2) "42") true)

    let sb3: StringBuilder = (sb_append sb2 " and ")
    let sb4: StringBuilder = (sb_append_int sb3 100)
    assert (== (== (sb_to_string sb4) "42 and 100") true)
}

/* Append a character (ASCII value) */
pub fn sb_append_char(sb: StringBuilder, c: int) -> StringBuilder {
    unsafe {
        (nl_sb_append_char sb.handle c)
    }
    return sb
}

shadow sb_append_char {
    let sb1: StringBuilder = (sb_new)
    let sb2: StringBuilder = (sb_append_char sb1 'H')
    let sb3: StringBuilder = (sb_append_char sb2 'i')
    assert (== (== (sb_to_string sb3) "Hi") true)
}

/* Get the current content as a string */
pub fn sb_to_string(sb: StringBuilder) -> string {
    return (nl_sb_to_string sb.handle)
}

/* Get current length */
pub fn sb_length(sb: StringBuilder) -> int {
    return (nl_sb_length sb.handle)
}

pub fn sb_capacity(sb: StringBuilder) -> int {
    return (nl_sb_capacity sb.handle)
}

/* Clear the StringBuilder (reset to empty) */
pub fn sb_clear(sb: StringBuilder) -> StringBuilder {
    unsafe {
        (nl_sb_clear sb.handle)
    }
    return sb
}

shadow sb_clear {
    let sb1: StringBuilder = (sb_new)
    let sb2: StringBuilder = (sb_append sb1 "Hello")
    let sb3: StringBuilder = (sb_clear sb2)
    assert (== (sb_length sb3) 0)
    assert (== (== (sb_to_string sb3) "") true)
}

/* Check if StringBuilder is empty */
pub fn sb_is_empty(sb: StringBuilder) -> bool {
    return (== (sb_length sb) 0)
}

shadow sb_is_empty {
    let sb1: StringBuilder = (sb_new)
    assert (sb_is_empty sb1)

    let sb2: StringBuilder = (sb_append sb1 "X")
    assert (not (sb_is_empty sb2))
}

pub fn sb_free(sb: StringBuilder) -> void {
    unsafe {
        (nl_sb_free sb.handle)
    }
}

shadow sb_free {
    let sb1: StringBuilder = (sb_new)
    let sb2: StringBuilder = (sb_append sb1 "Bye")
    (sb_free sb2)
    assert true
}

/* Build a string from multiple parts efficiently */
pub fn sb_from_parts(parts: array<string>) -> string {
    let sb_start: StringBuilder = (sb_new)
    let count: int = (array_length parts)
    let mut sb: StringBuilder = sb_start
    let mut part_val: string = ""
    let mut idx: int = 0
    while (< idx count) {
        set part_val (at parts idx)
        set sb (sb_append sb part_val)
        set idx (+ idx 1)
    }
    
    return (sb_to_string sb)
}

shadow sb_from_parts {
    let parts: array<string> = (array_new 3 "")
    (array_set parts 0 "Hello")
    (array_set parts 1 " ")
    (array_set parts 2 "World")
    let result: string = (sb_from_parts parts)
    assert (== (== result "Hello World") true)
}

/* Join strings with a separator */
pub fn sb_join(parts: array<string>, separator: string) -> string {
    let sb_start: StringBuilder = (sb_new)
    let count: int = (array_length parts)
    let mut sb: StringBuilder = sb_start
    let mut part_val: string = ""
    let mut idx: int = 0
    while (< idx count) {
        if (!= idx 0) {
            set sb (sb_append sb separator)
        }
        set part_val (at parts idx)
        set sb (sb_append sb part_val)
        set idx (+ idx 1)
    }
    
    return (sb_to_string sb)
}

shadow sb_join {
    let parts: array<string> = (array_new 3 "")
    (array_set parts 0 "one")
    (array_set parts 1 "two")
    (array_set parts 2 "three")
    let result: string = (sb_join parts ", ")
    assert (== (== result "one, two, three") true)
}

/* Repeat a string n times */
pub fn sb_repeat(text: string, n: int) -> string {
    let sb_start: StringBuilder = (sb_new)
    let mut sb: StringBuilder = sb_start
    let mut i: int = 0
    while (< i n) {
        set sb (sb_append sb text)
        set i (+ i 1)
    }
    
    return (sb_to_string sb)
}

shadow sb_repeat {
    let result: string = (sb_repeat "ab" 3)
    assert (== (== result "ababab") true)
}

/* Build indentation string (spaces) */
pub fn sb_indent(level: int, spaces_per_level: int) -> string {
    let total_spaces: int = (* level spaces_per_level)
    return (sb_repeat " " total_spaces)
}

shadow sb_indent {
    let indent0: string = (sb_indent 0 4)
    assert (== (== indent0 "") true)

    let indent1: string = (sb_indent 1 4)
    assert (== (== indent1 "    ") true)

    let indent2: string = (sb_indent 2 4)
    assert (== (== indent2 "        ") true)
}

