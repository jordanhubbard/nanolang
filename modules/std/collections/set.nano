/* =============================================================================
 * std::collections::Set (string)
 * =============================================================================
 */

module std_collections_set

opaque type NLStringSet

extern fn nl_set_new() -> NLStringSet
extern fn nl_set_add(s: NLStringSet, key: string) -> void
extern fn nl_set_has(s: NLStringSet, key: string) -> bool
extern fn nl_set_size(s: NLStringSet) -> int
extern fn nl_set_values(s: NLStringSet) -> array<string>
extern fn nl_set_remove(s: NLStringSet, key: string) -> void
extern fn nl_set_clear(s: NLStringSet) -> void
extern fn nl_set_free(s: NLStringSet) -> void

pub struct Set {
    handle: NLStringSet
}

pub fn set_new() -> Set {
    return Set { handle: (nl_set_new) }
}

pub fn set_add(s: Set, key: string) -> Set {
    (nl_set_add s.handle key)
    return s
}

pub fn set_has(s: Set, key: string) -> bool {
    return (nl_set_has s.handle key)
}

pub fn set_size(s: Set) -> int {
    return (nl_set_size s.handle)
}

pub fn set_values(s: Set) -> array<string> {
    return (nl_set_values s.handle)
}

pub fn set_remove(s: Set, key: string) -> Set {
    (nl_set_remove s.handle key)
    return s
}

pub fn set_clear(s: Set) -> Set {
    (nl_set_clear s.handle)
    return s
}

pub fn set_free(s: Set) -> void {
    (nl_set_free s.handle)
}

shadow set_new {
    let s: Set = (set_new)
    assert (== (set_size s) 0)
}

shadow set_add {
    let s0: Set = (set_new)
    let s1: Set = (set_add s0 "x")
    assert (set_has s1 "x")
    assert (== (set_size s1) 1)
}
