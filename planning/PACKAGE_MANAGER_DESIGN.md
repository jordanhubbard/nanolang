# Nanolang Package Manager Design

## Overview

A comprehensive package manager for nanolang, enabling easy distribution, installation, and management of nanolang libraries and modules.

## Goals

1. **Easy Publishing**: Simple workflow to share packages
2. **Dependency Resolution**: Automatic handling of package dependencies
3. **Version Management**: Semantic versioning with conflict resolution
4. **Security**: Package verification and vulnerability scanning
5. **Performance**: Fast downloads and caching

## Architecture

```
┌──────────────┐
│   nano pkg   │  Command-line tool
└──────┬───────┘
       │
       ▼
┌──────────────┐
│   Registry   │  Central package repository
│   (HTTP API) │  (packages.nanolang.org)
└──────┬───────┘
       │
       ▼
┌──────────────┐
│  Local Cache │  ~/.nano/packages/
└──────┬───────┘
       │
       ▼
┌──────────────┐
│   Project    │  node_modules/ equivalent
│ Dependencies │
└──────────────┘
```

## Package Format

### nano.toml

```toml
[package]
name = "http-client"
version = "1.2.3"
description = "HTTP client library for nanolang"
authors = ["Alice <alice@example.com>"]
license = "MIT"
repository = "https://github.com/nanolang/http-client"
homepage = "https://nanolang.org/packages/http-client"
keywords = ["http", "client", "web"]
categories = ["networking", "web"]

[dependencies]
json = "^2.1.0"
datetime = "^1.0.0"

[dev-dependencies]
test-framework = "^1.0.0"

[build]
# Optional C compilation settings
c-sources = ["src/*.c"]
link-libraries = ["curl"]
pkg-config = ["libcurl"]

[[examples]]
name = "simple-get"
path = "examples/simple_get.nano"

[[tests]]
name = "integration"
path = "tests/integration_test.nano"
```

### Package Structure

```
http-client/
├── nano.toml           # Package manifest
├── README.md           # Documentation
├── LICENSE             # License file
├── src/
│   ├── http.nano       # Main module
│   └── http_impl.c     # C implementation (if needed)
├── examples/
│   └── simple_get.nano
├── tests/
│   └── integration_test.nano
└── docs/
    └── API.md
```

## CLI Commands

### nano pkg init

Create a new package:

```bash
$ nano pkg init
Package name: my-library
Version (1.0.0): 
Description: My awesome library
Author: Alice <alice@example.com>

✓ Created nano.toml
✓ Created src/my-library.nano
✓ Created README.md
```

### nano pkg install

Install dependencies:

```bash
# Install all dependencies
$ nano pkg install

# Install specific package
$ nano pkg install http-client

# Install with version constraint
$ nano pkg install json@^2.1.0

# Install as dev dependency
$ nano pkg install --dev test-framework
```

### nano pkg update

Update dependencies:

```bash
# Update all packages
$ nano pkg update

# Update specific package
$ nano pkg update http-client

# Check for outdated packages
$ nano pkg outdated
```

### nano pkg publish

Publish package to registry:

```bash
# Build and publish
$ nano pkg publish

# Dry run
$ nano pkg publish --dry-run

# Publish specific version
$ nano pkg publish --version 1.2.3
```

### nano pkg search

Search for packages:

```bash
$ nano pkg search http
Found 12 packages:

  http-client (1.2.3)        HTTP client library
  http-server (2.0.1)        HTTP server framework
  http-router (1.5.0)        HTTP routing library
  ...
```

### nano pkg info

Show package information:

```bash
$ nano pkg info http-client

http-client v1.2.3
HTTP client library for nanolang

Repository: https://github.com/nanolang/http-client
Downloads: 15,234 last month
License: MIT

Dependencies:
  json ^2.1.0
  datetime ^1.0.0
```

## Dependency Resolution

### Algorithm

```python
def resolve_dependencies(package, constraints):
    # 1. Fetch package metadata
    metadata = registry.get_metadata(package)
    
    # 2. Find compatible versions
    versions = filter_versions(metadata.versions, constraints)
    
    # 3. For each compatible version
    for version in versions:
        # 4. Recursively resolve dependencies
        deps = metadata.versions[version].dependencies
        resolved = {}
        
        for dep_name, dep_constraint in deps.items():
            dep_resolved = resolve_dependencies(dep_name, dep_constraint)
            
            # 5. Check for conflicts
            if conflicts_with(resolved, dep_resolved):
                continue  # Try next version
            
            resolved[dep_name] = dep_resolved
        
        # 6. If all dependencies resolved, return
        return {package: version, **resolved}
    
    # 7. No compatible version found
    raise DependencyError(f"Cannot resolve {package} with {constraints}")
```

### Lock File (nano.lock)

```toml
# Generated by nano pkg install
# Do not edit manually

[[packages]]
name = "http-client"
version = "1.2.3"
checksum = "sha256:a1b2c3d4..."
source = "registry+https://packages.nanolang.org/"

[[packages]]
name = "json"
version = "2.1.5"
checksum = "sha256:e5f6g7h8..."
source = "registry+https://packages.nanolang.org/"

[[packages]]
name = "datetime"
version = "1.0.2"
checksum = "sha256:i9j0k1l2..."
source = "registry+https://packages.nanolang.org/"
```

## Registry Implementation

### HTTP API

```
POST   /api/v1/packages                  # Publish package
GET    /api/v1/packages/:name            # Get package metadata
GET    /api/v1/packages/:name/:version   # Get specific version
GET    /api/v1/packages/:name/versions   # List all versions
GET    /api/v1/search?q=:query           # Search packages
DELETE /api/v1/packages/:name/:version   # Yank (unpublish) version
```

### Package Storage

```
packages/
├── http-client/
│   ├── 1.0.0/
│   │   ├── http-client-1.0.0.tar.gz
│   │   └── metadata.json
│   ├── 1.1.0/
│   │   ├── http-client-1.1.0.tar.gz
│   │   └── metadata.json
│   └── 1.2.3/
│       ├── http-client-1.2.3.tar.gz
│       └── metadata.json
└── json/
    └── ...
```

### Metadata Format

```json
{
  "name": "http-client",
  "description": "HTTP client library",
  "versions": {
    "1.2.3": {
      "version": "1.2.3",
      "published_at": "2024-12-17T10:00:00Z",
      "authors": ["Alice <alice@example.com>"],
      "license": "MIT",
      "dependencies": {
        "json": "^2.1.0",
        "datetime": "^1.0.0"
      },
      "checksum": "sha256:a1b2c3d4...",
      "download_url": "https://packages.nanolang.org/http-client/1.2.3/http-client-1.2.3.tar.gz"
    }
  }
}
```

## Local Cache

### Structure

```
~/.nano/
├── packages/           # Downloaded packages
│   ├── http-client-1.2.3/
│   ├── json-2.1.5/
│   └── datetime-1.0.2/
├── registry/           # Cached registry metadata
│   ├── http-client.json
│   ├── json.json
│   └── datetime.json
└── config.toml         # Global configuration
```

### Cache Management

```bash
# Clear cache
$ nano pkg cache clean

# Show cache size
$ nano pkg cache info
Cache location: ~/.nano/packages
Total size: 127 MB
Packages: 42

# Verify cache integrity
$ nano pkg cache verify
```

## Security

### Package Signing

```bash
# Generate signing key
$ nano pkg keygen

# Sign package
$ nano pkg sign

# Verify signature
$ nano pkg verify http-client@1.2.3
```

### Vulnerability Scanning

```bash
# Audit dependencies for known vulnerabilities
$ nano pkg audit

Found 1 vulnerability:

  Critical: Remote Code Execution in json@2.1.4
  Fixed in: json@2.1.5
  
Run 'nano pkg update json' to fix
```

## Implementation

### Core Data Structures

```c
// src/pkg/package.h

typedef struct {
    char* name;
    char* version;
    char* description;
    char** authors;
    char* license;
    HashMap* dependencies;  // name -> version constraint
} PackageMetadata;

typedef struct {
    char* name;
    char* version;
    char* checksum;
    char* path;  // Local path to package
} PackageInstallation;

typedef struct {
    PackageInstallation** packages;
    int count;
    HashMap* by_name;  // Fast lookup
} PackageRegistry;
```

### Dependency Resolver

```c
// src/pkg/resolver.c

typedef struct {
    char* name;
    char* version;
    PackageMetadata* metadata;
    ResolutionNode** dependencies;
} ResolutionNode;

ResolutionNode* resolve_dependencies(
    const char* package_name,
    const char* constraint,
    PackageRegistry* registry
) {
    // 1. Fetch available versions
    char** versions = registry_get_versions(registry, package_name);
    
    // 2. Filter by constraint
    char** compatible = filter_by_semver(versions, constraint);
    
    // 3. Try each version (newest first)
    for (int i = 0; compatible[i]; i++) {
        ResolutionNode* node = malloc(sizeof(ResolutionNode));
        node->name = strdup(package_name);
        node->version = strdup(compatible[i]);
        node->metadata = registry_get_metadata(registry, package_name, compatible[i]);
        
        // 4. Recursively resolve dependencies
        bool success = true;
        node->dependencies = malloc(...);
        
        for (int j = 0; j < node->metadata->dependencies->size; j++) {
            const char* dep_name = node->metadata->dependencies->keys[j];
            const char* dep_constraint = node->metadata->dependencies->values[j];
            
            ResolutionNode* dep = resolve_dependencies(dep_name, dep_constraint, registry);
            if (!dep) {
                success = false;
                break;
            }
            
            node->dependencies[j] = dep;
        }
        
        if (success) return node;
    }
    
    return NULL;  // No resolution found
}
```

## Integration with Compiler

### Module Resolution

```c
// When compiling: import "http-client" as HTTP

// 1. Check local packages/ directory
if (file_exists("packages/http-client/src/http-client.nano")) {
    return "packages/http-client/src/http-client.nano";
}

// 2. Check global cache
if (file_exists("~/.nano/packages/http-client-1.2.3/src/http-client.nano")) {
    return "~/.nano/packages/http-client-1.2.3/src/http-client.nano";
}

// 3. Error: package not installed
fprintf(stderr, "Error: Package 'http-client' not found\n");
fprintf(stderr, "Try: nano pkg install http-client\n");
return NULL;
```

## Implementation Roadmap

### Phase 1: Core Functionality (4 weeks)
- Package manifest parsing (nano.toml)
- Basic dependency resolution
- Install/update commands
- Local package cache

### Phase 2: Registry (4 weeks)
- HTTP API server
- Package storage backend
- Search functionality
- Authentication

### Phase 3: Advanced Features (4 weeks)
- Package signing
- Vulnerability scanning
- Lock file generation
- Multi-registry support

### Phase 4: Ecosystem (4 weeks)
- Web UI for package browsing
- CI/CD integration
- Package quality metrics
- Documentation hosting

## Future Enhancements

1. **Workspaces**: Manage monorepos with multiple packages
2. **Private Registries**: Corporate package hosting
3. **Binary Packages**: Pre-compiled modules for faster install
4. **Git Dependencies**: Install directly from git repos
5. **Patch System**: Apply patches to dependencies

## References

- [npm Documentation](https://docs.npmjs.com/)
- [Cargo Book (Rust)](https://doc.rust-lang.org/cargo/)
- [pip Documentation (Python)](https://pip.pypa.io/en/stable/)
- [Semantic Versioning](https://semver.org/)

## Related Issues

- Module system improvements
- Build system integration
- CI/CD workflows
- Package quality standards

