# NanoLang Code Formatter (Simple Line-Based Version)
# Formats NanoLang source code by just ensuring proper line breaks

# Format source code with basic line breaking
# For launcher display - simple and reliable
pub fn format(source: string) -> string {
    # For now, just return the source as-is
    # The launcher will handle line breaking
    return source
}

# Format with line breaks at max_width characters
pub fn format_with_wrap(source: string, max_width: int) -> string {
    let mut result: string = ""
    let mut line: string = ""
    let mut i: int = 0
    let len: int = (str_length source)
    
    while (< i len) {
        let c: string = (str_substring source i 1)  # FIX: length=1, not end=i+1
        
        # Always break on existing newlines
        if (== c "\n") {
            set result (+ result line)
            set result (+ result "\n")
            set line ""
        } else {
            # Add character to current line
            set line (+ line c)
            
            # Break if line is too long
            if (>= (str_length line) max_width) {
                set result (+ result line)
                set result (+ result "\n")
                set line ""
            } else {}
        }
        
        set i (+ i 1)
    }
    
    # Add remaining line
    if (> (str_length line) 0) {
        set result (+ result line)
    } else {}
    
    return result
}

# Format with proper indentation and brace handling
pub fn format_pretty(source: string) -> string {
    let mut result: string = ""
    let mut indent_level: int = 0
    let mut i: int = 0
    let len: int = (str_length source)
    let mut at_line_start: bool = true
    let indent_size: int = 4
    
    while (< i len) {
        let c: string = (str_substring source i 1)  # FIX: length=1
        
        # Opening brace: add space, brace, newline, increase indent
        if (== c "{") {
            set result (+ result " {\n")
            set indent_level (+ indent_level 1)
            set at_line_start true
        } else {
            # Closing brace: decrease indent, add indent, brace, newline
            if (== c "}") {
                set indent_level (- indent_level 1)
                if (< indent_level 0) {
                    set indent_level 0
                } else {}
                set result (+ result (make_indent indent_level indent_size))
                set result (+ result "}\n")
                set at_line_start true
            } else {
                # Newline: add it and mark line start
                if (== c "\n") {
                    set result (+ result "\n")
                    set at_line_start true
                } else {
                    # Skip multiple whitespace
                    if (or (== c " ") (or (== c "\t") (== c "\r"))) {
                        # Skip whitespace at line start
                        if (not at_line_start) {
                            set result (+ result " ")
                        } else {}
                    } else {
                        # Regular character: add indent if needed, then char
                        if at_line_start {
                            set result (+ result (make_indent indent_level indent_size))
                            set at_line_start false
                        } else {}
                        set result (+ result c)
                    }
                }
            }
        }
        
        set i (+ i 1)
    }
    
    return result
}

# Helper: Create indentation string
fn make_indent(level: int, size: int) -> string {
    let total_spaces: int = (* level size)
    let mut result: string = ""
    let mut i: int = 0
    while (< i total_spaces) {
        set result (+ result " ")
        set i (+ i 1)
    }
    return result
}

shadow make_indent {
    assert (== (make_indent 0 4) "")
    assert (== (make_indent 1 4) "    ")
    assert (== (make_indent 2 4) "        ")
    let indent3: string = (make_indent 3 4)
    assert (== (str_length indent3) 12)
}

shadow format {
    # Test passthrough (currently just returns input)
    let input1: string = "fn test() -> int { return 42 }"
    let output1: string = (format input1)
    assert (== input1 output1)
}

shadow format_with_wrap {
    # Test that wrap creates reasonable output
    let input: string = "This is a very long line that should be wrapped at some point when it exceeds the maximum width"
    let wrapped: string = (format_with_wrap input 40)
    assert (> (str_length wrapped) (str_length input))  # Should be longer (added newlines)
}

shadow format_pretty {
    # Test that pretty formatting works
    let input: string = "fn test() -> int { return 42 }"
    let output: string = (format_pretty input)
    assert (> (str_length output) 0)
    assert (str_contains output "{")
    assert (str_contains output "}")
}

# Example/test main function
fn main() -> int {
    let sample: string = "fn hello() -> int { let x: int = 42 return x }"
    
    (println "=== Testing format_with_wrap ===")
    let wrapped: string = (format_with_wrap sample 40)
    (println wrapped)
    (println "")
    
    (println "=== Testing format_pretty ===")
    let pretty: string = (format_pretty sample)
    (println pretty)
    
    return 0
}

shadow main {
    assert (== (main) 0)
}

