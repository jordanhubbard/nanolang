/* =============================================================================
 * std::math::vector4d Module - 4D Vector Mathematics
 * =============================================================================
 * Useful for homogeneous coordinates (mat4 transforms).
 */

module std_math_vector4d

from "std/math/vector3d.nano" import Vector3D, vec3_new

pub struct Vector4D {
    x: float,
    y: float,
    z: float,
    w: float
}

pub fn vec4_new(x: float, y: float, z: float, w: float) -> Vector4D {
    return Vector4D { x: x, y: y, z: z, w: w }
}

pub fn vec4_zero() -> Vector4D {
    return Vector4D { x: 0.0, y: 0.0, z: 0.0, w: 0.0 }
}

pub fn vec4_add(a: Vector4D, b: Vector4D) -> Vector4D {
    return Vector4D { x: (+ a.x b.x), y: (+ a.y b.y), z: (+ a.z b.z), w: (+ a.w b.w) }
}

pub fn vec4_sub(a: Vector4D, b: Vector4D) -> Vector4D {
    return Vector4D { x: (- a.x b.x), y: (- a.y b.y), z: (- a.z b.z), w: (- a.w b.w) }
}

pub fn vec4_scale(v: Vector4D, s: float) -> Vector4D {
    return Vector4D { x: (* v.x s), y: (* v.y s), z: (* v.z s), w: (* v.w s) }
}

pub fn vec4_dot(a: Vector4D, b: Vector4D) -> float {
    return (+ (+ (+ (* a.x b.x) (* a.y b.y)) (* a.z b.z)) (* a.w b.w))
}

pub fn vec4_length(v: Vector4D) -> float {
    return (sqrt (vec4_dot v v))
}

pub fn vec4_normalize(v: Vector4D) -> Vector4D {
    let len: float = (vec4_length v)
    if (> len 0.0) {
        return (vec4_scale v (/ 1.0 len))
    } else {
        return (vec4_zero)
    }
}

pub fn vec4_from_vec3(v: Vector3D, w: float) -> Vector4D {
    return Vector4D { x: v.x, y: v.y, z: v.z, w: w }
}

pub fn vec4_to_vec3_div_w(v: Vector4D) -> Vector3D {
    if (> (abs v.w) 0.0000001) {
        return (vec3_new (/ v.x v.w) (/ v.y v.w) (/ v.z v.w))
    } else {
        return (vec3_new v.x v.y v.z)
    }
}

/* ============================================================================
 * Shadow Tests
 * ============================================================================ */

shadow vec4_new {
    let v: Vector4D = (vec4_new 1.0 2.0 3.0 4.0)
    assert (== v.x 1.0)
    assert (== v.y 2.0)
    assert (== v.z 3.0)
    assert (== v.w 4.0)
}

shadow vec4_zero {
    let v: Vector4D = (vec4_zero)
    assert (== v.x 0.0)
    assert (== v.y 0.0)
    assert (== v.z 0.0)
    assert (== v.w 0.0)
}

shadow vec4_add {
    let a: Vector4D = (vec4_new 1.0 2.0 3.0 4.0)
    let b: Vector4D = (vec4_new 5.0 6.0 7.0 8.0)
    let c: Vector4D = (vec4_add a b)
    assert (== c.x 6.0)
    assert (== c.y 8.0)
    assert (== c.z 10.0)
    assert (== c.w 12.0)
}

shadow vec4_sub {
    let a: Vector4D = (vec4_new 10.0 9.0 8.0 7.0)
    let b: Vector4D = (vec4_new 1.0 2.0 3.0 4.0)
    let c: Vector4D = (vec4_sub a b)
    assert (== c.x 9.0)
    assert (== c.y 7.0)
    assert (== c.z 5.0)
    assert (== c.w 3.0)
}

shadow vec4_scale {
    let v: Vector4D = (vec4_new 1.0 2.0 3.0 4.0)
    let s: Vector4D = (vec4_scale v 2.0)
    assert (== s.x 2.0)
    assert (== s.y 4.0)
    assert (== s.z 6.0)
    assert (== s.w 8.0)
}

shadow vec4_dot {
    let a: Vector4D = (vec4_new 1.0 2.0 3.0 4.0)
    let b: Vector4D = (vec4_new 5.0 6.0 7.0 8.0)
    let dot: float = (vec4_dot a b)
    # 1*5 + 2*6 + 3*7 + 4*8 = 5 + 12 + 21 + 32 = 70
    assert (== dot 70.0)
}

shadow vec4_length {
    let v: Vector4D = (vec4_new 2.0 0.0 0.0 0.0)
    let len: float = (vec4_length v)
    assert (== len 2.0)
    
    # Test with multiple components
    let v2: Vector4D = (vec4_new 1.0 2.0 2.0 0.0)
    let len2: float = (vec4_length v2)
    # sqrt(1 + 4 + 4 + 0) = sqrt(9) = 3
    assert (== len2 3.0)
}

shadow vec4_normalize {
    let v: Vector4D = (vec4_new 4.0 0.0 0.0 0.0)
    let n: Vector4D = (vec4_normalize v)
    assert (== n.x 1.0)
    assert (== n.y 0.0)
    assert (== n.z 0.0)
    assert (== n.w 0.0)
    
    # Zero vector should return zero
    let zero: Vector4D = (vec4_zero)
    let norm_zero: Vector4D = (vec4_normalize zero)
    assert (== norm_zero.x 0.0)
    assert (== norm_zero.y 0.0)
    assert (== norm_zero.z 0.0)
    assert (== norm_zero.w 0.0)
}

shadow vec4_from_vec3 {
    let v3: Vector3D = (vec3_new 1.0 2.0 3.0)
    let v4: Vector4D = (vec4_from_vec3 v3 1.0)
    assert (== v4.x 1.0)
    assert (== v4.y 2.0)
    assert (== v4.z 3.0)
    assert (== v4.w 1.0)
    
    # Test with w=0 (direction vector)
    let v4_dir: Vector4D = (vec4_from_vec3 v3 0.0)
    assert (== v4_dir.w 0.0)
}

shadow vec4_to_vec3_div_w {
    # Test perspective divide
    let v4: Vector4D = (vec4_new 4.0 6.0 8.0 2.0)
    let v3: Vector3D = (vec4_to_vec3_div_w v4)
    assert (== v3.x 2.0)  # 4/2
    assert (== v3.y 3.0)  # 6/2
    assert (== v3.z 4.0)  # 8/2
    
    # Test with w=1 (no division)
    let v4_one: Vector4D = (vec4_new 5.0 6.0 7.0 1.0)
    let v3_one: Vector3D = (vec4_to_vec3_div_w v4_one)
    assert (== v3_one.x 5.0)
    assert (== v3_one.y 6.0)
    assert (== v3_one.z 7.0)
    
    # Test with wâ‰ˆ0 (should not divide)
    let v4_zero: Vector4D = (vec4_new 1.0 2.0 3.0 0.0)
    let v3_zero: Vector3D = (vec4_to_vec3_div_w v4_zero)
    assert (== v3_zero.x 1.0)
    assert (== v3_zero.y 2.0)
    assert (== v3_zero.z 3.0)
}