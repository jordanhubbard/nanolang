/* =============================================================================
 * std::math Module - Extended Math Functions
 * =============================================================================
 * Provides additional mathematical functions via FFI for:
 * - Inverse trigonometric functions
 * - Logarithmic and exponential functions
 * - Hyperbolic functions
 * - Additional utility functions
 * 
 * Usage:
 *   from "std/math/extended.nano" import atan2, log, exp
 *   
 *   let angle: float = (atan2 y_diff x_diff)
 *   let natural_log: float = (log value)
 */

module std_math

/* =============================================================================
 * Inverse Trigonometric Functions
 * =============================================================================
 */

/* Arcsine (inverse sine)
 * Returns: angle in radians [-π/2, π/2]
 * Domain: [-1, 1]
 */
pub extern fn asin(_x: float) -> float

/* Arccosine (inverse cosine)
 * Returns: angle in radians [0, π]
 * Domain: [-1, 1]
 */
pub extern fn acos(_x: float) -> float

/* Arctangent (inverse tangent)
 * Returns: angle in radians [-π/2, π/2]
 */
pub extern fn atan(_x: float) -> float

/* Note: atan2 is a language built-in, so we don't redeclare it here. */

/* =============================================================================
 * Logarithmic and Exponential Functions
 * =============================================================================
 */

/* Natural logarithm (base e)
 * Returns: ln(x)
 * Domain: (0, ∞)
 */
pub extern fn log(_x: float) -> float

/* Base-10 logarithm
 * Returns: log₁₀(x)
 * Domain: (0, ∞)
 */
pub extern fn log10(_x: float) -> float

/* Base-2 logarithm
 * Returns: log₂(x)
 * Domain: (0, ∞)
 */
pub extern fn log2(_x: float) -> float

/* log(1 + x), accurate for small x */
pub extern fn log1p(_x: float) -> float

/* Exponential function
 * Returns: e^x
 */
pub extern fn exp(_x: float) -> float

/* Base-2 exponential
 * Returns: 2^x
 */
pub extern fn exp2(_x: float) -> float

/* exp(x) - 1, accurate for small x */
pub extern fn expm1(_x: float) -> float

/* =============================================================================
 * Hyperbolic Functions
 * =============================================================================
 */

/* Hyperbolic sine
 * Returns: sinh(x) = (e^x - e^(-x)) / 2
 */
pub extern fn sinh(_x: float) -> float

/* Hyperbolic cosine
 * Returns: cosh(x) = (e^x + e^(-x)) / 2
 */
pub extern fn cosh(_x: float) -> float

/* Hyperbolic tangent
 * Returns: tanh(x) = sinh(x) / cosh(x)
 */
pub extern fn tanh(_x: float) -> float

/* Inverse hyperbolic functions */
pub extern fn asinh(_x: float) -> float
pub extern fn acosh(_x: float) -> float
pub extern fn atanh(_x: float) -> float

/* =============================================================================
 * Utility Functions
 * =============================================================================
 */

/* Floating-point remainder
 * Returns: x - n * y, where n is the quotient x/y rounded to zero
 * 
 * Example (wrap angle to range):
 *   let wrapped: float = (fmod angle 360.0)
 */
pub extern fn fmod(_x: float, _y: float) -> float

/* Floating-point absolute value
 * Returns: |x|
 */
pub extern fn fabs(_x: float) -> float

/* Cube root */
pub extern fn cbrt(_x: float) -> float

/* Hypotenuse (sqrt(x*x + y*y)) with improved numerical stability */
pub extern fn hypot(_x: float, _y: float) -> float

/* Rounding (toward zero / nearest integer variants) */
pub extern fn trunc(_x: float) -> float
pub extern fn rint(_x: float) -> float
pub extern fn nearbyint(_x: float) -> float

/* IEEE remainder */
pub extern fn remainder(_x: float, _y: float) -> float

/* Floating-point min/max */
pub extern fn fmin(_x: float, _y: float) -> float
pub extern fn fmax(_x: float, _y: float) -> float

/* Copy sign of y onto magnitude of x */
pub extern fn copysign(_x: float, _y: float) -> float

/* =============================================================================
 * Constants
 * =============================================================================
 */

/* Pi (π) constant (kept private; use pi() accessor) */
let PI: float = 3.141592653589793

/* Euler's number (e) constant (kept private; use e() accessor) */
let E: float = 2.718281828459045

pub fn pi() -> float { return PI }
shadow pi {
    assert (> (pi) 3.14)
    assert (< (pi) 3.15)
}
pub fn e() -> float { return E }
shadow e {
    assert (> (e) 2.71)
    assert (< (e) 2.72)
}

/* =============================================================================
 * Helper Functions
 * =============================================================================
 */

/* Convert degrees to radians */
pub fn deg_to_rad(degrees: float) -> float {
    return (* degrees (/ PI 180.0))
}
shadow deg_to_rad {
    assert (== (deg_to_rad 0.0) 0.0)
    let half_circle: float = (deg_to_rad 180.0)
    assert (> half_circle 3.14)
    assert (< half_circle 3.15)
    let quarter_circle: float = (deg_to_rad 90.0)
    assert (> quarter_circle 1.57)
    assert (< quarter_circle 1.58)
}

/* Convert radians to degrees */
pub fn rad_to_deg(radians: float) -> float {
    return (* radians (/ 180.0 PI))
}
shadow rad_to_deg {
    assert (== (rad_to_deg 0.0) 0.0)
    let half_circle: float = (rad_to_deg PI)
    assert (> half_circle 179.9)
    assert (< half_circle 180.1)
    let quarter_circle: float = (rad_to_deg (/ PI 2.0))
    assert (> quarter_circle 89.9)
    assert (< quarter_circle 90.1)
}

/* Clamp value between min and max */
pub fn clamp(value: float, min: float, max: float) -> float
requires (<= min max)
ensures (>= result min)
ensures (<= result max)
{
    if (< value min) {
        return min
    } else {
        if (> value max) {
            return max
        } else {
            return value
        }
    }
}

shadow clamp {
    assert (== (clamp 5.0 0.0 10.0) 5.0)
    assert (== (clamp -1.0 0.0 10.0) 0.0)
    assert (== (clamp 15.0 0.0 10.0) 10.0)
}

/* Linear interpolation between a and b */
pub fn lerp(a: float, b: float, t: float) -> float {
    return (+ a (* (- b a) t))
}

shadow lerp {
    assert (== (lerp 0.0 10.0 0.5) 5.0)
    assert (== (lerp 0.0 10.0 0.0) 0.0)
    assert (== (lerp 0.0 10.0 1.0) 10.0)
}

