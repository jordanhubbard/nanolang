/* =============================================================================
 * std::math::complex Module - Complex Numbers (float)
 * =============================================================================
 */

module std_math_complex

/* libm */
extern fn exp(x: float) -> float

pub struct Complex {
    re: float,
    im: float
}

pub fn complex_new(re: float, im: float) -> Complex {
    return Complex { re: re, im: im }
}

pub fn complex_add(a: Complex, b: Complex) -> Complex {
    return Complex { re: (+ a.re b.re), im: (+ a.im b.im) }
}

pub fn complex_sub(a: Complex, b: Complex) -> Complex {
    return Complex { re: (- a.re b.re), im: (- a.im b.im) }
}

pub fn complex_mul(a: Complex, b: Complex) -> Complex {
    return Complex {
        re: (- (* a.re b.re) (* a.im b.im)),
        im: (+ (* a.re b.im) (* a.im b.re))
    }
}

pub fn complex_conj(a: Complex) -> Complex {
    return Complex { re: a.re, im: (- a.im) }
}

pub fn complex_abs(a: Complex) -> float {
    return (sqrt (+ (* a.re a.re) (* a.im a.im)))
}

pub fn complex_arg(a: Complex) -> float {
    return (atan2 a.im a.re)
}

pub fn complex_div(a: Complex, b: Complex) -> Complex {
    let denom: float = (+ (* b.re b.re) (* b.im b.im))
    if (== denom 0.0) {
        return (complex_new 0.0 0.0)
    }
    return Complex {
        re: (/ (+ (* a.re b.re) (* a.im b.im)) denom),
        im: (/ (- (* a.im b.re) (* a.re b.im)) denom)
    }
}

pub fn complex_from_polar(r: float, theta: float) -> Complex {
    return Complex { re: (* r (cos theta)), im: (* r (sin theta)) }
}

pub fn complex_exp(z: Complex) -> Complex {
    let er: float = (exp z.re)
    return Complex { re: (* er (cos z.im)), im: (* er (sin z.im)) }
}