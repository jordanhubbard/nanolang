/* =============================================================================
 * std::math::vector3d Module - 3D Vector Mathematics
 * =============================================================================
 * Intended for graphics/physics workloads.
 */

module std_math_vector3d

pub struct Vector3D {
    x: float,
    y: float,
    z: float
}

pub fn vec3_new(x: float, y: float, z: float) -> Vector3D {
    return Vector3D { x: x, y: y, z: z }
}

pub fn vec3_zero() -> Vector3D {
    return Vector3D { x: 0.0, y: 0.0, z: 0.0 }
}

pub fn vec3_add(a: Vector3D, b: Vector3D) -> Vector3D {
    return Vector3D { x: (+ a.x b.x), y: (+ a.y b.y), z: (+ a.z b.z) }
}

pub fn vec3_sub(a: Vector3D, b: Vector3D) -> Vector3D {
    return Vector3D { x: (- a.x b.x), y: (- a.y b.y), z: (- a.z b.z) }
}

pub fn vec3_scale(v: Vector3D, s: float) -> Vector3D {
    return Vector3D { x: (* v.x s), y: (* v.y s), z: (* v.z s) }
}

pub fn vec3_dot(a: Vector3D, b: Vector3D) -> float {
    return (+ (+ (* a.x b.x) (* a.y b.y)) (* a.z b.z))
}

pub fn vec3_cross(a: Vector3D, b: Vector3D) -> Vector3D {
    return Vector3D {
        x: (- (* a.y b.z) (* a.z b.y)),
        y: (- (* a.z b.x) (* a.x b.z)),
        z: (- (* a.x b.y) (* a.y b.x))
    }
}

pub fn vec3_length_squared(v: Vector3D) -> float {
    return (vec3_dot v v)
}

pub fn vec3_length(v: Vector3D) -> float {
    return (sqrt (vec3_length_squared v))
}

pub fn vec3_distance(a: Vector3D, b: Vector3D) -> float {
    return (vec3_length (vec3_sub b a))
}

pub fn vec3_normalize(v: Vector3D) -> Vector3D {
    let len: float = (vec3_length v)
    if (> len 0.0) {
        return (vec3_scale v (/ 1.0 len))
    } else {
        return (vec3_zero)
    }
}

pub fn vec3_lerp(a: Vector3D, b: Vector3D, t: float) -> Vector3D {
    return Vector3D {
        x: (+ a.x (* (- b.x a.x) t)),
        y: (+ a.y (* (- b.y a.y) t)),
        z: (+ a.z (* (- b.z a.z) t))
    }
}

pub fn vec3_reflect(v: Vector3D, normal: Vector3D) -> Vector3D {
    let d: float = (vec3_dot v normal)
    return (vec3_sub v (vec3_scale normal (* 2.0 d)))
}

pub fn vec3_clamp_length(v: Vector3D, max_len: float) -> Vector3D {
    let len: float = (vec3_length v)
    if (> len max_len) {
        return (vec3_scale (vec3_normalize v) max_len)
    } else {
        return v
    }
}

/* ============================================================================
 * Shadow Tests
 * ============================================================================ */

shadow vec3_new {
    let v: Vector3D = (vec3_new 1.0 2.0 3.0)
    assert (== v.x 1.0)
    assert (== v.y 2.0)
    assert (== v.z 3.0)
}

shadow vec3_zero {
    let v: Vector3D = (vec3_zero)
    assert (== v.x 0.0)
    assert (== v.y 0.0)
    assert (== v.z 0.0)
}

shadow vec3_add {
    let a: Vector3D = (vec3_new 1.0 2.0 3.0)
    let b: Vector3D = (vec3_new 4.0 5.0 6.0)
    let c: Vector3D = (vec3_add a b)
    assert (== c.x 5.0)
    assert (== c.y 7.0)
    assert (== c.z 9.0)
}

shadow vec3_sub {
    let a: Vector3D = (vec3_new 5.0 7.0 9.0)
    let b: Vector3D = (vec3_new 1.0 2.0 3.0)
    let c: Vector3D = (vec3_sub a b)
    assert (== c.x 4.0)
    assert (== c.y 5.0)
    assert (== c.z 6.0)
}

shadow vec3_scale {
    let v: Vector3D = (vec3_new 1.0 2.0 3.0)
    let s: Vector3D = (vec3_scale v 2.0)
    assert (== s.x 2.0)
    assert (== s.y 4.0)
    assert (== s.z 6.0)
}

shadow vec3_dot {
    let a: Vector3D = (vec3_new 1.0 2.0 3.0)
    let b: Vector3D = (vec3_new 4.0 5.0 6.0)
    let dot: float = (vec3_dot a b)
    # 1*4 + 2*5 + 3*6 = 4 + 10 + 18 = 32
    assert (== dot 32.0)
    
    # Perpendicular vectors should have dot product of 0
    let x_axis: Vector3D = (vec3_new 1.0 0.0 0.0)
    let y_axis: Vector3D = (vec3_new 0.0 1.0 0.0)
    let perp_dot: float = (vec3_dot x_axis y_axis)
    assert (== perp_dot 0.0)
}

shadow vec3_cross {
    # Cross product of standard basis vectors
    let x_axis: Vector3D = (vec3_new 1.0 0.0 0.0)
    let y_axis: Vector3D = (vec3_new 0.0 1.0 0.0)
    let z_axis: Vector3D = (vec3_cross x_axis y_axis)
    assert (== z_axis.x 0.0)
    assert (== z_axis.y 0.0)
    assert (== z_axis.z 1.0)
}

shadow vec3_length_squared {
    let v: Vector3D = (vec3_new 3.0 4.0 0.0)
    let len_sq: float = (vec3_length_squared v)
    # 3^2 + 4^2 + 0^2 = 9 + 16 = 25
    assert (== len_sq 25.0)
}

shadow vec3_length {
    let v: Vector3D = (vec3_new 3.0 4.0 0.0)
    let len: float = (vec3_length v)
    # sqrt(3^2 + 4^2) = sqrt(25) = 5
    assert (== len 5.0)
}

shadow vec3_distance {
    let a: Vector3D = (vec3_new 0.0 0.0 0.0)
    let b: Vector3D = (vec3_new 3.0 4.0 0.0)
    let dist: float = (vec3_distance a b)
    assert (== dist 5.0)
}

shadow vec3_normalize {
    let v: Vector3D = (vec3_new 3.0 4.0 0.0)
    let n: Vector3D = (vec3_normalize v)
    # Should be unit length
    let len: float = (vec3_length n)
    assert (< (- len 1.0) 0.001)  # Within tolerance
    assert (> (+ len 1.0) 0.999)
    
    # Zero vector should return zero
    let zero: Vector3D = (vec3_zero)
    let norm_zero: Vector3D = (vec3_normalize zero)
    assert (== norm_zero.x 0.0)
    assert (== norm_zero.y 0.0)
    assert (== norm_zero.z 0.0)
}

shadow vec3_lerp {
    let a: Vector3D = (vec3_new 0.0 0.0 0.0)
    let b: Vector3D = (vec3_new 10.0 10.0 10.0)
    
    # t=0 should return a
    let lerp0: Vector3D = (vec3_lerp a b 0.0)
    assert (== lerp0.x 0.0)
    assert (== lerp0.y 0.0)
    assert (== lerp0.z 0.0)
    
    # t=0.5 should return midpoint
    let lerp_half: Vector3D = (vec3_lerp a b 0.5)
    assert (== lerp_half.x 5.0)
    assert (== lerp_half.y 5.0)
    assert (== lerp_half.z 5.0)
    
    # t=1 should return b
    let lerp1: Vector3D = (vec3_lerp a b 1.0)
    assert (== lerp1.x 10.0)
    assert (== lerp1.y 10.0)
    assert (== lerp1.z 10.0)
}

shadow vec3_reflect {
    # Reflect a vector off a horizontal surface
    let v: Vector3D = (vec3_new 1.0 -1.0 0.0)  # Going down-right
    let normal: Vector3D = (vec3_new 0.0 1.0 0.0)  # Upward normal
    let reflected: Vector3D = (vec3_reflect v normal)
    # Should bounce back up-right
    assert (== reflected.x 1.0)
    assert (== reflected.y 1.0)
    assert (== reflected.z 0.0)
}

shadow vec3_clamp_length {
    let v: Vector3D = (vec3_new 6.0 8.0 0.0)  # Length = 10
    let clamped: Vector3D = (vec3_clamp_length v 5.0)
    let len: float = (vec3_length clamped)
    # Should be clamped to length 5
    assert (< (- len 5.0) 0.001)
    assert (> (+ len 5.0) 4.999)
    
    # Vector shorter than max should be unchanged
    let short: Vector3D = (vec3_new 1.0 1.0 1.0)
    let unclamped: Vector3D = (vec3_clamp_length short 10.0)
    assert (== unclamped.x 1.0)
    assert (== unclamped.y 1.0)
    assert (== unclamped.z 1.0)
}