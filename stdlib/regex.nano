# Regular Expression Library
# POSIX regex for nanolang - built into runtime (not a module)

# Compile a regex pattern
# Returns opaque handle to compiled regex, or null on error
opaque type Regex

extern fn nl_regex_compile(pattern: string) -> Regex

# Test if string matches pattern
# Returns 1 if match, 0 if no match, -1 on error
extern fn nl_regex_match(regex: Regex, text: string) -> int

# Find first match in text
# Returns match position or -1 if not found
extern fn nl_regex_find(regex: Regex, text: string) -> int

# Find all matches in text
# Returns array of match positions
extern fn nl_regex_find_all(regex: Regex, text: string) -> array<int>

# Extract capture groups from last match
# Returns array of captured strings
extern fn nl_regex_groups(regex: Regex, text: string) -> array<string>

# Replace first occurrence
extern fn nl_regex_replace(regex: Regex, text: string, replacement: string) -> string

# Replace all occurrences
extern fn nl_regex_replace_all(regex: Regex, text: string, replacement: string) -> string

# Split string by regex pattern
extern fn nl_regex_split(regex: Regex, text: string) -> array<string>

# Free compiled regex
extern fn nl_regex_free(regex: Regex) -> void

# High-level convenience API

pub fn compile(pattern: string) -> Regex {
    unsafe {
        return (nl_regex_compile pattern)
    }
}

pub fn matches(regex: Regex, text: string) -> bool {
    let mut result: int = 0
    unsafe {
        set result (nl_regex_match regex text)
    }
    return (== result 1)
}

pub fn find(regex: Regex, text: string) -> int {
    let mut out: int = 0
    unsafe {
        set out (nl_regex_find regex text)
    }
    return out
}

pub fn find_all(regex: Regex, text: string) -> array<int> {
    let mut out: array<int> = []
    unsafe {
        set out (nl_regex_find_all regex text)
    }
    return out
}

pub fn groups(regex: Regex, text: string) -> array<string> {
    let mut out: array<string> = []
    unsafe {
        set out (nl_regex_groups regex text)
    }
    return out
}

pub fn replace(regex: Regex, text: string, replacement: string) -> string {
    let mut out: string = ""
    unsafe {
        set out (nl_regex_replace regex text replacement)
    }
    return out
}

pub fn replace_all(regex: Regex, text: string, replacement: string) -> string {
    let mut out: string = ""
    unsafe {
        set out (nl_regex_replace_all regex text replacement)
    }
    return out
}

pub fn split(regex: Regex, text: string) -> array<string> {
    let mut out: array<string> = []
    unsafe {
        set out (nl_regex_split regex text)
    }
    return out
}

pub fn free(regex: Regex) -> void {
    unsafe {
        (nl_regex_free regex)
    }
}

# One-shot convenience functions (compile, use, free in one call)

pub fn quick_match(pattern: string, text: string) -> bool {
    let regex: Regex = (compile pattern)
    if (== regex (cast 0 Regex)) {
        return false
    }
    let result: bool = (matches regex text)
    (free regex)
    return result
}

pub fn quick_find(pattern: string, text: string) -> int {
    let regex: Regex = (compile pattern)
    if (== regex (cast 0 Regex)) {
        return (- 1)
    }
    let result: int = (find regex text)
    (free regex)
    return result
}

pub fn quick_replace(pattern: string, text: string, replacement: string) -> string {
    let regex: Regex = (compile pattern)
    if (== regex (cast 0 Regex)) {
        return text
    }
    let result: string = (replace regex text replacement)
    (free regex)
    return result
}

pub fn quick_split(pattern: string, text: string) -> array<string> {
    let regex: Regex = (compile pattern)
    if (== regex (cast 0 Regex)) {
        return []
    }
    let result: array<string> = (split regex text)
    (free regex)
    return result
}

shadow compile {
    let r: Regex = (compile "a.c")
    assert (!= r (null_opaque))
    (free r)
}

shadow matches {
    let r: Regex = (compile "a.c")
    assert (matches r "abc")
    assert (not (matches r "ac"))
    (free r)
}

shadow find {
    let r: Regex = (compile "b")
    assert (== (find r "abc") 1)
    (free r)
}

shadow find_all {
    let r: Regex = (compile "b")
    let xs: array<int> = (find_all r "abbb")
    assert (>= (array_length xs) 1)
    (free r)
}

shadow groups {
    let r: Regex = (compile "(a)(b)")
    let gs: array<string> = (groups r "ab")
    assert (>= (array_length gs) 3)
    assert (== (array_get gs 0) "ab")
    assert (== (array_get gs 1) "a")
    assert (== (array_get gs 2) "b")
    (free r)
}

shadow replace {
    let r: Regex = (compile "b")
    assert (== (replace r "abc" "X") "aXc")
    (free r)
}

shadow replace_all {
    let r: Regex = (compile "b")
    assert (== (replace_all r "abbb" "X") "aXXX")
    (free r)
}

shadow split {
    let r: Regex = (compile "[,;]")
    let parts: array<string> = (split r "a,b;c")
    assert (== (array_length parts) 3)
    assert (== (array_get parts 0) "a")
    assert (== (array_get parts 1) "b")
    assert (== (array_get parts 2) "c")
    (free r)
}

shadow free {
    let r: Regex = (compile "a")
    (free r)
}

shadow quick_match {
    assert (quick_match "a.c" "abc")
    assert (not (quick_match "a.c" "ac"))
}

shadow quick_find {
    assert (== (quick_find "b" "abc") 1)
}

shadow quick_replace {
    assert (== (quick_replace "b" "abc" "X") "aXc")
}

shadow quick_split {
    let parts: array<string> = (quick_split "[,;]" "a,b;c")
    assert (== (array_length parts) 3)
}
