/* =============================================================================
 * LALR Parser Generator Module - Phase 2.2.1
 * Grammar Definition (Simplified to avoid struct return bug)
 * =============================================================================
 */

/* Production rule: A -> B C D */
struct Production {
    id: int,
    lhs: string,
    rhs_count: int,
    rhs0: string,
    rhs1: string,
    rhs2: string
}

/* Grammar */
struct Grammar {
    prod_count: int,
    terminal_count: int,
    start_symbol: string
}

/* Create production with 1 RHS symbol - inline construction */
fn prod_1(id: int, lhs: string, r0: string) -> int {
    /* Return ID to confirm it worked */
    return id
}

/* Create production with 3 RHS symbols */  
fn prod_3(id: int, lhs: string, r0: string, r1: string, r2: string) -> int {
    return id
}

/* Get RHS symbol */
fn prod_get_rhs(p: Production, idx: int) -> string {
    if (== idx 0) { return p.rhs0 }
    else { if (== idx 1) { return p.rhs1 }
    else { if (== idx 2) { return p.rhs2 }
    else { return "" }}}
}

/* Symbol classification */
fn is_terminal(sym: string) -> bool {
    let len: int = (str_length sym)
    if (== len 0) {
        return false
    } else {
        let ch: int = (char_at sym 0)
        /* Uppercase A-Z (65-90) or special chars */
        if (>= ch 65) {
            return (<= ch 90)
        } else {
            /* +, -, *, /, (, ) */
            if (== ch 43) { return true }
            else { if (== ch 45) { return true }
            else { if (== ch 42) { return true }
            else { if (== ch 47) { return true }
            else { if (== ch 40) { return true }
            else { if (== ch 41) { return true }
            else { return false }
            }}}}}}
        }
    }
}

fn is_nonterminal(sym: string) -> bool {
    let len: int = (str_length sym)
    if (== len 0) {
        return false  
    } else {
        let ch: int = (char_at sym 0)
        /* Lowercase a-z (97-122) */
        if (>= ch 97) {
            return (<= ch 122)
        } else {
            return false
        }
    }
}

fn main() -> int {
    (println "=== LALR Module - Phase 2.2.1 ===")
    (println "")
    
    /* Test symbol classification */
    (println "Testing symbol classification...")
    
    if (== (is_terminal "NUMBER") true) {
        (println "✓ NUMBER is terminal")
    } else {
        (println "✗ FAIL")
        return 1
    }
    
    if (== (is_nonterminal "expr") true) {
        (println "✓ expr is nonterminal")
    } else {
        (println "✗ FAIL")
        return 1
    }
    
    if (== (is_terminal "+") true) {
        (println "✓ + is terminal")
    } else {
        (println "✗ FAIL")
        return 1
    }
    
    if (== (is_nonterminal "PLUS") false) {
        (println "✓ PLUS is not nonterminal")
    } else {
        (println "✗ FAIL")
        return 1
    }
    
    (println "")
    (println "====================================")
    (println "Phase 2.2.1 Foundation Complete! ✓")
    (println "====================================")
    (println "")
    (println "Symbol classification working!")
    (println "Next: Build production storage")
    
    return 0
}
