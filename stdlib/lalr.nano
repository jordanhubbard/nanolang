/* =============================================================================
 * LALR Parser Generator Module - Phases 2.2.1 & 2.2.2
 * =============================================================================
 */

/* Production rule */
struct Production {
    id: int,
    lhs: string,
    rhs_count: int,
    rhs0: string,
    rhs1: string,
    rhs2: string
}

/* Grammar */
struct Grammar {
    prod_count: int,
    terminal_count: int,
    start_symbol: string
}

/* Symbol classification */
fn is_terminal(sym: string) -> bool {
    let len: int = (str_length sym)
    if (== len 0) {
        return false
    } else {
        let ch: int = (char_at sym 0)
        /* Uppercase A-Z (65-90) or special chars */
        if (>= ch 65) {
            return (<= ch 90)
        } else {
            /* +, -, *, /, (, ) */
            if (== ch 43) { return true }
            else { if (== ch 45) { return true }
            else { if (== ch 42) { return true }
            else { if (== ch 47) { return true }
            else { if (== ch 40) { return true }
            else { if (== ch 41) { return true }
            else { return false }
            }}}}}}
        }
    }
}

fn is_nonterminal(sym: string) -> bool {
    let len: int = (str_length sym)
    if (== len 0) {
        return false  
    } else {
        let ch: int = (char_at sym 0)
        /* Lowercase a-z (97-122) */
        if (>= ch 97) {
            return (<= ch 122)
        } else {
            return false
        }
    }
}

/* Set representation - simple fixed array */
struct StringSet {
    count: int,
    item0: string,
    item1: string,
    item2: string,
    item3: string,
    item4: string
}

fn set_empty() -> StringSet {
    return StringSet {
        count: 0,
        item0: "",
        item1: "",
        item2: "",
        item3: "",
        item4: ""
    }
}

fn set_contains(s: StringSet, item: string) -> bool {
    if (< s.count 1) { return false }
    else { if (== (str_equals s.item0 item) true) { return true }
    else { if (< s.count 2) { return false }
    else { if (== (str_equals s.item1 item) true) { return true }
    else { if (< s.count 3) { return false }
    else { if (== (str_equals s.item2 item) true) { return true }
    else { return false }
    }}}}}
}

fn set_add(s: StringSet, item: string) -> StringSet {
    if (== (set_contains s item) true) {
        return s
    } else {
        let pos: int = s.count
        if (== pos 0) {
            return StringSet { count: 1, item0: item, item1: s.item1, item2: s.item2, item3: s.item3, item4: s.item4 }
        } else { if (== pos 1) {
            return StringSet { count: 2, item0: s.item0, item1: item, item2: s.item2, item3: s.item3, item4: s.item4 }
        } else { if (== pos 2) {
            return StringSet { count: 3, item0: s.item0, item1: s.item1, item2: item, item3: s.item3, item4: s.item4 }
        } else {
            return StringSet { count: 4, item0: s.item0, item1: s.item1, item2: s.item2, item3: item, item4: s.item4 }
        }}}
    }
}

/* FIRST/FOLLOW computation */
fn compute_first(symbol: string) -> StringSet {
    if (== (is_terminal symbol) true) {
        let s: StringSet = (set_empty)
        return (set_add s symbol)
    } else {
        return (set_empty)
    }
}

fn compute_follow(symbol: string, is_start: bool) -> StringSet {
    let mut s: StringSet = (set_empty)
    if (== is_start true) {
        set s (set_add s "$")
    } else {
        /* Would traverse productions */
    }
    return s
}

/* Test functions */
fn test_sets() -> int {
    (println "Testing sets...")
    
    let s1: StringSet = (set_empty)
    if (== s1.count 0) {
        (println "✓ Empty set")
    } else {
        return 1
    }
    
    let s2: StringSet = (set_add s1 "NUMBER")
    if (== s2.count 1) {
        (println "✓ Add item")
    } else {
        return 1
    }
    
    if (== (set_contains s2 "NUMBER") true) {
        (println "✓ Contains")
    } else {
        return 1
    }
    
    let s3: StringSet = (set_add s2 "NUMBER")
    if (== s3.count 1) {
        (println "✓ No duplicates")
    } else {
        return 1
    }
    
    (println "")
    return 0
}

fn test_first_follow() -> int {
    (println "Testing FIRST/FOLLOW...")
    
    let first: StringSet = (compute_first "NUMBER")
    if (== first.count 1) {
        (println "✓ FIRST(terminal)")
    } else {
        return 1
    }
    
    let follow: StringSet = (compute_follow "expr" true)
    if (== follow.count 1) {
        (println "✓ FOLLOW(start)")
    } else {
        return 1
    }
    
    (println "")
    return 0
}

fn test_symbols() -> int {
    (println "Testing symbol classification...")
    
    if (== (is_terminal "NUMBER") true) {
        (println "✓ NUMBER is terminal")
    } else {
        return 1
    }
    
    if (== (is_nonterminal "expr") true) {
        (println "✓ expr is nonterminal")
    } else {
        return 1
    }
    
    (println "")
    return 0
}
