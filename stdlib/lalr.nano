/* =============================================================================
 * LALR Parser Generator Module - Phases 2.2.1 & 2.2.2
 * =============================================================================
 */

/* Production rule */
struct Production {
    id: int,
    lhs: string,
    rhs_count: int,
    rhs0: string,
    rhs1: string,
    rhs2: string
}

/* Grammar */
struct Grammar {
    prod_count: int,
    terminal_count: int,
    start_symbol: string
}

/* Symbol classification */
fn is_terminal(sym: string) -> bool {
    let len: int = (str_length sym)
    if (== len 0) {
        return false
    } else {
        let ch: int = (char_at sym 0)
        /* Uppercase A-Z (65-90) or special chars */
        if (>= ch 65) {
            return (<= ch 90)
        } else {
            /* +, -, *, /, (, ) */
            if (== ch 43) { return true }
            else { if (== ch 45) { return true }
            else { if (== ch 42) { return true }
            else { if (== ch 47) { return true }
            else { if (== ch 40) { return true }
            else { if (== ch 41) { return true }
            else { return false }
            }}}}}}
        }
    }
}

fn is_nonterminal(sym: string) -> bool {
    let len: int = (str_length sym)
    if (== len 0) {
        return false  
    } else {
        let ch: int = (char_at sym 0)
        /* Lowercase a-z (97-122) */
        if (>= ch 97) {
            return (<= ch 122)
        } else {
            return false
        }
    }
}

/* Set representation - simple fixed array */
struct StringSet {
    count: int,
    item0: string,
    item1: string,
    item2: string,
    item3: string,
    item4: string
}

fn set_empty() -> StringSet {
    return StringSet {
        count: 0,
        item0: "",
        item1: "",
        item2: "",
        item3: "",
        item4: ""
    }
}

fn set_contains(s: StringSet, item: string) -> bool {
    if (< s.count 1) { return false }
    else { if (== (str_equals s.item0 item) true) { return true }
    else { if (< s.count 2) { return false }
    else { if (== (str_equals s.item1 item) true) { return true }
    else { if (< s.count 3) { return false }
    else { if (== (str_equals s.item2 item) true) { return true }
    else { return false }
    }}}}}
}

fn set_add(s: StringSet, item: string) -> StringSet {
    if (== (set_contains s item) true) {
        return s
    } else {
        let pos: int = s.count
        if (== pos 0) {
            return StringSet { count: 1, item0: item, item1: s.item1, item2: s.item2, item3: s.item3, item4: s.item4 }
        } else { if (== pos 1) {
            return StringSet { count: 2, item0: s.item0, item1: item, item2: s.item2, item3: s.item3, item4: s.item4 }
        } else { if (== pos 2) {
            return StringSet { count: 3, item0: s.item0, item1: s.item1, item2: item, item3: s.item3, item4: s.item4 }
        } else {
            return StringSet { count: 4, item0: s.item0, item1: s.item1, item2: s.item2, item3: item, item4: s.item4 }
        }}}
    }
}

/* FIRST/FOLLOW computation */
fn compute_first(symbol: string) -> StringSet {
    if (== (is_terminal symbol) true) {
        let s: StringSet = (set_empty)
        return (set_add s symbol)
    } else {
        return (set_empty)
    }
}

fn compute_follow(symbol: string, is_start: bool) -> StringSet {
    let mut s: StringSet = (set_empty)
    if (== is_start true) {
        set s (set_add s "$")
    } else {
        /* Would traverse productions */
    }
    return s
}

/* Test functions */
fn test_sets() -> int {
    (println "Testing sets...")
    
    let s1: StringSet = (set_empty)
    if (== s1.count 0) {
        (println "✓ Empty set")
    } else {
        return 1
    }
    
    let s2: StringSet = (set_add s1 "NUMBER")
    if (== s2.count 1) {
        (println "✓ Add item")
    } else {
        return 1
    }
    
    if (== (set_contains s2 "NUMBER") true) {
        (println "✓ Contains")
    } else {
        return 1
    }
    
    let s3: StringSet = (set_add s2 "NUMBER")
    if (== s3.count 1) {
        (println "✓ No duplicates")
    } else {
        return 1
    }
    
    (println "")
    return 0
}

fn test_first_follow() -> int {
    (println "Testing FIRST/FOLLOW...")
    
    let first: StringSet = (compute_first "NUMBER")
    if (== first.count 1) {
        (println "✓ FIRST(terminal)")
    } else {
        return 1
    }
    
    let follow: StringSet = (compute_follow "expr" true)
    if (== follow.count 1) {
        (println "✓ FOLLOW(start)")
    } else {
        return 1
    }
    
    (println "")
    return 0
}

fn test_symbols() -> int {
    (println "Testing symbol classification...")
    
    if (== (is_terminal "NUMBER") true) {
        (println "✓ NUMBER is terminal")
    } else {
        return 1
    }
    
    if (== (is_nonterminal "expr") true) {
        (println "✓ expr is nonterminal")
    } else {
        return 1
    }
    
    (println "")
    return 0
}

/* =============================================================================
 * Phase 2.2.3: LR(1) Items, Closure, and Goto
 * =============================================================================
 * An LR(1) item: [A -> alpha . beta, a]
 *   - Production A -> alpha beta
 *   - Dot position (between alpha and beta)
 *   - Lookahead symbol a
 */

struct LRItem {
    prod_id: int,           /* Which production */
    dot_pos: int,           /* Position of dot (0 = before first symbol) */
    lookahead: string       /* Lookahead terminal */
}

fn item_create(prod_id: int, dot_pos: int, lookahead: string) -> LRItem {
    return LRItem {
        prod_id: prod_id,
        dot_pos: dot_pos,
        lookahead: lookahead
    }
}

/* Item set - collection of LR items */
struct ItemSet {
    count: int,
    item0: LRItem,
    item1: LRItem,
    item2: LRItem,
    item3: LRItem,
    item4: LRItem,
    item5: LRItem,
    item6: LRItem,
    item7: LRItem
}

fn itemset_empty() -> ItemSet {
    let empty_item: LRItem = (item_create 0 0 "")
    return ItemSet {
        count: 0,
        item0: empty_item,
        item1: empty_item,
        item2: empty_item,
        item3: empty_item,
        item4: empty_item,
        item5: empty_item,
        item6: empty_item,
        item7: empty_item
    }
}

fn itemset_add(iset: ItemSet, item: LRItem) -> ItemSet {
    let pos: int = iset.count
    let new_count: int = (+ pos 1)
    
    if (== pos 0) {
        return ItemSet {
            count: new_count,
            item0: item,
            item1: iset.item1,
            item2: iset.item2,
            item3: iset.item3,
            item4: iset.item4,
            item5: iset.item5,
            item6: iset.item6,
            item7: iset.item7
        }
    } else { if (== pos 1) {
        return ItemSet {
            count: new_count,
            item0: iset.item0,
            item1: item,
            item2: iset.item2,
            item3: iset.item3,
            item4: iset.item4,
            item5: iset.item5,
            item6: iset.item6,
            item7: iset.item7
        }
    } else { if (== pos 2) {
        return ItemSet {
            count: new_count,
            item0: iset.item0,
            item1: iset.item1,
            item2: item,
            item3: iset.item3,
            item4: iset.item4,
            item5: iset.item5,
            item6: iset.item6,
            item7: iset.item7
        }
    } else {
        /* Add at position 3+ */
        return ItemSet {
            count: new_count,
            item0: iset.item0,
            item1: iset.item1,
            item2: iset.item2,
            item3: item,
            item4: iset.item4,
            item5: iset.item5,
            item6: iset.item6,
            item7: iset.item7
        }
    }}}
}

/* Get item at index */
fn itemset_get(iset: ItemSet, idx: int) -> LRItem {
    if (== idx 0) { return iset.item0 }
    else { if (== idx 1) { return iset.item1 }
    else { if (== idx 2) { return iset.item2 }
    else { if (== idx 3) { return iset.item3 }
    else { if (== idx 4) { return iset.item4 }
    else { if (== idx 5) { return iset.item5 }
    else { if (== idx 6) { return iset.item6 }
    else { if (== idx 7) { return iset.item7 }
    else { return (item_create 0 0 "") }
    }}}}}}}
}

/* Closure operation - expand item set
 * For each item [A -> alpha . B beta, a] where B is nonterminal:
 *   Add [B -> . gamma, b] for each production B -> gamma
 *   where b is in FIRST(beta a)
 */
fn closure(iset: ItemSet) -> ItemSet {
    /* Simplified: just return the input set for now */
    /* Full implementation would iterate and add new items */
    return iset
}

/* Goto operation - compute next state
 * Given item set I and symbol X:
 *   For each item [A -> alpha . X beta, a] in I:
 *     Add [A -> alpha X . beta, a] to result
 */
fn goto_state(iset: ItemSet, symbol: string) -> ItemSet {
    /* Simplified: return empty set for now */
    /* Would scan items, advance dot past symbol */
    return (itemset_empty)
}

/* =============================================================================
 * Phase 2.2.4: Parse Table Structures
 * =============================================================================
 */

/* Action types for parse table */
enum ActionType {
    Shift,
    Reduce,
    Accept,
    Error
}

struct Action {
    action_type: ActionType,
    value: int  /* State number for Shift, production ID for Reduce */
}

fn action_shift(state: int) -> Action {
    return Action {
        action_type: ActionType.Shift,
        value: state
    }
}

fn action_reduce(prod_id: int) -> Action {
    return Action {
        action_type: ActionType.Reduce,
        value: prod_id
    }
}

fn action_accept() -> Action {
    return Action {
        action_type: ActionType.Accept,
        value: 0
    }
}

fn action_error() -> Action {
    return Action {
        action_type: ActionType.Error,
        value: 0
    }
}

/* Simple parse table - fixed size for demo */
struct ParseTable {
    state_count: int,
    /* For a real implementation, would have 2D arrays */
    /* action[state][terminal] and goto[state][nonterminal] */
}

fn table_create() -> ParseTable {
    return ParseTable {
        state_count: 0
    }
}

/* =============================================================================
 * Tests for LR Items
 * =============================================================================
 */

fn test_lr_items() -> int {
    (println "Testing LR items...")
    
    /* Create item: [expr -> . term, $] */
    let item1: LRItem = (item_create 1 0 "$")
    if (== item1.prod_id 1) {
        (println "✓ Item creation")
    } else {
        return 1
    }
    
    /* Create item set */
    let iset1: ItemSet = (itemset_empty)
    if (== iset1.count 0) {
        (println "✓ Empty item set")
    } else {
        return 1
    }
    
    /* Add item */
    let iset2: ItemSet = (itemset_add iset1 item1)
    if (== iset2.count 1) {
        (println "✓ Add item to set")
    } else {
        return 1
    }
    
    /* Get item */
    let retrieved: LRItem = (itemset_get iset2 0)
    if (== retrieved.prod_id 1) {
        (println "✓ Get item from set")
    } else {
        return 1
    }
    
    /* Closure (simplified) */
    let closed: ItemSet = (closure iset2)
    if (>= closed.count 1) {
        (println "✓ Closure operation")
    } else {
        return 1
    }
    
    (println "")
    return 0
}

fn test_actions() -> int {
    (println "Testing parse actions...")
    
    let shift_act: Action = (action_shift 5)
    if (== shift_act.action_type ActionType.Shift) {
        (println "✓ Shift action")
    } else {
        return 1
    }
    
    let reduce_act: Action = (action_reduce 2)
    if (== reduce_act.action_type ActionType.Reduce) {
        (println "✓ Reduce action")
    } else {
        return 1
    }
    
    let accept_act: Action = (action_accept)
    if (== accept_act.action_type ActionType.Accept) {
        (println "✓ Accept action")
    } else {
        return 1
    }
    
    (println "")
    return 0
}

fn test_table() -> int {
    (println "Testing parse table...")
    
    let table: ParseTable = (table_create)
    if (== table.state_count 0) {
        (println "✓ Parse table creation")
    } else {
        return 1
    }
    
    (println "")
    return 0
}
