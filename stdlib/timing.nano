# Timing and Benchmarking Utilities for Nanolang
# Provides high-resolution timing for performance measurement

# External C functions for high-resolution timing
extern fn nl_timing_get_microseconds() -> int
extern fn nl_timing_get_nanoseconds() -> int

# Public API

# Get current time in microseconds since epoch
pub fn get_microseconds() -> int
ensures (>= result 0)
{
    return (nl_timing_get_microseconds)
}

shadow get_microseconds {
    let us: int = (get_microseconds)
    assert (>= us 0)
}

# Get current time in nanoseconds (uses best available clock)
pub fn get_nanoseconds() -> int
ensures (>= result 0)
{
    return (nl_timing_get_nanoseconds)
}

shadow get_nanoseconds {
    let ns: int = (get_nanoseconds)
    assert (>= ns 0)
}

# Format microseconds as seconds with 4 decimal places
pub fn format_microseconds(microseconds: int) -> string
requires (>= microseconds 0)
{
    let seconds: int = (/ microseconds 1000000)
    let remaining: int = (% microseconds 1000000)
    let decimals: int = (/ remaining 100)  # 100 us = 0.0001 s

    let sec_str: string = (int_to_string seconds)
    let dec_str: string = (int_to_string decimals)
    let dec_len: int = (str_length dec_str)

    # Pad to 4 digits
    let mut padded: string = ""
    let needed_zeros: int = (- 4 dec_len)
    let mut i: int = 0
    while (< i needed_zeros) {
        set padded (+ padded "0")
        set i (+ i 1)
    }
    set padded (+ padded dec_str)

    return (+ sec_str (+ "." padded))
}

shadow format_microseconds {
    # Test zero
    assert (str_equals (format_microseconds 0) "0.0000")

    # Test sub-second values (< 1000000 us)
    assert (str_equals (format_microseconds 100) "0.0001")
    assert (str_equals (format_microseconds 1000) "0.0010")
    assert (str_equals (format_microseconds 10000) "0.0100")
    assert (str_equals (format_microseconds 100000) "0.1000")
    assert (str_equals (format_microseconds 500000) "0.5000")

    # Test whole seconds
    assert (str_equals (format_microseconds 1000000) "1.0000")
    assert (str_equals (format_microseconds 5000000) "5.0000")

    # Test mixed seconds and decimals
    assert (str_equals (format_microseconds 1234567) "1.2345")
    assert (str_equals (format_microseconds 2500000) "2.5000")
    assert (str_equals (format_microseconds 10250000) "10.2500")
}

# Format nanoseconds as seconds with 4 decimal places
pub fn format_nanoseconds(nanoseconds: int) -> string
requires (>= nanoseconds 0)
{
    let microseconds: int = (/ nanoseconds 1000)
    return (format_microseconds microseconds)
}

shadow format_nanoseconds {
    # Test zero
    assert (str_equals (format_nanoseconds 0) "0.0000")

    # Test sub-second values (< 1000000000 ns)
    assert (str_equals (format_nanoseconds 100000) "0.0001")
    assert (str_equals (format_nanoseconds 1000000) "0.0010")
    assert (str_equals (format_nanoseconds 10000000) "0.0100")
    assert (str_equals (format_nanoseconds 100000000) "0.1000")

    # Test whole seconds
    assert (str_equals (format_nanoseconds 1000000000) "1.0000")
    assert (str_equals (format_nanoseconds 5000000000) "5.0000")

    # Test mixed seconds and decimals
    assert (str_equals (format_nanoseconds 1234567000) "1.2345")
    assert (str_equals (format_nanoseconds 2500000000) "2.5000")
}
