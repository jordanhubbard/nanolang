/* Integration test for std::env, std::process, std::fs, and std::binary */

from "modules/std/env.nano" import get, set_env, unset, args
from "modules/std/fs.nano" import walkdir, glob, normalize
from "modules/std/binary.nano" import encode_int, decode_int, encode_string, decode_string, encode_int_array, decode_int_array

fn array_contains_string(a: array<string>, needle: string) -> bool {
    let n: int = (array_length a)
    let mut i: int = 0
    while (< i n) {
        if (== (at a i) needle) {
            return true
        }
        set i (+ i 1)
    }
    return false
}

fn std_env_get_set_unset() -> int {
    let k: string = "NANOLANG_TEST_ENV"
    assert (== (set_env k "abc") 0)
    assert (== (get k) "abc")
    assert (== (unset k) 0)
    assert (== (get k) "")
    return 0
}

shadow std_env_get_set_unset {
    assert (== (std_env_get_set_unset) 0)
}

fn std_env_args() -> int {
    let a: array<string> = (args)
    /* args() always returns an array - verify we can get its length */
    let len: int = (array_length a)
    /* Length is non-negative by definition, so just check it's a valid int */
    assert (or (== len 0) (> len 0))
    if (> len 0) {
        let first: string = (at a 0)
        let first_len: int = (str_length first)
        assert (or (== first_len 0) (> first_len 0))
    }
    return 0
}

shadow std_env_args {
    assert (== (std_env_args) 0)
}

fn std_fs_walkdir_glob_normalize() -> int {
    let root: string = (mktemp_dir "nanolang_fs_")
    let f1: string = (path_join root "a.txt")
    let f2: string = (path_join root "b.md")
    assert (== (file_write f1 "hi") 0)
    assert (== (file_write f2 "hi") 0)

    let files: array<string> = (walkdir root)
    assert (array_contains_string files f1)
    assert (array_contains_string files f2)

    let hits: array<string> = (glob root "*.txt")
    assert (> (array_length hits) 0)

    assert (== (normalize "./a/../b") "b")
    return 0
}

shadow std_fs_walkdir_glob_normalize {
    assert (== (std_fs_walkdir_glob_normalize) 0)
}

fn std_binary_int_and_string() -> int {
    let bi: array<u8> = (encode_int (- 0 12))
    let ri: Result<int, string> = (decode_int bi)
    assert (result_is_ok ri)
    assert (== (result_unwrap ri) (- 0 12))

    let bs: array<u8> = (encode_string "hello")
    let rs: Result<string, string> = (decode_string bs)
    assert (result_is_ok rs)
    assert (== (result_unwrap rs) "hello")

    let trunc: array<u8> = (array_slice bs 0 (- (array_length bs) 1))
    let rs_trunc: Result<string, string> = (decode_string trunc)
    assert (result_is_err rs_trunc)
    return 0
}

shadow std_binary_int_and_string {
    assert (== (std_binary_int_and_string) 0)
}

fn std_binary_int_array() -> int {
    let a: array<int> = [1, (- 0 2), 300]
    let b: array<u8> = (encode_int_array a)
    let ra: Result<array<int>, string> = (decode_int_array b)
    assert (result_is_ok ra)
    let out: array<int> = (result_unwrap ra)
    assert (== (array_length out) 3)
    assert (== (at out 0) 1)
    assert (== (at out 1) (- 0 2))
    assert (== (at out 2) 300)
    return 0
}

shadow std_binary_int_array {
    assert (== (std_binary_int_array) 0)
}

fn main() -> int { return 0 }
