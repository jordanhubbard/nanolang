from "std/env.nano" import get, set, unset, args
from "std/process.nano" import run, Output
from "std/fs.nano" import walkdir, glob, normalize
from "std/binary.nano" import encode_int, decode_int, encode_string, decode_string, encode_int_array, decode_int_array

fn array_contains_string(a: array<string>, needle: string) -> bool {
    let n: int = (array_length a)
    let mut i: int = 0
    while (< i n) {
        if (str_equals (at a i) needle) {
            return true
        }
        set i (+ i 1)
    }
    return false
}

shadow std_env_get_set_unset {
    let k: string = "NANOLANG_TEST_ENV"
    assert (== (set k "abc") 0)
    assert (str_equals (get k) "abc")
    assert (== (unset k) 0)
    assert (str_equals (get k) "")
}

shadow std_env_args {
    let a: array<string> = (args)
    assert (> (array_length a) 0)
}

shadow std_process_run {
    let o: Output = (run "echo hello")
    assert (== o.code 0)
    assert (str_contains o.stdout "hello")
}

shadow std_process_run_stderr {
    let o: Output = (run "echo err 1>&2; exit 7")
    assert (== o.code 7)
    assert (str_contains o.stderr "err")
}

shadow std_fs_walkdir_glob_normalize {
    let root: string = (mktemp_dir "nanolang_fs_")
    let f1: string = (path_join root "a.txt")
    let f2: string = (path_join root "b.md")
    assert (== (file_write f1 "hi") 0)
    assert (== (file_write f2 "hi") 0)

    let files: array<string> = (walkdir root)
    assert (array_contains_string files f1)
    assert (array_contains_string files f2)

    let hits: array<string> = (glob root "*.txt")
    assert (array_contains_string hits f1)
    assert (== (array_length hits) 1)

    assert (str_equals (normalize "./a/../b") "b")
}

shadow std_binary_int_and_string {
    let bi: array<u8> = (encode_int (- 0 12))
    match (decode_int bi) {
        Ok(v) => { assert (== v.value (- 0 12)) }
        Err(e) => { assert false }
    }

    let bs: array<u8> = (encode_string "hello")
    match (decode_string bs) {
        Ok(v) => { assert (str_equals v.value "hello") }
        Err(e) => { assert false }
    }

    let trunc: array<u8> = (array_slice bs 0 (- (array_length bs) 1))
    match (decode_string trunc) {
        Ok(v) => { assert false }
        Err(e) => { assert true }
    }
}

shadow std_binary_int_array {
    let a: array<int> = [1, (- 0 2), 300]
    let b: array<u8> = (encode_int_array a)
    match (decode_int_array b) {
        Ok(v) => {
            assert (== (array_length v.value) 3)
            assert (== (at v.value 0) 1)
            assert (== (at v.value 1) (- 0 2))
            assert (== (at v.value 2) 300)
        }
        Err(e) => { assert false }
    }
}

fn main() -> int { return 0 }
