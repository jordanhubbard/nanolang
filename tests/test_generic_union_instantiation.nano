/* Test generic union instantiation syntax */

union Result<T, E> {
    Ok { value: T },
    Err { error: E }
}

fn test_result_parsing() -> int {
    /* Test that generic union instantiation parses correctly */
    let r1: Result<int, string> = Result<int, string>.Ok { value: 42 }
    let r2: Result<int, string> = Result<int, string>.Err { error: "failed" }
    
    /* TODO: Match expressions with generic unions need type substitution support */
    /* For now, just test that parsing and construction work */
    return 0
}

fn test_result_in_function() -> Result<int, string> {
    /* Test returning generic union from function */
    if true {
        return Result<int, string>.Ok { value: 100 }
    } else {
        return Result<int, string>.Err { error: "error" }
    }
}

fn main() -> int {
    let _ : int = (test_result_parsing)
    let _r: Result<int, string> = (test_result_in_function)
    return 0
}

shadow test_result_parsing {
    assert (== (test_result_parsing) 0)
}

shadow test_result_in_function {
    /* Just verify it returns without error */
    let _res: Result<int, string> = (test_result_in_function)
    assert true
}

shadow main {
    assert (== (main) 0)
}

