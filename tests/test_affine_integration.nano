/* Affine Types Integration Test
 * Tests compile-time resource safety guarantees
 */

resource struct FileHandle {
    fd: int
}

/* Use regular functions instead of extern for testing */

fn create_file() -> FileHandle {
    return FileHandle { fd: 42 }
}

fn close_file(f: FileHandle) -> void {
    (println "File closed")
}

/* Test 1: Basic create and close */

fn test_basic() -> int {
    let f: FileHandle = (create_file)
    (close_file f)
    return 0
}

shadow test_basic {
    assert (== (test_basic) 0)
}

/* Test 2: Resource in struct */

struct Connection {
    handle: FileHandle
}

fn test_resource_in_struct() -> int {
    let f: FileHandle = (create_file)
    let conn: Connection = Connection { handle: f }
    (close_file conn.handle)
    return 0
}

shadow test_resource_in_struct {
    assert (== (test_resource_in_struct) 0)
}

/* Test 3: Conditional with close in all branches */

fn test_conditional_branches() -> int {
    let x: int = 10
    
    if (> x 0) {
        let f: FileHandle = (create_file)
        (close_file f)
        return 1
    } else {
        let g: FileHandle = (create_file)
        (close_file g)
        return 0
    }
}

shadow test_conditional_branches {
    assert (== (test_conditional_branches) 1)
}

/* Test 4: Multiple resources created in sequence */

fn test_sequential() -> int {
    let f1: FileHandle = (create_file)
    (close_file f1)
    
    let f2: FileHandle = (create_file)
    (close_file f2)
    
    return 0
}

shadow test_sequential {
    assert (== (test_sequential) 0)
}

/* Main test runner */

fn main() -> int {
    assert (== (test_basic) 0)
    assert (== (test_resource_in_struct) 0)
    assert (== (test_conditional_branches) 1)
    assert (== (test_sequential) 0)
    return 0
}

/* This test validates that affine types correctly:
 * ✓ Track basic resource lifecycle (create → consume)
 * ✓ Handle resources within structs
 * ✓ Handle conditional branches with proper cleanup
 * ✓ Handle sequential resource creation and cleanup
 */
