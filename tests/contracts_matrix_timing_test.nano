/* Test matrix4 and timing contracts */

from "stdlib/std/math/matrix4.nano" import Mat4, mat4_identity, mat4_get, mat4_set
from "stdlib/timing.nano" import format_microseconds, format_nanoseconds

fn test_matrix_contracts() -> bool {
    let m: Mat4 = (mat4_identity)
    
    /* Test mat4_get with valid indices */
    let v00: float = (mat4_get m 0 0)
    assert (== v00 1.0)
    
    let v11: float = (mat4_get m 1 1)
    assert (== v11 1.0)
    
    let v33: float = (mat4_get m 3 3)
    assert (== v33 1.0)
    
    let v01: float = (mat4_get m 0 1)
    assert (== v01 0.0)
    
    /* Test mat4_set with valid indices */
    let m2: Mat4 = (mat4_set m 2 3 5.0)
    let v23: float = (mat4_get m2 2 3)
    assert (== v23 5.0)
    
    return true
}

shadow test_matrix_contracts {
    assert (test_matrix_contracts)
}

fn test_timing_contracts() -> bool {
    /* Test format_microseconds with non-negative values */
    let fmt1: string = (format_microseconds 0)
    assert (str_equals fmt1 "0.0000")
    
    let fmt2: string = (format_microseconds 1234567)
    assert (str_equals fmt2 "1.2345")
    
    /* Test format_nanoseconds with non-negative values */
    let fmt3: string = (format_nanoseconds 0)
    assert (str_equals fmt3 "0.0000")
    
    let fmt4: string = (format_nanoseconds 1000000000)
    assert (str_equals fmt4 "1.0000")
    
    return true
}

shadow test_timing_contracts {
    assert (test_timing_contracts)
}

fn main() -> int {
    (println "Testing matrix4 and timing contracts...")
    assert (test_matrix_contracts)
    assert (test_timing_contracts)
    (println "All matrix4 and timing contract tests passed!")
    return 0
}

shadow main { assert true }
