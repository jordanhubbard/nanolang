# Note: Opaque types (regex, hashmap, JSON) are automatically GC-managed
import "examples/opl/opl_parser.nano"
import "examples/opl/opl_compile.nano"
import "examples/opl/opl_validate.nano"

module "modules/std/fs.nano"
module "modules/std/json/json.nano"

fn errors_have_code(errors: Json, code: string) -> bool {
    let mut i: int = 0
    let n: int = (array_size errors)
    while (< i n) {
        let e: Json = (get_index errors i)
        let c: string = (get_string e "code")
        if (== c code) {
            return true
        } else {}
        set i (+ i 1)
    }
    return false
}

shadow errors_have_code {
    let errs: Json = (new_array)
    let e: Json = (new_object)
    (object_set e "code" (new_string "E_X"))
    (json_array_push errs e)
    assert (errors_have_code errs "E_X")
    assert (not (errors_have_code errs "E_Y"))
}

fn run_golden_ast(input_path: string, expected_path: string) -> bool {
    let src: string = (read input_path)
    let r: OplParseResult = (opl_parse src)
    if (not r.ok) {
        return false
    } else {}
    let got: string = (stringify r.ast)

    let exp_src: string = (read expected_path)
    let exp_json: Json = (parse exp_src)
    let exp: string = (stringify exp_json)

    let ok: bool = (== got exp)
    return ok
}

shadow run_golden_ast {
    assert (run_golden_ast "examples/opl/bundle/EXAMPLES.opl" "examples/opl/bundle/EXAMPLES.expected_ast.json")
}

fn run_golden_plan(input_path: string, expected_path: string) -> bool {
    let src: string = (read input_path)
    let plan: Json = (opl_compile src)
    if (== plan 0) {
        return false
    } else {}
    let got: string = (stringify plan)

    let exp_src: string = (read expected_path)
    let exp_json: Json = (parse exp_src)
    let exp: string = (stringify exp_json)

    let ok: bool = (== got exp)
    return ok
}

shadow run_golden_plan {
    assert (run_golden_plan "examples/opl/bundle/EXAMPLES.opl" "examples/opl/bundle/EXAMPLES.expected_plan.json")
}

fn run_validate_error(input_src: string, codes: Json) -> bool {
    let r: Json = (opl_validate input_src)
    let okv: Json = (get r "ok")
    let ok: bool = (as_bool okv)
    if ok {
        return false
    } else {}

    let errs: Json = (get r "errors")
    let mut i: int = 0
    let n: int = (array_size codes)
    while (< i n) {
        let c: Json = (get_index codes i)
        let code: string = (as_string c)
        if (not (errors_have_code errs code)) {
            return false
        } else {}
        set i (+ i 1)
    }

    return true
}

shadow run_validate_error {
    let codes: Json = (new_array)
    (json_array_push codes (new_string "E_UNRESOLVED_ID"))
    assert (run_validate_error "agent a { uses web.search call web.search { query: q } }" codes)
}

fn run_cases() -> int {
    let src: string = (read "examples/opl/bundle/TESTS.cases.json")
    let root: Json = (parse src)
    if (== root 0) { return 1 } else {}

    let cases: Json = (get root "cases")
    let mut i: int = 0
    let n: int = (array_size cases)
    let mut failures: int = 0
    let mut first_fail: string = ""

    while (< i n) {
        let c: Json = (get_index cases i)
        let name: string = (get_string c "name")
        let kind: string = (get_string c "kind")

        if (== kind "golden_ast") {
            let inp: string = (+ "examples/opl/bundle/" (get_string c "inputFile"))
            let exp: string = (+ "examples/opl/bundle/" (get_string c "expectedFile"))
            if (not (run_golden_ast inp exp)) {
                (println (+ "FAIL golden_ast " name))
                if (== first_fail "") { set first_fail (+ "golden_ast:" name) } else {}
                set failures (+ failures 1)
            } else {}
        } else {}

        if (== kind "golden_plan") {
            let inp: string = (+ "examples/opl/bundle/" (get_string c "inputFile"))
            let exp: string = (+ "examples/opl/bundle/" (get_string c "expectedFile"))
            if (not (run_golden_plan inp exp)) {
                (println (+ "FAIL golden_plan " name))
                if (== first_fail "") { set first_fail (+ "golden_plan:" name) } else {}
                set failures (+ failures 1)
            } else {}
        } else {}

        if (== kind "validate_error") {
            let inp: string = (get_string c "input")
            let expect: Json = (get c "expect")
            let codes: Json = (get expect "errorsContainCodes")
            if (not (run_validate_error inp codes)) {
                (println (+ "FAIL validate_error " name))
                if (== first_fail "") { set first_fail (+ "validate_error:" name) } else {}
                set failures (+ failures 1)
            } else {}
        } else {}
        set i (+ i 1)
    }

    if (!= failures 0) {
        (println (+ "OPL_CASES_FAILED " (+ first_fail (+ " count=" (int_to_string failures)))))
    } else {}

    return failures
}

shadow run_cases {
    assert (== (run_cases) 0)
}

fn main() -> int {
    let fails: int = (run_cases)
    if (== fails 0) { return 0 } else { return 1 }
}

shadow main {
    assert (== (main) 0)
}

