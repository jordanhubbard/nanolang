from "std/math/vector2d.nano" import Vector2D, vec_new, vec_zero, vec_add, vec_sub, vec_scale, vec_dot, vec_length, vec_length_squared, vec_distance, vec_distance_squared, vec_normalize, vec_rotate, vec_from_angle, vec_to_angle, vec_lerp, vec_clamp_length, vec_perp, vec_reflect
from "std/math/extended.nano" import pi

let EPS: float = 0.00001

fn approx(a: float, b: float) -> bool {
    return (< (abs (- a b)) EPS)
}

fn test_vector2d_ops() -> int {
    let a: Vector2D = (vec_new 1.0 2.0)
    let b: Vector2D = (vec_new 3.0 4.0)

    let s: Vector2D = (vec_add a b)
    assert (approx s.x 4.0)
    assert (approx s.y 6.0)

    let d: Vector2D = (vec_sub a b)
    assert (approx d.x (- 2.0))
    assert (approx d.y (- 2.0))

    let sc: Vector2D = (vec_scale a 2.0)
    assert (approx sc.x 2.0)
    assert (approx sc.y 4.0)

    assert (approx (vec_dot (vec_new 1.0 0.0) (vec_new 0.0 1.0)) 0.0)

    let v: Vector2D = (vec_new 3.0 4.0)
    assert (approx (vec_length v) 5.0)
    assert (approx (vec_length_squared v) 25.0)

    let z: Vector2D = (vec_zero)
    assert (approx (vec_length z) 0.0)

    assert (approx (vec_distance (vec_zero) (vec_new 3.0 4.0)) 5.0)
    assert (approx (vec_distance_squared (vec_zero) (vec_new 3.0 4.0)) 25.0)

    let n: Vector2D = (vec_normalize v)
    assert (approx n.x 0.6)
    assert (approx n.y 0.8)

    let half_pi: float = (/ (pi) 2.0)
    let r: Vector2D = (vec_rotate (vec_new 1.0 0.0) half_pi)
    assert (< (abs r.x) 0.01)
    assert (> r.y 0.99)

    let fa: Vector2D = (vec_from_angle half_pi)
    assert (< (abs fa.x) 0.01)
    assert (> fa.y 0.99)

    let ang: float = (vec_to_angle (vec_new 0.0 1.0))
    assert (approx ang half_pi)

    let l: Vector2D = (vec_lerp (vec_new 0.0 0.0) (vec_new 10.0 0.0) 0.25)
    assert (approx l.x 2.5)
    assert (approx l.y 0.0)

    let cl: Vector2D = (vec_clamp_length (vec_new 3.0 4.0) 3.0)
    assert (approx (vec_length cl) 3.0)
    assert (approx cl.x 1.8)
    assert (approx cl.y 2.4)

    let p: Vector2D = (vec_perp (vec_new 1.0 2.0))
    assert (approx p.x (- 2.0))
    assert (approx p.y 1.0)

    let refl: Vector2D = (vec_reflect (vec_new 1.0 (- 1.0)) (vec_new 0.0 1.0))
    assert (approx refl.x 1.0)
    assert (approx refl.y 1.0)
    return 0
}

shadow test_vector2d_ops {
    assert (== (test_vector2d_ops) 0)
}

fn main() -> int { return 0 }

shadow main {
    assert (== (main) 0)
}
