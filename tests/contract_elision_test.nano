/* Test contract elision (static analysis) */

fn always_positive() -> int
requires (> 5 0)          /* Always true - should be elided */
ensures (>= 10 0)         /* Always true - should be elided */
{
    return 10
}

shadow always_positive {
    assert (== (always_positive) 10)
}

fn with_impossible_require() -> int
requires (< 0 0)          /* Always false - should warn */
{
    return 42
}

shadow with_impossible_require {
    /* Can't test this - would fail at runtime */
    assert true
}

fn main() -> int {
    (println (int_to_string (always_positive)))
    return 0
}

shadow main { assert true }
