# Test: Parser refactoring doesn't break compilation
# This file exercises all parser features to ensure refactoring preserves functionality

fn simple_function(x: int) -> int {
    return (+ x 1)
}

shadow simple_function {
    assert (== (simple_function 5) 6)
}

fn main() -> int {
    # Test: literals
    let num: int = 42
    let str: string = "hello"
    let flag: bool = true
    
    # Test: binary ops
    let sum: int = (+ 1 2)
    let cmp: bool = (< sum 10)
    
    # Test: function calls
    let result: int = (simple_function num)
    
    # Test: if/else
    if (> result 0) {
        (println "positive")
    } else {
        (println "non-positive")
    }
    
    # Test: while loop
    let mut i: int = 0
    while (< i 3) {
        set i (+ i 1)
    }
    
    # Test: cond expression
    let val: int = (cond
        ((< i 0) -1)
        ((> i 10) 1)
        (else 0)
    )
    
    return 0
}

shadow main {
    assert (== (main) 0)
}

