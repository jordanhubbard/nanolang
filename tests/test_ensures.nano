/* Test ensures clauses (postconditions) */

/* Test 1: Simple ensures with result reference */
fn double(x: int) -> int
    ensures (== result (* x 2))
{
    return (* x 2)
}

shadow double {
    assert (== (double 5) 10)
    assert (== (double 0) 0)
    assert (== (double (- 0 3)) (- 0 6))
}

/* Test 2: Multiple ensures clauses */
fn factorial(n: int) -> int
    requires (>= n 0)
    ensures (>= result 1)
    ensures (or (== n 0) (>= result n))
{
    if (== n 0) {
        return 1
    } else {
        return (* n (factorial (- n 1)))
    }
}

shadow factorial {
    assert (== (factorial 0) 1)
    assert (== (factorial 1) 1)
    assert (== (factorial 5) 120)
}

/* Test 3: Ensures with comparison */
fn maximum(a: int, b: int) -> int
    ensures (>= result a)
    ensures (>= result b)
    ensures (or (== result a) (== result b))
{
    if (> a b) {
        return a
    } else {
        return b
    }
}

shadow maximum {
    assert (== (maximum 5 3) 5)
    assert (== (maximum 3 5) 5)
    assert (== (maximum 5 5) 5)
}

/* Test 4: Ensures without result reference */
fn increment(x: int) -> int
    ensures (> result x)
{
    return (+ x 1)
}

shadow increment {
    assert (== (increment 5) 6)
    assert (== (increment 0) 1)
}

/* Test 5: Both requires and ensures */
fn safe_divide(x: int, y: int) -> int
    requires (> x 0)
    requires (!= y 0)
    ensures (>= result 0)
{
    return (/ x y)
}

shadow safe_divide {
    assert (== (safe_divide 10 2) 5)
    assert (== (safe_divide 100 10) 10)
}

fn main() -> int {
    let d: int = (double 21)
    let f: int = (factorial 5)
    let m: int = (maximum 10 20)
    let i: int = (increment 99)
    let s: int = (safe_divide 100 5)

    assert (== d 42)
    assert (== f 120)
    assert (== m 20)
    assert (== i 100)
    assert (== s 20)

    return 0
}

shadow main {
    assert (== (main) 0)
}
