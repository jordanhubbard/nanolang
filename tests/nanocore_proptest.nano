/* =============================================================================
 * NanoCore Property-Based Testing Bridge
 *
 * Empirically validates the properties proven in the Coq formal verification:
 * 1. Determinism: evaluating the same expression twice yields identical results
 * 2. Type preservation: well-typed NanoCore expressions produce correctly-typed values
 * 3. Arithmetic identities: basic algebraic laws hold
 *
 * Uses the proptest module to randomly test these properties across many inputs,
 * bridging the gap between formal proofs and empirical validation.
 *
 * All functions in this file are in the NanoCore verified subset
 * (run with --trust-report to confirm).
 * ============================================================================= */

from "modules/proptest/proptest.nano" import int_range, int_pair, forall_int_with_config, forall_int_pair_with_config, prop_pass, prop_fail, config, report_passed, report_summary, RunConfig, PropertyReport, IntPairGenerator, IntRangeGenerator

/* =============================================================================
 * DETERMINISM TESTS
 * Proven in formal/Determinism.v: eval is a partial function
 * If eval renv e renv1 v1 and eval renv e renv2 v2, then v1 = v2 and renv1 = renv2
 * ============================================================================= */

/* Arithmetic determinism: same inputs, same outputs */
fn prop_arith_determinism(a: int, b: int) -> bool {
    let r1: int = (+ a b)
    let r2: int = (+ a b)
    return (== r1 r2)
}

shadow prop_arith_determinism {
    assert (prop_arith_determinism 0 0)
    assert (prop_arith_determinism 42 -42)
    assert (prop_arith_determinism 999999 1)
    assert (prop_arith_determinism -100 -200)
}

/* Multiplication determinism */
fn prop_mul_determinism(a: int, b: int) -> bool {
    let r1: int = (* a b)
    let r2: int = (* a b)
    return (== r1 r2)
}

shadow prop_mul_determinism {
    assert (prop_mul_determinism 7 6)
    assert (prop_mul_determinism 0 999)
    assert (prop_mul_determinism -3 -4)
}

/* Division determinism (safe: divisor != 0) */
fn prop_div_determinism(a: int, b: int) -> bool {
    if (== b 0) {
        return true
    }
    let r1: int = (/ a b)
    let r2: int = (/ a b)
    return (== r1 r2)
}

shadow prop_div_determinism {
    assert (prop_div_determinism 10 3)
    assert (prop_div_determinism 7 0)
    assert (prop_div_determinism -100 7)
}

/* String concatenation determinism */
fn prop_strcat_determinism(s1: string, s2: string) -> bool {
    let r1: string = (+ s1 s2)
    let r2: string = (+ s1 s2)
    return (== r1 r2)
}

shadow prop_strcat_determinism {
    assert (prop_strcat_determinism "hello" " world")
    assert (prop_strcat_determinism "" "")
    assert (prop_strcat_determinism "nano" "core")
}

/* Boolean logic determinism */
fn prop_logic_determinism(a: bool, b: bool) -> bool {
    let r1: bool = (and a b)
    let r2: bool = (and a b)
    let r3: bool = (or a b)
    let r4: bool = (or a b)
    return (and (== r1 r2) (== r3 r4))
}

shadow prop_logic_determinism {
    assert (prop_logic_determinism true true)
    assert (prop_logic_determinism true false)
    assert (prop_logic_determinism false true)
    assert (prop_logic_determinism false false)
}

/* Comparison determinism */
fn prop_cmp_determinism(a: int, b: int) -> bool {
    let lt1: bool = (< a b)
    let lt2: bool = (< a b)
    let eq1: bool = (== a b)
    let eq2: bool = (== a b)
    return (and (== lt1 lt2) (== eq1 eq2))
}

shadow prop_cmp_determinism {
    assert (prop_cmp_determinism 1 2)
    assert (prop_cmp_determinism 5 5)
    assert (prop_cmp_determinism 10 3)
}

/* If-expression determinism */
fn prop_if_determinism(x: int) -> bool {
    let mut r1: int = 0
    if (> x 0) {
        set r1 x
    } else {
        set r1 (- 0 x)
    }
    let mut r2: int = 0
    if (> x 0) {
        set r2 x
    } else {
        set r2 (- 0 x)
    }
    return (== r1 r2)
}

shadow prop_if_determinism {
    assert (prop_if_determinism 5)
    assert (prop_if_determinism -5)
    assert (prop_if_determinism 0)
}

/* While loop determinism */
fn prop_while_determinism(n: int) -> bool {
    let mut i: int = 0
    let mut sum1: int = 0
    while (< i n) {
        set sum1 (+ sum1 i)
        set i (+ i 1)
    }
    set i 0
    let mut sum2: int = 0
    while (< i n) {
        set sum2 (+ sum2 i)
        set i (+ i 1)
    }
    return (== sum1 sum2)
}

shadow prop_while_determinism {
    assert (prop_while_determinism 0)
    assert (prop_while_determinism 5)
    assert (prop_while_determinism 10)
}

/* Array determinism */
fn prop_array_determinism() -> bool {
    let arr1: array<int> = [1, 2, 3, 4, 5]
    let arr2: array<int> = [1, 2, 3, 4, 5]
    let v1: int = (at arr1 2)
    let v2: int = (at arr2 2)
    return (== v1 v2)
}

shadow prop_array_determinism {
    assert (prop_array_determinism)
}

/* Struct/record determinism */
struct Point {
    x: int,
    y: int
}

fn prop_struct_determinism(x: int, y: int) -> bool {
    let p1: Point = Point { x: x, y: y }
    let p2: Point = Point { x: x, y: y }
    return (and (== p1.x p2.x) (== p1.y p2.y))
}

shadow prop_struct_determinism {
    assert (prop_struct_determinism 3 4)
    assert (prop_struct_determinism 0 0)
    assert (prop_struct_determinism -1 1)
}

/* Union/match determinism */
union IntResult {
    Ok { value: int },
    Err { message: string }
}

fn safe_div(a: int, b: int) -> IntResult {
    if (== b 0) {
        return IntResult.Err { message: "division by zero" }
    }
    return IntResult.Ok { value: (/ a b) }
}

shadow safe_div {
    let ok: IntResult = (safe_div 10 2)
    let v: int = match ok { Ok(o) => o.value, Err(_e) => -1 }
    assert (== v 5)
}

fn prop_union_determinism(a: int, b: int) -> bool {
    let r1: IntResult = (safe_div a b)
    let r2: IntResult = (safe_div a b)
    let v1: int = match r1 {
        Ok(ok) => ok.value,
        Err(_err) => -1
    }
    let v2: int = match r2 {
        Ok(ok) => ok.value,
        Err(_err) => -1
    }
    return (== v1 v2)
}

shadow prop_union_determinism {
    assert (prop_union_determinism 10 3)
    assert (prop_union_determinism 10 0)
    assert (prop_union_determinism 0 1)
}

/* =============================================================================
 * TYPE PRESERVATION TESTS
 * Proven in formal/Soundness.v: evaluation preserves types
 * If has_type ctx e t and eval renv e renv' v, then val_has_type v t
 * ============================================================================= */

/* Arithmetic type preservation: int op int -> int */
fn prop_arith_type_preservation(a: int, b: int) -> bool {
    /* All arithmetic operations on int produce int.
     * If this compiles and runs, the typechecker has verified the types,
     * and the Coq proofs guarantee they're preserved at runtime. */
    let sum: int = (+ a b)
    let diff: int = (- a b)
    let prod: int = (* a b)
    /* Verify the results are integers by doing arithmetic on them */
    let check: int = (+ sum (+ diff prod))
    return (== check (+ (+ a b) (+ (- a b) (* a b))))
}

shadow prop_arith_type_preservation {
    assert (prop_arith_type_preservation 1 2)
    assert (prop_arith_type_preservation 0 0)
}

/* Comparison type preservation: int op int -> bool */
fn prop_cmp_type_preservation(a: int, b: int) -> bool {
    let lt: bool = (< a b)
    let le: bool = (<= a b)
    let gt: bool = (> a b)
    let ge: bool = (>= a b)
    let eq: bool = (== a b)
    let ne: bool = (!= a b)
    /* All comparisons produce bool - verified by typechecker + Coq */
    return (or lt (or le (or gt (or ge (or eq ne)))))
}

shadow prop_cmp_type_preservation {
    assert (prop_cmp_type_preservation 1 2)
    assert (prop_cmp_type_preservation 5 5)
}

/* String type preservation: string operations produce strings */
fn prop_string_type_preservation(s: string) -> bool {
    let _cat: string = (+ s s)
    let len: int = (str_length s)
    /* _cat is string, len is int - verified */
    return (>= len 0)
}

shadow prop_string_type_preservation {
    assert (prop_string_type_preservation "hello")
    assert (prop_string_type_preservation "")
}

/* =============================================================================
 * ALGEBRAIC IDENTITY TESTS
 * These verify that NanoCore arithmetic obeys standard algebraic laws,
 * which follow from the Coq semantics definitions.
 * ============================================================================= */

/* Addition is commutative: a + b = b + a */
fn prop_add_commutative(a: int, b: int) -> bool {
    return (== (+ a b) (+ b a))
}

shadow prop_add_commutative {
    assert (prop_add_commutative 0 0)
    assert (prop_add_commutative 1 2)
    assert (prop_add_commutative -5 3)
    assert (prop_add_commutative 100 -100)
}

/* Multiplication is commutative: a * b = b * a */
fn prop_mul_commutative(a: int, b: int) -> bool {
    return (== (* a b) (* b a))
}

shadow prop_mul_commutative {
    assert (prop_mul_commutative 3 7)
    assert (prop_mul_commutative 0 42)
    assert (prop_mul_commutative -3 4)
}

/* Addition identity: a + 0 = a */
fn prop_add_identity(a: int) -> bool {
    return (== (+ a 0) a)
}

shadow prop_add_identity {
    assert (prop_add_identity 0)
    assert (prop_add_identity 42)
    assert (prop_add_identity -99)
}

/* Multiplication identity: a * 1 = a */
fn prop_mul_identity(a: int) -> bool {
    return (== (* a 1) a)
}

shadow prop_mul_identity {
    assert (prop_mul_identity 0)
    assert (prop_mul_identity 7)
    assert (prop_mul_identity -13)
}

/* Multiplication by zero: a * 0 = 0 */
fn prop_mul_zero(a: int) -> bool {
    return (== (* a 0) 0)
}

shadow prop_mul_zero {
    assert (prop_mul_zero 0)
    assert (prop_mul_zero 999)
    assert (prop_mul_zero -42)
}

/* Negation: a + (-a) = 0 */
fn prop_negation(a: int) -> bool {
    return (== (+ a (- 0 a)) 0)
}

shadow prop_negation {
    assert (prop_negation 0)
    assert (prop_negation 5)
    assert (prop_negation -7)
}

/* Boolean: De Morgan's law: not(a and b) = (not a) or (not b) */
fn prop_demorgan(a: bool, b: bool) -> bool {
    return (== (not (and a b)) (or (not a) (not b)))
}

shadow prop_demorgan {
    assert (prop_demorgan true true)
    assert (prop_demorgan true false)
    assert (prop_demorgan false true)
    assert (prop_demorgan false false)
}

/* Boolean: double negation: not(not a) = a */
fn prop_double_negation(a: bool) -> bool {
    return (== (not (not a)) a)
}

shadow prop_double_negation {
    assert (prop_double_negation true)
    assert (prop_double_negation false)
}

/* Higher-order function determinism: map is deterministic */
shadow double { assert (== (double 3) 6) }

fn double(x: int) -> int {
    return (* x 2)
}

fn map_array(arr: array<int>, f: fn(int) -> int) -> array<int> {
    let mut result: array<int> = []
    let mut i: int = 0
    while (< i (array_length arr)) {
        set result (array_push result (f (at arr i)))
        set i (+ i 1)
    }
    return result
}

shadow map_array {
    let r: array<int> = (map_array [1, 2] double)
    assert (== (at r 0) 2)
    assert (== (at r 1) 4)
}

fn prop_map_determinism() -> bool {
    let input: array<int> = [1, 2, 3, 4, 5]
    let r1: array<int> = (map_array input double)
    let r2: array<int> = (map_array input double)
    let mut i: int = 0
    let mut all_equal: bool = true
    while (< i (array_length r1)) {
        if (!= (at r1 i) (at r2 i)) {
            set all_equal false
        }
        set i (+ i 1)
    }
    return all_equal
}

shadow prop_map_determinism {
    assert (prop_map_determinism)
}

/* Recursive function determinism */
fn fibonacci(n: int) -> int {
    if (<= n 1) {
        return n
    }
    let mut a: int = 0
    let mut b: int = 1
    let mut i: int = 2
    while (<= i n) {
        let temp: int = b
        set b (+ a b)
        set a temp
        set i (+ i 1)
    }
    return b
}

shadow fibonacci { assert (== (fibonacci 10) 55) }

fn prop_fib_determinism(n: int) -> bool {
    let r1: int = (fibonacci n)
    let r2: int = (fibonacci n)
    return (== r1 r2)
}

shadow prop_fib_determinism {
    assert (prop_fib_determinism 0)
    assert (prop_fib_determinism 1)
    assert (prop_fib_determinism 10)
    assert (== (fibonacci 10) 55)
}

/* =============================================================================
 * PROPTEST WRAPPERS
 * Adapt bool-returning properties to proptest's string-encoded protocol
 * ============================================================================= */

/* --- Determinism properties (pair) --- */
fn pt_arith_determinism(a: int, b: int) -> string {
    if (prop_arith_determinism a b) { return (prop_pass) }
    return (prop_fail "add not deterministic")
}

fn pt_mul_determinism(a: int, b: int) -> string {
    if (prop_mul_determinism a b) { return (prop_pass) }
    return (prop_fail "mul not deterministic")
}

fn pt_div_determinism(a: int, b: int) -> string {
    if (prop_div_determinism a b) { return (prop_pass) }
    return (prop_fail "div not deterministic")
}

fn pt_cmp_determinism(a: int, b: int) -> string {
    if (prop_cmp_determinism a b) { return (prop_pass) }
    return (prop_fail "cmp not deterministic")
}

fn pt_struct_determinism(a: int, b: int) -> string {
    if (prop_struct_determinism a b) { return (prop_pass) }
    return (prop_fail "struct not deterministic")
}

fn pt_union_determinism(a: int, b: int) -> string {
    if (prop_union_determinism a b) { return (prop_pass) }
    return (prop_fail "union/match not deterministic")
}

/* --- Determinism properties (unary) --- */
fn pt_if_determinism(x: int) -> string {
    if (prop_if_determinism x) { return (prop_pass) }
    return (prop_fail "if not deterministic")
}

fn pt_while_determinism(n: int) -> string {
    if (< n 0) { return (prop_pass) }
    if (> n 100) { return (prop_pass) }
    if (prop_while_determinism n) { return (prop_pass) }
    return (prop_fail "while not deterministic")
}

fn pt_fib_determinism(n: int) -> string {
    if (< n 0) { return (prop_pass) }
    if (> n 30) { return (prop_pass) }
    if (prop_fib_determinism n) { return (prop_pass) }
    return (prop_fail "fib not deterministic")
}

/* --- Algebraic properties (pair) --- */
fn pt_add_commutative(a: int, b: int) -> string {
    if (prop_add_commutative a b) { return (prop_pass) }
    return (prop_fail "add not commutative")
}

fn pt_mul_commutative(a: int, b: int) -> string {
    if (prop_mul_commutative a b) { return (prop_pass) }
    return (prop_fail "mul not commutative")
}

/* --- Algebraic properties (unary) --- */
fn pt_add_identity(a: int) -> string {
    if (prop_add_identity a) { return (prop_pass) }
    return (prop_fail "add identity failed")
}

fn pt_mul_identity(a: int) -> string {
    if (prop_mul_identity a) { return (prop_pass) }
    return (prop_fail "mul identity failed")
}

fn pt_mul_zero(a: int) -> string {
    if (prop_mul_zero a) { return (prop_pass) }
    return (prop_fail "mul zero failed")
}

fn pt_negation(a: int) -> string {
    if (prop_negation a) { return (prop_pass) }
    return (prop_fail "negation failed")
}

/* --- Type preservation properties (pair) --- */
fn pt_arith_type_preservation(a: int, b: int) -> string {
    if (prop_arith_type_preservation a b) { return (prop_pass) }
    return (prop_fail "arith type not preserved")
}

fn pt_cmp_type_preservation(a: int, b: int) -> string {
    if (prop_cmp_type_preservation a b) { return (prop_pass) }
    return (prop_fail "cmp type not preserved")
}

shadow pt_arith_determinism { assert (== (prop_pass) (pt_arith_determinism 1 2)) }
shadow pt_mul_determinism { assert (== (prop_pass) (pt_mul_determinism 3 4)) }
shadow pt_div_determinism { assert (== (prop_pass) (pt_div_determinism 10 3)) }
shadow pt_cmp_determinism { assert (== (prop_pass) (pt_cmp_determinism 1 2)) }
shadow pt_struct_determinism { assert (== (prop_pass) (pt_struct_determinism 5 6)) }
shadow pt_union_determinism { assert (== (prop_pass) (pt_union_determinism 10 3)) }
shadow pt_if_determinism { assert (== (prop_pass) (pt_if_determinism 5)) }
shadow pt_while_determinism { assert (== (prop_pass) (pt_while_determinism 5)) }
shadow pt_fib_determinism { assert (== (prop_pass) (pt_fib_determinism 10)) }
shadow pt_add_commutative { assert (== (prop_pass) (pt_add_commutative 1 2)) }
shadow pt_mul_commutative { assert (== (prop_pass) (pt_mul_commutative 3 4)) }
shadow pt_add_identity { assert (== (prop_pass) (pt_add_identity 42)) }
shadow pt_mul_identity { assert (== (prop_pass) (pt_mul_identity 7)) }
shadow pt_mul_zero { assert (== (prop_pass) (pt_mul_zero 99)) }
shadow pt_negation { assert (== (prop_pass) (pt_negation 5)) }
shadow pt_arith_type_preservation { assert (== (prop_pass) (pt_arith_type_preservation 1 2)) }
shadow pt_cmp_type_preservation { assert (== (prop_pass) (pt_cmp_type_preservation 1 2)) }

/* --- Division consistency: a == (a/b)*b + (a%b) when b != 0 --- */
fn pt_div_mod_consistency(a: int, b: int) -> string {
    if (== b 0) { return (prop_pass) }
    let q: int = (/ a b)
    let r: int = (% a b)
    if (== a (+ (* q b) r)) { return (prop_pass) }
    return (prop_fail "div/mod inconsistent")
}

shadow pt_div_mod_consistency {
    assert (== (prop_pass) (pt_div_mod_consistency 10 3))
    assert (== (prop_pass) (pt_div_mod_consistency -7 2))
    assert (== (prop_pass) (pt_div_mod_consistency 5 0))
}

/* =============================================================================
 * MAIN: Run random property tests via proptest module
 * ============================================================================= */

shadow check_prop { assert true }

fn check_prop(report: PropertyReport) -> bool {
    print (report_summary report)
    return (report_passed report)
}

fn main() -> int {
    print "=== NanoCore Property-Based Testing Bridge ==="
    print "Empirically validating Coq-proven properties with random inputs"
    print ""

    let wide: IntRangeGenerator = (int_range -10000 10000)
    let small: IntRangeGenerator = (int_range -100 100)
    let positive: IntRangeGenerator = (int_range 0 100)
    let cfg: RunConfig = (config 200 10 400 42)
    let wide_pair: IntPairGenerator = (int_pair wide wide)
    let small_pair: IntPairGenerator = (int_pair small small)

    let mut all_passed: bool = true

    /* --- Determinism (proven in Determinism.v) --- */
    print "--- Determinism Properties (Determinism.v) ---"
    if (not (check_prop (forall_int_pair_with_config "arith_determinism" wide_pair pt_arith_determinism cfg))) { set all_passed false }
    if (not (check_prop (forall_int_pair_with_config "mul_determinism" wide_pair pt_mul_determinism cfg))) { set all_passed false }
    if (not (check_prop (forall_int_pair_with_config "div_determinism" wide_pair pt_div_determinism cfg))) { set all_passed false }
    if (not (check_prop (forall_int_pair_with_config "cmp_determinism" wide_pair pt_cmp_determinism cfg))) { set all_passed false }
    if (not (check_prop (forall_int_pair_with_config "struct_determinism" small_pair pt_struct_determinism cfg))) { set all_passed false }
    if (not (check_prop (forall_int_pair_with_config "union_determinism" small_pair pt_union_determinism cfg))) { set all_passed false }
    if (not (check_prop (forall_int_with_config "if_determinism" wide pt_if_determinism cfg))) { set all_passed false }
    if (not (check_prop (forall_int_with_config "while_determinism" positive pt_while_determinism cfg))) { set all_passed false }
    if (not (check_prop (forall_int_with_config "fib_determinism" (int_range 0 30) pt_fib_determinism cfg))) { set all_passed false }

    print ""
    print "--- Algebraic Properties (follows from Semantics.v) ---"
    if (not (check_prop (forall_int_pair_with_config "add_commutative" wide_pair pt_add_commutative cfg))) { set all_passed false }
    if (not (check_prop (forall_int_pair_with_config "mul_commutative" wide_pair pt_mul_commutative cfg))) { set all_passed false }
    if (not (check_prop (forall_int_with_config "add_identity" wide pt_add_identity cfg))) { set all_passed false }
    if (not (check_prop (forall_int_with_config "mul_identity" wide pt_mul_identity cfg))) { set all_passed false }
    if (not (check_prop (forall_int_with_config "mul_zero" wide pt_mul_zero cfg))) { set all_passed false }
    if (not (check_prop (forall_int_with_config "negation" wide pt_negation cfg))) { set all_passed false }

    print ""
    print "--- Type Preservation (Soundness.v) ---"
    if (not (check_prop (forall_int_pair_with_config "arith_type_preservation" wide_pair pt_arith_type_preservation cfg))) { set all_passed false }
    if (not (check_prop (forall_int_pair_with_config "cmp_type_preservation" wide_pair pt_cmp_type_preservation cfg))) { set all_passed false }

    print ""
    print "--- Division/Modulus Consistency ---"
    if (not (check_prop (forall_int_pair_with_config "div_mod_consistency" wide_pair pt_div_mod_consistency cfg))) { set all_passed false }

    print ""
    /* Manual spot checks from shadow tests still hold */
    assert (prop_array_determinism)
    assert (prop_map_determinism)
    assert (prop_demorgan true true)
    assert (prop_demorgan true false)
    assert (prop_demorgan false true)
    assert (prop_demorgan false false)
    assert (prop_double_negation true)
    assert (prop_double_negation false)
    print "Manual spot checks: PASS"

    print ""
    if all_passed {
        print "ALL PROPERTY TESTS PASSED"
    } else {
        print "SOME PROPERTY TESTS FAILED"
    }

    assert all_passed
    return 0
}

shadow main { assert true }
