# Comprehensive test of Module.StructName qualification

module "test_modules/simple_math.nano" as Math

fn main() -> int {
    (println "=== Module.StructName Comprehensive Test ===")
    
    # Test 1: Qualified type annotation
    let p1: Math.Point = Point { x: 10, y: 20 }
    (print "Test 1 - Qualified type: p1.x = ")
    (println (int_to_string p1.x))
    if (!= p1.x 10) {
        (println "✗ Test 1 failed")
        return 1
    }
    
    # Test 2: Qualified struct literal
    let p2: Math.Point = Math.Point { x: 30, y: 40 }
    (print "Test 2 - Qualified literal: p2.y = ")
    (println (int_to_string p2.y))
    if (!= p2.y 40) {
        (println "✗ Test 2 failed")
        return 1
    }
    
    # Test 3: Both qualified
    let p3: Math.Point = Math.Point { x: 50, y: 60 }
    (print "Test 3 - Both qualified: p3.x = ")
    (println (int_to_string p3.x))
    if (!= p3.x 50) {
        (println "✗ Test 3 failed")
        return 1
    }
    
    # Test 4: Use in function calls
    (print "Test 4 - Function call: p3.x = ")
    (println (int_to_string p3.x))
    (print "Test 4 - Function call: p3.y = ")
    (println (int_to_string p3.y))
    let sum: int = (Math.add p3.x p3.y)
    (print "Test 4 - Function call: sum = ")
    (println (int_to_string sum))
    if (!= sum 110) {
        (println "✗ Test 4 failed")
        return 1
    }
    
    # Test 5: Multiple qualified types
    let r: Math.Rectangle = Math.Rectangle { x: 0, y: 0, w: 100, h: 200 }
    (print "Test 5 - Rectangle: r.w = ")
    (println (int_to_string r.w))
    if (!= r.w 100) {
        (println "✗ Test 5 failed")
        return 1
    }
    
    (println "✓ All Module.StructName tests passed!")
    return 0
}

# Shadow test disabled - interpreter may not support qualified types yet
# shadow main {
#     assert (== (main) 0)
# }
