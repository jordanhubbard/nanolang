fn bounded_increment(x: int, max: int) -> int
requires (>= x 0)
requires (> max x)
ensures (> result x)
ensures (<= result max)
{
    return (cond
        ((< (+ x 1) max) (+ x 1))
        (else max)
    )
}

shadow bounded_increment {
    assert (== (bounded_increment 5 10) 6)
    assert (== (bounded_increment 9 10) 10)
}

fn main() -> int {
    (println (int_to_string (bounded_increment 5 100)))
    return 0
}

shadow main { assert true }
