from "modules/std/json/json.nano" import Json, parse, free, object_has, get, get_int, get_string, as_int, as_string, is_number, keys, stringify

fn contains_str(xs: array<string>, target: string) -> bool {
    let mut i: int = 0
    while (< i (array_length xs)) {
        if (== (at xs i) target) {
            return true
        }
        set i (+ i 1)
    }
    return false
}

shadow contains_str {
    let xs: array<string> = ["a", "b"]
    assert (contains_str xs "a")
    assert (contains_str xs "b")
    assert (not (contains_str xs "c"))
}

fn json_basic() -> int {
    return 0
}

fn json_stringify_many() -> int {
    return 0
}

fn main() -> int {
    return 0
}

shadow json_basic {
    let j: Json = (parse "{\"a\": 1, \"b\": \"hi\"}")
    assert (!= j 0)

    assert (object_has j "a")

    let a: Json = (get j "a")
    assert (!= a 0)
    assert (is_number a)
    assert (== (as_int a) 1)
    (free a)

    let b: Json = (get j "b")
    assert (!= b 0)
    assert (== (as_string b) "hi")
    (free b)

    let ks: array<string> = (keys j)
    assert (== (array_length ks) 2)
    assert (contains_str ks "a")
    assert (contains_str ks "b")

    let s: string = (stringify j)
    assert (> (str_length s) 0)

    (free j)

    # keys() must return owned/copied strings (safe after JSON is freed)
    assert (contains_str ks "a")
    assert (contains_str ks "b")
}

shadow get_int {
    let j: Json = (parse "{\"a\": 1}")
    assert (== (get_int j "a") 1)
    assert (== (get_int j "missing") 0)
    (free j)
}

shadow get_string {
    let j: Json = (parse "{\"b\": \"hi\"}")
    assert (== (get_string j "b") "hi")
    assert (== (get_string j "missing") "")
    (free j)
}

shadow json_stringify_many {
    let j: Json = (parse "{\"a\": 1, \"b\": [1, 2, 3], \"c\": {\"x\": true}}")
    let mut i: int = 0
    while (< i 2000) {
        let s: string = (stringify j)
        assert (> (str_length s) 0)
        set i (+ i 1)
    }
    (free j)
}

shadow main {
    assert (== (main) 0)
}
