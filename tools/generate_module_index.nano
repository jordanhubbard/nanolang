# Generate modules/index.json from all module.manifest.json files
# This creates a searchable index for LLM agent module discovery

from "modules/std/fs.nano" import walkdir, file_read, file_write, basename
from "modules/std/json/json.nano" import Json, parse, stringify, free, is_object, get, is_array, is_string, array_size, get_index, as_string, new_object, new_array, new_string, new_int, object_set, array_push

fn ends_with(str: string, suffix: string) -> bool {
    let str_len: int = (str_length str)
    let suffix_len: int = (str_length suffix)
    
    if (< str_len suffix_len) {
        return false
    }
    
    let mut i: int = 0
    while (< i suffix_len) {
        let str_idx: int = (- (- str_len suffix_len) (- 0 i))
        if (!= (char_at str str_idx) (char_at suffix i)) {
            return false
        }
        set i (+ i 1)
    }
    
    return true
}

shadow ends_with {
    assert (ends_with "hello.json" ".json")
    assert (not (ends_with "hello.txt" ".json"))
    assert (not (ends_with "json" ".json"))
}

fn find_manifests(modules_dir: string) -> array<string> {
    let all_files: array<string> = (walkdir modules_dir)
    let len: int = (array_length all_files)
    
    # Count matching files first
    let mut count: int = 0
    let mut i: int = 0
    while (< i len) {
        let path: string = (array_get all_files i)
        if (ends_with (basename path) "module.manifest.json") {
            set count (+ count 1)
        }
        set i (+ i 1)
    }
    
    # Create result array with exact size
    let mut result: array<string> = (array_new count "")
    let mut j: int = 0
    let mut k: int = 0
    
    while (< j len) {
        let path: string = (array_get all_files j)
        if (ends_with (basename path) "module.manifest.json") {
            (array_set result k path)
            set k (+ k 1)
        }
        set j (+ j 1)
    }
    
    return result
}

shadow find_manifests {
    let manifests: array<string> = (find_manifests "modules")
    assert (>= (array_length manifests) 0)
}

fn load_manifest(path: string) -> Json {
    let content: string = (file_read path)
    let json: Json = (parse content)
    return json
}

fn build_empty_indices() -> Json {
    # For now, just create empty indices
    # Python version will generate full reverse indices
    let capabilities_idx: Json = (new_object)
    let keywords_idx: Json = (new_object)
    let io_surfaces_idx: Json = (new_object)
    
    let indices: Json = (new_object)
    (object_set indices "capabilities" capabilities_idx)
    (object_set indices "keywords" keywords_idx)
    (object_set indices "io_surfaces" io_surfaces_idx)
    
    return indices
}

fn generate_index(modules_dir: string) -> Json {
    (println "Scanning for module manifests...")
    
    let manifest_paths: array<string> = (find_manifests modules_dir)
    let num_manifests: int = (array_length manifest_paths)
    
    let msg: string = (+ "Found " (+ (int_to_string num_manifests) " module manifests"))
    (println msg)
    
    # Load all manifests
    let modules_arr: Json = (new_array)
    let mut i: int = 0
    
    while (< i num_manifests) {
        let path: string = (array_get manifest_paths i)
        let manifest: Json = (load_manifest path)
        
        if (is_object manifest) {
            let name_field: Json = (get manifest "name")
            if (is_string name_field) {
                let name: string = (as_string name_field)
                let status_msg: string = (+ "  ✓ " name)
                (println status_msg)
                (array_push modules_arr manifest)
            }
        }
        
        set i (+ i 1)
    }
    
    # Build indices (simplified - Python version builds full reverse indices)
    (println "")
    (println "Building indices...")
    let indices: Json = (build_empty_indices)
    
    # Create final index
    let index: Json = (new_object)
    (object_set index "version" (new_string "1.0.0"))
    (object_set index "generated_at" (new_string "auto-generated by tools/generate_module_index.nano"))
    (object_set index "total_modules" (new_int (array_size modules_arr)))
    (object_set index "modules" modules_arr)
    (object_set index "indices" indices)
    
    return index
}

fn main() -> int {
    (println "NanoLang Module Index Generator")
    (println "================================")
    (println "")
    
    let modules_dir: string = "modules"
    let index: Json = (generate_index modules_dir)
    
    # Write to file
    let output_path: string = "modules/index.json"
    let json_str: string = (stringify index)
    
    let wrote: int = (file_write output_path json_str)
    
    if (== wrote 0) {
        (println "")
        let success_msg: string = (+ "✓ Generated " output_path)
        (println success_msg)
        (free index)
        return 0
    } else {
        (println "")
        (println "✗ Failed to write index")
        (free index)
        return 1
    }
}

shadow main {
    # Test would require filesystem access
    # In real usage, run: ./bin/generate_module_index
    assert true
}

