# Logical Operators
# This example demonstrates and, or, and not operators

fn and_op(a: bool, b: bool) -> bool {
    return (and a b)
}

shadow and_op {
    assert (== (and_op true true) true)
    assert (== (and_op true false) false)
    assert (== (and_op false true) false)
    assert (== (and_op false false) false)
}

fn or_op(a: bool, b: bool) -> bool {
    return (or a b)
}

shadow or_op {
    assert (== (or_op true true) true)
    assert (== (or_op true false) true)
    assert (== (or_op false true) true)
    assert (== (or_op false false) false)
}

fn not_op(a: bool) -> bool {
    return (not a)
}

shadow not_op {
    assert (== (not_op true) false)
    assert (== (not_op false) true)
}

fn complex_logic(a: bool, b: bool, c: bool) -> bool {
    return (or (and a b) c)
}

shadow complex_logic {
    assert (== (complex_logic true true false) true)
    assert (== (complex_logic false false true) true)
    assert (== (complex_logic false false false) false)
}

fn is_in_range(x: int, low: int, high: int) -> bool {
    return (and (>= x low) (<= x high))
}

shadow is_in_range {
    assert (== (is_in_range 5 1 10) true)
    assert (== (is_in_range 0 1 10) false)
    assert (== (is_in_range 15 1 10) false)
    assert (== (is_in_range 1 1 10) true)
    assert (== (is_in_range 10 1 10) true)
}

fn xor_sim(a: bool, b: bool) -> bool {
    return (and (or a b) (not (and a b)))
}

shadow xor_sim {
    assert (== (xor_sim true false) true)
    assert (== (xor_sim false true) true)
    assert (== (xor_sim true true) false)
    assert (== (xor_sim false false) false)
}

fn main() -> int {
    print (and_op true false)
    print (or_op true false)
    print (not_op true)
    print (complex_logic true true false)
    print (is_in_range 7 5 10)
    print (xor_sim true false)
    return 0
}

shadow main {
    assert (== (main) 0)
}