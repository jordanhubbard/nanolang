/*
 * Soft Body Hourglass Flood - Bullet Physics + SDL2
 * Inspired by large-scale particle/fluids showcases such as NVIDIA Omni Physics
 * particle documentation and Jason Huang's SPH fluid project.
 */

import "modules/sdl/sdl.nano"
import "modules/sdl_helpers/sdl_helpers.nano"
import "modules/bullet/bullet.nano"

/* Window */
let WINDOW_WIDTH: int = 1200
let WINDOW_HEIGHT: int = 900
let TARGET_FPS: int = 60
let FRAME_TIME: float = 0.016666

let CAMERA_SCALE: float = 15.0
let CAMERA_OFFSET_Y: float = 42.0

/* Particle parameters */
let MAX_PARTICLES: int = 240
let SPAWN_INTERVAL: float = 0.06
let SPAWN_BURST: int = 3
let PARTICLE_RADIUS: float = 1.1
let PARTICLE_RESOLUTION: int = 18
let PARTICLE_SPAWN_Y: float = 36.0

/* Colors */
let COLOR_BG_R: int = 5
let COLOR_BG_G: int = 8
let COLOR_BG_B: int = 12
let COLOR_PARTICLE_R: int = 180
let COLOR_PARTICLE_G: int = 220
let COLOR_PARTICLE_B: int = 255
let COLOR_OBSTACLE_R: int = 200
let COLOR_OBSTACLE_G: int = 120
let COLOR_OBSTACLE_B: int = 60

struct SoftParticle {
    handle: int,
    active: bool,
    crossed: bool
}

fn project_x(x: float) -> int {
    let screen_x: float = (+ (/ (cast_float WINDOW_WIDTH) 2.0) (* x CAMERA_SCALE))
    return (cast_int screen_x)
}

shadow project_x {
    assert (== (project_x 0.0) (/ WINDOW_WIDTH 2))
}

fn project_y(y: float) -> int {
    let adjusted_y: float = (- y CAMERA_OFFSET_Y)
    let screen_y: float = (+ (/ (cast_float WINDOW_HEIGHT) 2.0) (- (* adjusted_y CAMERA_SCALE)))
    return (cast_int screen_y)
}

shadow project_y {
    assert (< (project_y 10.0) (project_y (- 0.0 10.0)))
}

fn draw_filled_circle(renderer: SDL_Renderer, cx: int, cy: int, radius: int) -> void {
    let mut y: int = (- 0 radius)
    while (<= y radius) {
        let mut x: int = (- 0 radius)
        while (<= x radius) {
            let dist_sq: int = (+ (* x x) (* y y))
            let limit: int = (* radius radius)
            if (<= dist_sq limit) {
                unsafe { (SDL_RenderDrawPoint renderer (+ cx x) (+ cy y)) }
            }
            set x (+ x 1)
        }
        set y (+ y 1)
    }
    return
}

shadow draw_filled_circle {
    (draw_filled_circle 0 0 0 1)
    assert true
}

fn format_percent(value: float) -> string {
    let mut clamped: float = value
    if (< clamped 0.0) {
        set clamped 0.0
    }
    if (> clamped 1.0) {
        set clamped 1.0
    }
    let percent: int = (cast_int (* clamped 100.0))
    return (+ (int_to_string percent) "%")
}

shadow format_percent {
    assert (str_equals (format_percent 0.25) "25%")
}

fn main() -> int {
    (println "╔════════════════════════════════════════════════════════════╗")
    (println "║      BULLET SOFT BODY HOURGLASS (PARTICLE FLOOD)          ║")
    (println "╚════════════════════════════════════════════════════════════╝")
    (println "Streams of deformable spheres squeeze through an hourglass funnel")
    (println "SPACE toggles emitter, ESC exits")
    (println "")

    unsafe { (SDL_Init SDL_INIT_VIDEO) }
    let window: SDL_Window = (SDL_CreateWindow
        "Bullet Soft Body Hourglass"
        SDL_WINDOWPOS_CENTERED SDL_WINDOWPOS_CENTERED
        WINDOW_WIDTH WINDOW_HEIGHT
        SDL_WINDOW_SHOWN)
    let renderer: SDL_Renderer = (SDL_CreateRenderer window -1 SDL_RENDERER_ACCELERATED)

    let mut bullet_ok: int = 0
    unsafe { set bullet_ok (nl_bullet_init) }
    if (== bullet_ok 0) {
        (println "Failed to init Bullet")
        unsafe {
            (SDL_DestroyRenderer renderer)
            (SDL_DestroyWindow window)
            (SDL_Quit)
        }
        return 1
    }

    /* Static world */
    unsafe {
        (nl_bullet_create_rigid_box 0.0 (- 0.0 48.0) 0.0 80.0 2.0 60.0 0.0 0.4)
        (nl_bullet_create_rigid_box_rotated (- 0.0 14.0) 0.0 0.0 24.0 1.0 6.0 25.0 0.0 0.3)
        (nl_bullet_create_rigid_box_rotated 14.0 0.0 0.0 24.0 1.0 6.0 (- 25.0) 0.0 0.3)
        (nl_bullet_create_rigid_box_rotated (- 0.0 10.0) (- 0.0 18.0) 0.0 18.0 1.0 6.0 (- 25.0) 0.0 0.3)
        (nl_bullet_create_rigid_box_rotated 10.0 (- 0.0 18.0) 0.0 18.0 1.0 6.0 25.0 0.0 0.3)
        (nl_bullet_create_rigid_box 0.0 (- 0.0 30.0) 0.0 4.0 10.0 6.0 0.0 0.2)
    }

    let mut particles: array<SoftParticle> = []
    let mut active_count: int = 0
    let mut crossed_count: int = 0
    let mut spawn_timer: float = 0.0
    let mut emitter_enabled: bool = true

    let mut running: bool = true
    let mut frame_count: int = 0

    while running {
        let mut frame_start: int = 0
        unsafe { set frame_start (SDL_GetTicks) }

        if (== (nl_sdl_poll_event_quit) 1) {
            set running false
        }
        let key: int = (nl_sdl_poll_keypress)
        if (== key 41) {
            set running false
        }
        if (== key 44) {
            set emitter_enabled (not emitter_enabled)
            (println (cond ((== emitter_enabled true) "Emitter resumed") (else "Emitter paused")))
        }

        unsafe { (nl_bullet_step FRAME_TIME) }

        set spawn_timer (+ spawn_timer FRAME_TIME)
        if (and emitter_enabled (> spawn_timer SPAWN_INTERVAL)) {
            set spawn_timer 0.0
            let mut spawned: int = 0
            while (and (< spawned SPAWN_BURST) (< active_count MAX_PARTICLES)) {
                let lane_offset: float = (+ (- 0.0 4.0) (* (cast_float (% (+ frame_count spawned) 6)) 1.4))
                let spawn_x: float = (+ lane_offset (cond ((== (% spawned 2) 0) 1.2) (else (- 0.0 1.2))))
                let mut handle: int = 0
                unsafe {
                    set handle (nl_bullet_create_soft_sphere spawn_x PARTICLE_SPAWN_Y 0.0 PARTICLE_RADIUS PARTICLE_RESOLUTION)
                }
                if (!= handle (- 0 1)) {
                    let particle: SoftParticle = SoftParticle {
                        handle: handle,
                        active: true,
                        crossed: false
                    }
                    set particles (array_push particles particle)
                    set active_count (+ active_count 1)
                }
                set spawned (+ spawned 1)
            }
        }

        /* Update particle lifecycle */
        let mut index: int = 0
        while (< index (array_length particles)) {
            let particle: SoftParticle = (at particles index)
            if particle.active {
                let mut sample_y: float = 0.0
                unsafe {
                    set sample_y (nl_bullet_get_soft_body_node_y particle.handle 0)
                }
                if (and (< sample_y (- 0.0 5.0)) (not particle.crossed)) {
                    set crossed_count (+ crossed_count 1)
                    let updated: SoftParticle = SoftParticle {
                        handle: particle.handle,
                        active: true,
                        crossed: true
                    }
                    (array_set particles index updated)
                }
                if (< sample_y (- 0.0 45.0)) {
                    unsafe { (nl_bullet_remove_soft_body particle.handle) }
                    let updated2: SoftParticle = SoftParticle {
                        handle: particle.handle,
                        active: false,
                        crossed: true
                    }
                    (array_set particles index updated2)
                    set active_count (- active_count 1)
                }
            }
            set index (+ index 1)
        }

        if (== (% frame_count 180) 0) {
            let fill_ratio: float = (/ (cast_float active_count) (cast_float MAX_PARTICLES))
            let status: string = (+ "Particles active: "
                (+ (int_to_string active_count)
                    (+ "/"
                        (+ (int_to_string MAX_PARTICLES)
                            (+ " ("
                                (+ (format_percent fill_ratio)
                                    (+ ") | crossed total: " (int_to_string crossed_count))))))))
            (println status)
        }

        /* Rendering */
        unsafe {
            (SDL_SetRenderDrawColor renderer COLOR_BG_R COLOR_BG_G COLOR_BG_B 255)
            (SDL_RenderClear renderer)
        }

        unsafe {
            (SDL_SetRenderDrawColor renderer COLOR_OBSTACLE_R COLOR_OBSTACLE_G COLOR_OBSTACLE_B 255)
        }
        /* Simple funnel visualization */
        let funnel_top_y: int = (project_y 0.0)
        unsafe {
            (nl_sdl_render_fill_rect renderer 0 (+ funnel_top_y 120) WINDOW_WIDTH 10)
        }

        unsafe {
            (SDL_SetRenderDrawColor renderer COLOR_PARTICLE_R COLOR_PARTICLE_G COLOR_PARTICLE_B 255)
        }
        let mut draw_index: int = 0
        while (< draw_index (array_length particles)) {
            let particle: SoftParticle = (at particles draw_index)
            if particle.active {
                let mut node_count: int = 0
                unsafe { set node_count (nl_bullet_get_soft_body_node_count particle.handle) }
                let mut node_idx: int = 0
                while (< node_idx node_count) {
                    let mut node_x: float = 0.0
                    let mut node_y: float = 0.0
                    unsafe {
                        set node_x (nl_bullet_get_soft_body_node_x particle.handle node_idx)
                        set node_y (nl_bullet_get_soft_body_node_y particle.handle node_idx)
                    }
                    let sx: int = (project_x node_x)
                    let sy: int = (project_y node_y)
                    (draw_filled_circle renderer sx sy 2)
                    set node_idx (+ node_idx 1)
                }
            }
            set draw_index (+ draw_index 1)
        }

        unsafe { (SDL_RenderPresent renderer) }

        set frame_count (+ frame_count 1)

        let mut frame_end: int = 0
        unsafe { set frame_end (SDL_GetTicks) }
        let duration: int = (- frame_end frame_start)
        let frame_budget: int = (/ 1000 TARGET_FPS)
        if (< duration frame_budget) {
            unsafe { (SDL_Delay (- frame_budget duration)) }
        }
    }

    unsafe {
        (nl_bullet_cleanup)
        (SDL_DestroyRenderer renderer)
        (SDL_DestroyWindow window)
        (SDL_Quit)
    }

    (println "Hourglass demo finished")
    return 0
}

shadow main {
    assert true
}
