# NanoLang Regex Demo - Pythonic API
# Showcases one-shot operations (Tier 1) and compiled patterns (Tier 2)

from "std/regex/regex.nano" import regex_match, regex_find, regex_replace, regex_replace_all, regex_split, compile, matches, free

# =============================================================================
# TIER 1 DEMOS: Simple One-Shot API (90% of use cases)
# =============================================================================

fn demo_validation() -> void {
    (println "╔════════════════════════════════════════╗")
    (println "║  TIER 1: Simple Validation (No Handles!)  ║")
    (println "╚════════════════════════════════════════╝")
    (println "")
    
    # Email validation - one line, no memory management!
    if (regex_match "[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.[a-z]+" "user@example.com") {
        (println "✓ Valid email: user@example.com")
    }
    
    # Phone validation
    if (regex_match "^[0-9]{3}-[0-9]{3}-[0-9]{4}$" "555-123-4567") {
        (println "✓ Valid phone: 555-123-4567")
    }
    
    if (not (regex_match "^[0-9]{3}-[0-9]{3}-[0-9]{4}$" "invalid")) {
        (println "✗ Invalid phone: invalid")
    }
}

fn demo_replacement() -> void {
    (println "")
    (println "╔════════════════════════════════════════╗")
    (println "║  TIER 1: Text Replacement              ║")
    (println "╚════════════════════════════════════════╝")
    (println "")
    
    let text: string = "I have 3 apples and 5 oranges"
    (println (+ "Original:  " text))
    
    # Replace first number - one line!
    let r1: string = (regex_replace "[0-9]+" "X" text)
    (println (+ "First:     " r1))
    
    # Replace all numbers - still one line!
    let r2: string = (regex_replace_all "[0-9]+" "X" text)
    (println (+ "All:       " r2))
}

fn demo_split() -> void {
    (println "")
    (println "╔════════════════════════════════════════╗")
    (println "║  TIER 1: Split by Pattern              ║")
    (println "╚════════════════════════════════════════╝")
    (println "")
    
    let csv: string = "apple,banana;cherry,date;elderberry"
    let parts: array<string> = (regex_split "[,;]" csv)
    
    (println (+ "Input: " csv))
    (println (+ "Split into " (+ (int_to_string (array_length parts)) " parts:")))
    
    let mut i: int = 0
    while (< i (array_length parts)) {
        (println (+ "  [" (+ (int_to_string i) (+ "] " (array_get parts i)))))
        set i (+ i 1)
    }
}

fn demo_find() -> void {
    (println "")
    (println "╔════════════════════════════════════════╗")
    (println "║  TIER 1: Find Pattern Position         ║")
    (println "╚════════════════════════════════════════╝")
    (println "")
    
    let text: string = "The answer is 42 and the year is 2024"
    let pos: int = (regex_find "[0-9]+" text)
    
    (println (+ "Text: " text))
    if (>= pos 0) {
        (println (+ "First number at position: " (int_to_string pos)))
    }
}

# =============================================================================
# TIER 2 DEMOS: Compiled Patterns (Power Users - for performance)
# =============================================================================

fn demo_compiled_loop() -> void {
    (println "")
    (println "╔════════════════════════════════════════╗")
    (println "║  TIER 2: Compiled Pattern in Loop      ║")
    (println "╚════════════════════════════════════════╝")
    (println "")
    (println "Validating 5 emails with ONE compiled pattern...")
    (println "")
    
    # Compile once - efficient for loops
    let email_pattern: opaque = (compile "[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.[a-z]+")
    
    # Test valid email
    if (matches email_pattern "alice@example.com") {
        (println "  ✓ Valid:   alice@example.com")
    } else {
        (println "  ✗ Invalid: alice@example.com")
    }
    
    # Test another valid
    if (matches email_pattern "bob@test.org") {
        (println "  ✓ Valid:   bob@test.org")
    } else {
        (println "  ✗ Invalid: bob@test.org")
    }
    
    # Test invalid
    if (matches email_pattern "invalid.email") {
        (println "  ✓ Valid:   invalid.email")
    } else {
        (println "  ✗ Invalid: invalid.email")
    }
    
    # Test valid
    if (matches email_pattern "charlie@company.net") {
        (println "  ✓ Valid:   charlie@company.net")
    } else {
        (println "  ✗ Invalid: charlie@company.net")
    }
    
    # Test invalid
    if (matches email_pattern "not-an-email") {
        (println "  ✓ Valid:   not-an-email")
    } else {
        (println "  ✗ Invalid: not-an-email")
    }
    
    # Don't forget to free!
    (free email_pattern)
    (println "")
    (println "✓ Pattern freed - no memory leaks")
}

fn demo_comparison() -> void {
    (println "")
    (println "╔════════════════════════════════════════╗")
    (println "║  API Comparison                         ║")
    (println "╚════════════════════════════════════════╝")
    (println "")
    (println "TIER 1 (Simple): One line, automatic cleanup")
    (println "  if (regex_match pattern text) { ... }")
    (println "")
    (println "TIER 2 (Power): Compile once, use many times")
    (println "  let re: opaque = (compile pattern)")
    (println "  if (matches re text1) { ... }")
    (println "  if (matches re text2) { ... }")
    (println "  (free re)")
}

# =============================================================================
# MAIN
# =============================================================================

fn main() -> int {
    (println "")
    (println "═══════════════════════════════════════════════════")
    (println "    NanoLang Regex - Pythonic API Demo")
    (println "    No Manual Memory Management Required!")
    (println "═══════════════════════════════════════════════════")
    (println "")
    
    # Tier 1: Simple one-shot operations
    (demo_validation)
    (demo_replacement)
    (demo_split)
    (demo_find)
    
    # Tier 2: Power user API
    (demo_compiled_loop)
    
    # Comparison
    (demo_comparison)
    
    (println "")
    (println "═══════════════════════════════════════════════════")
    (println "✓ All demos completed successfully!")
    (println "═══════════════════════════════════════════════════")
    
    return 0
}
