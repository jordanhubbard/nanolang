# SNAKE - Classic Snake Game (Text-based)
# Tests: Dynamic arrays, collision detection, game logic
# MODERNIZED: Uses enums for directions, struct for positions

# === ENUMS ===
enum Direction {
    UP = 0,
    RIGHT = 1,
    DOWN = 2,
    LEFT = 3
}

# === STRUCTS ===
struct Position {
    x: int,
    y: int
}

# === CONSTANTS ===
let GRID_WIDTH: int = 30
let GRID_HEIGHT: int = 15
let INITIAL_LENGTH: int = 3
let MAX_MOVES: int = 50

# === GRID OPERATIONS ===

fn grid_index(x: int, y: int, width: int) -> int {
    return (+ (* y width) x)
}

shadow grid_index {
    assert (== (grid_index 0 0 10) 0)
    assert (== (grid_index 5 2 10) 25)
}

fn is_valid_pos(x: int, y: int, width: int, height: int) -> bool {
    if (< x 0) {
        return false
    } else {
        if (>= x width) {
            return false
        } else {
            if (< y 0) {
                return false
            } else {
                if (>= y height) {
                    return false
                } else {
                    return true
                }
            }
        }
    }
}

shadow is_valid_pos {
    assert (== (is_valid_pos 5 5 10 10) true)
    assert (== (is_valid_pos -1 5 10 10) false)
    assert (== (is_valid_pos 10 5 10 10) false)
}

fn move_in_direction(x: int, y: int, dir: int) -> int {
    if (== dir Direction.UP) {
        return (- y 1)
    } else {
        if (== dir Direction.DOWN) {
            return (+ y 1)
        } else {
            if (== dir Direction.LEFT) {
                return x
            } else {
                if (== dir Direction.RIGHT) {
                    return x
                } else {
                    return x
                }
            }
        }
    }
}

shadow move_in_direction {
    let y: int = (move_in_direction 5 5 Direction.UP)
    assert (== y 4)
}

fn print_grid(snake_x: array<int>, snake_y: array<int>, food_x: int, food_y: int, width: int, height: int) -> int {
    let snake_len: int = (array_length snake_x)
    
    let mut y: int = 0
    while (< y height) {
        let mut x: int = 0
        while (< x width) {
            # Check if this is food
            let mut is_food: bool = false
            if (== x food_x) {
                if (== y food_y) {
                    set is_food true
                } else {
                    (print "")
                }
            } else {
                (print "")
            }
            
            if is_food {
                (print "â—‰")
            } else {
                # Check if this is snake
                let mut is_snake: bool = false
                let mut i: int = 0
                while (< i snake_len) {
                    if (== x (at snake_x i)) {
                        if (== y (at snake_y i)) {
                            set is_snake true
                        } else {
                            (print "")
                        }
                    } else {
                        (print "")
                    }
                    set i (+ i 1)
                }
                
                if is_snake {
                    (print "â–ˆ")
                } else {
                    (print "Â·")
                }
            }
            
            set x (+ x 1)
        }
        (println "")
        set y (+ y 1)
    }
    return 0
}

shadow print_grid {
    let sx: array<int> = [5, 4, 3]
    let sy: array<int> = [5, 5, 5]
    assert (== (print_grid sx sy 10 5 15 10) 0)
}

# === COLLISION DETECTION ===

fn check_self_collision(snake_x: array<int>, snake_y: array<int>) -> bool {
    let len: int = (array_length snake_x)
    if (< len 2) {
        return false
    } else {
        let head_x: int = (at snake_x 0)
        let head_y: int = (at snake_y 0)
        
        let mut i: int = 1
        while (< i len) {
            if (== head_x (at snake_x i)) {
                if (== head_y (at snake_y i)) {
                    return true
                } else {
                    (print "")
                }
            } else {
                (print "")
            }
            set i (+ i 1)
        }
        return false
    }
}

shadow check_self_collision {
    let sx1: array<int> = [5, 4, 3]
    let sy1: array<int> = [5, 5, 5]
    assert (== (check_self_collision sx1 sy1) false)
    
    let sx2: array<int> = [5, 4, 3, 5]
    let sy2: array<int> = [5, 5, 5, 5]
    assert (== (check_self_collision sx2 sy2) true)
}

# === MAIN ===

fn main() -> int {
    (println "")
    (println "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    (println "â•‘         SNAKE GAME                    â•‘")
    (println "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    (println "")
    
    # Initialize snake in center, moving right
    let start_x: int = (/ GRID_WIDTH 2)
    let start_y: int = (/ GRID_HEIGHT 2)
    
    let mut snake_x: array<int> = []
    let mut snake_y: array<int> = []
    
    let mut i: int = 0
    while (< i INITIAL_LENGTH) {
        set snake_x (array_push snake_x (- start_x i))
        set snake_y (array_push snake_y start_y)
        set i (+ i 1)
    }
    
    (print "âœ“ Snake initialized at (")
    (print start_x)
    (print ", ")
    (print start_y)
    (println ")")
    
    # Place food
    let mut food_x: int = 20
    let mut food_y: int = 7
    
    (print "âœ“ Food placed at (")
    (print food_x)
    (print ", ")
    (print food_y)
    (println ")")
    (println "")
    
    # Initial direction
    let mut direction: int = Direction.RIGHT
    let mut score: int = 0
    let mut moves: int = 0
    let mut game_over: bool = false
    
    (println "Starting game...")
    (println "")
    (print_grid snake_x snake_y food_x food_y GRID_WIDTH GRID_HEIGHT)
    (println "")
    
    # Game loop - auto-play with simple AI
    while (and (not game_over) (< moves MAX_MOVES)) {
        # Simple AI: move towards food
        let head_x: int = (at snake_x 0)
        let head_y: int = (at snake_y 0)
        
        # Decide direction based on food position
        if (< head_x food_x) {
            set direction Direction.RIGHT
        } else {
            if (> head_x food_x) {
                set direction Direction.LEFT
            } else {
                if (< head_y food_y) {
                    set direction Direction.DOWN
                } else {
                    if (> head_y food_y) {
                        set direction Direction.UP
                    } else {
                        (print "")
                    }
                }
            }
        }
        
        # Calculate new head position
        let mut new_head_x: int = head_x
        let mut new_head_y: int = head_y
        
        if (== direction Direction.UP) {
            set new_head_y (- head_y 1)
        } else {
            if (== direction Direction.DOWN) {
                set new_head_y (+ head_y 1)
            } else {
                if (== direction Direction.LEFT) {
                    set new_head_x (- head_x 1)
                } else {
                    if (== direction Direction.RIGHT) {
                        set new_head_x (+ head_x 1)
                    } else {
                        (print "")
                    }
                }
            }
        }
        
        # Check wall collision
        if (not (is_valid_pos new_head_x new_head_y GRID_WIDTH GRID_HEIGHT)) {
            (println "ğŸ’¥ Hit wall! Game Over!")
            set game_over true
        } else {
            # Move snake (add new head)
            let mut new_snake_x: array<int> = []
            let mut new_snake_y: array<int> = []
            
            set new_snake_x (array_push new_snake_x new_head_x)
            set new_snake_y (array_push new_snake_y new_head_y)
            
            # Check if food eaten
            let mut ate_food: bool = false
            if (== new_head_x food_x) {
                if (== new_head_y food_y) {
                    set ate_food true
                    set score (+ score 1)
                    # Move food (simple: add offset)
                    set food_x (+ food_x 5)
                    set food_y (+ food_y 3)
                    # Wrap food position
                    if (>= food_x GRID_WIDTH) {
                        set food_x (- food_x GRID_WIDTH)
                    } else {
                        (print "")
                    }
                    if (>= food_y GRID_HEIGHT) {
                        set food_y (- food_y GRID_HEIGHT)
                    } else {
                        (print "")
                    }
                } else {
                    (print "")
                }
            } else {
                (print "")
            }
            
            # Copy rest of body
            let body_len: int = (array_length snake_x)
            let copy_len: int = body_len
            if (not ate_food) {
                set copy_len (- body_len 1)  # Remove tail
            } else {
                (print "")
            }
            
            set i 0
            while (< i copy_len) {
                set new_snake_x (array_push new_snake_x (at snake_x i))
                set new_snake_y (array_push new_snake_y (at snake_y i))
                set i (+ i 1)
            }
            
            set snake_x new_snake_x
            set snake_y new_snake_y
            
            # Check self collision
            if (check_self_collision snake_x snake_y) {
                (println "ğŸ Ate self! Game Over!")
                set game_over true
            } else {
                # Print every 10 moves
                if (== (% moves 10) 0) {
                    (print "Move ")
                    (print moves)
                    (print " - Score: ")
                    (println score)
                    (print_grid snake_x snake_y food_x food_y GRID_WIDTH GRID_HEIGHT)
                    (println "")
                } else {
                    (print "")
                }
            }
        }
        
        set moves (+ moves 1)
    }
    
    (println "")
    (println "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    (println "â•‘        GAME COMPLETE âœ“                â•‘")
    (println "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    (println "")
    (print "Final Score: ")
    (println score)
    (print "Total Moves: ")
    (println moves)
    (print "Snake Length: ")
    (println (array_length snake_x))
    (println "")
    (println "âœ… FEATURES DEMONSTRATED:")
    (println "  â€¢ Dynamic snake growth")
    (println "  â€¢ Collision detection (walls & self)")
    (println "  â€¢ Simple AI pathfinding")
    (println "  â€¢ Dynamic array manipulation")
    (println "  â€¢ Score tracking")
    (println "  â€¢ Game state management")
    (println "")
    (println "ğŸ Snake slithered successfully!")
    
    return 0
}

shadow main {
    assert (== (main) 0)
}

