// All Types
// This example demonstrates all data types in nanolang

fn return_int() -> int {
    return 42
}

shadow return_int {
    assert (== (return_int) 42)
}

fn return_float() -> float {
    return 3.14159
}

shadow return_float {
    assert (== (return_float) 3.14159)
}

fn return_bool() -> bool {
    return true
}

shadow return_bool {
    assert (== (return_bool) true)
}

fn return_string() -> string {
    return "Hello, nanolang!"
}

shadow return_string {
    assert (== (return_string) "Hello, nanolang!")
}

fn void_function() -> void {
    print "This function returns void"
}

shadow void_function {
    (void_function)
}

fn process_int(n: int) -> int {
    return (* n 2)
}

shadow process_int {
    assert (== (process_int 10) 20)
    assert (== (process_int 0) 0)
    assert (== (process_int (- 0 5)) (- 0 10))
}

fn process_float(f: float) -> float {
    return (/ f 2.0)
}

shadow process_float {
    assert (== (process_float 10.0) 5.0)
    assert (== (process_float 7.5) 3.75)
}

fn process_bool(b: bool) -> bool {
    return (not b)
}

shadow process_bool {
    assert (== (process_bool true) false)
    assert (== (process_bool false) true)
}

fn process_string(s: string) -> string {
    return s
}

shadow process_string {
    assert (== (process_string "test") "test")
    assert (== (process_string "") "")
}

fn mixed_types(i: int, f: float, b: bool, s: string) -> int {
    if b {
        return i
    } else {
        return 0
    }
}

shadow mixed_types {
    assert (== (mixed_types 10 3.14 true "hello") 10)
    assert (== (mixed_types 10 3.14 false "hello") 0)
}

fn main() -> int {
    let my_int: int = 100
    let my_float: float = 2.718
    let my_bool: bool = true
    let my_string: string = "nanolang"

    print my_int
    print my_float
    print my_bool
    print my_string

    print (process_int 25)
    print (process_float 50.0)
    print (process_bool false)
    print (process_string "types")

    (void_function)

    return 0
}

shadow main {
    assert (== (main) 0)
}