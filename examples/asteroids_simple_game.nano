# Simplified Asteroids Game - Dynamic Array Demo
# This demonstrates dynamic entity management without pointers!

# Note: Running in interpreter mode - full SDL rendering would require transpiler support

fn main() -> int {
    (println "=== Asteroids - Dynamic Array Demo ===")
    (println "")
    
    # Initialize game entities using dynamic arrays
    let mut asteroids: array<int> = []  # Will store asteroid positions
    let mut bullets: array<int> = []     # Will store bullet positions
    
    # Spawn initial asteroids
    (println "Spawning 3 asteroids...")
    set asteroids (array_push asteroids 100)
    set asteroids (array_push asteroids 200)
    set asteroids (array_push asteroids 300)
    
    (print "Active asteroids: ")
    (println (array_length asteroids))
    (print "Asteroid positions: ")
    (println asteroids)
    (println "")
    
    # Player fires bullets
    (println "Player fires 2 bullets...")
    set bullets (array_push bullets 50)
    set bullets (array_push bullets 150)
    
    (print "Active bullets: ")
    (println (array_length bullets))
    (print "Bullet positions: ")
    (println bullets)
    (println "")
    
    # Collision detection - bullet hits asteroid at 200
    (println "Collision detected! Asteroid at 200 destroyed.")
    set asteroids (array_remove_at asteroids 1)  # Remove asteroid at index 1 (200)
    set bullets (array_remove_at bullets 1)      # Remove bullet at index 1 (150)
    
    (print "Asteroids remaining: ")
    (println (array_length asteroids))
    (print "Asteroid positions: ")
    (println asteroids)
    (println "")
    
    # Spawn more asteroids dynamically
    (println "Spawning 2 more asteroids...")
    set asteroids (array_push asteroids 400)
    set asteroids (array_push asteroids 500)
    
    (print "Active asteroids: ")
    (println (array_length asteroids))
    (print "Asteroid positions: ")
    (println asteroids)
    (println "")
    
    # Simulate game loop - remove all bullets
    (println "Bullets despawn after timeout...")
    let bullet_count: int = (array_length bullets)
    let mut i: int = 0
    while (< i bullet_count) {
        let bullet_pos: int = (array_pop bullets)
        (print "Bullet at ")
        (print bullet_pos)
        (println " despawned")
        set i (+ i 1)
    }
    
    (print "Active bullets: ")
    (println (array_length bullets))
    (println "")
    
    # Final status
    (println "=== Game State ===")
    (print "Asteroids: ")
    (println (array_length asteroids))
    (print "Bullets: ")
    (println (array_length bullets))
    (println "")
    (println "✓ Dynamic entity management working!")
    (println "✓ No memory leaks (GC handles everything)")
    (println "✓ No manual pointer management needed!")
    
    return 0
}

shadow main {
    assert (== (main) 0)
}

