# Tuple Coordinates Example
# Demonstrates practical use of tuples for 2D/3D coordinates and transformations

# === 2D COORDINATES ===

fn make_point_2d(x: int, y: int) -> (int, int) {
    return (x, y)
}

shadow make_point_2d {
    let p: (int, int) = (make_point_2d 10 20)
    assert (== p.0 10)
    assert (== p.1 20)
}

fn distance_2d(p1: (int, int), p2: (int, int)) -> float {
    let dx: int = (- p2.0 p1.0)
    let dy: int = (- p2.1 p1.1)
    let dx_f: float = (cast_float dx)
    let dy_f: float = (cast_float dy)
    let dist_sq: float = (+ (* dx_f dx_f) (* dy_f dy_f))
    return (sqrt dist_sq)
}

shadow distance_2d {
    let p1: (int, int) = (make_point_2d 0 0)
    let p2: (int, int) = (make_point_2d 3 4)
    let dist: float = (distance_2d p1 p2)
    assert (== dist 5.0)
}

fn translate_2d(p: (int, int), dx: int, dy: int) -> (int, int) {
    let x: int = p.0
    let y: int = p.1
    return ((+ x dx), (+ y dy))
}

shadow translate_2d {
    let p: (int, int) = (make_point_2d 10 20)
    let translated: (int, int) = (translate_2d p 5 -3)
    assert (== translated.0 15)
    assert (== translated.1 17)
}

# === 3D COORDINATES ===

fn make_point_3d(x: int, y: int, z: int) -> (int, int, int) {
    return (x, y, z)
}

shadow make_point_3d {
    let p: (int, int, int) = (make_point_3d 1 2 3)
    assert (== p.0 1)
    assert (== p.1 2)
    assert (== p.2 3)
}

fn translate_3d(p: (int, int, int), dx: int, dy: int, dz: int) -> (int, int, int) {
    let x: int = p.0
    let y: int = p.1
    let z: int = p.2
    return ((+ x dx), (+ y dy), (+ z dz))
}

shadow translate_3d {
    let p: (int, int, int) = (make_point_3d 10 20 30)
    let translated: (int, int, int) = (translate_3d p 1 2 3)
    assert (== translated.0 11)
    assert (== translated.1 22)
    assert (== translated.2 33)
}

# === BOUNDS CHECKING ===

fn in_bounds(p: (int, int), width: int, height: int) -> bool {
    let x: int = p.0
    let y: int = p.1
    return (and 
        (and (>= x 0) (< x width))
        (and (>= y 0) (< y height)))
}

shadow in_bounds {
    let inside: (int, int) = (make_point_2d 50 50)
    let outside: (int, int) = (make_point_2d 150 50)
    assert (== (in_bounds inside 100 100) true)
    assert (== (in_bounds outside 100 100) false)
}

# === POLAR COORDINATES ===

fn make_polar(r: float, theta: float) -> (float, float) {
    return (r, theta)
}

shadow make_polar {
    let polar: (float, float) = (make_polar 10.0 3.14)
    assert (== polar.0 10.0)
    assert (== polar.1 3.14)
}

fn polar_to_cartesian(polar: (float, float)) -> (float, float) {
    let r: float = polar.0
    let theta: float = polar.1
    let x: float = (* r (cos theta))
    let y: float = (* r (sin theta))
    return (x, y)
}

shadow polar_to_cartesian {
    let polar: (float, float) = (make_polar 1.0 0.0)
    let cart: (float, float) = (polar_to_cartesian polar)
    # cos(0) = 1, sin(0) = 0
    let x: float = cart.0
    let y: float = cart.1
    # Check approximately equal (floating point)
    assert (< (abs (- x 1.0)) 0.001)
    assert (< (abs y) 0.001)
}

# === BOUNDING BOX ===

fn make_bbox(x: int, y: int, width: int, height: int) -> (int, int, int, int) {
    return (x, y, width, height)
}

shadow make_bbox {
    let bbox: (int, int, int, int) = (make_bbox 10 20 100 50)
    assert (== bbox.0 10)
    assert (== bbox.1 20)
    assert (== bbox.2 100)
    assert (== bbox.3 50)
}

fn bbox_contains(bbox: (int, int, int, int), p: (int, int)) -> bool {
    let x: int = bbox.0
    let y: int = bbox.1
    let width: int = bbox.2
    let height: int = bbox.3
    let px: int = p.0
    let py: int = p.1
    return (and
        (and (>= px x) (< px (+ x width)))
        (and (>= py y) (< py (+ y height))))
}

shadow bbox_contains {
    let bbox: (int, int, int, int) = (make_bbox 10 10 100 100)
    let inside: (int, int) = (make_point_2d 50 50)
    let outside: (int, int) = (make_point_2d 150 50)
    assert (== (bbox_contains bbox inside) true)
    assert (== (bbox_contains bbox outside) false)
}

# === COLOR REPRESENTATION ===

fn make_rgb(r: int, g: int, b: int) -> (int, int, int) {
    return (r, g, b)
}

shadow make_rgb {
    let red: (int, int, int) = (make_rgb 255 0 0)
    assert (== red.0 255)
    assert (== red.1 0)
    assert (== red.2 0)
}

fn make_rgba(r: int, g: int, b: int, a: int) -> (int, int, int, int) {
    return (r, g, b, a)
}

shadow make_rgba {
    let transparent_red: (int, int, int, int) = (make_rgba 255 0 0 128)
    assert (== transparent_red.3 128)
}

# === VELOCITY VECTOR ===

fn make_velocity(vx: float, vy: float) -> (float, float) {
    return (vx, vy)
}

shadow make_velocity {
    let v: (float, float) = (make_velocity 5.0 -3.0)
    assert (== v.0 5.0)
    assert (== v.1 -3.0)
}

fn apply_velocity(pos: (float, float), vel: (float, float), dt: float) -> (float, float) {
    let x: float = pos.0
    let y: float = pos.1
    let vx: float = vel.0
    let vy: float = vel.1
    let new_x: float = (+ x (* vx dt))
    let new_y: float = (+ y (* vy dt))
    return (new_x, new_y)
}

shadow apply_velocity {
    let pos: (float, float) = (0.0, 0.0)
    let vel: (float, float) = (make_velocity 10.0 5.0)
    let new_pos: (float, float) = (apply_velocity pos vel 1.0)
    assert (== new_pos.0 10.0)
    assert (== new_pos.1 5.0)
}

# === RANGE REPRESENTATION ===

fn make_range(start: int, end: int) -> (int, int) {
    return (start, end)
}

shadow make_range {
    let r: (int, int) = (make_range 10 20)
    assert (== r.0 10)
    assert (== r.1 20)
}

fn in_range(value: int, range: (int, int)) -> bool {
    let start: int = range.0
    let end: int = range.1
    return (and (>= value start) (<= value end))
}

shadow in_range {
    let r: (int, int) = (make_range 10 20)
    assert (== (in_range 15 r) true)
    assert (== (in_range 5 r) false)
    assert (== (in_range 25 r) false)
}

# === DEMONSTRATION MAIN ===

fn main() -> void {
    (println "=== Tuple Coordinates Demo ===")
    (println "")
    
    # 2D Point
    (println "2D Coordinates:")
    let p1: (int, int) = (make_point_2d 10 20)
    (print "  Point: (")
    (print (int_to_string p1.0))
    (print ", ")
    (print (int_to_string p1.1))
    (println ")")
    
    let p2: (int, int) = (make_point_2d 13 24)
    (print "  Distance to (13, 24): ")
    (print (int_to_string (cast_int (distance_2d p1 p2)))
    (println "")
    
    # Translation
    (println "")
    (println "Translation:")
    let translated: (int, int) = (translate_2d p1 5 -3)
    (print "  After translate(5, -3): (")
    (print (int_to_string translated.0))
    (print ", ")
    (print (int_to_string translated.1))
    (println ")")
    
    # 3D Point
    (println "")
    (println "3D Coordinates:")
    let p3d: (int, int, int) = (make_point_3d 1 2 3)
    (print "  Point: (")
    (print (int_to_string p3d.0))
    (print ", ")
    (print (int_to_string p3d.1))
    (print ", ")
    (print (int_to_string p3d.2))
    (println ")")
    
    # Bounding Box
    (println "")
    (println "Bounding Box:")
    let bbox: (int, int, int, int) = (make_bbox 0 0 100 100)
    let test_point: (int, int) = (make_point_2d 50 50)
    (print "  Point (50, 50) in bbox? ")
    if (bbox_contains bbox test_point) {
        (println "Yes")
    } else {
        (println "No")
    }
    
    # Colors
    (println "")
    (println "Colors:")
    let color: (int, int, int) = (make_rgb 255 128 0)
    (print "  RGB: (")
    (print (int_to_string color.0))
    (print ", ")
    (print (int_to_string color.1))
    (print ", ")
    (print (int_to_string color.2))
    (println ")")
    
    # Velocity
    (println "")
    (println "Physics:")
    let pos: (float, float) = (0.0, 0.0)
    let vel: (float, float) = (make_velocity 10.0 5.0)
    let new_pos: (float, float) = (apply_velocity pos vel 2.0)
    (print "  After 2 seconds at v=(10, 5): (")
    (print (int_to_string (cast_int new_pos.0))
    (print ", ")
    (print (int_to_string (cast_int new_pos.1))
    (println ")")
    
    (println "")
    (println "All tests passed! âœ“")
    return 0
}

shadow main {
    assert true
}
