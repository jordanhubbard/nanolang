# Real-Time Whitted-Style Ray Tracer
# Classic recursive raytracer with reflections and shadows
# Demonstrates NanoLang's dynamic array capabilities
#
# Controls:
#   Arrow keys: Rotate camera
#   R: Reset camera
#   ESC: Quit

import "modules/sdl/sdl.nano"
import "modules/sdl_helpers/sdl_helpers.nano"
import "modules/sdl_ttf/sdl_ttf.nano"
import "modules/sdl_ttf/sdl_ttf_helpers.nano"

from "std/math/extended.nano" import sqrt, sin, cos, tan, deg_to_rad, clamp, max

let WINDOW_WIDTH: int = 800
let WINDOW_HEIGHT: int = 600
let RENDER_SCALE: int = 2  # Render at half resolution for balance
let RENDER_W: int = (/ WINDOW_WIDTH RENDER_SCALE)
let RENDER_H: int = (/ WINDOW_HEIGHT RENDER_SCALE)

let MAX_DEPTH: int = 4  # More bounces for better reflections

# === Simple 3D Vector Operations ===
struct Vec3 {
    x: float,
    y: float,
    z: float
}

fn vec_add(a: Vec3, b: Vec3) -> Vec3 {
    return Vec3 { x: (+ a.x b.x), y: (+ a.y b.y), z: (+ a.z b.z) }
}

shadow vec_add { assert true }

fn vec_sub(a: Vec3, b: Vec3) -> Vec3 {
    return Vec3 { x: (- a.x b.x), y: (- a.y b.y), z: (- a.z b.z) }
}

shadow vec_sub { assert true }

fn vec_scale(v: Vec3, s: float) -> Vec3 {
    return Vec3 { x: (* v.x s), y: (* v.y s), z: (* v.z s) }
}

shadow vec_scale { assert true }

fn vec_dot(a: Vec3, b: Vec3) -> float {
    return (+ (+ (* a.x b.x) (* a.y b.y)) (* a.z b.z))
}

shadow vec_dot { assert true }

fn vec_length(v: Vec3) -> float {
    return (sqrt (vec_dot v v))
}

shadow vec_length { assert true }

fn vec_normalize(v: Vec3) -> Vec3 {
    let len: float = (vec_length v)
    if (< len 0.0001) {
        return Vec3 { x: 0.0, y: 1.0, z: 0.0 }
    }
    return (vec_scale v (/ 1.0 len))
}

shadow vec_normalize { assert true }

fn vec_reflect(v: Vec3, n: Vec3) -> Vec3 {
    let dot2: float = (* 2.0 (vec_dot v n))
    return (vec_sub v (vec_scale n dot2))
}

shadow vec_reflect { assert true }

fn light_from_mouse(encoded: int, current_z: float) -> Vec3 {
    let mouse_x: int = (/ encoded 10000)
    let mouse_y: int = (% encoded 10000)
    let lx: float = (- (/ (cast_float mouse_x) 100.0) 4.0)
    let ly: float = (- 6.0 (/ (cast_float mouse_y) 100.0))
    return Vec3 { x: lx, y: ly, z: current_z }
}

shadow light_from_mouse {
    let encoded: int = (+ (* 200 10000) 100)
    let pos: Vec3 = (light_from_mouse encoded 0.0)
    assert (== pos.x -2.0)
    assert (> pos.y -7.1)
}

# === Ray ===
struct Ray {
    origin: Vec3,
    direction: Vec3
}

# === Sphere ===
struct Sphere {
    center: Vec3,
    radius: float,
    r: float,
    g: float,
    b: float,
    reflectivity: float
}

# === Hit ===
struct Hit {
    hit: int,
    t: float,
    point: Vec3,
    normal: Vec3,
    r: float,
    g: float,
    b: float,
    refl: float
}

# === Scene Creation (Demonstrates NanoLang Array Idioms) ===
fn create_scene() -> array<Sphere> {
    # Create empty array and build incrementally
    let mut spheres: array<Sphere> = []
    
    # Ground plane (large sphere below)
    set spheres (array_push spheres Sphere {
        center: Vec3 { x: 0.0, y: -1000.5, z: 0.0 },
        radius: 1000.0,
        r: 0.5, g: 0.5, b: 0.5,
        reflectivity: 0.0
    })
    
    # Center sphere (gold, highly reflective)
    set spheres (array_push spheres Sphere {
        center: Vec3 { x: 0.0, y: 0.0, z: -3.5 },
        radius: 0.5,
        r: 0.9, g: 0.8, b: 0.3,
        reflectivity: 0.9
    })
    
    # Left sphere (red metal)
    set spheres (array_push spheres Sphere {
        center: Vec3 { x: -1.2, y: 0.0, z: -3.0 },
        radius: 0.5,
        r: 0.95, g: 0.2, b: 0.15,
        reflectivity: 0.3
    })
    
    # Right sphere (blue glass-like)
    set spheres (array_push spheres Sphere {
        center: Vec3 { x: 1.2, y: 0.0, z: -3.0 },
        radius: 0.5,
        r: 0.15, g: 0.4, b: 0.95,
        reflectivity: 0.85
    })
    
    # Back large sphere (chrome mirror)
    set spheres (array_push spheres Sphere {
        center: Vec3 { x: 0.0, y: 0.7, z: -5.5 },
        radius: 1.2,
        r: 0.95, g: 0.95, b: 0.95,
        reflectivity: 0.98
    })
    
    # Small front sphere (green metallic)
    set spheres (array_push spheres Sphere {
        center: Vec3 { x: -0.5, y: -0.25, z: -1.5 },
        radius: 0.25,
        r: 0.2, g: 0.95, b: 0.3,
        reflectivity: 0.7
    })
    
    # Small right sphere (purple)
    set spheres (array_push spheres Sphere {
        center: Vec3 { x: 0.8, y: -0.3, z: -2.0 },
        radius: 0.2,
        r: 0.8, g: 0.2, b: 0.9,
        reflectivity: 0.4
    })
    
    return spheres
}

shadow create_scene { assert true }

# === Ray-Sphere Intersection ===
fn intersect_sphere(ray: Ray, sphere: Sphere) -> Hit {
    let oc: Vec3 = (vec_sub ray.origin sphere.center)
    let a: float = (vec_dot ray.direction ray.direction)
    let b: float = (* 2.0 (vec_dot oc ray.direction))
    let c: float = (- (vec_dot oc oc) (* sphere.radius sphere.radius))
    let disc: float = (- (* b b) (* 4.0 (* a c)))
    
    if (< disc 0.0) {
        return Hit {
            hit: 0, t: 0.0,
            point: Vec3 { x: 0.0, y: 0.0, z: 0.0 },
            normal: Vec3 { x: 0.0, y: 0.0, z: 0.0 },
            r: 0.0, g: 0.0, b: 0.0, refl: 0.0
        }
    }
    
    let t: float = (/ (- (- 0.0 b) (sqrt disc)) (* 2.0 a))
    
    if (< t 0.001) {
        return Hit {
            hit: 0, t: 0.0,
            point: Vec3 { x: 0.0, y: 0.0, z: 0.0 },
            normal: Vec3 { x: 0.0, y: 0.0, z: 0.0 },
            r: 0.0, g: 0.0, b: 0.0, refl: 0.0
        }
    }
    
    let point: Vec3 = (vec_add ray.origin (vec_scale ray.direction t))
    let normal: Vec3 = (vec_normalize (vec_sub point sphere.center))
    
    return Hit {
        hit: 1, t: t,
        point: point,
        normal: normal,
        r: sphere.r, g: sphere.g, b: sphere.b,
        refl: sphere.reflectivity
    }
}

shadow intersect_sphere { assert true }

# === Scene Intersection (Demonstrates Array Iteration) ===
fn intersect_scene(ray: Ray, spheres: array<Sphere>) -> Hit {
    let mut closest: Hit = Hit {
        hit: 0, t: 999999.0,
        point: Vec3 { x: 0.0, y: 0.0, z: 0.0 },
        normal: Vec3 { x: 0.0, y: 0.0, z: 0.0 },
        r: 0.0, g: 0.0, b: 0.0, refl: 0.0
    }
    
    # Iterate through all spheres using array_length and at
    let count: int = (array_length spheres)
    let mut i: int = 0
    while (< i count) {
        let sphere: Sphere = (at spheres i)
        let hit: Hit = (intersect_sphere ray sphere)
        
        if (== hit.hit 1) {
            if (< hit.t closest.t) {
                set closest hit
            }
        }
        
        set i (+ i 1)
    }
    
    return closest
}

shadow intersect_scene { assert true }

# === Shadow Test ===
fn in_shadow(point: Vec3, light_pos: Vec3, spheres: array<Sphere>) -> int {
    let to_light: Vec3 = (vec_sub light_pos point)
    let dist: float = (vec_length to_light)
    let dir: Vec3 = (vec_normalize to_light)
    
    let shadow_ray: Ray = Ray {
        origin: (vec_add point (vec_scale dir 0.001)),
        direction: dir
    }
    
    let hit: Hit = (intersect_scene shadow_ray spheres)
    
    if (== hit.hit 1) {
        if (< hit.t dist) {
            return 1
        }
    }
    
    return 0
}

shadow in_shadow { assert true }

# === Trace Ray ===
fn trace(ray: Ray, spheres: array<Sphere>, light_pos: Vec3, depth: int) -> Vec3 {
    if (>= depth MAX_DEPTH) {
        return Vec3 { x: 0.1, y: 0.1, z: 0.15 }
    }
    
    let hit: Hit = (intersect_scene ray spheres)
    
    if (== hit.hit 0) {
        # Sky gradient
        let t: float = (* 0.5 (+ 1.0 ray.direction.y))
        return Vec3 {
            x: (+ (* (- 1.0 t) 0.5) (* t 0.1)),
            y: (+ (* (- 1.0 t) 0.7) (* t 0.1)),
            z: (+ (* (- 1.0 t) 1.0) (* t 0.2))
        }
    }
    
    let to_light: Vec3 = (vec_normalize (vec_sub light_pos hit.point))
    let mut diffuse: float = (max 0.0 (vec_dot hit.normal to_light))
    
    let shadowed: int = (in_shadow hit.point light_pos spheres)
    if (== shadowed 1) {
        set diffuse (* diffuse 0.2)
    }
    
    let mut lit_r: float = (* hit.r (+ 0.2 (* 0.8 diffuse)))
    let mut lit_g: float = (* hit.g (+ 0.2 (* 0.8 diffuse)))
    let mut lit_b: float = (* hit.b (+ 0.2 (* 0.8 diffuse)))
    
    if (> hit.refl 0.01) {
        let refl_dir: Vec3 = (vec_reflect ray.direction hit.normal)
        let refl_ray: Ray = Ray {
            origin: (vec_add hit.point (vec_scale hit.normal 0.001)),
            direction: refl_dir
        }
        let refl_color: Vec3 = (trace refl_ray spheres light_pos (+ depth 1))
        
        set lit_r (+ (* lit_r (- 1.0 hit.refl)) (* refl_color.x hit.refl))
        set lit_g (+ (* lit_g (- 1.0 hit.refl)) (* refl_color.y hit.refl))
        set lit_b (+ (* lit_b (- 1.0 hit.refl)) (* refl_color.z hit.refl))
    }
    
    return Vec3 { x: lit_r, y: lit_g, z: lit_b }
}

shadow trace { assert true }

# === Camera Ray ===
fn get_ray(x: int, y: int, yaw: float, pitch: float, cam_pos: Vec3) -> Ray {
    let ndc_x: float = (/ (- (* (cast_float x) 2.0) (cast_float RENDER_W)) (cast_float RENDER_W))
    let ndc_y: float = (/ (- (cast_float RENDER_H) (* (cast_float y) 2.0)) (cast_float RENDER_H))
    
    let aspect: float = (/ (cast_float RENDER_W) (cast_float RENDER_H))
    let scale: float = (tan (/ (* 60.0 3.14159) 360.0))
    
    let cam_x: float = (* (* ndc_x aspect) scale)
    let cam_y: float = (* ndc_y scale)
    let cam_z: float = -1.0
    
    let yaw_rad: float = (deg_to_rad yaw)
    let pitch_rad: float = (deg_to_rad pitch)
    
    let cos_yaw: float = (cos yaw_rad)
    let sin_yaw: float = (sin yaw_rad)
    let rot_x: float = (- (* cam_x cos_yaw) (* cam_z sin_yaw))
    let rot_z: float = (+ (* cam_x sin_yaw) (* cam_z cos_yaw))
    
    let cos_pitch: float = (cos pitch_rad)
    let sin_pitch: float = (sin pitch_rad)
    let final_y: float = (- (* cam_y cos_pitch) (* rot_z sin_pitch))
    let final_z: float = (+ (* cam_y sin_pitch) (* rot_z cos_pitch))
    
    let dir: Vec3 = (vec_normalize Vec3 { x: rot_x, y: final_y, z: final_z })
    
    return Ray { origin: cam_pos, direction: dir }
}

shadow get_ray { assert true }

# === Main ===
fn main() -> int {
    unsafe {     (SDL_Init SDL_INIT_VIDEO) }
    unsafe {     (TTF_Init) }
    
    let window: SDL_Window = (SDL_CreateWindow "Ray Tracer" SDL_WINDOWPOS_CENTERED SDL_WINDOWPOS_CENTERED WINDOW_WIDTH WINDOW_HEIGHT SDL_WINDOW_SHOWN)
    let renderer: SDL_Renderer = (SDL_CreateRenderer window -1 SDL_RENDERER_ACCELERATED)
    
    # Load font for on-screen help
    let font: TTF_Font = (nl_open_font_portable "Arial" 12)
    
    # Create scene using dynamic arrays (NanoLang idiom)
    let spheres: array<Sphere> = (create_scene)
    
    # Light position (mouse-controlled)
    let mut light_x: float = 3.0
    let mut light_y: float = 5.0
    let mut light_z: float = 0.0
    
    let mut cam_pos: Vec3 = Vec3 { x: 0.0, y: 0.5, z: 2.0 }
    let mut yaw: float = 0.0
    let mut pitch: float = 0.0
    
    let mut running: int = 1
    
    while (== running 1) {
        unsafe {         (SDL_SetRenderDrawColor renderer 50 50 80 255) }
        unsafe {         (SDL_RenderClear renderer) }
        
        # Handle keyboard
        let key: int = (nl_sdl_poll_keypress)
        if (== key 21) {  # R - reset
            set cam_pos Vec3 { x: 0.0, y: 0.5, z: 2.0 }
            set yaw 0.0
            set pitch 0.0
        }
        
        # Arrow keys for camera rotation
        if (== (nl_sdl_key_state 79) 1) { set yaw (- yaw 2.0) }
        if (== (nl_sdl_key_state 80) 1) { set yaw (+ yaw 2.0) }
        if (== (nl_sdl_key_state 82) 1) { set pitch (+ pitch 1.0) }
        if (== (nl_sdl_key_state 81) 1) { set pitch (- pitch 1.0) }
        
        if (> pitch 89.0) { set pitch 89.0 }
        if (< pitch -89.0) { set pitch -89.0 }
        
        # Handle mouse drag input to move light interactively
        let drag_state: int = (nl_sdl_poll_mouse_state)
        if (!= drag_state -1) {
            let light_pos_drag: Vec3 = (light_from_mouse drag_state light_z)
            set light_x light_pos_drag.x
            set light_y light_pos_drag.y
        } else {
            let mouse_result: int = (nl_sdl_poll_mouse_click)
            if (!= mouse_result -1) {
                let light_pos_click: Vec3 = (light_from_mouse mouse_result light_z)
                set light_x light_pos_click.x
                set light_y light_pos_click.y
            } else {}
        }
        
        let light_pos: Vec3 = Vec3 { x: light_x, y: light_y, z: light_z }

        let mut y: int = 0
        while (< y RENDER_H) {
            let mut x: int = 0
            while (< x RENDER_W) {
                let ray: Ray = (get_ray x y yaw pitch cam_pos)
                let color: Vec3 = (trace ray spheres light_pos 0)
                
                let r: int = (cast_int (clamp (* color.x 255.0) 0.0 255.0))
                let g: int = (cast_int (clamp (* color.y 255.0) 0.0 255.0))
                let b: int = (cast_int (clamp (* color.z 255.0) 0.0 255.0))
                
                unsafe {                 (SDL_SetRenderDrawColor renderer r g b 255) }
                unsafe {                 (nl_sdl_render_fill_rect renderer (* x RENDER_SCALE) (* y RENDER_SCALE) RENDER_SCALE RENDER_SCALE) }
                
                set x (+ x 1)
            }
            set y (+ y 1)
        }
        
        # Draw on-screen help (standard position: top-left, white text)
        
        unsafe {         (SDL_RenderPresent renderer) }

        if (== (nl_sdl_poll_event_quit) 1) { set running 0 }
    }
    
    unsafe {     (TTF_CloseFont font) }
    unsafe {     (SDL_DestroyRenderer renderer) }
    unsafe {     (SDL_DestroyWindow window) }
    unsafe {     (TTF_Quit) }
    unsafe {     (SDL_Quit) }
    
    return 0
}

shadow main { assert true }
