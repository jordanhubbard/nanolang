# Example: Checksum Validator
# Purpose: Verified checksum algorithms for data integrity validation with determinism guarantees
# Features: arrays, while loops, integer arithmetic, structs, unions, shadow tests
# Difficulty: Intermediate
# Category: verified
# Prerequisites: none
# Expected Output: (no stdout, exits cleanly)

/* =============================================================================
 * Verified Data Integrity / Checksum Validator
 * =============================================================================
 * Trust Level: VERIFIED (NanoCore subset — type soundness + determinism proven)
 *
 * Industry Context:
 *   Amazon's s2n TLS library uses continuous formal verification: every commit
 *   triggers SAW verification proving the HMAC implementation matches its Coq
 *   specification. Mozilla Firefox ships HACL*, a formally verified crypto
 *   library extracted from F* (a dependent type theory like Coq).
 *
 *   This example demonstrates the "verified library" pattern: a small set of
 *   data integrity functions that are pure NanoCore, called by unverified
 *   application code. The Coq proofs guarantee the checksum computation
 *   is deterministic — the same data always produces the same hash.
 *
 * What the Coq proofs guarantee:
 *   - Determinism: same input data → same checksum, always
 *   - Type soundness: checksum functions always return the correct type
 *   - No silent corruption: well-typed programs cannot produce wrong types
 *
 * Run: nanoc --trust-report examples/verified/checksum_validator.nano
 * ============================================================================= */

/* ── Simple checksum: sum of all elements mod a prime ──
 * This is a pedagogical example — not cryptographic! —
 * but the determinism property is the same as for SHA-256. */

fn checksum_sum(data: array<int>, modulus: int) -> int {
    if (<= modulus 0) {
        return 0
    }
    let mut sum: int = 0
    let mut i: int = 0
    while (< i (array_length data)) {
        let val: int = (at data i)
        /* Use absolute value to handle negative data */
        let mut abs_val: int = val
        if (< val 0) { set abs_val (- 0 val) }
        set sum (% (+ sum abs_val) modulus)
        set i (+ i 1)
    }
    return sum
}

shadow checksum_sum {
    assert (== (checksum_sum [1, 2, 3, 4, 5] 997) (% 15 997))
    assert (== (checksum_sum [] 997) 0)
    assert (== (checksum_sum [997] 997) 0)
    /* Determinism: same input twice */
    assert (== (checksum_sum [10, 20, 30] 997) (checksum_sum [10, 20, 30] 997))
}

/* ── Fletcher-16 style checksum (two running sums) ──
 * Fletcher's checksum is used in TCP, IS-IS routing protocol, and
 * file integrity checking. It detects transposition errors that
 * simple sum checksums miss. */

struct FletcherResult {
    sum1: int,
    sum2: int,
    combined: int
}

fn fletcher_checksum(data: array<int>, modulus: int) -> FletcherResult {
    if (<= modulus 0) {
        return FletcherResult { sum1: 0, sum2: 0, combined: 0 }
    }
    let mut s1: int = 0
    let mut s2: int = 0
    let mut i: int = 0
    while (< i (array_length data)) {
        let val: int = (at data i)
        let mut abs_val: int = val
        if (< val 0) { set abs_val (- 0 val) }
        set s1 (% (+ s1 abs_val) modulus)
        set s2 (% (+ s2 s1) modulus)
        set i (+ i 1)
    }
    return FletcherResult {
        sum1: s1,
        sum2: s2,
        combined: (+ (* s2 modulus) s1)
    }
}

shadow fletcher_checksum {
    let r: FletcherResult = (fletcher_checksum [1, 2, 3] 255)
    /* s1 = (0+1)%255=1, (1+2)%255=3, (3+3)%255=6 → 6 */
    assert (== r.sum1 6)
    /* s2 = (0+1)%255=1, (1+3)%255=4, (4+6)%255=10 → 10 */
    assert (== r.sum2 10)

    /* Fletcher detects transposition: [1,2] != [2,1] */
    let r1: FletcherResult = (fletcher_checksum [1, 2] 255)
    let r2: FletcherResult = (fletcher_checksum [2, 1] 255)
    assert (!= r1.combined r2.combined)
}

/* ── CRC-like polynomial checksum ──
 * Simplified CRC using integer arithmetic (no bit operations needed).
 * Uses polynomial division over a prime field. */

fn poly_checksum(data: array<int>, poly: int) -> int {
    if (<= poly 0) {
        return 0
    }
    let mut remainder: int = 0
    let mut i: int = 0
    while (< i (array_length data)) {
        let val: int = (at data i)
        let mut abs_val: int = val
        if (< val 0) { set abs_val (- 0 val) }
        /* Shift remainder and incorporate new data */
        set remainder (% (+ (* remainder 256) abs_val) poly)
        set i (+ i 1)
    }
    return remainder
}

shadow poly_checksum {
    assert (== (poly_checksum [72, 101, 108, 108, 111] 65521) (poly_checksum [72, 101, 108, 108, 111] 65521))
    /* Different data → (very likely) different checksum */
    assert (!= (poly_checksum [1, 2, 3] 65521) (poly_checksum [3, 2, 1] 65521))
}

/* ── Data integrity verification ──
 * Computes checksum, then verifies it matches. This is the core
 * trust boundary pattern: compute once, verify independently. */

union IntegrityResult {
    Valid { checksum: int },
    Corrupted { expected: int, actual: int }
}

fn verify_integrity(data: array<int>, expected_checksum: int, modulus: int) -> IntegrityResult {
    let actual: int = (checksum_sum data modulus)
    if (== actual expected_checksum) {
        return IntegrityResult.Valid { checksum: actual }
    }
    return IntegrityResult.Corrupted { expected: expected_checksum, actual: actual }
}

shadow verify_integrity {
    let data: array<int> = [10, 20, 30, 40, 50]
    let expected: int = (checksum_sum data 997)
    let r: IntegrityResult = (verify_integrity data expected 997)
    let mut valid: bool = false
    match r { Valid(v) => { set valid true }, Corrupted(c) => {} }
    assert valid

    /* Corrupted data detection */
    let bad_data: array<int> = [10, 20, 31, 40, 50]
    let r2: IntegrityResult = (verify_integrity bad_data expected 997)
    let mut corrupted: bool = false
    match r2 { Valid(v) => {}, Corrupted(c) => { set corrupted true } }
    assert corrupted
}

/* ── Multi-algorithm cross-check ──
 * Uses two independent checksum algorithms to detect corruption.
 * If both agree, the data is (with high probability) intact. */

fn cross_verify(data: array<int>) -> bool {
    let sum_check: int = (checksum_sum data 997)
    let fletcher: FletcherResult = (fletcher_checksum data 255)
    let poly: int = (poly_checksum data 65521)

    /* Recompute and compare */
    let sum_check2: int = (checksum_sum data 997)
    let fletcher2: FletcherResult = (fletcher_checksum data 255)
    let poly2: int = (poly_checksum data 65521)

    return (and (== sum_check sum_check2)
                (and (== fletcher.combined fletcher2.combined)
                     (== poly poly2)))
}

shadow cross_verify {
    assert (cross_verify [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
    assert (cross_verify [])
    assert (cross_verify [255, 255, 255])
}

/* ── Block-wise checksum for large data ──
 * Splits data into blocks and checksums each block independently.
 * If one block is corrupted, we can identify which one. */

fn blockwise_checksums(data: array<int>, block_size: int, modulus: int) -> array<int> {
    if (<= block_size 0) {
        return []
    }
    let mut checksums: array<int> = []
    let mut block_start: int = 0
    while (< block_start (array_length data)) {
        let mut block_sum: int = 0
        let mut j: int = 0
        while (and (< j block_size) (< (+ block_start j) (array_length data))) {
            let val: int = (at data (+ block_start j))
            let mut abs_val: int = val
        if (< val 0) { set abs_val (- 0 val) }
            set block_sum (% (+ block_sum abs_val) modulus)
            set j (+ j 1)
        }
        set checksums (array_push checksums block_sum)
        set block_start (+ block_start block_size)
    }
    return checksums
}

shadow blockwise_checksums {
    /* 10 elements, block size 5 → 2 blocks */
    let data: array<int> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    let cs: array<int> = (blockwise_checksums data 5 997)
    assert (== (array_length cs) 2)
    /* First block: (1+2+3+4+5) % 997 = 15 */
    assert (== (at cs 0) 15)
    /* Second block: (6+7+8+9+10) % 997 = 40 */
    assert (== (at cs 1) 40)
}

/* ── Locate corrupted block ── */

fn find_corrupted_block(data: array<int>, expected_checksums: array<int>,
                         block_size: int, modulus: int) -> int {
    let actual: array<int> = (blockwise_checksums data block_size modulus)
    let mut check_len: int = (array_length actual)
    if (< (array_length expected_checksums) check_len) {
        set check_len (array_length expected_checksums)
    }
    let mut i: int = 0
    while (< i check_len) {
        if (!= (at actual i) (at expected_checksums i)) {
            return i
        }
        set i (+ i 1)
    }
    return -1
}

shadow find_corrupted_block {
    let data: array<int> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    let good_cs: array<int> = (blockwise_checksums data 5 997)
    assert (== (find_corrupted_block data good_cs 5 997) -1)

    let bad_data: array<int> = [1, 2, 3, 4, 99, 6, 7, 8, 9, 10]
    assert (== (find_corrupted_block bad_data good_cs 5 997) 0)
}

/* ── Determinism verification ── */

fn verify_checksum_determinism(data: array<int>) -> bool {
    let a: int = (checksum_sum data 997)
    let b: int = (checksum_sum data 997)
    let f1: FletcherResult = (fletcher_checksum data 255)
    let f2: FletcherResult = (fletcher_checksum data 255)
    let p1: int = (poly_checksum data 65521)
    let p2: int = (poly_checksum data 65521)
    return (and (== a b)
                (and (== f1.combined f2.combined)
                     (== p1 p2)))
}

shadow verify_checksum_determinism {
    assert (verify_checksum_determinism [42, 17, 255, 0, 128])
    assert (verify_checksum_determinism [])
    assert (verify_checksum_determinism [1])
}

/* ── Main ── */

fn main() -> int {
    /* Test all checksum algorithms */
    let data: array<int> = [72, 101, 108, 108, 111]

    let sum: int = (checksum_sum data 997)
    assert (> sum 0)

    let fletcher: FletcherResult = (fletcher_checksum data 255)
    assert (> fletcher.combined 0)

    /* Integrity verification */
    let r: IntegrityResult = (verify_integrity data sum 997)
    let mut valid: bool = false
    match r { Valid(v) => { set valid true }, Corrupted(c) => {} }
    assert valid

    /* Cross-verification */
    assert (cross_verify data)

    /* Determinism */
    assert (verify_checksum_determinism data)

    return 0
}

shadow main {
    assert (== (main) 0)
}
