# Example: Sensor Voting System
# Purpose: Triple modular redundancy majority voting for safety-critical sensor readings
# Features: unions, pattern matching, structs, arrays, integer arithmetic, shadow tests
# Difficulty: Intermediate
# Category: verified
# Prerequisites: none
# Expected Output: 

/* =============================================================================
 * Verified Triple-Redundant Sensor Voting System
 * =============================================================================
 * Trust Level: VERIFIED (NanoCore subset — type soundness + determinism proven)
 *
 * Industry Context:
 *   Triple Modular Redundancy (TMR) is standard in aerospace (Airbus fly-by-wire),
 *   nuclear reactor control, and medical devices. Three independent sensors measure
 *   the same quantity; a voter selects the majority or detects disagreement.
 *
 *   The Ariane 5 Flight 501 failure ($370M, 1996) was caused by a 64-bit to
 *   16-bit integer conversion overflow. A formal model with bounds checking
 *   would have made the assumption explicit and forced verification.
 *
 * What the Coq proofs guarantee:
 *   - Determinism: same three sensor readings always produce the same vote
 *   - Type soundness: voting logic never produces a wrong-typed result
 *   - The voter CANNOT silently produce a wrong answer for well-typed inputs
 *
 * Run: nanoc --trust-report examples/verified/sensor_voting.nano
 * ============================================================================= */

/* ── Sensor reading with bounds ── */

struct SensorReading {
    value: int,
    sensor_id: int,
    timestamp: int
}

/* ── Vote result: consensus, degraded, or failure ── */

union VoteResult {
    Consensus { value: int, agreement: int },
    Degraded { value: int, dissenter_id: int },
    Failure { reason: string }
}

/* ── Absolute value helper ── */

fn int_abs(x: int) -> int {
    if (< x 0) {
        return (- 0 x)
    }
    return x
}

shadow int_abs {
    assert (== (int_abs 5) 5)
    assert (== (int_abs -5) 5)
    assert (== (int_abs 0) 0)
}

/* ── Check if two readings agree within tolerance ── */

fn readings_agree(a: int, b: int, tolerance: int) -> bool {
    return (<= (int_abs (- a b)) tolerance)
}

shadow readings_agree {
    assert (readings_agree 100 102 5)
    assert (readings_agree 100 100 0)
    assert (not (readings_agree 100 110 5))
}

/* ── Triple majority voter ──
 * Given three sensor readings and a tolerance, determines the consensus value.
 *
 * Decision logic:
 *   - If all three agree: Consensus (average, agreement=3)
 *   - If two agree: Degraded (average of agreeing pair, dissenter identified)
 *   - If none agree: Failure
 *
 * The determinism proof guarantees: same inputs → same decision, always. */

fn triple_vote(s1: SensorReading, s2: SensorReading, s3: SensorReading,
               tolerance: int) -> VoteResult {
    let a: int = s1.value
    let b: int = s2.value
    let c: int = s3.value

    let ab_agree: bool = (readings_agree a b tolerance)
    let ac_agree: bool = (readings_agree a c tolerance)
    let bc_agree: bool = (readings_agree b c tolerance)

    /* All three agree → full consensus */
    if (and ab_agree (and ac_agree bc_agree)) {
        let avg: int = (/ (+ a (+ b c)) 3)
        return VoteResult.Consensus { value: avg, agreement: 3 }
    }

    /* Two of three agree → degraded mode */
    if ab_agree {
        let avg: int = (/ (+ a b) 2)
        return VoteResult.Degraded { value: avg, dissenter_id: s3.sensor_id }
    }
    if ac_agree {
        let avg: int = (/ (+ a c) 2)
        return VoteResult.Degraded { value: avg, dissenter_id: s2.sensor_id }
    }
    if bc_agree {
        let avg: int = (/ (+ b c) 2)
        return VoteResult.Degraded { value: avg, dissenter_id: s1.sensor_id }
    }

    /* No agreement → failure */
    return VoteResult.Failure { reason: "no sensor agreement" }
}

shadow triple_vote {
    let s1: SensorReading = SensorReading { value: 100, sensor_id: 1, timestamp: 0 }
    let s2: SensorReading = SensorReading { value: 101, sensor_id: 2, timestamp: 0 }
    let s3: SensorReading = SensorReading { value: 99, sensor_id: 3, timestamp: 0 }

    /* All agree within tolerance=5 */
    let r: VoteResult = (triple_vote s1 s2 s3 5)
    let mut val: int = -1
    match r {
        Consensus(c) => { set val c.value },
        Degraded(d) => { set val d.value },
        Failure(f) => { set val -1 }
    }
    assert (== val 100)  /* (100+101+99)/3 = 100 */

    /* One dissenter */
    let s_bad: SensorReading = SensorReading { value: 200, sensor_id: 3, timestamp: 0 }
    let r2: VoteResult = (triple_vote s1 s2 s_bad 5)
    let mut is_degraded: bool = false
    match r2 {
        Consensus(c) => {},
        Degraded(d) => { set is_degraded true },
        Failure(f) => {}
    }
    assert is_degraded
    let mut dissenter: int = -1
    match r2 {
        Consensus(c) => {},
        Degraded(d) => { set dissenter d.dissenter_id },
        Failure(f) => {}
    }
    assert (== dissenter 3)

    /* All disagree */
    let s_a: SensorReading = SensorReading { value: 100, sensor_id: 1, timestamp: 0 }
    let s_b: SensorReading = SensorReading { value: 200, sensor_id: 2, timestamp: 0 }
    let s_c: SensorReading = SensorReading { value: 300, sensor_id: 3, timestamp: 0 }
    let r3: VoteResult = (triple_vote s_a s_b s_c 5)
    let mut is_failure: bool = false
    match r3 {
        Consensus(c) => {},
        Degraded(d) => {},
        Failure(f) => { set is_failure true }
    }
    assert is_failure
}

/* ── Range validity check ──
 * Ensures a reading is within the sensor's valid operating range.
 * Inspired by Ariane 5: explicitly encode the assumption about value ranges. */

union RangeCheck {
    InRange { value: int },
    OutOfRange { value: int, min: int, max: int }
}

fn check_range(reading: SensorReading, min_val: int, max_val: int) -> RangeCheck {
    if (< reading.value min_val) {
        return RangeCheck.OutOfRange { value: reading.value, min: min_val, max: max_val }
    }
    if (> reading.value max_val) {
        return RangeCheck.OutOfRange { value: reading.value, min: min_val, max: max_val }
    }
    return RangeCheck.InRange { value: reading.value }
}

shadow check_range {
    let s: SensorReading = SensorReading { value: 100, sensor_id: 1, timestamp: 0 }
    let r: RangeCheck = (check_range s 0 200)
    let mut in_range: bool = false
    match r { InRange(v) => { set in_range true }, OutOfRange(v) => {} }
    assert in_range

    let s2: SensorReading = SensorReading { value: 32768, sensor_id: 1, timestamp: 0 }
    let r2: RangeCheck = (check_range s2 0 32767)
    let mut out: bool = false
    match r2 { InRange(v) => {}, OutOfRange(v) => { set out true } }
    assert out
}

/* ── Time-series sliding window voter ──
 * Votes over a sliding window of readings from a single sensor.
 * Detects stuck-at faults (sensor always returning the same value). */

fn detect_stuck_sensor(readings: array<int>, min_variation: int) -> bool {
    if (< (array_length readings) 2) {
        return false
    }
    let mut min_val: int = (at readings 0)
    let mut max_val: int = (at readings 0)
    let mut i: int = 1
    while (< i (array_length readings)) {
        let v: int = (at readings i)
        if (< v min_val) {
            set min_val v
        }
        if (> v max_val) {
            set max_val v
        }
        set i (+ i 1)
    }
    /* If max - min < min_variation, sensor may be stuck */
    return (< (- max_val min_val) min_variation)
}

shadow detect_stuck_sensor {
    /* All same value → stuck */
    assert (detect_stuck_sensor [100, 100, 100, 100, 100] 1)
    /* Normal variation → not stuck */
    assert (not (detect_stuck_sensor [100, 102, 98, 101, 99] 1))
    /* Tiny variation below threshold → stuck */
    assert (detect_stuck_sensor [100, 100, 101, 100, 100] 5)
}

/* ── Full validated reading pipeline ──
 * Combines range check + voting + stuck detection. */

union ValidatedReading {
    Valid { value: int, quality: int },
    Invalid { reason: string }
}

fn validated_vote(s1: SensorReading, s2: SensorReading, s3: SensorReading,
                   tolerance: int, min_val: int, max_val: int) -> ValidatedReading {
    /* Step 1: range checks */
    let r1: RangeCheck = (check_range s1 min_val max_val)
    let r2: RangeCheck = (check_range s2 min_val max_val)
    let r3: RangeCheck = (check_range s3 min_val max_val)

    let mut ok1: bool = false
    let mut ok2: bool = false
    let mut ok3: bool = false
    match r1 { InRange(v) => { set ok1 true }, OutOfRange(v) => {} }
    match r2 { InRange(v) => { set ok2 true }, OutOfRange(v) => {} }
    match r3 { InRange(v) => { set ok3 true }, OutOfRange(v) => {} }

    /* Count valid sensors */
    let mut valid_count: int = 0
    if ok1 { set valid_count (+ valid_count 1) }
    if ok2 { set valid_count (+ valid_count 1) }
    if ok3 { set valid_count (+ valid_count 1) }

    if (< valid_count 2) {
        return ValidatedReading.Invalid { reason: "fewer than 2 sensors in range" }
    }

    /* Step 2: vote on in-range sensors */
    let vote: VoteResult = (triple_vote s1 s2 s3 tolerance)

    let mut quality: int = 0
    let mut value: int = 0
    match vote {
        Consensus(c) => { set quality 3  set value c.value },
        Degraded(d) => { set quality 2  set value d.value },
        Failure(f) => { set quality 0  set value 0 }
    }

    if (== quality 0) {
        return ValidatedReading.Invalid { reason: "no sensor agreement after range check" }
    }

    return ValidatedReading.Valid { value: value, quality: quality }
}

shadow validated_vote {
    let s1: SensorReading = SensorReading { value: 100, sensor_id: 1, timestamp: 0 }
    let s2: SensorReading = SensorReading { value: 101, sensor_id: 2, timestamp: 0 }
    let s3: SensorReading = SensorReading { value: 99, sensor_id: 3, timestamp: 0 }

    let r: ValidatedReading = (validated_vote s1 s2 s3 5 0 200)
    let mut valid: bool = false
    match r { Valid(v) => { set valid true }, Invalid(inv) => {} }
    assert valid

    /* One out of range */
    let s_bad: SensorReading = SensorReading { value: 999, sensor_id: 3, timestamp: 0 }
    let r2: ValidatedReading = (validated_vote s1 s2 s_bad 5 0 200)
    let mut valid2: bool = false
    match r2 { Valid(v) => { set valid2 true }, Invalid(inv) => {} }
    assert valid2  /* Still valid: 2 of 3 agree */
}

/* ── Determinism verification ── */

fn verify_vote_determinism(s1: SensorReading, s2: SensorReading, s3: SensorReading) -> bool {
    let r1: VoteResult = (triple_vote s1 s2 s3 5)
    let r2: VoteResult = (triple_vote s1 s2 s3 5)
    let mut v1: int = -999999
    let mut v2: int = -999999
    match r1 {
        Consensus(c) => { set v1 c.value },
        Degraded(d) => { set v1 d.value },
        Failure(f) => {}
    }
    match r2 {
        Consensus(c) => { set v2 c.value },
        Degraded(d) => { set v2 d.value },
        Failure(f) => {}
    }
    return (== v1 v2)
}

shadow verify_vote_determinism {
    let s1: SensorReading = SensorReading { value: 100, sensor_id: 1, timestamp: 0 }
    let s2: SensorReading = SensorReading { value: 200, sensor_id: 2, timestamp: 0 }
    let s3: SensorReading = SensorReading { value: 300, sensor_id: 3, timestamp: 0 }
    assert (verify_vote_determinism s1 s2 s3)
}

/* ── Main ── */

fn main() -> int {
    let s1: SensorReading = SensorReading { value: 1013, sensor_id: 1, timestamp: 1000 }
    let s2: SensorReading = SensorReading { value: 1014, sensor_id: 2, timestamp: 1000 }
    let s3: SensorReading = SensorReading { value: 1012, sensor_id: 3, timestamp: 1000 }

    let vote: VoteResult = (triple_vote s1 s2 s3 5)
    let mut val: int = -1
    match vote {
        Consensus(c) => { set val c.value },
        Degraded(d) => { set val d.value },
        Failure(f) => {}
    }
    assert (== val 1013)
    assert (verify_vote_determinism s1 s2 s3)
    assert (not (detect_stuck_sensor [1013, 1014, 1012, 1015, 1011] 1))
    return 0
}

shadow main {
    assert (== (main) 0)
}
