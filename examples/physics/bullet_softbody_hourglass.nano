# Example: Bullet Soft Body Hourglass
# Purpose: Streams of deformable soft body spheres squeeze through an hourglass funnel with particle lifecycle management
# Features: Bullet physics, soft body, structs, SDL rendering, particle emitter, hourglass funnel, lifecycle tracking
# Difficulty: Advanced
# Category: physics
# Prerequisites: bullet_soft_body_modern
# Expected Output: graphical

/*
 * Soft Body Hourglass Flood - Bullet Physics + SDL2
 * Inspired by large-scale particle/fluids showcases such as NVIDIA Omni Physics
 * particle documentation and Jason Huang's SPH fluid project.
 */

unsafe module "modules/sdl/sdl.nano"
unsafe module "modules/sdl_helpers/sdl_helpers.nano"
unsafe module "modules/bullet/bullet.nano"

/* Window */
let WINDOW_WIDTH: int = 1200
let WINDOW_HEIGHT: int = 900
let TARGET_FPS: int = 60
let FRAME_TIME: float = 0.016666

let CAMERA_SCALE: float = 15.0
let CAMERA_OFFSET_Y: float = 42.0

/* Particle parameters */
let MAX_PARTICLES: int = 240
let SPAWN_INTERVAL: float = 0.06
let SPAWN_BURST: int = 3
let PARTICLE_RADIUS: float = 1.1
let PARTICLE_RESOLUTION: int = 18
let PARTICLE_SPAWN_Y: float = 36.0

/* Colors */
let COLOR_BG_R: int = 5
let COLOR_BG_G: int = 8
let COLOR_BG_B: int = 12
let COLOR_PARTICLE_R: int = 180
let COLOR_PARTICLE_G: int = 220
let COLOR_PARTICLE_B: int = 255
let COLOR_OBSTACLE_R: int = 200
let COLOR_OBSTACLE_G: int = 120
let COLOR_OBSTACLE_B: int = 60

struct SoftParticle {
    handle: int,
    active: bool,
    crossed: bool
}

fn project_x(x: float) -> int {
    let screen_x: float = (+ (/ (cast_float WINDOW_WIDTH) 2.0) (* x CAMERA_SCALE))
    return (cast_int screen_x)
}

shadow project_x {
    assert (== (project_x 0.0) (/ WINDOW_WIDTH 2))
}

fn project_y(y: float) -> int {
    let adjusted_y: float = (- y CAMERA_OFFSET_Y)
    let screen_y: float = (+ (/ (cast_float WINDOW_HEIGHT) 2.0) (- (* adjusted_y CAMERA_SCALE)))
    return (cast_int screen_y)
}

shadow project_y {
    assert (< (project_y 10.0) (project_y (- 0.0 10.0)))
}

fn draw_filled_circle(renderer: SDL_Renderer, cx: int, cy: int, radius: int) -> void {
    let mut y: int = (- 0 radius)
    while (<= y radius) {
        let mut x: int = (- 0 radius)
        while (<= x radius) {
            let dist_sq: int = (+ (* x x) (* y y))
            let limit: int = (* radius radius)
            if (<= dist_sq limit) {
                (SDL_RenderDrawPoint renderer (+ cx x) (+ cy y)) 
            }
            set x (+ x 1)
        }
        set y (+ y 1)
    }
    return
}

shadow draw_filled_circle {
    (draw_filled_circle 0 0 0 1)
    assert true
}

fn format_percent(value: float) -> string {
    let mut clamped: float = value
    if (< clamped 0.0) {
        set clamped 0.0
    }
    if (> clamped 1.0) {
        set clamped 1.0
    }
    let percent: int = (cast_int (* clamped 100.0))
    return (+ (int_to_string percent) "%")
}

shadow format_percent {
    assert (== (format_percent 0.25) "25%")
}

fn main() -> int {
    (println "╔════════════════════════════════════════════════════════════╗")
    (println "║      BULLET SOFT BODY HOURGLASS (PARTICLE FLOOD)          ║")
    (println "╚════════════════════════════════════════════════════════════╝")
    (println "Streams of deformable spheres squeeze through an hourglass funnel")
    (println "SPACE toggles emitter, ESC exits")
    (println "")

    (SDL_Init SDL_INIT_VIDEO) 
    let window: SDL_Window = (SDL_CreateWindow
        "Bullet Soft Body Hourglass"
        SDL_WINDOWPOS_CENTERED SDL_WINDOWPOS_CENTERED
        WINDOW_WIDTH WINDOW_HEIGHT
        SDL_WINDOW_SHOWN)
    let renderer: SDL_Renderer = (SDL_CreateRenderer window -1 SDL_RENDERER_ACCELERATED)

    let mut bullet_ok: int = 0
    set bullet_ok (nl_bullet_init) 
    if (== bullet_ok 0) {
        (println "Failed to init Bullet")
        (SDL_DestroyRenderer renderer)
        (SDL_DestroyWindow window)
        (SDL_Quit)
        return 1
    }

    /* Static world */
    (nl_bullet_create_rigid_box 0.0 (- 0.0 48.0) 0.0 80.0 2.0 60.0 0.0 0.4)
    (nl_bullet_create_rigid_box_rotated (- 0.0 14.0) 0.0 0.0 24.0 1.0 6.0 25.0 0.0 0.3)
    (nl_bullet_create_rigid_box_rotated 14.0 0.0 0.0 24.0 1.0 6.0 (- 25.0) 0.0 0.3)
    (nl_bullet_create_rigid_box_rotated (- 0.0 10.0) (- 0.0 18.0) 0.0 18.0 1.0 6.0 (- 25.0) 0.0 0.3)
    (nl_bullet_create_rigid_box_rotated 10.0 (- 0.0 18.0) 0.0 18.0 1.0 6.0 25.0 0.0 0.3)
    (nl_bullet_create_rigid_box 0.0 (- 0.0 30.0) 0.0 4.0 10.0 6.0 0.0 0.2)

    let mut particles: array<SoftParticle> = []
    let mut active_count: int = 0
    let mut crossed_count: int = 0
    let mut spawn_timer: float = 0.0
    let mut emitter_enabled: bool = true

    let mut running: bool = true
    let mut frame_count: int = 0

    while running {
        let mut frame_start: int = 0
        set frame_start (SDL_GetTicks) 

        if (== (nl_sdl_poll_event_quit) 1) {
            set running false
        }
        let key: int = (nl_sdl_poll_keypress)
        if (== key 41) {
            set running false
        }
        if (== key 44) {
            set emitter_enabled (not emitter_enabled)
            (println (cond ((== emitter_enabled true) "Emitter resumed") (else "Emitter paused")))
        }

        (nl_bullet_step FRAME_TIME) 

        set spawn_timer (+ spawn_timer FRAME_TIME)
        if (and emitter_enabled (> spawn_timer SPAWN_INTERVAL)) {
            set spawn_timer 0.0
            let mut spawned: int = 0
            while (and (< spawned SPAWN_BURST) (< active_count MAX_PARTICLES)) {
                let lane_offset: float = (+ (- 0.0 4.0) (* (cast_float (% (+ frame_count spawned) 6)) 1.4))
                let spawn_x: float = (+ lane_offset (cond ((== (% spawned 2) 0) 1.2) (else (- 0.0 1.2))))
                let mut handle: int = 0
                set handle (nl_bullet_create_soft_sphere spawn_x PARTICLE_SPAWN_Y 0.0 PARTICLE_RADIUS PARTICLE_RESOLUTION)
                if (!= handle (- 0 1)) {
                    let particle: SoftParticle = SoftParticle {
                        handle: handle,
                        active: true,
                        crossed: false
                    }
                    set particles (array_push particles particle)
                    set active_count (+ active_count 1)
                }
                set spawned (+ spawned 1)
            }
        }

        /* Update particle lifecycle */
        let mut index: int = 0
        while (< index (array_length particles)) {
            let particle: SoftParticle = (at particles index)
            if particle.active {
                let mut sample_y: float = 0.0
                set sample_y (nl_bullet_get_soft_body_node_y particle.handle 0)
                if (and (< sample_y (- 0.0 5.0)) (not particle.crossed)) {
                    set crossed_count (+ crossed_count 1)
                    let updated: SoftParticle = SoftParticle {
                        handle: particle.handle,
                        active: true,
                        crossed: true
                    }
                    (array_set particles index updated)
                }
                if (< sample_y (- 0.0 45.0)) {
                    (nl_bullet_remove_soft_body particle.handle) 
                    let updated2: SoftParticle = SoftParticle {
                        handle: particle.handle,
                        active: false,
                        crossed: true
                    }
                    (array_set particles index updated2)
                    set active_count (- active_count 1)
                }
            }
            set index (+ index 1)
        }

        if (== (% frame_count 180) 0) {
            let fill_ratio: float = (/ (cast_float active_count) (cast_float MAX_PARTICLES))
            let status: string = (+ "Particles active: "
                (+ (int_to_string active_count)
                    (+ "/"
                        (+ (int_to_string MAX_PARTICLES)
                            (+ " ("
                                (+ (format_percent fill_ratio)
                                    (+ ") | crossed total: " (int_to_string crossed_count))))))))
            (println status)
        }

        /* Rendering */
        (SDL_SetRenderDrawColor renderer COLOR_BG_R COLOR_BG_G COLOR_BG_B 255)
        (SDL_RenderClear renderer)

        /* Draw hourglass structure (matching physics boxes) */
        (SDL_SetRenderDrawColor renderer COLOR_OBSTACLE_R COLOR_OBSTACLE_G COLOR_OBSTACLE_B 255)
        
        # Floor
        let floor_y: int = (project_y (- 0.0 48.0))
        let floor_left: int = (project_x (- 0.0 40.0))
        let floor_right: int = (project_x 40.0)
        (nl_sdl_render_fill_rect renderer floor_left floor_y (- floor_right floor_left) 30)
        
        # Upper funnel - left side (angled wall from top-left to center)
        # Physics: box at (-14, 0) with length 24, rotated 25 degrees
        let ul_top_x: int = (project_x (- 0.0 32.0))
        let ul_top_y: int = (project_y 10.0)
        let ul_bot_x: int = (project_x (- 0.0 4.0))
        let ul_bot_y: int = (project_y (- 0.0 8.0))
        (SDL_RenderDrawLine renderer ul_top_x ul_top_y ul_bot_x ul_bot_y)
        (SDL_RenderDrawLine renderer (+ ul_top_x 1) ul_top_y (+ ul_bot_x 1) ul_bot_y)
        (SDL_RenderDrawLine renderer (+ ul_top_x 2) ul_top_y (+ ul_bot_x 2) ul_bot_y)
        (SDL_RenderDrawLine renderer (- ul_top_x 1) ul_top_y (- ul_bot_x 1) ul_bot_y)
        (SDL_RenderDrawLine renderer (- ul_top_x 2) ul_top_y (- ul_bot_x 2) ul_bot_y)
        
        # Upper funnel - right side (angled wall from top-right to center)
        let ur_top_x: int = (project_x 32.0)
        let ur_top_y: int = (project_y 10.0)
        let ur_bot_x: int = (project_x 4.0)
        let ur_bot_y: int = (project_y (- 0.0 8.0))
        (SDL_RenderDrawLine renderer ur_top_x ur_top_y ur_bot_x ur_bot_y)
        (SDL_RenderDrawLine renderer (+ ur_top_x 1) ur_top_y (+ ur_bot_x 1) ur_bot_y)
        (SDL_RenderDrawLine renderer (+ ur_top_x 2) ur_top_y (+ ur_bot_x 2) ul_bot_y)
        (SDL_RenderDrawLine renderer (- ur_top_x 1) ur_top_y (- ur_bot_x 1) ur_bot_y)
        (SDL_RenderDrawLine renderer (- ur_top_x 2) ur_top_y (- ur_bot_x 2) ur_bot_y)
        
        # Neck (narrow passage in the middle)
        let neck_left: int = (project_x (- 0.0 4.0))
        let neck_right: int = (project_x 4.0)
        let neck_top: int = (project_y (- 0.0 20.0))
        let neck_bot: int = (project_y (- 0.0 40.0))
        (nl_sdl_render_fill_rect renderer (- neck_left 4) neck_top 8 (- neck_bot neck_top))
        (nl_sdl_render_fill_rect renderer (- neck_right 4) neck_top 8 (- neck_bot neck_top))
        
        # Lower funnel - left side (angled wall from center down-left)
        let ll_top_x: int = (project_x (- 0.0 4.0))
        let ll_top_y: int = (project_y (- 0.0 8.0))
        let ll_bot_x: int = (project_x (- 0.0 24.0))
        let ll_bot_y: int = (project_y (- 0.0 28.0))
        (SDL_RenderDrawLine renderer ll_top_x ll_top_y ll_bot_x ll_bot_y)
        (SDL_RenderDrawLine renderer (+ ll_top_x 1) ll_top_y (+ ll_bot_x 1) ll_bot_y)
        (SDL_RenderDrawLine renderer (+ ll_top_x 2) ll_top_y (+ ll_bot_x 2) ll_bot_y)
        (SDL_RenderDrawLine renderer (- ll_top_x 1) ll_top_y (- ll_bot_x 1) ll_bot_y)
        (SDL_RenderDrawLine renderer (- ll_top_x 2) ll_top_y (- ll_bot_x 2) ll_bot_y)
        
        # Lower funnel - right side (angled wall from center down-right)
        let lr_top_x: int = (project_x 4.0)
        let lr_top_y: int = (project_y (- 0.0 8.0))
        let lr_bot_x: int = (project_x 24.0)
        let lr_bot_y: int = (project_y (- 0.0 28.0))
        (SDL_RenderDrawLine renderer lr_top_x lr_top_y lr_bot_x lr_bot_y)
        (SDL_RenderDrawLine renderer (+ lr_top_x 1) lr_top_y (+ lr_bot_x 1) lr_bot_y)
        (SDL_RenderDrawLine renderer (+ lr_top_x 2) lr_top_y (+ lr_bot_x 2) lr_bot_y)
        (SDL_RenderDrawLine renderer (- lr_top_x 1) lr_top_y (- lr_bot_x 1) lr_bot_y)
        (SDL_RenderDrawLine renderer (- lr_top_x 2) lr_top_y (- lr_bot_x 2) lr_bot_y)
        
        # Outer walls (vertical sides of hourglass)
        let wall_left: int = (project_x (- 0.0 32.0))
        let wall_right: int = (project_x 32.0)
        let wall_top: int = (project_y 10.0)
        let wall_bottom: int = (project_y (- 0.0 28.0))
        (nl_sdl_render_fill_rect renderer (- wall_left 4) wall_top 8 (- wall_bottom wall_top))
        (nl_sdl_render_fill_rect renderer (- wall_right 4) wall_top 8 (- wall_bottom wall_top))

        (SDL_SetRenderDrawColor renderer COLOR_PARTICLE_R COLOR_PARTICLE_G COLOR_PARTICLE_B 255)
        let mut draw_index: int = 0
        while (< draw_index (array_length particles)) {
            let particle: SoftParticle = (at particles draw_index)
            if particle.active {
                let mut node_count: int = 0
                set node_count (nl_bullet_get_soft_body_node_count particle.handle) 
                let mut node_idx: int = 0
                while (< node_idx node_count) {
                    let mut node_x: float = 0.0
                    let mut node_y: float = 0.0
                    set node_x (nl_bullet_get_soft_body_node_x particle.handle node_idx)
                    set node_y (nl_bullet_get_soft_body_node_y particle.handle node_idx)
                    let sx: int = (project_x node_x)
                    let sy: int = (project_y node_y)
                    (draw_filled_circle renderer sx sy 2)
                    set node_idx (+ node_idx 1)
                }
            }
            set draw_index (+ draw_index 1)
        }

        (SDL_RenderPresent renderer) 

        set frame_count (+ frame_count 1)

        let mut frame_end: int = 0
        set frame_end (SDL_GetTicks) 
        let duration: int = (- frame_end frame_start)
        let frame_budget: int = (/ 1000 TARGET_FPS)
        if (< duration frame_budget) {
            (SDL_Delay (- frame_budget duration)) 
        }
    }

    (nl_bullet_cleanup)
    (SDL_DestroyRenderer renderer)
    (SDL_DestroyWindow window)
    (SDL_Quit)

    (println "Hourglass demo finished")
    return 0
}

shadow main {
    assert true
}
