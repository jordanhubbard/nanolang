/*
 * Interactive Bouncy Balls - Bullet Physics + SDL2
 * 
 * Click and hold the mouse to rain down colorful bouncy balls!
 * Balls have rubber-like physics and fall into a ball pit at the bottom.
 * 
 * Controls:
 *   MOUSE - Click and hold to spawn balls at cursor
 *   SPACE - Clear all balls
 *   ESC   - Quit
 */

unsafe module "modules/sdl/sdl.nano"
unsafe module "modules/sdl_helpers/sdl_helpers.nano"
unsafe module "modules/sdl_ttf/sdl_ttf.nano"
unsafe module "modules/sdl_ttf/sdl_ttf_helpers.nano"
module "modules/ui_widgets/ui_widgets.nano"
unsafe module "modules/bullet/bullet.nano"

/* Window + camera */
let WINDOW_WIDTH: int = 1200
let WINDOW_HEIGHT: int = 800
let TARGET_FPS: int = 60
let FRAME_TIME: float = 0.016666

let CAMERA_SCALE: float = 15.0
let CAMERA_OFFSET_X: float = 0.0
let CAMERA_OFFSET_Y: float = 0.0

/* Ball properties */
let BALL_RADIUS: float = 0.8
let BALL_MASS: float = 1.0
let BALL_RESTITUTION: float = 0.85  # High bounce (rubber-like)

/* Ball pit properties */
let PIT_BOTTOM_Y: float = (- 0.0 25.0)
let PIT_WALL_THICKNESS: float = 8.0  # Thick bottom to prevent tunneling
let PIT_WIDTH: float = 60.0
let PIT_HEIGHT: float = 15.0  # Taller walls to contain more balls

/* Spawn timing */
let SPAWN_DELAY_MS: int = 50  # Spawn every 50ms when holding mouse

/* Project world coordinates to screen */
fn project_x(wx: float) -> int {
    let scaled: float = (* wx CAMERA_SCALE)
    let centered: float = (+ scaled (/ (cast_float WINDOW_WIDTH) 2.0))
    return (cast_int centered)
}

shadow project_x {
    assert (> (project_x 0.0) 0)
}

fn project_y(wy: float) -> int {
    let scaled: float = (* wy CAMERA_SCALE)
    let flipped: float = (- (/ (cast_float WINDOW_HEIGHT) 2.0) scaled)
    return (cast_int flipped)
}

shadow project_y {
    assert (> (project_y 0.0) 0)
}

/* Unproject screen coordinates to world */
fn unproject_x(sx: int) -> float {
    let centered: float = (- (cast_float sx) (/ (cast_float WINDOW_WIDTH) 2.0))
    let wx: float = (/ centered CAMERA_SCALE)
    return wx
}

shadow unproject_x {
    assert (< (unproject_x 600) 100.0)
}

fn unproject_y(sy: int) -> float {
    let flipped: float = (- (/ (cast_float WINDOW_HEIGHT) 2.0) (cast_float sy))
    let wy: float = (/ flipped CAMERA_SCALE)
    return wy
}

shadow unproject_y {
    assert (> (unproject_y 0) (- 0.0 100.0))
}

/* Clamp int value */
fn clamp_int(v: int, lo: int, hi: int) -> int {
    if (< v lo) {
        return lo
    } else {
        if (> v hi) {
            return hi
        } else {
            return v
        }
    }
}

shadow clamp_int {
    assert (== (clamp_int 5 0 10) 5)
    assert (== (clamp_int (- 1) 0 10) 0)
    assert (== (clamp_int 99 0 10) 10)
}

/* Draw filled circle for ball */
fn draw_filled_circle(r: SDL_Renderer, cx: int, cy: int, radius: int) -> void {
    let mut y: int = (- radius)
    while (<= y radius) {
        let mut x: int = (- radius)
        while (<= x radius) {
            let dist_sq: int = (+ (* x x) (* y y))
            let radius_sq: int = (* radius radius)
            if (<= dist_sq radius_sq) {
                (SDL_RenderDrawPoint r (+ cx x) (+ cy y))
            } else {}
            set x (+ x 1)
        }
        set y (+ y 1)
    }
}

shadow draw_filled_circle {
    assert true  # Uses extern SDL
}

/* Random number generator (simple LCG) */
let mut rng_state: int = 12345

fn random_int(max: int) -> int {
    set rng_state (% (+ (* rng_state 1103515245) 12345) 2147483647)
    return (% rng_state max)
}

shadow random_int {
    let r1: int = (random_int 100)
    let r2: int = (random_int 100)
    assert (!= r1 r2)
}

/* Generate random color */
fn random_color() -> int {
    let r: int = (+ 100 (random_int 156))
    let g: int = (+ 100 (random_int 156))
    let b: int = (+ 100 (random_int 156))
    return (+ (* r 65536) (+ (* g 256) b))
}

shadow random_color {
    let c1: int = (random_color)
    let c2: int = (random_color)
    assert (!= c1 c2)
}

/* Main function */
fn main() -> int {
    (println "╔════════════════════════════════════════════════════════╗")
    (println "║      INTERACTIVE BOUNCY BALLS - Physics Demo          ║")
    (println "╚════════════════════════════════════════════════════════╝")
    (println "")
    (println "Controls:")
    (println "  • Click and hold mouse to spawn bouncy balls")
    (println "  • SPACE to clear all balls")
    (println "  • ESC to quit")
    (println "")
    
    /* Init SDL */
    (SDL_Init SDL_INIT_VIDEO)
    (TTF_Init)
    
    let window: SDL_Window = (SDL_CreateWindow "Bouncy Balls Physics Demo"
                                                SDL_WINDOWPOS_CENTERED
                                                SDL_WINDOWPOS_CENTERED
                                                WINDOW_WIDTH WINDOW_HEIGHT
                                                SDL_WINDOW_SHOWN)
    let renderer: SDL_Renderer = (SDL_CreateRenderer window -1
                                                      (+ SDL_RENDERER_ACCELERATED SDL_RENDERER_PRESENTVSYNC))
    
    let font: TTF_Font = (nl_open_font_portable "Arial" 14)
    
    /* Init Bullet Physics */
    let physics_ok: int = (nl_bullet_init)
    if (== physics_ok 0) {
        (println "✗ Physics initialization failed")
        (SDL_DestroyRenderer renderer)
        (SDL_DestroyWindow window)
        (TTF_Quit)
        (SDL_Quit)
        return 1
    } else {}
    (println "✓ Physics engine initialized")
    
    /* Create ball pit */
    # Bottom (thick to prevent fast balls from tunneling through)
    (nl_bullet_create_rigid_box 0.0 (- PIT_BOTTOM_Y PIT_WALL_THICKNESS) 0.0 
                                 (/ PIT_WIDTH 2.0) PIT_WALL_THICKNESS (/ PIT_WIDTH 2.0) 
                                 0.0 0.6)
    
    # Left wall
    let left_x: float = (- 0.0 (/ PIT_WIDTH 2.0))
    (nl_bullet_create_rigid_box left_x (+ PIT_BOTTOM_Y (/ PIT_HEIGHT 2.0)) 0.0 
                                 PIT_WALL_THICKNESS (/ PIT_HEIGHT 2.0) PIT_WALL_THICKNESS 
                                 0.0 0.6)
    
    # Right wall
    let right_x: float = (/ PIT_WIDTH 2.0)
    (nl_bullet_create_rigid_box right_x (+ PIT_BOTTOM_Y (/ PIT_HEIGHT 2.0)) 0.0 
                                 PIT_WALL_THICKNESS (/ PIT_HEIGHT 2.0) PIT_WALL_THICKNESS 
                                 0.0 0.6)
    
    (println "✓ Ball pit created")
    (println "")
    (println "Ready! Click to start spawning balls...")
    
    /* Ball tracking */
    let mut ball_handles: array<int> = []
    let mut ball_colors: array<int> = []
    let mut last_spawn_time: int = 0
    let mut current_color: int = (random_color)
    let mut last_click_state: bool = false
    
    /* Main loop */
    let mut running: bool = true
    
    while running {
        /* Event handling */
        if (== (nl_sdl_poll_event_quit) 1) {
            set running false
        } else {}
        
        let key: int = (nl_sdl_poll_keypress)
        
        # ESC to quit
        if (== key 41) {
            set running false
        } else {}
        
        # SPACE to clear balls
        if (== key 44) {
            let ball_count: int = (array_length ball_handles)
            (println (+ "Clearing " (+ (int_to_string ball_count) " balls...")))
            set ball_handles []
            set ball_colors []
        } else {}
        
        /* Mouse input */
        let mouse_state: int = (nl_sdl_poll_mouse_state)
        let mouse_x: int = (/ mouse_state 10000)
        let mouse_y: int = (% mouse_state 10000)
        let mouse_down: bool = (> (% mouse_state 2) 0)
        
        let now: int = (SDL_GetTicks)
        let time_since_spawn: int = (- now last_spawn_time)
        
        /* Spawn balls when mouse held down */
        if mouse_down {
            # Generate new color when mouse is first pressed
            if (not last_click_state) {
                set current_color (random_color)
            } else {}
            
            if (>= time_since_spawn SPAWN_DELAY_MS) {
                let world_x: float = (unproject_x mouse_x)
                let world_y: float = (unproject_y mouse_y)
                
                # Spawn ball at cursor position
                let ball_handle: int = (nl_bullet_create_rigid_sphere 
                                        world_x world_y 0.0 
                                        BALL_RADIUS BALL_MASS BALL_RESTITUTION)
                
                if (!= ball_handle (- 1)) {
                    set ball_handles (array_push ball_handles ball_handle)
                    set ball_colors (array_push ball_colors current_color)
                    set last_spawn_time now
                } else {}
            } else {}
        } else {}
        
        set last_click_state mouse_down
        
        /* Physics step */
        (nl_bullet_step FRAME_TIME)
        
        /* Rendering */
        # Clear background
        (SDL_SetRenderDrawColor renderer 15 15 25 255)
        (SDL_RenderClear renderer)
        
        # Draw ball pit
        (SDL_SetRenderDrawColor renderer 80 80 100 255)
        
        # Bottom
        let pit_bottom_y_screen: int = (project_y PIT_BOTTOM_Y)
        let pit_left_screen: int = (project_x left_x)
        let pit_right_screen: int = (project_x right_x)
        let pit_width_screen: int = (- pit_right_screen pit_left_screen)
        let pit_thickness_screen: int = (cast_int (* PIT_WALL_THICKNESS CAMERA_SCALE))
        (nl_sdl_render_fill_rect renderer pit_left_screen pit_bottom_y_screen 
                                 pit_width_screen (* pit_thickness_screen 2))
        
        # Left wall
        let pit_height_screen: int = (cast_int (* PIT_HEIGHT CAMERA_SCALE))
        let left_wall_y: int = (- pit_bottom_y_screen pit_height_screen)
        (nl_sdl_render_fill_rect renderer pit_left_screen left_wall_y 
                                 (* pit_thickness_screen 2) pit_height_screen)
        
        # Right wall
        let right_wall_x: int = (- pit_right_screen (* pit_thickness_screen 2))
        (nl_sdl_render_fill_rect renderer right_wall_x left_wall_y 
                                 (* pit_thickness_screen 2) pit_height_screen)
        
        # Draw balls
        let ball_count: int = (array_length ball_handles)
        let mut i: int = 0
        while (< i ball_count) {
            let handle: int = (at ball_handles i)
            let color: int = (at ball_colors i)
            
            let ball_x: float = (nl_bullet_get_rigid_body_x handle)
            let ball_y: float = (nl_bullet_get_rigid_body_y handle)
            
            let screen_x: int = (project_x ball_x)
            let screen_y: int = (project_y ball_y)
            let screen_radius: int = (cast_int (* BALL_RADIUS CAMERA_SCALE))
            
            # Extract RGB from color
            let r: int = (/ color 65536)
            let g: int = (% (/ color 256) 256)
            let b: int = (% color 256)
            
            (SDL_SetRenderDrawColor renderer r g b 255)
            (draw_filled_circle renderer screen_x screen_y screen_radius)
            
            set i (+ i 1)
        }
        
        # Draw UI text
        (SDL_SetRenderDrawColor renderer 240 240 255 255)
        (nl_ui_label renderer font (+ "Balls: " (int_to_string ball_count)) 10 10 240 240 255 255)
        (nl_ui_label renderer font "Click to spawn • SPACE to clear • ESC to quit" 10 30 200 200 220 255)
        
        if mouse_down {
            (nl_ui_label renderer font "SPAWNING!" (- WINDOW_WIDTH 120) 10 100 255 100 255)
        } else {}
        
        (SDL_RenderPresent renderer)
        (SDL_Delay 16)
    }
    
    /* Cleanup */
    (println "")
    (println (+ "Final ball count: " (int_to_string (array_length ball_handles))))
    (println "Cleaning up...")
    
    (nl_bullet_cleanup)
    (TTF_CloseFont font)
    (SDL_DestroyRenderer renderer)
    (SDL_DestroyWindow window)
    (TTF_Quit)
    (SDL_Quit)
    
    (println "Done!")
    return 0
}

shadow main {
    assert true
}
