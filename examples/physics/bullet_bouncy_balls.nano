/*
 * Interactive Bouncy Balls - Bullet Physics + SDL2
 * 
 * Click and hold the mouse to rain down colorful bouncy balls!
 * Balls have rubber-like physics and fall into a ball pit at the bottom.
 * 
 * Controls:
 *   MOUSE      - Click and hold to spawn balls at cursor
 *   UP/DOWN    - Increase/decrease gravity (+/- 1.0)
 *   LEFT/RIGHT - Fine gravity adjustment (+/- 0.1)
 *   SPACE      - Clear all balls
 *   ESC        - Quit
 */

unsafe module "modules/sdl/sdl.nano"
unsafe module "modules/sdl_helpers/sdl_helpers.nano"
unsafe module "modules/sdl_ttf/sdl_ttf.nano"
unsafe module "modules/sdl_ttf/sdl_ttf_helpers.nano"
module "modules/ui_widgets/ui_widgets.nano"
unsafe module "modules/bullet/bullet.nano"

/* Window + camera */
let WINDOW_WIDTH: int = 1200
let WINDOW_HEIGHT: int = 800
let TARGET_FPS: int = 60
let FRAME_TIME: float = 0.016666

let CAMERA_SCALE: float = 15.0
let CAMERA_OFFSET_X: float = 0.0
let CAMERA_OFFSET_Y: float = 0.0

/* Ball properties */
let BALL_RADIUS: float = 0.8
let BALL_MASS: float = 1.0
let BALL_RESTITUTION: float = 0.85  # High bounce (rubber-like)

/* Gravity (absolute, user-facing: + pulls down, - pulls up, NO LIMIT) */
let GRAVITY_MIN: float = (- 0.0 10.0)  # Only used for slider range display
let GRAVITY_MAX: float = 10.0           # Arrow keys can go beyond this!

/* Ball pit properties */
let PIT_BOTTOM_Y: float = (- 0.0 25.0)
let PIT_WALL_THICKNESS: float = 8.0  # Thick bottom to prevent tunneling
let PIT_WIDTH: float = 60.0
let PIT_HEIGHT: float = 15.0  # Taller walls to contain more balls

/* Spawn timing */
let SPAWN_DELAY_MS: int = 50  # Spawn every 50ms when holding mouse

/* Project world coordinates to screen */
fn project_x(wx: float) -> int {
    let scaled: float = (* wx CAMERA_SCALE)
    let centered: float = (+ scaled (/ (cast_float WINDOW_WIDTH) 2.0))
    return (cast_int centered)
}

shadow project_x {
    assert (> (project_x 0.0) 0)
}

fn project_y(wy: float) -> int {
    let scaled: float = (* wy CAMERA_SCALE)
    let flipped: float = (- (/ (cast_float WINDOW_HEIGHT) 2.0) scaled)
    return (cast_int flipped)
}

shadow project_y {
    assert (> (project_y 0.0) 0)
}

/* Unproject screen coordinates to world */
fn unproject_x(sx: int) -> float {
    let centered: float = (- (cast_float sx) (/ (cast_float WINDOW_WIDTH) 2.0))
    let wx: float = (/ centered CAMERA_SCALE)
    return wx
}

shadow unproject_x {
    assert (< (unproject_x 600) 100.0)
}

fn unproject_y(sy: int) -> float {
    let flipped: float = (- (/ (cast_float WINDOW_HEIGHT) 2.0) (cast_float sy))
    let wy: float = (/ flipped CAMERA_SCALE)
    return wy
}

shadow unproject_y {
    assert (> (unproject_y 0) (- 0.0 100.0))
}

/* RGB helper for color packing */
fn rgb(r: int, g: int, b: int) -> int {
    return (+ (* r 65536) (+ (* g 256) b))
}

shadow rgb {
    assert (== (rgb 255 0 0) 16711680)
    assert (== (rgb 0 255 0) 65280)
}

/* Clamp int value using cond */
fn clamp_int(v: int, lo: int, hi: int) -> int {
    return (cond
        ((< v lo) lo)
        ((> v hi) hi)
        (else v)
    )
}

shadow clamp_int {
    assert (== (clamp_int 5 0 10) 5)
    assert (== (clamp_int (- 1) 0 10) 0)
    assert (== (clamp_int 99 0 10) 10)
}

fn clamp_float(v: float, lo: float, hi: float) -> float {
    if (< v lo) {
        return lo
    } else {
        if (> v hi) {
            return hi
        } else {
            return v
        }
    }
}

shadow clamp_float {
    assert (== (clamp_float 1.0 0.0 2.0) 1.0)
    assert (== (clamp_float (- 0.0 1.0) 0.0 2.0) 0.0)
    assert (== (clamp_float 99.0 0.0 2.0) 2.0)
}

fn slider_to_gravity_value(s: float) -> float {
    let t: float = (clamp_float s 0.0 1.0)
    return (- (* t 20.0) 10.0)
}

shadow slider_to_gravity_value {
    assert (== (slider_to_gravity_value 0.0) (- 0.0 10.0))
    assert (== (slider_to_gravity_value 0.5) 0.0)
    assert (== (slider_to_gravity_value 1.0) 10.0)
}

fn gravity_value_to_slider(g: float) -> float {
    let gg: float = (clamp_float g GRAVITY_MIN GRAVITY_MAX)
    return (/ (+ gg 10.0) 20.0)
}

shadow gravity_value_to_slider {
    assert (== (gravity_value_to_slider (- 0.0 10.0)) 0.0)
    assert (== (gravity_value_to_slider 0.0) 0.5)
    assert (== (gravity_value_to_slider 10.0) 1.0)
}

fn float_to_string_simple(f: float) -> string {
    return (+ (int_to_string (cast_int f)) ".0")
}

shadow float_to_string_simple {
    assert (> (str_length (float_to_string_simple 1.0)) 0)
    assert (> (str_length (float_to_string_simple (- 0.0 1.0))) 0)
}

/* Draw filled circle for ball */
fn draw_filled_circle(r: SDL_Renderer, cx: int, cy: int, radius: int) -> void {
    let mut y: int = (- radius)
    while (<= y radius) {
        let mut x: int = (- radius)
        while (<= x radius) {
            let dist_sq: int = (+ (* x x) (* y y))
            let radius_sq: int = (* radius radius)
            if (<= dist_sq radius_sq) {
                (SDL_RenderDrawPoint r (+ cx x) (+ cy y))
            } else {}
            set x (+ x 1)
        }
        set y (+ y 1)
    }
}

shadow draw_filled_circle {
    assert true  # Uses extern SDL
}

/* Random number generator (simple LCG) */
let mut rng_state: int = 12345

fn random_int(max: int) -> int {
    set rng_state (% (+ (* rng_state 1103515245) 12345) 2147483647)
    return (% rng_state max)
}

shadow random_int {
    let r1: int = (random_int 100)
    let r2: int = (random_int 100)
    assert (!= r1 r2)
}

/* Random float in range [min, max] */
fn random_float(min: float, max: float) -> float {
    let r: int = (random_int 10000)
    let t: float = (/ (cast_float r) 10000.0)
    return (+ min (* t (- max min)))
}

shadow random_float {
    let r1: float = (random_float 0.0 10.0)
    assert (>= r1 0.0)
    assert (<= r1 10.0)
}

/* Generate random color */
fn random_color() -> int {
    let r: int = (+ 100 (random_int 156))
    let g: int = (+ 100 (random_int 156))
    let b: int = (+ 100 (random_int 156))
    return (rgb r g b)
}

shadow random_color {
    let c1: int = (random_color)
    let c2: int = (random_color)
    assert (!= c1 c2)
}

/* Main function */
fn main() -> int {
    (println "╔════════════════════════════════════════════════════════╗")
    (println "║      INTERACTIVE BOUNCY BALLS - Physics Demo          ║")
    (println "╚════════════════════════════════════════════════════════╝")
    (println "")
    (println "Controls:")
    (println "  • Click and hold mouse to spawn bouncy balls")
    (println "  • UP/DOWN arrows: change gravity by +/-1.0")
    (println "  • LEFT/RIGHT arrows: fine adjustment +/-0.1")
    (println "  • SPACE to clear all balls")
    (println "  • ESC to quit")
    (println "  • Gravity: negative = up, positive = down (no limit!)")
    (println "")
    
    /* Init SDL */
    (SDL_Init SDL_INIT_VIDEO)
    (TTF_Init)
    
    let window: SDL_Window = (SDL_CreateWindow "Bouncy Balls Physics Demo"
                                                SDL_WINDOWPOS_CENTERED
                                                SDL_WINDOWPOS_CENTERED
                                                WINDOW_WIDTH WINDOW_HEIGHT
                                                SDL_WINDOW_SHOWN)
    let renderer: SDL_Renderer = (SDL_CreateRenderer window -1
                                                      (+ SDL_RENDERER_ACCELERATED SDL_RENDERER_PRESENTVSYNC))
    
    let font: TTF_Font = (nl_open_font_portable "Arial" 14)
    
    /* Init Bullet Physics */
    let physics_ok: int = (nl_bullet_init)
    if (== physics_ok 0) {
        (println "✗ Physics initialization failed")
        (SDL_DestroyRenderer renderer)
        (SDL_DestroyWindow window)
        (TTF_Quit)
        (SDL_Quit)
        return 1
    } else {}
    (println "✓ Physics engine initialized")
    
    /* Create ball pit */
    # Bottom (thick to prevent fast balls from tunneling through)
    (nl_bullet_create_rigid_box 0.0 (- PIT_BOTTOM_Y PIT_WALL_THICKNESS) 0.0 
                                 (/ PIT_WIDTH 2.0) PIT_WALL_THICKNESS (/ PIT_WIDTH 2.0) 
                                 0.0 0.6)
    
    # Left wall
    let left_x: float = (- 0.0 (/ PIT_WIDTH 2.0))
    (nl_bullet_create_rigid_box left_x (+ PIT_BOTTOM_Y (/ PIT_HEIGHT 2.0)) 0.0 
                                 PIT_WALL_THICKNESS (/ PIT_HEIGHT 2.0) PIT_WALL_THICKNESS 
                                 0.0 0.6)
    
    # Right wall
    let right_x: float = (/ PIT_WIDTH 2.0)
    (nl_bullet_create_rigid_box right_x (+ PIT_BOTTOM_Y (/ PIT_HEIGHT 2.0)) 0.0 
                                 PIT_WALL_THICKNESS (/ PIT_HEIGHT 2.0) PIT_WALL_THICKNESS 
                                 0.0 0.6)

    # === Bottom obstacles (RANDOMIZED each run!) ===
    # Seed RNG with current time for different layouts each run
    set rng_state (SDL_GetTicks)
    
    let obstacle_restitution: float = 0.25
    let obstacle_depth: float = PIT_WALL_THICKNESS
    let base_y: float = (+ PIT_BOTTOM_Y 2.0)

    # Randomize V-funnel parameters
    let v_height_offset: float = (random_float 3.0 7.0)
    let v_angle: float = (random_float 15.0 40.0)
    let v_spread: float = (random_float 4.0 10.0)
    let v_length: float = (random_float 4.0 8.0)
    
    # Randomize ramp parameters
    let ramp_height_offset: float = (random_float 2.0 5.0)
    let ramp_angle: float = (random_float 10.0 30.0)
    let ramp_x_offset: float = (random_float 14.0 22.0)
    let ramp_length: float = (random_float 5.0 9.0)
    
    # Randomize peg parameters
    let peg_height_offset: float = (random_float 5.0 10.0)
    let peg1_x: float = (- 0.0 (random_float 8.0 14.0))
    let peg2_x: float = (random_float (- 0.0 3.0) 3.0)
    let peg3_x: float = (random_float 8.0 14.0)
    let peg_size: float = (random_float 0.8 1.5)

    # Center "V" funnel (randomized)
    (nl_bullet_create_rigid_box_rotated (- 0.0 v_spread) (+ base_y v_height_offset) 0.0 
                                         v_length 0.6 obstacle_depth v_angle 0.0 obstacle_restitution)
    (nl_bullet_create_rigid_box_rotated v_spread (+ base_y v_height_offset) 0.0 
                                         v_length 0.6 obstacle_depth (- 0.0 v_angle) 0.0 obstacle_restitution)

    # Left ramp (randomized)
    (nl_bullet_create_rigid_box_rotated (- 0.0 ramp_x_offset) (+ base_y ramp_height_offset) 0.0 
                                         ramp_length 0.6 obstacle_depth ramp_angle 0.0 obstacle_restitution)

    # Right ramp (randomized)
    (nl_bullet_create_rigid_box_rotated ramp_x_offset (+ base_y ramp_height_offset) 0.0 
                                         ramp_length 0.6 obstacle_depth (- 0.0 ramp_angle) 0.0 obstacle_restitution)

    # Pegs (randomized)
    (nl_bullet_create_rigid_box peg1_x (+ base_y peg_height_offset) 0.0 
                                 peg_size peg_size obstacle_depth 0.0 obstacle_restitution)
    (nl_bullet_create_rigid_box peg2_x (+ base_y (+ peg_height_offset 0.5)) 0.0 
                                 peg_size peg_size obstacle_depth 0.0 obstacle_restitution)
    (nl_bullet_create_rigid_box peg3_x (+ base_y peg_height_offset) 0.0 
                                 peg_size peg_size obstacle_depth 0.0 obstacle_restitution)
    
    (println "✓ Ball pit created with RANDOMIZED obstacles!")
    (println "  (Restart for a different layout)")
    (println "")
    (println "Ready! Click to start spawning balls...")
    
    /* Ball tracking */
    let mut ball_handles: array<int> = []
    let mut ball_colors: array<int> = []
    let mut last_spawn_time: int = 0
    let mut current_color: int = (random_color)
    let mut last_click_state: bool = false

    /* Gravity UI state (absolute) */
    let mut gravity_value: float = 1.0
    let mut gravity_slider: float = (gravity_value_to_slider gravity_value)
    
    /* Main loop */
    let mut running: bool = true
    
    while running {
        # Update UI mouse state once per frame (for slider interaction)
        (nl_ui_update_mouse_state)

        /* Event handling */
        if (== (nl_sdl_poll_event_quit) 1) {
            set running false
        } else {}
        
        let key: int = (nl_sdl_poll_keypress)
        
        # ESC to quit
        if (== key 41) {
            set running false
        } else {}
        
        # SPACE to clear balls
        if (== key 44) {
            let ball_count: int = (array_length ball_handles)
            (println (+ "Clearing " (+ (int_to_string ball_count) " balls...")))
            set ball_handles []
            set ball_colors []
        } else {}
        
        # UP arrow - increase gravity (more down = positive)
        if (== key 82) {
            set gravity_value (+ gravity_value 1.0)
            set gravity_slider (gravity_value_to_slider gravity_value)
        } else {}
        
        # DOWN arrow - decrease gravity (less down = negative)
        if (== key 81) {
            set gravity_value (- gravity_value 1.0)
            set gravity_slider (gravity_value_to_slider gravity_value)
        } else {}
        
        # RIGHT arrow - fine increase (+0.1)
        if (== key 79) {
            set gravity_value (+ gravity_value 0.1)
            set gravity_slider (gravity_value_to_slider gravity_value)
        } else {}
        
        # LEFT arrow - fine decrease (-0.1)
        if (== key 80) {
            set gravity_value (- gravity_value 0.1)
            set gravity_slider (gravity_value_to_slider gravity_value)
        } else {}
        
        /* Mouse input (hold to spawn) */
        let mouse_state: int = (nl_sdl_poll_mouse_state)
        let mouse_x: int = (/ mouse_state 10000)
        let mouse_y: int = (% mouse_state 10000)
        let mouse_down: bool = (!= mouse_state (- 1))
        
        let now: int = (SDL_GetTicks)
        let time_since_spawn: int = (- now last_spawn_time)
        
        /* Spawn balls when mouse held down */
        if mouse_down {
            # Generate new color when mouse is first pressed
            if (not last_click_state) {
                set current_color (random_color)
            } else {}
            
            if (>= time_since_spawn SPAWN_DELAY_MS) {
                let world_x: float = (unproject_x mouse_x)
                let world_y: float = (unproject_y mouse_y)
                
                # Spawn ball at cursor position
                let ball_handle: int = (nl_bullet_create_rigid_sphere 
                                        world_x world_y 0.0 
                                        BALL_RADIUS BALL_MASS BALL_RESTITUTION)
                
                if (!= ball_handle (- 1)) {
                    set ball_handles (array_push ball_handles ball_handle)
                    set ball_colors (array_push ball_colors current_color)
                    set last_spawn_time now
                } else {}
            } else {}
        } else {}
        
        set last_click_state mouse_down

        /* Gravity slider (absolute -10..+10), default +1 */
        set gravity_slider (nl_ui_slider renderer 10 55 200 18 gravity_slider)
        set gravity_value (slider_to_gravity_value gravity_slider)
        (nl_bullet_set_gravity 0.0 (- 0.0 gravity_value) 0.0)
        
        /* Physics step */
        (nl_bullet_step FRAME_TIME)
        
        /* Rendering */
        # Clear background
        (SDL_SetRenderDrawColor renderer 15 15 25 255)
        (SDL_RenderClear renderer)
        
        # Draw ball pit
        (SDL_SetRenderDrawColor renderer 80 80 100 255)
        
        # Bottom
        let pit_bottom_y_screen: int = (project_y PIT_BOTTOM_Y)
        let pit_left_screen: int = (project_x left_x)
        let pit_right_screen: int = (project_x right_x)
        let pit_width_screen: int = (- pit_right_screen pit_left_screen)
        let pit_thickness_screen: int = (cast_int (* PIT_WALL_THICKNESS CAMERA_SCALE))
        (nl_sdl_render_fill_rect renderer pit_left_screen pit_bottom_y_screen 
                                 pit_width_screen (* pit_thickness_screen 2))
        
        # Left wall
        let pit_height_screen: int = (cast_int (* PIT_HEIGHT CAMERA_SCALE))
        let left_wall_y: int = (- pit_bottom_y_screen pit_height_screen)
        (nl_sdl_render_fill_rect renderer pit_left_screen left_wall_y 
                                 (* pit_thickness_screen 2) pit_height_screen)
        
        # Right wall
        let right_wall_x: int = (- pit_right_screen (* pit_thickness_screen 2))
        (nl_sdl_render_fill_rect renderer right_wall_x left_wall_y 
                                 (* pit_thickness_screen 2) pit_height_screen)
        
        # Draw obstacles (using same randomized positions as physics)
        (SDL_SetRenderDrawColor renderer 100 90 120 255)
        
        # Center V funnel - draw as simple rectangles (approximation of angled boxes)
        let v_left_cx: int = (project_x (- 0.0 v_spread))
        let v_left_cy: int = (project_y (+ base_y v_height_offset))
        let v_right_cx: int = (project_x v_spread)
        let v_right_cy: int = (project_y (+ base_y v_height_offset))
        let v_draw_width: int = (cast_int (* (* v_length 2.0) CAMERA_SCALE))
        let v_draw_height: int = (cast_int (* 1.2 CAMERA_SCALE))
        (nl_sdl_render_fill_rect renderer (- v_left_cx (/ v_draw_width 2)) (- v_left_cy (/ v_draw_height 2)) v_draw_width v_draw_height)
        (nl_sdl_render_fill_rect renderer (- v_right_cx (/ v_draw_width 2)) (- v_right_cy (/ v_draw_height 2)) v_draw_width v_draw_height)
        
        # Left ramp
        let ramp_left_cx: int = (project_x (- 0.0 ramp_x_offset))
        let ramp_left_cy: int = (project_y (+ base_y ramp_height_offset))
        let ramp_draw_width: int = (cast_int (* (* ramp_length 2.0) CAMERA_SCALE))
        let ramp_draw_height: int = (cast_int (* 1.2 CAMERA_SCALE))
        (nl_sdl_render_fill_rect renderer (- ramp_left_cx (/ ramp_draw_width 2)) (- ramp_left_cy (/ ramp_draw_height 2)) ramp_draw_width ramp_draw_height)
        
        # Right ramp
        let ramp_right_cx: int = (project_x ramp_x_offset)
        let ramp_right_cy: int = (project_y (+ base_y ramp_height_offset))
        (nl_sdl_render_fill_rect renderer (- ramp_right_cx (/ ramp_draw_width 2)) (- ramp_right_cy (/ ramp_draw_height 2)) ramp_draw_width ramp_draw_height)
        
        # Pegs (using randomized positions and sizes)
        let peg_draw_size: int = (cast_int (* (* peg_size 2.0) CAMERA_SCALE))
        let peg1_cx: int = (project_x peg1_x)
        let peg1_cy: int = (project_y (+ base_y peg_height_offset))
        (nl_sdl_render_fill_rect renderer (- peg1_cx (/ peg_draw_size 2)) (- peg1_cy (/ peg_draw_size 2)) peg_draw_size peg_draw_size)
        
        let peg2_cx: int = (project_x peg2_x)
        let peg2_cy: int = (project_y (+ base_y (+ peg_height_offset 0.5)))
        (nl_sdl_render_fill_rect renderer (- peg2_cx (/ peg_draw_size 2)) (- peg2_cy (/ peg_draw_size 2)) peg_draw_size peg_draw_size)
        
        let peg3_cx: int = (project_x peg3_x)
        let peg3_cy: int = (project_y (+ base_y peg_height_offset))
        (nl_sdl_render_fill_rect renderer (- peg3_cx (/ peg_draw_size 2)) (- peg3_cy (/ peg_draw_size 2)) peg_draw_size peg_draw_size)
        
        # Draw balls
        let ball_count: int = (array_length ball_handles)
        let mut i: int = 0
        while (< i ball_count) {
            let handle: int = (at ball_handles i)
            let color: int = (at ball_colors i)
            
            let ball_x: float = (nl_bullet_get_rigid_body_x handle)
            let ball_y: float = (nl_bullet_get_rigid_body_y handle)
            
            let screen_x: int = (project_x ball_x)
            let screen_y: int = (project_y ball_y)
            let screen_radius: int = (cast_int (* BALL_RADIUS CAMERA_SCALE))
            
            # Extract RGB from color
            let r: int = (/ color 65536)
            let g: int = (% (/ color 256) 256)
            let b: int = (% color 256)
            
            (SDL_SetRenderDrawColor renderer r g b 255)
            (draw_filled_circle renderer screen_x screen_y screen_radius)
            
            set i (+ i 1)
        }
        
        # Draw UI text
        (SDL_SetRenderDrawColor renderer 240 240 255 255)
        (nl_ui_label renderer font (+ "Balls: " (int_to_string ball_count)) 10 10 240 240 255 255)
        (nl_ui_label renderer font "Click to spawn • SPACE to clear • ESC to quit" 10 30 200 200 220 255)
        (nl_ui_label renderer font (+ "Gravity: " (float_to_string_simple gravity_value)) 220 50 200 220 255 255)
        (nl_ui_label renderer font "UP/DOWN +/-1 • LEFT/RIGHT +/-0.1" 220 68 140 160 190 255)
        
        if mouse_down {
            (nl_ui_label renderer font "SPAWNING!" (- WINDOW_WIDTH 120) 10 100 255 100 255)
        } else {}
        
        (SDL_RenderPresent renderer)
        (SDL_Delay 16)
    }
    
    /* Cleanup */
    (println "")
    (println (+ "Final ball count: " (int_to_string (array_length ball_handles))))
    (println "Cleaning up...")
    
    (nl_bullet_cleanup)
    (TTF_CloseFont font)
    (SDL_DestroyRenderer renderer)
    (SDL_DestroyWindow window)
    (TTF_Quit)
    (SDL_Quit)
    
    (println "Done!")
    return 0
}

shadow main {
    assert true
}
