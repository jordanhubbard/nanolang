# PARTICLE EXPLOSION - Interactive Particle System
# Click to spawn explosions! Tests: Dynamic arrays, GC, SDL events
# MODERNIZED: Added Particle struct for cleaner data organization

unsafe module "modules/sdl/sdl.nano"
unsafe module "modules/sdl_helpers/sdl_helpers.nano"
unsafe module "modules/sdl_ttf/sdl_ttf.nano"
unsafe module "modules/sdl_ttf/sdl_ttf_helpers.nano"
module "modules/ui_widgets/ui_widgets.nano"

# === STRUCTS ===
struct Particle {
    x: float,
    y: float,
    vx: float,
    vy: float,
    life: float
}

# === CONSTANTS ===
let WINDOW_WIDTH: int = 800
let WINDOW_HEIGHT: int = 600
let PARTICLE_SIZE: int = 2
let PARTICLES_PER_EXPLOSION: int = 300
let GRAVITY: float = 100.0

# === PARTICLE PHYSICS ===

fn compute_horizontal_position(x: float, vx: float, dt: float) -> float {
    return (+ x (* vx dt))
}

shadow compute_horizontal_position {
    let new_x: float = (compute_horizontal_position 100.0 50.0 0.1)
    assert (> new_x 104.0)
    assert (< new_x 106.0)
}

fn compute_vertical_position(y: float, vy: float, dt: float, gravity: float) -> float {
    let new_vy: float = (+ vy (* gravity dt))
    return (+ y (* new_vy dt))
}

shadow compute_vertical_position {
    let new_y: float = (compute_vertical_position 100.0 0.0 0.1 10.0)
    assert (> new_y 100.0)
}

fn is_particle_offscreen(x: float, y: float, width: int, height: int) -> bool {
    let max_x: float = (cast_float width)
    let max_y: float = (cast_float height)
    return (cond
        ((< x 0.0) true)
        ((> x max_x) true)
        ((< y 0.0) true)
        ((> y max_y) true)
        (else false)
    )
}

shadow is_particle_offscreen {
    assert (== (is_particle_offscreen 50.0 50.0 100 100) false)
    assert (== (is_particle_offscreen -10.0 50.0 100 100) true)
    assert (== (is_particle_offscreen 50.0 200.0 100 100) true)
}

# === UI OVERLAY ===

fn draw_ui_overlay(renderer: SDL_Renderer, font: TTF_Font, particle_count: int) -> void {
    # Draw semi-transparent bar at bottom
    (SDL_SetRenderDrawColor renderer 0 0 0 200) 
    (nl_sdl_render_fill_rect renderer 0 (- WINDOW_HEIGHT 40) WINDOW_WIDTH 40) 
    
    # Draw help text using SDL_ttf
    let mut count_text: string = "Particles: "
    set count_text (+ count_text (int_to_string particle_count))
    (nl_draw_text_blended renderer font count_text 10 (- WINDOW_HEIGHT 30) 255 150 50 255) 
    
    (nl_draw_text_blended renderer font "Click to spawn explosions" (- (/ WINDOW_WIDTH 2) 100) (- WINDOW_HEIGHT 30) 100 200 255 255) 
    
}

shadow draw_ui_overlay {
    assert true
}

# === MAIN ===

fn main() -> int {
    
    # Initialize SDL
    (SDL_Init 32) 
    
    let window: SDL_Window = (SDL_CreateWindow "Nanolang Particles" 100 100 WINDOW_WIDTH WINDOW_HEIGHT 4)
    let renderer: SDL_Renderer = (SDL_CreateRenderer window -1 2)
    
    if (== renderer 0) {
        (println "Failed to create renderer")
        return 1
    } else {
        (println "âœ“ SDL initialized")
    }
    
    # Initialize SDL_ttf
    (TTF_Init) 
    
    # Load font
    let font: TTF_Font = (nl_open_font_portable "Arial" 16)
    if (== font 0) {
        (println "Failed to load font")
        (SDL_DestroyRenderer renderer) 
        (SDL_DestroyWindow window) 
        (SDL_Quit) 
        return 1
    } else {
        (println "âœ“ Font loaded")
    }
    
    # Disable mouse motion events to prevent event queue flooding
    # SDL_MOUSEMOTION = 0x400 = 1024
    (SDL_EventState 1024 0) 
    
    # Particle data (parallel arrays)
    let mut particle_x: array<float> = []
    let mut particle_y: array<float> = []
    let mut particle_vx: array<float> = []
    let mut particle_vy: array<float> = []
    let mut particle_life: array<int> = []
    
    # Spawn initial explosion at center
    (println "Spawning initial explosion...")
    let center_x: float = (/ (cast_float WINDOW_WIDTH) 2.0)
    let center_y: float = (/ (cast_float WINDOW_HEIGHT) 2.0)
    
    let mut i: int = 0
    while (< i PARTICLES_PER_EXPLOSION) {
        # Pseudo-random velocities using modulo
        let angle_seed: int = (* i 37)
        let speed_seed: int = (+ (* i 13) 7)
        
        let angle_mod: float = (cast_float (% angle_seed 360))
        let speed_mod: float = (cast_float (% speed_seed 100))
        
        # Simple velocity calculation (not true angles, just spread)
        let vx: float = (* (- angle_mod 180.0) 2.0)
        let vy: float = (* (- speed_mod 50.0) 2.0)
        
        set particle_x (array_push particle_x center_x)
        set particle_y (array_push particle_y center_y)
        set particle_vx (array_push particle_vx vx)
        set particle_vy (array_push particle_vy vy)
        set particle_life (array_push particle_life 100)
        
        set i (+ i 1)
    }
    
    (print "âœ“ Spawned ")
    (print PARTICLES_PER_EXPLOSION)
    (println " particles")
    (println "")
    
    # Main loop
    let dt: float = 0.016
    let mut frame: int = 0
    let mut running: bool = true
    
    # Adjustable gravity (slider controls this)
    let mut gravity: float = 100.0
    
    (println "")
    
    while running {
        # Handle keyboard input (ESC to quit)
        let key: int = (nl_sdl_poll_keypress)
        if (> key -1) {
            set running false
        }
        
        # Check for quit event (window close)
        let quit: int = (nl_sdl_poll_event_quit)
        if (== quit 1) {
            set running false
        }
        
        # Check for mouse click to spawn explosion
        let mouse: int = (nl_sdl_poll_mouse_click)
        if (> mouse -1) {
            # Decode mouse position: x * 10000 + y
            let click_x: float = (cast_float (/ mouse 10000))
            let click_y: float = (cast_float (% mouse 10000))
            
            # Spawn new explosion at click position
            set i 0
            while (< i PARTICLES_PER_EXPLOSION) {
                let angle_seed: int = (* i 37)
                let speed_seed: int = (+ (* i 13) 7)
                let angle_mod: float = (cast_float (% angle_seed 360))
                let speed_mod: float = (cast_float (% speed_seed 100))
                let vx: float = (* (- angle_mod 180.0) 2.0)
                let vy: float = (* (- speed_mod 50.0) 3.0)
                
                set particle_x (array_push particle_x click_x)
                set particle_y (array_push particle_y click_y)
                set particle_vx (array_push particle_vx vx)
                set particle_vy (array_push particle_vy vy)
                set particle_life (array_push particle_life 100)
                
                set i (+ i 1)
            }
        } else {
            (print "")
        }
        
        # Update particles
        let count: int = (array_length particle_x)
        let mut new_x: array<float> = []
        let mut new_y: array<float> = []
        let mut new_vx: array<float> = []
        let mut new_vy: array<float> = []
        let mut new_life: array<int> = []
        
        set i 0
        let mut alive_count: int = 0
        
        while (< i count) {
            let life: int = (at particle_life i)
            let new_life_val: int = (- life 1)
            
            # Keep particle if still alive and onscreen
            if (> new_life_val 0) {
                let x: float = (at particle_x i)
                let y: float = (at particle_y i)
                let vx: float = (at particle_vx i)
                let vy: float = (at particle_vy i)
                
                # Update velocity (gravity)
                let new_vy_val: float = (+ vy (* gravity dt))
                
                # Update position
                let new_x_val: float = (+ x (* vx dt))
                let new_y_val: float = (+ y (* new_vy_val dt))
                
                if (not (is_particle_offscreen new_x_val new_y_val WINDOW_WIDTH WINDOW_HEIGHT)) {
                    set new_x (array_push new_x new_x_val)
                    set new_y (array_push new_y new_y_val)
                    set new_vx (array_push new_vx vx)
                    set new_vy (array_push new_vy new_vy_val)
                    set new_life (array_push new_life new_life_val)
                    set alive_count (+ alive_count 1)
                } else {
                    (print "")
                }
            } else {
                (print "")
            }
            
            set i (+ i 1)
        }
        
        set particle_x new_x
        set particle_y new_y
        set particle_vx new_vx
        set particle_vy new_vy
        set particle_life new_life
        
        # Render
        (SDL_SetRenderDrawColor renderer 10 10 20 255) 
        (SDL_RenderClear renderer) 
        
        # Gravity slider in a panel
        (nl_ui_panel renderer 10 530 240 65 25 25 35 220) 
        (nl_ui_label renderer font "Physics Controls" 20 535 150 200 255 255) 
        
        # Gravity slider (bottom of screen) - range 0 to 300
        let gravity_norm: float = (/ gravity 300.0)
        let gravity_slider: float = (nl_ui_slider renderer 20 565 200 20 gravity_norm)
        set gravity (* gravity_slider 300.0)
        (nl_ui_label renderer font "Gravity" 20 548 200 200 200 255) 
        
        # Draw particles
        (SDL_SetRenderDrawColor renderer 255 200 100 255) 
        set i 0
        while (< i alive_count) {
            let px: int = (cast_int (at particle_x i))
            let py: int = (cast_int (at particle_y i))
            
            (nl_sdl_render_fill_rect renderer px py PARTICLE_SIZE PARTICLE_SIZE) 
            
            set i (+ i 1)
        }
        
        # Draw UI overlay
        let particle_count: int = (array_length particle_x)
        (draw_ui_overlay renderer font particle_count)
        
        # Draw on-screen help
        
        (SDL_RenderPresent renderer) 
        (SDL_Delay 16) 
        
        set frame (+ frame 1)
    }
    
    (println "")
    (println "âœ¨ Exiting...")
    (print "Total frames: ")
    (println frame)
    (println "")
    (println "âœ… FEATURES DEMONSTRATED:")
    (println "  â€¢ Dynamic particle arrays")
    (println "  â€¢ Automatic garbage collection")
    (println "  â€¢ Particle lifecycle management")
    (println "  â€¢ SDL2 rendering")
    (println "  â€¢ Physics simulation (gravity)")
    (println "  â€¢ Array filtering (dead particles removed)")
    (println "")
    (println "ðŸŽ† Particles exploded beautifully!")
    
    # Cleanup
    (TTF_CloseFont font) 
    (TTF_Quit) 
    (SDL_DestroyRenderer renderer) 
    (SDL_DestroyWindow window) 
    (SDL_Quit) 
    
    return 0
}

shadow main {
    assert (== (main) 0)
}

