# Example: SDL Texture Demo
# Purpose: Demonstrates dynamic texture creation and pixel-level updates with animated patterns
# Features: SDL textures, pixel manipulation, animation, SDL graphics
# Difficulty: Intermediate
# Category: graphics
# Prerequisites: sdl_drawing_primitives
# Expected Output: graphical

unsafe module "modules/sdl/sdl.nano"
unsafe module "modules/sdl_helpers/sdl_helpers.nano"
unsafe module "modules/sdl_ttf/sdl_ttf.nano"
unsafe module "modules/sdl_ttf/sdl_ttf_helpers.nano"

let WINDOW_WIDTH: int = 640
let WINDOW_HEIGHT: int = 480
let TEXTURE_WIDTH: int = 256
let TEXTURE_HEIGHT: int = 256

fn main() -> int {
    # Initialize SDL
    (SDL_Init SDL_INIT_VIDEO) 
    (TTF_Init) 
    
    let window: SDL_Window = (SDL_CreateWindow "Texture Demo" SDL_WINDOWPOS_CENTERED SDL_WINDOWPOS_CENTERED WINDOW_WIDTH WINDOW_HEIGHT SDL_WINDOW_SHOWN)
    let renderer: SDL_Renderer = (SDL_CreateRenderer window -1 (+ SDL_RENDERER_ACCELERATED SDL_RENDERER_PRESENTVSYNC))
    let font: TTF_Font = (nl_open_font_portable "Arial" 12)
    
    # Create a streaming texture (format: ARGB8888 = 372645892)
    let texture: SDL_Texture = (SDL_CreateTexture renderer 372645892 1 TEXTURE_WIDTH TEXTURE_HEIGHT)
    
    if (== texture 0) {
        (println (+ "Failed to create texture: " (SDL_GetError)))
        return 1
    } else {}
    
    (println "âœ“ Texture created successfully")
    
    # Set texture blend mode
    (SDL_SetTextureBlendMode texture SDL_BLENDMODE_BLEND) 
    
    # Create pixel buffer (will be updated each frame)
    let mut pixels: array<int> = []
    let pixel_count: int = (* TEXTURE_WIDTH TEXTURE_HEIGHT)
    let mut i: int = 0
    while (< i pixel_count) {
        set pixels (array_push pixels 0)
        set i (+ i 1)
    }
    
    # Main loop
    let mut running: bool = true
    let mut frame: int = 0
    
    while running {
        # Events
        let quit_event: int = (nl_sdl_poll_event_quit)
        (nl_sdl_poll_keypress) 
        let should_quit: bool = (cond
            ((!= quit_event 0) true)
            (else false)
        )
        if should_quit {
            set running false
        } else {}
        
        # Clear screen
        (SDL_SetRenderDrawColor renderer 30 30 40 255) 
        (SDL_RenderClear renderer) 
        
        # Generate animated pattern
        # (In real code, would update pixels array and call SDL_UpdateTexture)
        # For now, just render some shapes to show texture rendering works
        
        # Draw texture at center
        let tex_x: int = (/ (- WINDOW_WIDTH TEXTURE_WIDTH) 2)
        let tex_y: int = (/ (- WINDOW_HEIGHT TEXTURE_HEIGHT) 2)
        
        # Draw a colored rectangle as placeholder for texture content
        let r: int = (+ 128 (cast_int (* 127.0 (sin (* 0.05 (cast_float frame))))))
        let g: int = (+ 128 (cast_int (* 127.0 (sin (* 0.07 (cast_float frame))))))
        let b: int = (+ 128 (cast_int (* 127.0 (sin (* 0.03 (cast_float frame))))))
        (SDL_SetRenderDrawColor renderer r g b 255) 
        (nl_sdl_render_fill_rect renderer tex_x tex_y TEXTURE_WIDTH TEXTURE_HEIGHT) 
        
        # Draw border around texture area
        (SDL_SetRenderDrawColor renderer 255 255 255 255) 
        # Top
        (SDL_RenderDrawLine renderer tex_x tex_y (+ tex_x TEXTURE_WIDTH) tex_y) 
        # Bottom  
        (SDL_RenderDrawLine renderer tex_x (+ tex_y TEXTURE_HEIGHT) (+ tex_x TEXTURE_WIDTH) (+ tex_y TEXTURE_HEIGHT)) 
        # Left
        (SDL_RenderDrawLine renderer tex_x tex_y tex_x (+ tex_y TEXTURE_HEIGHT)) 
        # Right
        (SDL_RenderDrawLine renderer (+ tex_x TEXTURE_WIDTH) tex_y (+ tex_x TEXTURE_WIDTH) (+ tex_y TEXTURE_HEIGHT)) 
        
        # Draw on-screen help
        
        # Present
        (SDL_RenderPresent renderer) 
        (SDL_Delay 16) 
        
        set frame (+ frame 1)
    }
    
    # Cleanup
    (TTF_CloseFont font) 
    (SDL_DestroyTexture texture) 
    (SDL_DestroyRenderer renderer) 
    (SDL_DestroyWindow window) 
    (TTF_Quit) 
    (SDL_Quit) 
    
    (println "Done!")
    return 0
}

shadow main { assert true }
