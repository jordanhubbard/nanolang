# BOIDS - Visual Flocking Simulation with SDL
# Demonstrates: Vector math, steering behaviors, emergent behavior, SDL graphics
# MODERNIZED: Added Boid struct for cleaner data organization

import "modules/sdl/sdl.nano"
import "modules/sdl_helpers/sdl_helpers.nano"
import "modules/sdl_ttf/sdl_ttf.nano"
import "modules/sdl_ttf/sdl_ttf_helpers.nano"

# === STRUCTS ===
struct Boid {
    x: float,
    y: float,
    vx: float,
    vy: float
}

# === CONSTANTS ===
let WINDOW_WIDTH: int = 800
let WINDOW_HEIGHT: int = 600
let NUM_BOIDS: int = 50
let BOID_SIZE: int = 3
let MAX_SPEED: float = 100.0
let PERCEPTION_RADIUS: float = 50.0
let FPS: int = 60

# Flocking behavior constants
let VISUAL_RANGE: float = 75.0
let MIN_DISTANCE: float = 20.0
let COHESION_FACTOR: float = 0.005
let SEPARATION_FACTOR: float = 0.05
let ALIGNMENT_FACTOR: float = 0.05

# === VECTOR MATH ===

fn vec_length(dx: float, dy: float) -> float {
    return (sqrt (+ (* dx dx) (* dy dy)))
}

shadow vec_length {
    assert (== (vec_length 3.0 4.0) 5.0)
}

fn vec_normalize(dx: float, dy: float, length: float) -> float {
    if (> length 0.0) {
        return (/ dx length)
    } else {
        return 0.0
    }
}

shadow vec_normalize {
    let nx: float = (vec_normalize 3.0 4.0 5.0)
    assert (> nx 0.59)
    assert (< nx 0.61)
}

fn limit_speed(vx: float, vy: float, max_speed: float) -> float {
    let speed: float = (vec_length vx vy)
    if (> speed max_speed) {
        let scale: float = (/ max_speed speed)
        return (* vx scale)
    } else {
        return vx
    }
}

shadow limit_speed {
    let limited: float = (limit_speed 100.0 100.0 50.0)
    assert (< limited 50.0)
}

# === SIMPLIFIED BOID UPDATE (JUST WRAPPING FOR NOW) ===

fn wrap_coord(val: float, max: float) -> float {
    if (> val max) {
        return 0.0
    } else {
        if (< val 0.0) {
            return max
        } else {
            return val
        }
    }
}

shadow wrap_coord {
    assert (== (wrap_coord 50.0 100.0) 50.0)
    let wrapped: float = (wrap_coord 150.0 100.0)
    assert (< wrapped 1.0)
}

# === UI OVERLAY ===

fn draw_ui_overlay(renderer: SDL_Renderer, font: TTF_Font, boid_count: int) -> void {
    # Draw semi-transparent bar at bottom
    (SDL_SetRenderDrawColor renderer 0 0 0 200)
    (nl_sdl_render_fill_rect renderer 0 (- WINDOW_HEIGHT 30) WINDOW_WIDTH 30)
    
    # Draw "Boids: XX" text
    (nl_draw_text_blended renderer font "Boids: 50" 10 (- WINDOW_HEIGHT 25) 100 200 100 255)
    
    # Draw "ESC = Quit" text
    (nl_draw_text_blended renderer font "ESC = Quit" (- WINDOW_WIDTH 100) (- WINDOW_HEIGHT 25) 200 100 100 255)
}

# === MAIN ===

fn main() -> int {
    
    # Initialize SDL
    (SDL_Init 32)
    
    let window: SDL_Window = (SDL_CreateWindow "Nanolang Boids" 100 100 WINDOW_WIDTH WINDOW_HEIGHT 4)
    let renderer: SDL_Renderer = (SDL_CreateRenderer window -1 2)
    
    if (== renderer 0) {
        return 1
    } else {}
    
    # Initialize SDL_ttf
    (TTF_Init)
    
    # Load font
    let font: TTF_Font = (nl_open_font_portable "Arial" 16)
    if (== font 0) {
        (SDL_DestroyRenderer renderer)
        (SDL_DestroyWindow window)
        (SDL_Quit)
        return 1
    } else {}
    
    # Disable mouse motion events to prevent event queue flooding
    # SDL_MOUSEMOTION = 0x400 = 1024
    (SDL_EventState 1024 0)
    
    # Initialize boids with random-ish positions - pre-allocate arrays
    let mut boid_x: array<float> = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    let mut boid_y: array<float> = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    let mut boid_vx: array<float> = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    let mut boid_vy: array<float> = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    
    let mut i: int = 0
    while (< i NUM_BOIDS) {
        let i_f: float = (cast_float i)
        let x: float = (+ 100.0 (* 10.0 i_f))
        let y: float = (+ 100.0 (* 8.0 i_f))
        
        # Pseudo-random velocities
        let mod5: float = (cast_float (% i 5))
        let mod3: float = (cast_float (% i 3))
        let vx: float = (- (* 20.0 mod5) 40.0)
        let vy: float = (- (* 20.0 mod3) 30.0)
        
        (array_set boid_x i x)
        (array_set boid_y i y)
        (array_set boid_vx i vx)
        (array_set boid_vy i vy)
        
        set i (+ i 1)
    }
    
    # Main loop
    let dt: float = 0.016
    let mut frame: int = 0
    let mut running: bool = true
    
    while running {
        # Handle events - keypress drains the event queue
        let key: int = (nl_sdl_poll_keypress)
        if (> key -1) {
            if (== key 41) {
                # ESC key = quit
                set running false
            } else {
                (print "")
            }
        } else {
            (print "")
        }
        
        # Note: nl_sdl_poll_keypress already handles SDL_QUIT by pushing it back
        # But we still check for safety in case the queue wasn't empty
        let quit: int = (nl_sdl_poll_event_quit)
        if (== quit 1) {
            set running false
        } else {
            (print "")
        }
        
        # Apply flocking rules - pre-allocate arrays
        let mut new_vx: array<float> = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        let mut new_vy: array<float> = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        
        set i 0
        while (< i NUM_BOIDS) {
            let x: float = (at boid_x i)
            let y: float = (at boid_y i)
            let vx: float = (at boid_vx i)
            let vy: float = (at boid_vy i)
            
            # Initialize accumulator forces (use variables to avoid false warnings)
            let mut separation_x: float = 0.0
            let mut separation_y: float = 0.0
            let mut neighbor_count: int = 0
            let mut cohesion_x: float = (+ x separation_x)
            let mut cohesion_y: float = (+ y separation_y)
            let mut alignment_x: float = (- (+ vx cohesion_x) cohesion_x)
            let mut alignment_y: float = (- (+ vy cohesion_y) cohesion_y)
            
            # Reset accumulators to 0 (dummy read to avoid unused warnings)
            let _dummy: float = (+ (+ cohesion_x cohesion_y) (+ alignment_x alignment_y))
            set cohesion_x 0.0
            set cohesion_y 0.0
            set alignment_x 0.0
            set alignment_y 0.0
            
            # Check all other boids
            let mut j: int = 0
            while (< j NUM_BOIDS) {
                if (!= i j) {
                    let other_x: float = (at boid_x j)
                    let other_y: float = (at boid_y j)
                    let dx: float = (- other_x x)
                    let dy: float = (- other_y y)
                    let dist: float = (vec_length dx dy)
                    
                    if (< dist VISUAL_RANGE) {
                        # Cohesion: steer towards average position
                        set cohesion_x (+ cohesion_x other_x)
                        set cohesion_y (+ cohesion_y other_y)
                        
                        # Alignment: match velocity
                        set alignment_x (+ alignment_x (at boid_vx j))
                        set alignment_y (+ alignment_y (at boid_vy j))
                        
                        set neighbor_count (+ neighbor_count 1)
                    } else {}
                    
                    # Separation: avoid crowding
                    if (< dist MIN_DISTANCE) {
                        set separation_x (- separation_x dx)
                        set separation_y (- separation_y dy)
                    } else {}
                } else {}
                
                set j (+ j 1)
            }
            
            # Apply cohesion
            let mut new_vx_val: float = vx
            let mut new_vy_val: float = vy
            
            if (> neighbor_count 0) {
                let avg_x: float = (/ cohesion_x (cast_float neighbor_count))
                let avg_y: float = (/ cohesion_y (cast_float neighbor_count))
                set new_vx_val (+ new_vx_val (* (- avg_x x) COHESION_FACTOR))
                set new_vy_val (+ new_vy_val (* (- avg_y y) COHESION_FACTOR))
                
                let avg_vx: float = (/ alignment_x (cast_float neighbor_count))
                let avg_vy: float = (/ alignment_y (cast_float neighbor_count))
                set new_vx_val (+ new_vx_val (* (- avg_vx vx) ALIGNMENT_FACTOR))
                set new_vy_val (+ new_vy_val (* (- avg_vy vy) ALIGNMENT_FACTOR))
            } else {}
            
            # Apply separation
            set new_vx_val (+ new_vx_val (* separation_x SEPARATION_FACTOR))
            set new_vy_val (+ new_vy_val (* separation_y SEPARATION_FACTOR))
            
            # Limit speed
            let speed: float = (vec_length new_vx_val new_vy_val)
            if (> speed MAX_SPEED) {
                let scale: float = (/ MAX_SPEED speed)
                set new_vx_val (* new_vx_val scale)
                set new_vy_val (* new_vy_val scale)
            } else {}
            
            (array_set new_vx i new_vx_val)
            (array_set new_vy i new_vy_val)
            
            set i (+ i 1)
        }
        
        # Update velocities
        set boid_vx new_vx
        set boid_vy new_vy
        
        # Update positions - pre-allocate arrays
        let mut new_x: array<float> = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        let mut new_y: array<float> = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        
        set i 0
        while (< i NUM_BOIDS) {
            let x: float = (at boid_x i)
            let y: float = (at boid_y i)
            let vx: float = (at boid_vx i)
            let vy: float = (at boid_vy i)
            
            let mut new_x_val: float = (+ x (* vx dt))
            let mut new_y_val: float = (+ y (* vy dt))
            
            # Wrap around screen
            set new_x_val (wrap_coord new_x_val (cast_float WINDOW_WIDTH))
            set new_y_val (wrap_coord new_y_val (cast_float WINDOW_HEIGHT))
            
            (array_set new_x i new_x_val)
            (array_set new_y i new_y_val)
            
            set i (+ i 1)
        }
        
        set boid_x new_x
        set boid_y new_y
        
        # Render
        (SDL_SetRenderDrawColor renderer 10 10 30 255)
        (SDL_RenderClear renderer)
        
        # Draw boids
        (SDL_SetRenderDrawColor renderer 100 200 255 255)
        set i 0
        while (< i NUM_BOIDS) {
            let bx: int = (cast_int (at boid_x i))
            let by: int = (cast_int (at boid_y i))
            
            (nl_sdl_render_fill_rect renderer bx by BOID_SIZE BOID_SIZE)
            
            set i (+ i 1)
        }
        
        # Draw UI overlay
        (draw_ui_overlay renderer font NUM_BOIDS)
        
        (SDL_RenderPresent renderer)
        (SDL_Delay 16)
        
        set frame (+ frame 1)
    }
    
    (println "")
    (println "âœ… Simulation complete!")
    (print "Total frames: ")
    (println frame)
    
    # Cleanup
    (TTF_CloseFont font)
    (TTF_Quit)
    (SDL_DestroyRenderer renderer)
    (SDL_DestroyWindow window)
    (SDL_Quit)
    
    return 0
}

shadow main {
    assert (== (main) 0)
}
