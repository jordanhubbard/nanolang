# Example 24: Random Nonsense Sentence Generator
# Reads words from /usr/share/dict/words and generates random sentences

# External C functions for random numbers and time
extern fn rand() -> int
extern fn srand(seed: int) -> void
extern fn time(tloc: int) -> int

# String and character operations
extern fn strlen(s: string) -> int
extern fn strcmp(s1: string, s2: string) -> int
extern fn strchr(s: string, c: int) -> string

# Helper: Get a random number in range [min, max]
fn random_range(min: int, max: int) -> int {
    let diff: int = (- max min)
    let r: int = (% (rand) (+ diff 1))
    return (+ min r)
}

shadow random_range {
    # Seed for consistent testing
    (srand 12345)
    let r1: int = (random_range 0 10)
    let r2: int = (random_range 5 15)
    assert (>= r1 0)
    assert (<= r1 10)
    assert (>= r2 5)
    assert (<= r2 15)
}

# Parse words from dictionary content
# Returns the Nth word from the content (0-indexed)
fn get_word_at_index(content: string, index: int) -> string {
    let mut current_word_start: int = 0
    let mut current_index: int = 0
    let content_len: int = (strlen content)
    let mut pos: int = 0
    
    # Scan through content to find the Nth word
    while (< pos content_len) {
        let ch: int = (char_at content pos)
        
        # Check if we found a newline (word boundary)
        if (== ch 10) {  # 10 is '\n'
            # Is this the word we want?
            if (== current_index index) {
                # Extract substring from current_word_start to pos
                let word_len: int = (- pos current_word_start)
                return (str_substring content current_word_start word_len)
            } else {
                # Move to next word
                set current_index (+ current_index 1)
                set current_word_start (+ pos 1)
            }
        } else {
            # Continue in current word
        }
        
        set pos (+ pos 1)
    }
    
    # Handle last word if file doesn't end with newline
    if (== current_index index) {
        let word_len: int = (- pos current_word_start)
        return (str_substring content current_word_start word_len)
    }
    
    return ""
}

shadow get_word_at_index {
    let test_content: string = "apple\nbanana\ncherry\ndate\n"
    assert (str_equals (get_word_at_index test_content 0) "apple")
    assert (str_equals (get_word_at_index test_content 1) "banana")
    assert (str_equals (get_word_at_index test_content 2) "cherry")
    assert (str_equals (get_word_at_index test_content 3) "date")
}

# Count words in content (count newlines)
fn count_words(content: string) -> int {
    let mut count: int = 0
    let len: int = (strlen content)
    let mut pos: int = 0
    
    while (< pos len) {
        let ch: int = (char_at content pos)
        if (== ch 10) {  # '\n'
            set count (+ count 1)
        } else {
            # Continue
        }
        set pos (+ pos 1)
    }
    
    return count
}

shadow count_words {
    let test_content: string = "apple\nbanana\ncherry\ndate\n"
    assert (== (count_words test_content) 4)
}

# Generate a random sentence
fn generate_sentence(content: string, word_count: int) -> string {
    let total_words: int = (count_words content)
    
    if (== total_words 0) {
        return "Error: No words available"
    } else {
        # Build sentence word by word
        let mut sentence: string = ""
        let mut i: int = 0
        
        while (< i word_count) {
            # Get random word index
            let word_idx: int = (random_range 0 (- total_words 1))
            let word: string = (get_word_at_index content word_idx)
            
            # Add word to sentence
            if (== i 0) {
                # First word - capitalize it (just add as-is for now)
                set sentence word
            } else {
                # Add space and word
                set sentence (str_concat sentence " ")
                set sentence (str_concat sentence word)
            }
            
            set i (+ i 1)
        }
        
        # Add period at end
        set sentence (str_concat sentence ".")
        
        return sentence
    }
}

shadow generate_sentence {
    let test_content: string = "apple\nbanana\ncherry\ndate\negg\nfig\n"
    (srand 42)
    let sentence: string = (generate_sentence test_content 5)
    assert (> (strlen sentence) 0)
    # Sentence should end with period
    let last_char: int = (char_at sentence (- (strlen sentence) 1))
    assert (== last_char 46)  # 46 is '.'
}

# Main function
fn main() -> int {
    (println "========================================")
    (println "Random Nonsense Sentence Generator")
    (println "========================================")
    (println "")
    
    # Initialize random seed with current time
    let seed: int = (time 0)
    (srand seed)
    
    # Try to read dictionary file
    let dict_path: string = "/usr/share/dict/words"
    let content: string = (file_read dict_path)
    let content_len: int = (strlen content)
    
    if (== content_len 0) {
        (println "Error: Could not read dictionary file")
        (println "Expected file at: /usr/share/dict/words")
        return 1
    } else {
        let word_count_in_dict: int = (count_words content)
        (println "Dictionary loaded successfully!")
        (println "Total words available:")
        (println word_count_in_dict)
        (println "")
        
        # Generate 5 random sentences
        let mut i: int = 0
        while (< i 5) {
            let sentence_length: int = (random_range 3 10)
            (println (+ "Sentence: " (int_to_string (+ i 1))))
            (println (+ "Words: " (int_to_string sentence_length)))
            
            let sentence: string = (generate_sentence content sentence_length)
            (println sentence)
            (println "")
            
            set i (+ i 1)
        }
        
        (println "========================================")
        return 0
    }
}

shadow main {
    # Can't easily test file I/O in shadow tests
    # Just verify main returns 0 or 1
    let result: int = (main)
    assert (or (== result 0) (== result 1))
}

