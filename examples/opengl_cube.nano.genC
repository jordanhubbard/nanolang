#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <stdarg.h>
#include <math.h>

/* nanolang runtime */
#include "runtime/list_int.h"
#include "runtime/list_string.h"
#include "runtime/list_token.h"
#include <sys/stat.h>
#include <sys/types.h>
#include <dirent.h>
#include <unistd.h>
#include <libgen.h>

/* ========== OS Standard Library ========== */

static char* nl_os_file_read(const char* path) {
    FILE* f = fopen(path, "r");
    if (!f) return "";
    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    fseek(f, 0, SEEK_SET);
    char* buffer = malloc(size + 1);
    fread(buffer, 1, size, f);
    buffer[size] = '\0';
    fclose(f);
    return buffer;
}

static int64_t nl_os_file_write(const char* path, const char* content) {
    FILE* f = fopen(path, "w");
    if (!f) return -1;
    fputs(content, f);
    fclose(f);
    return 0;
}

static int64_t nl_os_file_append(const char* path, const char* content) {
    FILE* f = fopen(path, "a");
    if (!f) return -1;
    fputs(content, f);
    fclose(f);
    return 0;
}

static int64_t nl_os_file_remove(const char* path) {
    return remove(path) == 0 ? 0 : -1;
}

static int64_t nl_os_file_rename(const char* old_path, const char* new_path) {
    return rename(old_path, new_path) == 0 ? 0 : -1;
}

static bool nl_os_file_exists(const char* path) {
    return access(path, F_OK) == 0;
}

static int64_t nl_os_file_size(const char* path) {
    struct stat st;
    if (stat(path, &st) != 0) return -1;
    return st.st_size;
}

static int64_t nl_os_dir_create(const char* path) {
    return mkdir(path, 0755) == 0 ? 0 : -1;
}

static int64_t nl_os_dir_remove(const char* path) {
    return rmdir(path) == 0 ? 0 : -1;
}

static char* nl_os_dir_list(const char* path) {
    DIR* dir = opendir(path);
    if (!dir) return "";
    char* buffer = malloc(4096);
    buffer[0] = '\0';
    struct dirent* entry;
    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) continue;
        strcat(buffer, entry->d_name);
        strcat(buffer, "\n");
    }
    closedir(dir);
    return buffer;
}

static bool nl_os_dir_exists(const char* path) {
    struct stat st;
    if (stat(path, &st) != 0) return false;
    return S_ISDIR(st.st_mode);
}

static char* nl_os_getcwd(void) {
    char* buffer = malloc(1024);
    if (getcwd(buffer, 1024) == NULL) {
        buffer[0] = '\0';
    }
    return buffer;
}

static int64_t nl_os_chdir(const char* path) {
    return chdir(path) == 0 ? 0 : -1;
}

static bool nl_os_path_isfile(const char* path) {
    struct stat st;
    if (stat(path, &st) != 0) return false;
    return S_ISREG(st.st_mode);
}

static bool nl_os_path_isdir(const char* path) {
    struct stat st;
    if (stat(path, &st) != 0) return false;
    return S_ISDIR(st.st_mode);
}

static char* nl_os_path_join(const char* a, const char* b) {
    char* buffer = malloc(2048);
    if (strlen(a) == 0) {
        snprintf(buffer, 2048, "%s", b);
    } else if (a[strlen(a) - 1] == '/') {
        snprintf(buffer, 2048, "%s%s", a, b);
    } else {
        snprintf(buffer, 2048, "%s/%s", a, b);
    }
    return buffer;
}

static char* nl_os_path_basename(const char* path) {
    char* path_copy = strdup(path);
    char* base = basename(path_copy);
    char* result = strdup(base);
    free(path_copy);
    return result;
}

static char* nl_os_path_dirname(const char* path) {
    char* path_copy = strdup(path);
    char* dir = dirname(path_copy);
    char* result = strdup(dir);
    free(path_copy);
    return result;
}

static int64_t nl_os_system(const char* command) {
    return system(command);
}

static void nl_os_exit(int64_t code) {
    exit((int)code);
}

static char* nl_os_getenv(const char* name) {
    const char* value = getenv(name);
    return value ? (char*)value : "";
}

/* ========== End OS Standard Library ========== */

/* ========== Advanced String Operations ========== */

static int64_t char_at(const char* s, int64_t index) {
    int len = strlen(s);
    if (index < 0 || index >= len) {
        fprintf(stderr, "Error: Index %lld out of bounds (string length %d)\n", index, len);
        return 0;
    }
    return (unsigned char)s[index];
}

static char* string_from_char(int64_t c) {
    char* buffer = malloc(2);
    buffer[0] = (char)c;
    buffer[1] = '\0';
    return buffer;
}

static bool is_digit(int64_t c) {
    return c >= '0' && c <= '9';
}

static bool is_alpha(int64_t c) {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

static bool is_alnum(int64_t c) {
    return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

static bool is_whitespace(int64_t c) {
    return c == ' ' || c == '\t' || c == '\n' || c == '\r';
}

static bool is_upper(int64_t c) {
    return c >= 'A' && c <= 'Z';
}

static bool is_lower(int64_t c) {
    return c >= 'a' && c <= 'z';
}

static char* int_to_string(int64_t n) {
    char* buffer = malloc(32);
    snprintf(buffer, 32, "%lld", n);
    return buffer;
}

static int64_t string_to_int(const char* s) {
    return strtoll(s, NULL, 10);
}

static int64_t digit_value(int64_t c) {
    if (c >= '0' && c <= '9') {
        return c - '0';
    }
    return -1;
}

static int64_t char_to_lower(int64_t c) {
    if (c >= 'A' && c <= 'Z') {
        return c + 32;
    }
    return c;
}

static int64_t char_to_upper(int64_t c) {
    if (c >= 'a' && c <= 'z') {
        return c - 32;
    }
    return c;
}

/* ========== End Advanced String Operations ========== */

/* ========== Math and Utility Built-in Functions ========== */

#define nl_abs(x) _Generic((x), \
    int64_t: (int64_t)((x) < 0 ? -(x) : (x)), \
    double: (double)((x) < 0.0 ? -(x) : (x)))

#define nl_min(a, b) _Generic((a), \
    int64_t: (int64_t)((a) < (b) ? (a) : (b)), \
    double: (double)((a) < (b) ? (a) : (b)))

#define nl_max(a, b) _Generic((a), \
    int64_t: (int64_t)((a) > (b) ? (a) : (b)), \
    double: (double)((a) > (b) ? (a) : (b)))

static int64_t nl_cast_int(double x) { return (int64_t)x; }
static int64_t nl_cast_int_from_int(int64_t x) { return x; }
static double nl_cast_float(int64_t x) { return (double)x; }
static double nl_cast_float_from_float(double x) { return x; }
static int64_t nl_cast_bool_to_int(bool x) { return x ? 1 : 0; }
static bool nl_cast_bool(int64_t x) { return x != 0; }

static void nl_println(void* value_ptr) {
    /* This is a placeholder - actual implementation uses type info from checker */
}

static void nl_print_int(int64_t value) {
    printf("%lld", value);
}

static void nl_print_float(double value) {
    printf("%g", value);
}

static void nl_print_string(const char* value) {
    printf("%s", value);
}

static void nl_print_bool(bool value) {
    printf(value ? "true" : "false");
}

static void nl_println_int(int64_t value) {
    printf("%lld\n", value);
}

static void nl_println_float(double value) {
    printf("%g\n", value);
}

static void nl_println_string(const char* value) {
    printf("%s\n", value);
}

/* Dynamic array runtime (using GC) - LEGACY */
#include "runtime/gc.h"
#include "runtime/dyn_array.h"

static DynArray* dynarray_literal_int(int count, ...) {
    DynArray* arr = dyn_array_new(ELEM_INT);
    va_list args;
    va_start(args, count);
    for (int i = 0; i < count; i++) {
        int64_t val = va_arg(args, int64_t);
        dyn_array_push_int(arr, val);
    }
    va_end(args);
    return arr;
}

static DynArray* dynarray_literal_float(int count, ...) {
    DynArray* arr = dyn_array_new(ELEM_FLOAT);
    va_list args;
    va_start(args, count);
    for (int i = 0; i < count; i++) {
        double val = va_arg(args, double);
        dyn_array_push_float(arr, val);
    }
    va_end(args);
    return arr;
}

static DynArray* dynarray_push(DynArray* arr, double val) {
    if (arr->elem_type == ELEM_INT) {
        return dyn_array_push_int(arr, (int64_t)val);
    } else {
        return dyn_array_push_float(arr, val);
    }
}

static DynArray* nl_array_push(DynArray* arr, double val) {
    if (arr->elem_type == ELEM_INT) {
        return dyn_array_push_int(arr, (int64_t)val);
    } else {
        return dyn_array_push_float(arr, val);
    }
}

static double nl_array_pop(DynArray* arr) {
    bool success = false;
    if (arr->elem_type == ELEM_INT) {
        return (double)dyn_array_pop_int(arr, &success);
    } else {
        return dyn_array_pop_float(arr, &success);
    }
}

static int64_t nl_array_length(DynArray* arr) {
    return dyn_array_length(arr);
}

static int64_t nl_array_at_int(DynArray* arr, int64_t idx) {
    return dyn_array_get_int(arr, idx);
}

static double nl_array_at_float(DynArray* arr, int64_t idx) {
    return dyn_array_get_float(arr, idx);
}

static void nl_array_set_int(DynArray* arr, int64_t idx, int64_t val) {
    dyn_array_set_int(arr, idx, val);
}

static void nl_array_set_float(DynArray* arr, int64_t idx, double val) {
    dyn_array_set_float(arr, idx, val);
}

static DynArray* nl_array_new_int(int64_t size, int64_t default_val) {
    DynArray* arr = dyn_array_new(ELEM_INT);
    for (int64_t i = 0; i < size; i++) {
        dyn_array_push_int(arr, default_val);
    }
    return arr;
}

static int64_t dynarray_length(DynArray* arr) {
    return dyn_array_length(arr);
}

static double dynarray_at_for_transpiler(DynArray* arr, int64_t idx) {
    if (arr->elem_type == ELEM_INT) {
        return (double)dyn_array_get_int(arr, idx);
    } else {
        return dyn_array_get_float(arr, idx);
    }
}

/* String concatenation */
static const char* nl_str_concat(const char* s1, const char* s2) {
    size_t len1 = strlen(s1);
    size_t len2 = strlen(s2);
    char* result = malloc(len1 + len2 + 1);
    if (!result) return "";
    strcpy(result, s1);
    strcat(result, s2);
    return result;
}

/* String substring */
static const char* nl_str_substring(const char* str, int64_t start, int64_t length) {
    int64_t str_len = strlen(str);
    if (start < 0 || start >= str_len || length < 0) return "";
    if (start + length > str_len) length = str_len - start;
    char* result = malloc(length + 1);
    if (!result) return "";
    strncpy(result, str + start, length);
    result[length] = '\0';
    return result;
}

/* String contains */
static bool nl_str_contains(const char* str, const char* substr) {
    return strstr(str, substr) != NULL;
}

/* String equals */
static bool nl_str_equals(const char* s1, const char* s2) {
    return strcmp(s1, s2) == 0;
}

static void nl_println_bool(bool value) {
    printf("%s\n", value ? "true" : "false");
}

/* ========== Array Operations (With Bounds Checking!) ========== */

/* Array struct */
/* ========== End Array Operations ========== */

/* ========== End Math and Utility Built-in Functions ========== */

/* ========== Struct Definitions ========== */

/* ========== End Struct Definitions ========== */

/* ========== Enum Definitions ========== */

/* ========== End Enum Definitions ========== */

/* ========== Generic List Specializations ========== */

/* ========== End Generic List Specializations ========== */

/* ========== Union Definitions ========== */

/* ========== End Union Definitions ========== */

/* External C function declarations */
extern int64_t glfwInit();
extern void glfwTerminate();
extern int64_t glfwCreateWindow(int64_t width, int64_t height, const char* title, int64_t monitor, int64_t share);
extern void glfwDestroyWindow(int64_t window);
extern int64_t glfwWindowShouldClose(int64_t window);
extern void glfwSetWindowShouldClose(int64_t window, int64_t value);
extern void glfwSwapBuffers(int64_t window);
extern void glfwPollEvents();
extern void glfwMakeContextCurrent(int64_t window);
extern void glfwWindowHint(int64_t hint, int64_t value);
extern void glfwGetFramebufferSize(int64_t window, int64_t width_out, int64_t height_out);
extern int64_t glfwGetKey(int64_t window, int64_t key);
extern int64_t glfwGetMouseButton(int64_t window, int64_t button);
extern void glfwGetCursorPos(int64_t window, int64_t xpos_out, int64_t ypos_out);
extern double glfwGetTime();
extern void glfwSetTime(double time);
extern int64_t glewInit();
extern int64_t glewIsSupported(const char* extension);
extern const char* glewGetString(int64_t name);
extern const char* glewGetErrorString(int64_t error);
extern void glClear(int64_t mask);
extern void glClearColor(double r, double g, double b, double a);
extern void glViewport(int64_t x, int64_t y, int64_t width, int64_t height);
extern void glFlush();
extern void glFinish();
extern void glBegin(int64_t mode);
extern void glEnd();
extern void glVertex2f(double x, double y);
extern void glVertex3f(double x, double y, double z);
extern void glColor3f(double r, double g, double b);
extern void glColor4f(double r, double g, double b, double a);
extern void glMatrixMode(int64_t mode);
extern void glLoadIdentity();
extern void glOrtho(double left, double right, double bottom, double top, double near, double far);
extern void glTranslatef(double x, double y, double z);
extern void glRotatef(double angle, double x, double y, double z);
extern void glScalef(double x, double y, double z);
extern void glEnable(int64_t cap);
extern void glDisable(int64_t cap);
extern void glPushMatrix();
extern void glPopMatrix();
/* Forward declarations for module functions */
int64_t nl_char_at();
const char* nl_string_from_char();
bool nl_is_digit();
bool nl_is_alpha();
bool nl_is_alnum();
bool nl_is_whitespace();
bool nl_is_upper();
bool nl_is_lower();
const char* nl_int_to_string();
int64_t nl_string_to_int();
int64_t nl_digit_value();
int64_t nl_char_to_lower();
int64_t nl_char_to_upper();
List_int* nl_list_int_new();
List_int* nl_list_int_with_capacity();
void nl_list_int_push();
int64_t nl_list_int_pop();
int64_t nl_list_int_get();
void nl_list_int_set();
void nl_list_int_insert();
int64_t nl_list_int_remove();
int64_t nl_list_int_length();
int64_t nl_list_int_capacity();
bool nl_list_int_is_empty();
void nl_list_int_clear();
void nl_list_int_free();
List_string* nl_list_string_new();
List_string* nl_list_string_with_capacity();
void nl_list_string_push();
const char* nl_list_string_pop();
const char* nl_list_string_get();
void nl_list_string_set();
void nl_list_string_insert();
const char* nl_list_string_remove();
int64_t nl_list_string_length();
int64_t nl_list_string_capacity();
bool nl_list_string_is_empty();
void nl_list_string_clear();
void nl_list_string_free();
List_token* nl_list_token_new();
List_token* nl_list_token_with_capacity();
void nl_list_token_push();
void nl_list_token_set();
void nl_list_token_insert();
int64_t nl_list_token_length();
int64_t nl_list_token_capacity();
bool nl_list_token_is_empty();
void nl_list_token_clear();
void nl_list_token_free();
int64_t nl_char_at();
const char* nl_string_from_char();
bool nl_is_digit();
bool nl_is_alpha();
bool nl_is_alnum();
bool nl_is_whitespace();
bool nl_is_upper();
bool nl_is_lower();
const char* nl_int_to_string();
int64_t nl_string_to_int();
int64_t nl_digit_value();
int64_t nl_char_to_lower();
int64_t nl_char_to_upper();
List_int* nl_list_int_new();
List_int* nl_list_int_with_capacity();
void nl_list_int_push();
int64_t nl_list_int_pop();
int64_t nl_list_int_get();
void nl_list_int_set();
void nl_list_int_insert();
int64_t nl_list_int_remove();
int64_t nl_list_int_length();
int64_t nl_list_int_capacity();
bool nl_list_int_is_empty();
void nl_list_int_clear();
void nl_list_int_free();
List_string* nl_list_string_new();
List_string* nl_list_string_with_capacity();
void nl_list_string_push();
const char* nl_list_string_pop();
const char* nl_list_string_get();
void nl_list_string_set();
void nl_list_string_insert();
const char* nl_list_string_remove();
int64_t nl_list_string_length();
int64_t nl_list_string_capacity();
bool nl_list_string_is_empty();
void nl_list_string_clear();
void nl_list_string_free();
List_token* nl_list_token_new();
List_token* nl_list_token_with_capacity();
void nl_list_token_push();
void nl_list_token_set();
void nl_list_token_insert();
int64_t nl_list_token_length();
int64_t nl_list_token_capacity();
bool nl_list_token_is_empty();
void nl_list_token_clear();
void nl_list_token_free();
int64_t nl_char_at();
const char* nl_string_from_char();
bool nl_is_digit();
bool nl_is_alpha();
bool nl_is_alnum();
bool nl_is_whitespace();
bool nl_is_upper();
bool nl_is_lower();
const char* nl_int_to_string();
int64_t nl_string_to_int();
int64_t nl_digit_value();
int64_t nl_char_to_lower();
int64_t nl_char_to_upper();
List_int* nl_list_int_new();
List_int* nl_list_int_with_capacity();
void nl_list_int_push();
int64_t nl_list_int_pop();
int64_t nl_list_int_get();
void nl_list_int_set();
void nl_list_int_insert();
int64_t nl_list_int_remove();
int64_t nl_list_int_length();
int64_t nl_list_int_capacity();
bool nl_list_int_is_empty();
void nl_list_int_clear();
void nl_list_int_free();
List_string* nl_list_string_new();
List_string* nl_list_string_with_capacity();
void nl_list_string_push();
const char* nl_list_string_pop();
const char* nl_list_string_get();
void nl_list_string_set();
void nl_list_string_insert();
const char* nl_list_string_remove();
int64_t nl_list_string_length();
int64_t nl_list_string_capacity();
bool nl_list_string_is_empty();
void nl_list_string_clear();
void nl_list_string_free();
List_token* nl_list_token_new();
List_token* nl_list_token_with_capacity();
void nl_list_token_push();
void nl_list_token_set();
void nl_list_token_insert();
int64_t nl_list_token_length();
int64_t nl_list_token_capacity();
bool nl_list_token_is_empty();
void nl_list_token_clear();
void nl_list_token_free();

/* Top-level constants */
static const int64_t GL_COLOR_BUFFER_BIT = 16384LL;
static const int64_t GL_DEPTH_BUFFER_BIT = 256LL;
static const int64_t GL_DEPTH_TEST = 2929LL;
static const int64_t GL_QUADS = 7LL;
static const int64_t GL_MODELVIEW = 5888LL;
static const int64_t GL_PROJECTION = 5889LL;
static const int64_t GLEW_OK = 0LL;
static const int64_t GLFW_CONTEXT_VERSION_MAJOR = 139266LL;
static const int64_t GLFW_CONTEXT_VERSION_MINOR = 139267LL;
static const int64_t GLFW_OPENGL_PROFILE = 139272LL;
static const int64_t GLFW_OPENGL_CORE_PROFILE = 204801LL;
static const int64_t GLFW_KEY_ESCAPE = 256LL;
static const int64_t WINDOW_WIDTH = 800LL;
static const int64_t WINDOW_HEIGHT = 600LL;

/* Forward declarations for program functions */
void nl_setup_opengl();
void nl_draw_cube(double rotation);
int64_t nl_main();

void nl_setup_opengl() {
    glEnable(2929);
    glMatrixMode(5889);
    glLoadIdentity();
    glOrtho(-2, 2, -2, 2, 0.1, 100);
    glMatrixMode(5888);
}

void nl_draw_cube(double rotation) {
    glClear((16384 + 256));
    glLoadIdentity();
    glTranslatef(0, 0, -5);
    glRotatef(rotation, 1, 0.5, 0);
    glBegin(7);
    glColor3f(1, 0, 0);
    glVertex3f(-1, -1, 1);
    glVertex3f(1, -1, 1);
    glVertex3f(1, 1, 1);
    glVertex3f(-1, 1, 1);
    glColor3f(0, 1, 0);
    glVertex3f(-1, -1, -1);
    glVertex3f(-1, 1, -1);
    glVertex3f(1, 1, -1);
    glVertex3f(1, -1, -1);
    glColor3f(0, 0, 1);
    glVertex3f(-1, 1, -1);
    glVertex3f(-1, 1, 1);
    glVertex3f(1, 1, 1);
    glVertex3f(1, 1, -1);
    glColor3f(1, 1, 0);
    glVertex3f(-1, -1, -1);
    glVertex3f(1, -1, -1);
    glVertex3f(1, -1, 1);
    glVertex3f(-1, -1, 1);
    glColor3f(1, 0, 1);
    glVertex3f(1, -1, -1);
    glVertex3f(1, 1, -1);
    glVertex3f(1, 1, 1);
    glVertex3f(1, -1, 1);
    glColor3f(0, 1, 1);
    glVertex3f(-1, -1, -1);
    glVertex3f(-1, -1, 1);
    glVertex3f(-1, 1, 1);
    glVertex3f(-1, 1, -1);
    glEnd();
}

int64_t nl_main() {
    if (glfwInit() == 0LL) {
        nl_println_string("Failed to initialize GLFW!");
        return 1LL;
    }
    else {
        nl_println_string("✓ GLFW initialized");
    }
    int64_t window = glfwCreateWindow(800, 600, "OpenGL Rotating Cube - nanolang", 0LL, 0LL);
    if (window == 0LL) {
        nl_println_string("Failed to create GLFW window!");
        glfwTerminate();
        return 1LL;
    }
    else {
        nl_println_string("✓ Window created");
    }
    glfwMakeContextCurrent(window);
    int64_t glew_status = glewInit();
    if (glew_status != 0) {
        nl_println_string("Failed to initialize GLEW!");
        glfwTerminate();
        return 1LL;
    }
    else {
        nl_println_string("✓ GLEW initialized");
    }
    nl_setup_opengl();
    glClearColor(0.1, 0.1, 0.15, 1);
    nl_println_string("✓ OpenGL ready");
    nl_println_string("Press ESC to exit");
    nl_println_string("");
    double rotation = 0;
    int64_t frame_count = 0LL;
    while (glfwWindowShouldClose(window) == 0LL) {
        rotation = (rotation + 1);
        if (rotation >= 360) {
            rotation = 0;
        }
        else {
        }
        nl_draw_cube(rotation);
        glfwSwapBuffers(window);
        glfwPollEvents();
        if (glfwGetKey(window, 256) == 1LL) {
            glfwSetWindowShouldClose(window, 1LL);
        }
        else {
        }
        frame_count = (frame_count + 1LL);
    }
    nl_println_string("");
    nl_print_string("Rendered ");
    nl_print_int(frame_count);
    nl_println_string(" frames");
    glfwDestroyWindow(window);
    glfwTerminate();
    nl_println_string("✓ Cleanup complete");
    return 0LL;
}


/* C main() entry point - calls nanolang main (nl_main) */
int main() {
    return (int)nl_main();
}
