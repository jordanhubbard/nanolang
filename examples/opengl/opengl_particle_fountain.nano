# OpenGL Particle Fountain (Classic Blending + Points Demo)
# Demonstrates:
# - GL_POINTS rendering
# - Alpha blending
# - Simple particle simulation (CPU)
#
# Controls:
#   SPACE - Reset fountain
#   ESC   - Quit

unsafe module "modules/glfw/glfw.nano"
unsafe module "modules/glew/glew.nano"
unsafe module "modules/opengl/opengl.nano"

let WINDOW_WIDTH: int = 1000
let WINDOW_HEIGHT: int = 800

let MAX_PARTICLES: int = 700

fn clamp_float(v: float, lo: float, hi: float) -> float {
    if (< v lo) {
        return lo
    } else {
        if (> v hi) {
            return hi
        } else {
            return v
        }
    }
}

shadow clamp_float { assert (== (clamp_float 2.0 0.0 1.0) 1.0) }

fn setup_opengl() -> void {
    (glEnable GL_DEPTH_TEST)
    (glDepthFunc GL_LESS)
    (glEnable GL_BLEND)
    (glBlendFunc GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA)
    (glClearColor 0.02 0.02 0.04 1.0)

    (glMatrixMode GL_PROJECTION)
    (glLoadIdentity)
    let aspect: float = (/ (cast_float WINDOW_WIDTH) (cast_float WINDOW_HEIGHT))
    (glFrustum (* -0.6 aspect) (* 0.6 aspect) -0.6 0.6 1.0 200.0)
    (glMatrixMode GL_MODELVIEW)
}

shadow setup_opengl { assert true }

fn reset_particles(px: array<float>, py: array<float>, pz: array<float>, vx: array<float>, vy: array<float>, vz: array<float>, life: array<float>) -> void {
    let mut i: int = 0
    while (< i MAX_PARTICLES) {
        (array_set px i 0.0)
        (array_set py i (- 0.0 10.0))
        (array_set pz i 0.0)
        (array_set vx i 0.0)
        (array_set vy i 0.0)
        (array_set vz i 0.0)
        (array_set life i 0.0)
        set i (+ i 1)
    }
}

shadow reset_particles { assert true }

fn spawn_particle(i: int, px: array<float>, py: array<float>, pz: array<float>, vx: array<float>, vy: array<float>, vz: array<float>, life: array<float>, t: float) -> void {
    # deterministic pseudo-random using sin/cos
    let a: float = (* t 7.1)
    let j: float = (cast_float i)
    let dir_x: float = (sin (+ a (* j 0.13)))
    let dir_z: float = (cos (+ a (* j 0.17)))

    (array_set px i 0.0)
    (array_set py i (- 0.0 10.0))
    (array_set pz i 0.0)

    (array_set vx i (* dir_x 3.0))
    (array_set vz i (* dir_z 3.0))
    (array_set vy i (+ 14.0 (* (sin (+ a (* j 0.09))) 3.0)))

    (array_set life i 1.0)
}

shadow spawn_particle { assert true }

fn step_particles(px: array<float>, py: array<float>, pz: array<float>, vx: array<float>, vy: array<float>, vz: array<float>, life: array<float>, dt: float, t: float) -> void {
    let gravity: float = (- 0.0 9.0)
    let mut i: int = 0
    while (< i MAX_PARTICLES) {
        let l: float = (array_get life i)
        if (<= l 0.0) {
            (spawn_particle i px py pz vx vy vz life t)
        } else {
            let x: float = (array_get px i)
            let y: float = (array_get py i)
            let z: float = (array_get pz i)
            let vx_i: float = (array_get vx i)
            let vy_i: float = (array_get vy i)
            let vz_i: float = (array_get vz i)

            let vy_next: float = (+ vy_i (* gravity dt))
            (array_set vy i vy_next)

            (array_set px i (+ x (* vx_i dt)))
            (array_set py i (+ y (* vy_next dt)))
            (array_set pz i (+ z (* vz_i dt)))

            # fade and die when below ground
            let l_next: float = (- l (* dt 0.35))
            (array_set life i l_next)
            if (< (array_get py i) (- 0.0 18.0)) {
                (array_set life i 0.0)
            } else {}
        }
        set i (+ i 1)
    }
}

shadow step_particles { assert true }

fn render_particles(px: array<float>, py: array<float>, pz: array<float>, life: array<float>) -> void {
    (glClear (+ GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
    (glLoadIdentity)
    (glTranslatef 0.0 0.0 -60.0)

    # Floor reference plane
    (glDisable GL_LIGHTING)
    (glColor4f 0.2 0.2 0.25 0.7)
    (glBegin GL_QUADS)
    (glVertex3f -40.0 (- 0.0 18.0) -40.0)
    (glVertex3f 40.0 (- 0.0 18.0) -40.0)
    (glVertex3f 40.0 (- 0.0 18.0) 40.0)
    (glVertex3f -40.0 (- 0.0 18.0) 40.0)
    (glEnd)

    (glPointSize 4.0)
    (glBegin GL_POINTS)
    let mut i: int = 0
    while (< i MAX_PARTICLES) {
        let l: float = (array_get life i)
        if (> l 0.0) {
            let a: float = (clamp_float l 0.0 1.0)
            (glColor4f 0.4 (+ 0.3 (* a 0.7)) 1.0 a)
            (glVertex3f (array_get px i) (array_get py i) (array_get pz i))
        } else {}
        set i (+ i 1)
    }
    (glEnd)
    (glPointSize 1.0)
}

shadow render_particles { assert true }

fn main() -> int {
    if (== (glfwInit) 0) { return 1 } else {}
    let window: GLFWwindow = (glfwCreateWindow WINDOW_WIDTH WINDOW_HEIGHT "OpenGL Particle Fountain - NanoLang" 0 0)
    if (== window 0) {
        (glfwTerminate)
        return 1
    } else {}

    (glfwMakeContextCurrent window)
    (glfwSwapInterval 1)
    if (!= (glewInit) GLEW_OK) {
        (glfwTerminate)
        return 1
    } else {}

    (setup_opengl)
    (println "âœ“ Particle fountain running (SPACE reset, ESC quit)")

    let mut px: array<float> = (array_new MAX_PARTICLES 0.0)
    let mut py: array<float> = (array_new MAX_PARTICLES 0.0)
    let mut pz: array<float> = (array_new MAX_PARTICLES 0.0)
    let mut vx: array<float> = (array_new MAX_PARTICLES 0.0)
    let mut vy: array<float> = (array_new MAX_PARTICLES 0.0)
    let mut vz: array<float> = (array_new MAX_PARTICLES 0.0)
    let mut life: array<float> = (array_new MAX_PARTICLES 0.0)
    (reset_particles px py pz vx vy vz life)

    let mut last_t: float = (glfwGetTime)
    let mut last_space: int = 0

    while (== (glfwWindowShouldClose window) 0) {
        let now: float = (glfwGetTime)
        let dt_raw: float = (- now last_t)
        let dt: float = (clamp_float dt_raw 0.0 0.05)
        set last_t now

        if (== (glfwGetKey window GLFW_KEY_ESCAPE) 1) {
            (glfwSetWindowShouldClose window 1)
        } else {}

        let space: int = (glfwGetKey window GLFW_KEY_SPACE)
        if (and (== space 1) (== last_space 0)) {
            (reset_particles px py pz vx vy vz life)
        } else {}
        set last_space space

        (step_particles px py pz vx vy vz life dt now)
        (render_particles px py pz life)

        (glfwSwapBuffers window)
        (glfwPollEvents)
    }

    (glfwDestroyWindow window)
    (glfwTerminate)
    return 0
}

shadow main { assert true }

