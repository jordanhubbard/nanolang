# Example: Modern OpenGL Postprocess
# Purpose: Demonstrates offscreen rendering to a framebuffer object with a screen-space wave warp postprocess shader
# Features: OpenGL, GLFW, GLEW, FBO, framebuffer, texture, GLSL shaders, postprocessing, uniforms
# Difficulty: Advanced
# Category: opengl
# Prerequisites: opengl_modern_hello_triangle
# Expected Output: graphical

# Controls:
#   ESC - Quit

unsafe module "modules/glfw/glfw.nano"
unsafe module "modules/glew/glew.nano"
unsafe module "modules/opengl/opengl.nano"

let WINDOW_WIDTH: int = 1000
let WINDOW_HEIGHT: int = 700

fn main() -> int {
    if (== (glfwInit) 0) { return 1 } else {}
    let window: GLFWwindow = (glfwCreateWindow WINDOW_WIDTH WINDOW_HEIGHT "Modern OpenGL - Postprocess (NanoLang)" 0 0)
    if (== window 0) {
        (glfwTerminate)
        return 1
    } else {}

    (glfwMakeContextCurrent window)
    (glfwSwapInterval 1)
    if (!= (glewInit) GLEW_OK) {
        (glfwTerminate)
        return 1
    } else {}

    # Fullscreen triangle (clip space) with UV
    # vertex: x,y,u,v
    let mut tri: array<float> = []
    # big triangle covers screen
    set tri (array_push tri (- 1.0))
    set tri (array_push tri (- 1.0))
    set tri (array_push tri 0.0)
    set tri (array_push tri 0.0)

    set tri (array_push tri 3.0)
    set tri (array_push tri (- 1.0))
    set tri (array_push tri 2.0)
    set tri (array_push tri 0.0)

    set tri (array_push tri (- 1.0))
    set tri (array_push tri 3.0)
    set tri (array_push tri 0.0)
    set tri (array_push tri 2.0)

    let vao: int = (nl_gl3_gen_vertex_array)
    let vbo: int = (nl_gl3_gen_buffer)
    (nl_gl3_bind_vertex_array vao)
    (nl_gl3_bind_buffer GL_ARRAY_BUFFER vbo)
    (nl_gl3_buffer_data_f32 GL_ARRAY_BUFFER tri GL_STATIC_DRAW)
    (nl_gl3_enable_vertex_attrib_array 0)
    (nl_gl3_vertex_attrib_pointer_f32 0 2 0 16 0)
    (nl_gl3_enable_vertex_attrib_array 1)
    (nl_gl3_vertex_attrib_pointer_f32 1 2 0 16 8)

    # Program: sample texture, apply simple wave warp
    let vs: string =
        (+ (+ "#version 120\n"
              "attribute vec2 aPos; attribute vec2 aUV; varying vec2 vUV;\n")
           "void main(){ vUV=aUV; gl_Position=vec4(aPos,0.0,1.0);} \n")
    let fs: string =
        (+ (+ (+ (+ (+ (+ (+ "#version 120\n"
                            "uniform sampler2D uTex; uniform float uTime; varying vec2 vUV;\n")
                         "void main(){\n")
                      "  vec2 uv=vUV;\n")
                   "  uv.x += 0.02*sin(uv.y*10.0 + uTime);\n")
                "  vec4 c=texture2D(uTex, uv);\n")
             "  gl_FragColor=vec4(c.rgb,1.0);\n")
          "}\n")

    let program: int = (nl_gl3_create_program_from_sources vs fs)
    if (== program 0) {
        (println "Failed to build postprocess program")
        (glfwTerminate)
        return 1
    } else {}

    let loc_time: int = (nl_gl3_get_uniform_location program "uTime")
    let loc_tex: int = (nl_gl3_get_uniform_location program "uTex")

    # Create texture that we will render to (and also seed with checkerboard)
    let tex: int = (nl_gl3_gen_texture)
    (nl_gl3_active_texture GL_TEXTURE0)
    (nl_gl3_bind_texture GL_TEXTURE_2D tex)
    (nl_gl3_tex_parami GL_TEXTURE_2D GL_TEXTURE_MIN_FILTER GL_LINEAR)
    (nl_gl3_tex_parami GL_TEXTURE_2D GL_TEXTURE_MAG_FILTER GL_LINEAR)
    (nl_gl3_tex_parami GL_TEXTURE_2D GL_TEXTURE_WRAP_S GL_REPEAT)
    (nl_gl3_tex_parami GL_TEXTURE_2D GL_TEXTURE_WRAP_T GL_REPEAT)
    (nl_gl3_tex_image_2d_checker_rgba8 GL_TEXTURE_2D 512 512 32)

    # FBO with texture attachment (color-only for demo)
    let fbo: int = (nl_gl3_gen_framebuffer)
    (nl_gl3_bind_framebuffer GL_FRAMEBUFFER fbo)
    (nl_gl3_framebuffer_texture_2d GL_FRAMEBUFFER GL_COLOR_ATTACHMENT0 GL_TEXTURE_2D tex 0)
    let status: int = (nl_gl3_check_framebuffer_status GL_FRAMEBUFFER)
    if (!= status GL_FRAMEBUFFER_COMPLETE) {
        (println "FBO incomplete")
        (nl_gl3_bind_framebuffer GL_FRAMEBUFFER 0)
        (glfwTerminate)
        return 1
    } else {}
    (nl_gl3_bind_framebuffer GL_FRAMEBUFFER 0)

    (glClearColor 0.02 0.02 0.02 1.0)
    (println "âœ“ Postprocess demo running (ESC quit)")

    while (== (glfwWindowShouldClose window) 0) {
        if (== (glfwGetKey window GLFW_KEY_ESCAPE) 1) {
            (glfwSetWindowShouldClose window 1)
        } else {}

        let t: float = (glfwGetTime)

        # Render something to FBO (for now: clear with animated color)
        (nl_gl3_bind_framebuffer GL_FRAMEBUFFER fbo)
        (glViewport 0 0 512 512)
        (glClearColor 0.1 (+ 0.1 (* 0.1 (sin t))) 0.2 1.0)
        (glClear (+ GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
        (nl_gl3_bind_framebuffer GL_FRAMEBUFFER 0)

        # Postprocess to screen
        (glViewport 0 0 WINDOW_WIDTH WINDOW_HEIGHT)
        (glClearColor 0.02 0.02 0.02 1.0)
        (glClear (+ GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
        (nl_gl3_use_program program)
        (nl_gl3_uniform1f loc_time t)
        (nl_gl3_uniform1i loc_tex 0)
        (nl_gl3_bind_vertex_array vao)
        (nl_gl3_draw_arrays GL_TRIANGLES 0 3)

        (glfwSwapBuffers window)
        (glfwPollEvents)
    }

    (nl_gl3_use_program 0)
    (nl_gl3_delete_program program)
    (glfwDestroyWindow window)
    (glfwTerminate)
    return 0
}

shadow main { assert true }

