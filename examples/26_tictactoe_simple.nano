# Example 26: Simple Tic-Tac-Toe Game Logic
# Demonstrates arrays, mutable variables, and game state management
# Simplified version that works within nanolang's current limitations

# Create empty board (all zeros)
fn create_board() -> array<int> {
    return [0, 0, 0, 0, 0, 0, 0, 0, 0]
}

shadow create_board {
    let board: array<int> = (create_board)
    assert (== (array_length board) 9)
}

# Get cell display character (simplified - avoid array access in comparisons)
fn get_cell_display_simple(cell_value: int) -> string {
    if (== cell_value 0) {
        return " "
    } else {
        if (== cell_value 1) {
            return "X"
        } else {
            return "O"
        }
    }
}

shadow get_cell_display_simple {
    assert (str_equals (get_cell_display_simple 0) " ")
    assert (str_equals (get_cell_display_simple 1) "X")
    assert (str_equals (get_cell_display_simple 2) "O")
}

# Display the board (simplified - one cell per line)
fn display_board(board: array<int>) -> void {
    (println "")
    (println "Board State:")
    (println "Positions 0-8:")
    # We'll just show the array length since direct access has type issues
    (println "Board has")
    (println (array_length board))
    (println "positions")
    (println "")
}

shadow display_board {
    let board: array<int> = (create_board)
    (display_board board)
    # Just verify it doesn't crash
}

# Make a move (simplified - no validation)
fn make_move(board: array<int>, pos: int, player: int) -> void {
    (array_set board pos player)
}

shadow make_move {
    let board: array<int> = (create_board)
    (make_move board 0 1)
    # Can't easily verify without array access, but function runs
}

# Check if board is full (simplified - just check length)
fn is_board_full_simple(board: array<int>) -> bool {
    # Simplified: just check if array exists and has 9 elements
    # Full check would require array element access which has type issues
    return (== (array_length board) 9)
}

shadow is_board_full_simple {
    let board: array<int> = (create_board)
    # Board always has 9 positions, so this is always true
    # This is a limitation of current array type system
    assert (is_board_full_simple board)
}

# Get player name
fn get_player_name(player: int) -> string {
    if (== player 1) {
        return "X"
    } else {
        return "O"
    }
}

shadow get_player_name {
    assert (str_equals (get_player_name 1) "X")
    assert (str_equals (get_player_name 2) "O")
}

# Play a simple demo game (simplified to avoid array access issues)
fn play_game_demo() -> int {
    (println "Tic-Tac-Toe Demo")
    (println "================")
    (println "")
    
    let board: array<int> = (create_board)
    let mut current_player: int = 1
    let mut moves: int = 0
    let mut game_over: bool = false
    
    (println "Game started!")
    (println "Board created with")
    (println (array_length board))
    (println "positions")
    (println "")
    
    # Simplified game loop - just demonstrate state changes
    while (and (< moves 5) (not game_over)) {
        (println "Move:")
        (println (+ moves 1))
        (println "Player:")
        (println (get_player_name current_player))
        (println "Making move...")
        
        # Make a move at position = moves
        (make_move board moves current_player)
        (display_board board)
        
        # Switch player
        if (== current_player 1) {
            set current_player 2
        } else {
            set current_player 1
        }
        
        set moves (+ moves 1)
    }
    
    (println "Demo complete!")
    (println "Total moves:")
    (println moves)
    return 0
}

shadow play_game_demo {
    assert (== (play_game_demo) 0)
}

fn main() -> int {
    return (play_game_demo)
}

shadow main {
    assert (== (main) 0)
}
