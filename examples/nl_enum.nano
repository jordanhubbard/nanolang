# Test enum functionality

# Simple enum
enum Color {
    Red,
    Green,
    Blue
}

# Enum with explicit values
enum Status {
    Pending = 0,
    Active = 1,
    Done = 2
}

# Enum with non-sequential values
enum HttpStatus {
    Ok = 200,
    NotFound = 404,
    ServerError = 500
}

fn test_color() -> int {
    let c: Color = Color.Red
    return c
}

shadow test_color {
    assert (== (test_color) 0)
}

fn test_status() -> int {
    let s: Status = Status.Active
    return s
}

shadow test_status {
    assert (== (test_status) 1)
}

fn test_http() -> int {
    let h: HttpStatus = HttpStatus.Ok
    return h
}

shadow test_http {
    assert (== (test_http) 200)
}

fn color_to_int(c: Color) -> int {
    return c
}

shadow color_to_int {
    let red: Color = Color.Red
    let green: Color = Color.Green
    let blue: Color = Color.Blue
    assert (== (color_to_int red) 0)
    assert (== (color_to_int green) 1)
    assert (== (color_to_int blue) 2)
}

fn is_error(status: HttpStatus) -> bool {
    return (>= status 400)
}

shadow is_error {
    let ok: HttpStatus = HttpStatus.Ok
    let notfound: HttpStatus = HttpStatus.NotFound
    let error: HttpStatus = HttpStatus.ServerError
    assert (== (is_error ok) false)
    assert (== (is_error notfound) true)
    assert (== (is_error error) true)
}

fn bool_to_string(b: bool) -> string {
    return (cond ((== b true) "true") (else "false"))
}

shadow bool_to_string {
    assert (str_equals (bool_to_string true) "true")
    assert (str_equals (bool_to_string false) "false")
}

fn main() -> int {
    let color: Color = Color.Green
    (println (+ "Color value: " (int_to_string color)))
    
    let status: Status = Status.Done
    (println (+ "Status value: " (int_to_string status)))
    
    let http: HttpStatus = HttpStatus.NotFound
    (println (+ "HTTP status: " (int_to_string http)))
    (println (+ "Is error? " (bool_to_string (is_error http))))
    
    return 0
}

shadow main {
    assert (== (main) 0)
}

