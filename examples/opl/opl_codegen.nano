import "examples/opl/opl_json.nano"

module "modules/std/json/json.nano"

fn indent(n: int) -> string {
    let mut out: string = ""
    let mut i: int = 0
    while (< i n) {
        set out (+ out "    ")
        set i (+ i 1)
    }
    return out
}

shadow indent {
    assert (str_equals (indent 0) "")
    assert (str_equals (indent 2) "        ")
}

fn dq() -> string {
    return (string_from_char 34)
}

shadow dq {
    assert (== (str_length (dq)) 1)
}

fn q(s: string) -> string {
    let d: string = (dq)
    return (+ d (+ s d))
}

shadow q {
    assert (str_equals (q "x") "\"x\"")
}

fn escape_nano_string(s: string) -> string {
    let mut out: string = ""
    let mut i: int = 0
    let n: int = (str_length s)
    while (< i n) {
        let c: int = (char_at s i)
        if (== c (char_at "\\" 0)) {
            set out (+ out "\\\\")
        } else {
            if (== c (char_at "\"" 0)) {
                set out (+ out "\\\"")
            } else {
                if (== c 10) {
                    set out (+ out "\\n")
                } else {
                    set out (+ out (string_from_char c))
                }
            }
        }
        set i (+ i 1)
    }
    return out
}

shadow escape_nano_string {
    assert (str_equals (escape_nano_string "a\"b") "a\\\"b")
    assert (str_equals (escape_nano_string "a\\b") "a\\\\b")
}

fn emit_line(sb: string, line: string) -> string {
    return (+ sb (+ line (string_from_char 10)))
}

shadow emit_line {
    assert (str_equals (emit_line "" "x") (+ "x" (string_from_char 10)))
}

fn gen_expr_ir_as_string(expr: Json) -> string {
    # Keep this auditable: stringify exprIR and embed as JSON literal string for now.
    # Runtime skeleton will parse this when needed.
    return (stringify expr)
}

shadow gen_expr_ir_as_string {
    let e: Json = (new_object)
    (object_set e "kind" (new_string "id"))
    (object_set e "name" (new_string "x"))
    let s: string = (gen_expr_ir_as_string e)
    assert (> (str_length s) 0)
    (free e)
}

fn gen_program_from_plan(plan: Json) -> string {
    let mut out: string = ""

    set out (emit_line out (+ "module " (q "modules/std/json/json.nano")))
    set out (emit_line out (+ "module " (q "modules/std/fs.nano")))
    set out (emit_line out "")
    set out (emit_line out "# Generated by OPL codegen (skeleton)")
    set out (emit_line out "")

    set out (emit_line out "fn json_equals(a: Json, b: Json) -> bool {")
    set out (emit_line out (+ (indent 1) "let sa: string = (stringify a)"))
    set out (emit_line out (+ (indent 1) "let sb: string = (stringify b)"))
    set out (emit_line out (+ (indent 1) "return (str_equals sa sb)"))
    set out (emit_line out "}")
    set out (emit_line out "shadow json_equals {")
    set out (emit_line out (+ (indent 1) "let a: Json = (new_int 1)"))
    set out (emit_line out (+ (indent 1) "let b: Json = (new_int 1)"))
    set out (emit_line out (+ (indent 1) "assert (json_equals a b)"))
    set out (emit_line out (+ (indent 1) "(free a)"))
    set out (emit_line out (+ (indent 1) "(free b)"))
    set out (emit_line out "}")
    set out (emit_line out "")

    set out (emit_line out "fn value_to_bool(v: Json) -> bool {")
    set out (emit_line out (+ (indent 1) "if (is_null v) { return false } else {}"))
    set out (emit_line out (+ (indent 1) "if (is_bool v) { return (as_bool v) } else {}"))
    set out (emit_line out (+ (indent 1) "if (is_number v) { return (!= (as_int v) 0) } else {}"))
    set out (emit_line out (+ (indent 1) "if (is_string v) { return (> (str_length (as_string v)) 0) } else {}"))
    set out (emit_line out (+ (indent 1) "return true"))
    set out (emit_line out "}")
    set out (emit_line out "shadow value_to_bool {")
    set out (emit_line out (+ (indent 1) "let f: Json = (new_null)"))
    set out (emit_line out (+ (indent 1) "assert (not (value_to_bool f))"))
    set out (emit_line out (+ (indent 1) "(free f)"))
    set out (emit_line out "}")
    set out (emit_line out "")

    set out (emit_line out "fn eval_expr(env: Json, expr: Json) -> Json {")
    set out (emit_line out (+ (indent 1) (+ "let k: string = (get_string expr " (+ (q "kind") ")"))))
    set out (emit_line out (+ (indent 1) (+ "if (str_equals k " (+ (q "id") ") {"))))
    set out (emit_line out (+ (indent 2) (+ "return (get env (get_string expr " (+ (q "name") "))"))))
    set out (emit_line out (+ (indent 1) "} else {}"))
    set out (emit_line out (+ (indent 1) (+ "if (str_equals k " (+ (q "lit") ") {"))))
    set out (emit_line out (+ (indent 2) (+ "return (get expr " (+ (q "v") ")"))))
    set out (emit_line out (+ (indent 1) "} else {}"))
    set out (emit_line out (+ (indent 1) (+ "if (str_equals k " (+ (q "bin") ") {"))))
    set out (emit_line out (+ (indent 2) (+ "let op: string = (get_string expr " (+ (q "op") ")"))))
    set out (emit_line out (+ (indent 2) (+ "let a: Json = (eval_expr env (get expr " (+ (q "a") "))"))))
    set out (emit_line out (+ (indent 2) (+ "let b: Json = (eval_expr env (get expr " (+ (q "b") "))"))))
    set out (emit_line out (+ (indent 2) "let mut res: bool = false"))
    set out (emit_line out (+ (indent 2) (+ "if (str_equals op " (+ (q "==") ") { set res (json_equals a b) } else {}"))))
    set out (emit_line out (+ (indent 2) (+ "if (str_equals op " (+ (q "!=") ") { set res (not (json_equals a b)) } else {}"))))
    set out (emit_line out (+ (indent 2) "(free a)"))
    set out (emit_line out (+ (indent 2) "(free b)"))
    set out (emit_line out (+ (indent 2) "return (new_bool res)"))
    set out (emit_line out (+ (indent 1) "} else {}"))
    set out (emit_line out (+ (indent 1) "return (new_null)"))
    set out (emit_line out "}")
    set out (emit_line out "")

    set out (emit_line out "fn eval_value(env: Json, v: Json) -> Json {")
    set out (emit_line out (+ (indent 1) "if (is_object v) {"))
    set out (emit_line out (+ (indent 2) (+ "if (object_has v " (+ (q "$var") ") {"))))
    set out (emit_line out (+ (indent 3) (+ "return (get env (get_string v " (+ (q "$var") "))"))))
    set out (emit_line out (+ (indent 2) "} else {}"))
    set out (emit_line out (+ (indent 2) (+ "if (object_has v " (+ (q "$expr") ") {"))))
    set out (emit_line out (+ (indent 3) (+ "let e: Json = (get v " (+ (q "$expr") ")"))))
    set out (emit_line out (+ (indent 3) "let r: Json = (eval_expr env e)"))
    set out (emit_line out (+ (indent 3) "(free e)"))
    set out (emit_line out (+ (indent 3) "return r"))
    set out (emit_line out (+ (indent 2) "} else {}"))
    set out (emit_line out (+ (indent 1) "} else {}"))
    set out (emit_line out (+ (indent 1) "return (new_null)"))
    set out (emit_line out "}")
    set out (emit_line out "")

    set out (emit_line out "fn call_tool(tool: string, args: Json) -> Json {")
    set out (emit_line out (+ (indent 1) (+ "(println (+ " (+ (q "CALL ") " tool))"))))
    set out (emit_line out (+ (indent 1) "(println (stringify args))"))
    set out (emit_line out (+ (indent 1) "return (new_null)"))
    set out (emit_line out "}")
    set out (emit_line out "")

    set out (emit_line out "fn run_plan(plan: Json) -> int {")
    set out (emit_line out (+ (indent 1) (+ "let plans: Json = (get plan " (+ (q "plans") ")"))))
    set out (emit_line out (+ (indent 1) "let mut pi: int = 0"))
    set out (emit_line out (+ (indent 1) "let pn: int = (array_size plans)"))
    set out (emit_line out (+ (indent 1) "while (< pi pn) {"))
    set out (emit_line out (+ (indent 2) "let p: Json = (get_index plans pi)"))
    set out (emit_line out (+ (indent 2) "let env: Json = (new_object)"))
    set out (emit_line out (+ (indent 2) (+ "let steps: Json = (get p " (+ (q "steps") ")"))))
    set out (emit_line out (+ (indent 2) "let mut si: int = 0"))
    set out (emit_line out (+ (indent 2) "let sn: int = (array_size steps)"))
    set out (emit_line out (+ (indent 2) "while (< si sn) {"))
    set out (emit_line out (+ (indent 3) "let st: Json = (get_index steps si)"))
    set out (emit_line out (+ (indent 3) (+ "let op: string = (get_string st " (+ (q "op") ")"))))
    set out (emit_line out (+ (indent 3) (+ "if (str_equals op " (+ (q "call") ") {"))))
    set out (emit_line out (+ (indent 4) (+ "let tool: string = (get_string st " (+ (q "tool") ")"))))
    set out (emit_line out (+ (indent 4) (+ "let args_obj: Json = (get st " (+ (q "args") ")"))))
    set out (emit_line out (+ (indent 4) "let args_out: Json = (new_object)"))
    set out (emit_line out (+ (indent 4) "let ks: array<string> = (keys args_obj)"))
    set out (emit_line out (+ (indent 4) "let mut ki: int = 0"))
    set out (emit_line out (+ (indent 4) "while (< ki (array_length ks)) {"))
    set out (emit_line out (+ (indent 5) "let k: string = (at ks ki)"))
    set out (emit_line out (+ (indent 5) "let vsrc: Json = (get args_obj k)"))
    set out (emit_line out (+ (indent 5) "let v: Json = (eval_value env vsrc)"))
    set out (emit_line out (+ (indent 5) "(free vsrc)"))
    set out (emit_line out (+ (indent 5) "(object_set args_out k v)"))
    set out (emit_line out (+ (indent 5) "(free v)"))
    set out (emit_line out (+ (indent 5) "set ki (+ ki 1)"))
    set out (emit_line out (+ (indent 4) "}"))
    set out (emit_line out (+ (indent 4) "let res: Json = (call_tool tool args_out)"))
    set out (emit_line out (+ (indent 4) (+ "if (object_has st " (+ (q "saveAs") ") {"))))
    set out (emit_line out (+ (indent 5) (+ "let nm: string = (get_string st " (+ (q "saveAs") ")"))))
    set out (emit_line out (+ (indent 5) "(object_set env nm res)"))
    set out (emit_line out (+ (indent 4) "} else {}"))
    set out (emit_line out (+ (indent 4) "(free res)"))
    set out (emit_line out (+ (indent 4) "(free args_out)"))
    set out (emit_line out (+ (indent 4) "(free args_obj)"))
    set out (emit_line out (+ (indent 3) "} else {}"))
    set out (emit_line out (+ (indent 3) (+ "if (str_equals op " (+ (q "assert") ") {"))))
    set out (emit_line out (+ (indent 4) (+ "let csrc: Json = (get st " (+ (q "cond") ")"))))
    set out (emit_line out (+ (indent 4) "let c: Json = (eval_value env csrc)"))
    set out (emit_line out (+ (indent 4) "(free csrc)"))
    set out (emit_line out (+ (indent 4) "let ok: bool = (value_to_bool c)"))
    set out (emit_line out (+ (indent 4) "(free c)"))
    set out (emit_line out (+ (indent 4) "if (not ok) {"))
    set out (emit_line out (+ (indent 5) (+ "(println " (+ (q "ASSERT_FAILED") "))"))))
    set out (emit_line out (+ (indent 5) "return 1"))
    set out (emit_line out (+ (indent 4) "} else {}"))
    set out (emit_line out (+ (indent 3) "} else {}"))
    set out (emit_line out (+ (indent 3) (+ "if (str_equals op " (+ (q "emit") ") {"))))
    set out (emit_line out (+ (indent 4) (+ "let nm: string = (get_string st " (+ (q "name") ")"))))
    set out (emit_line out (+ (indent 4) (+ "let vsrc: Json = (get st " (+ (q "value") ")"))))
    set out (emit_line out (+ (indent 4) "let v: Json = (eval_value env vsrc)"))
    set out (emit_line out (+ (indent 4) "(free vsrc)"))
    set out (emit_line out (+ (indent 4) (+ "(println (+ " (+ (q "EMIT ") " nm))"))))
    set out (emit_line out (+ (indent 4) "(println (stringify v))"))
    set out (emit_line out (+ (indent 4) "(free v)"))
    set out (emit_line out (+ (indent 3) "} else {}"))
    set out (emit_line out (+ (indent 3) (+ "if (str_equals op " (+ (q "if") ") {"))))
    set out (emit_line out (+ (indent 4) (+ "let csrc: Json = (get st " (+ (q "cond") ")"))))
    set out (emit_line out (+ (indent 4) "let c: Json = (eval_value env csrc)"))
    set out (emit_line out (+ (indent 4) "(free csrc)"))
    set out (emit_line out (+ (indent 4) "let ok: bool = (value_to_bool c)"))
    set out (emit_line out (+ (indent 4) "(free c)"))
    set out (emit_line out (+ (indent 4) "if ok {"))
    set out (emit_line out (+ (indent 5) (+ "let inner: Json = (get st " (+ (q "then") ")"))))
    set out (emit_line out (+ (indent 5) "let mut ii: int = 0"))
    set out (emit_line out (+ (indent 5) "let inn: int = (array_size inner)"))
    set out (emit_line out (+ (indent 5) "while (< ii inn) {"))
    set out (emit_line out (+ (indent 6) "# NOTE: nested steps not executed in this skeleton"))
    set out (emit_line out (+ (indent 6) "set ii (+ ii 1)"))
    set out (emit_line out (+ (indent 5) "}"))
    set out (emit_line out (+ (indent 5) "(free inner)"))
    set out (emit_line out (+ (indent 4) "} else {"))
    set out (emit_line out (+ (indent 5) "# else branch ignored in skeleton"))
    set out (emit_line out (+ (indent 4) "}"))
    set out (emit_line out (+ (indent 3) "} else {}"))
    set out (emit_line out (+ (indent 3) "(free st)"))
    set out (emit_line out (+ (indent 3) "set si (+ si 1)"))
    set out (emit_line out (+ (indent 2) "}"))
    set out (emit_line out (+ (indent 2) "(free steps)"))
    set out (emit_line out (+ (indent 2) "(free env)"))
    set out (emit_line out (+ (indent 2) "(free p)"))
    set out (emit_line out (+ (indent 2) "set pi (+ pi 1)"))
    set out (emit_line out (+ (indent 1) "}"))
    set out (emit_line out (+ (indent 1) "(free plans)"))
    set out (emit_line out (+ (indent 1) "return 0"))
    set out (emit_line out "}")
    set out (emit_line out "")

    set out (emit_line out "fn main() -> int {")
    set out (emit_line out (+ (indent 1) "# TODO: load plan JSON and execute"))
    set out (emit_line out (+ (indent 1) "return 0"))
    set out (emit_line out "}")
    set out (emit_line out "shadow main { assert (== (main) 0) }")

    # Ensure plan is referenced so it stays live for generation debugging
    let pv: string = (get_string plan "planVersion")
    if (== (str_length pv) 0) { return out } else { return out }
}

shadow gen_program_from_plan {
    let src: string = (read "examples/opl/bundle/EXAMPLES.expected_plan.json")
    let plan: Json = (parse src)
    let prog: string = (gen_program_from_plan plan)
    assert (> (str_length prog) 100)
    (free plan)
}

