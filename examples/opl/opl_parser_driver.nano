# Example: OPL Parser Driver
# Purpose: Test driver that parses an OPL file and compares AST to expected output
# Features: imports, file I/O, JSON comparison, testing
# Difficulty: Intermediate
# Category: opl
# Prerequisites: opl_parser, opl_lexer
# Expected Output: none

# Note: Opaque types (regex, hashmap, JSON) are automatically GC-managed
import "examples/opl/opl_parser.nano"
import "examples/opl/opl_lexer.nano"

module "modules/std/fs.nano"
module "modules/std/json/json.nano"

fn resolve_bundle_path(relative: string) -> string {
    if (exists relative) { return relative } else {}
    let prefix: string = "examples/"
    let prefix_len: int = 9
    let rel_len: int = (str_length relative)
    if (>= rel_len prefix_len) {
        let head: string = (str_substring relative 0 prefix_len)
        if (== head prefix) {
            let trimmed: string = (str_substring relative prefix_len (- rel_len prefix_len))
            if (exists trimmed) { return trimmed } else {}
        } else {}
    } else {}
    return relative
}

shadow resolve_bundle_path {
    assert (== (resolve_bundle_path "/tmp") "/tmp")
}

fn main() -> int {
    let src: string = (read (resolve_bundle_path "examples/opl/bundle/EXAMPLES.opl"))
    let r: OplParseResult = (opl_parse src)
    if (not r.ok) {
        (println (+ "PARSE_ERROR " r.error.code))
        (println r.error.msg)
        return 1
    } else {}

    let got: string = (stringify r.ast)

    let exp_src: string = (read (resolve_bundle_path "examples/opl/bundle/EXAMPLES.expected_ast.json"))
    let exp_json: Json = (parse exp_src)
    let exp: string = (stringify exp_json)

    if (== got exp) {
        return 0
    } else {
        (println "AST_MISMATCH")
        (println got)
        (println exp)

        let lr: OplTokensResult = (opl_lex src)
        if lr.ok {
            let mut i: int = 0
            while (< i 20) {
                if (< i (array_length lr.kinds)) {
                    let start: int = (at lr.text_starts i)
                    let ln: int = (at lr.text_lens i)
                    let txt: string = (+ "" (str_substring lr.text_buf start ln))
                    (println (+ (int_to_string (at lr.kinds i)) (+ ":" txt)))
                } else {
                    (println "<eof>")
                }
                set i (+ i 1)
            }
        } else {
            (println (+ "LEX_ERR " lr.error.code))
        }

        return 2
    }
}

shadow main {
    assert (== (main) 0)
}
