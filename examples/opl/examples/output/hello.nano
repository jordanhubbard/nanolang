# Example: OPL Hello World Output
# Purpose: Generated OPL runtime skeleton that executes plan-based workflows
# Features: JSON manipulation, plan execution, conditional logic, code generation
# Difficulty: Advanced
# Category: opl
# Prerequisites: opl_cli
# Expected Output: none

module "modules/std/json/json.nano"
module "modules/std/fs.nano"

# Generated by OPL codegen (skeleton)

fn json_equals(a: Json, b: Json) -> bool {
    let sa: string = (stringify a)
    let sb: string = (stringify b)
    return (== sa sb)
}
shadow json_equals {
    let a: Json = (new_int 1)
    let b: Json = (new_int 1)
    assert (json_equals a b)
    (free a)
    (free b)
}

fn value_to_bool(v: Json) -> bool {
    if (is_null v) { return false } else {}
    if (is_bool v) { return (as_bool v) } else {}
    if (is_number v) { return (!= (as_int v) 0) } else {}
    if (is_string v) { return (> (str_length (as_string v)) 0) } else {}
    return true
}
shadow value_to_bool {
    let f: Json = (new_null)
    assert (not (value_to_bool f))
    (free f)
}

fn eval_expr(env: Json, expr: Json) -> Json {
    let k: string = (get_string expr "kind")
    if (== k "id") {
        return (get env (get_string expr "name"))
    } else {}
    if (== k "lit") {
        return (get expr "v")
    } else {}
    if (== k "bin") {
        let op: string = (get_string expr "op")
        let a: Json = (eval_expr env (get expr "a"))
        let b: Json = (eval_expr env (get expr "b"))
        let mut res: bool = false
        if (== op "==") { set res (json_equals a b) } else {}
        if (== op "!=") { set res (not (json_equals a b)) } else {}
        (free a)
        (free b)
        return (new_bool res)
    } else {}
    return (new_null)
}

fn eval_value(env: Json, v: Json) -> Json {
    if (is_object v) {
        if (object_has v "$var") {
            return (get env (get_string v "$var"))
        } else {}
        if (object_has v "$expr") {
            let e: Json = (get v "$expr")
            let r: Json = (eval_expr env e)
            (free e)
            return r
        } else {}
    } else {}
    return (new_null)
}

fn call_tool(tool: string, args: Json) -> Json {
    (println (+ "CALL " tool))
    (println (stringify args))
    return (new_null)
}

fn run_plan(plan: Json) -> int {
    let plans: Json = (get plan "plans")
    let mut pi: int = 0
    let pn: int = (array_size plans)
    while (< pi pn) {
        let p: Json = (get_index plans pi)
        let env: Json = (new_object)
        let steps: Json = (get p "steps")
        let mut si: int = 0
        let sn: int = (array_size steps)
        while (< si sn) {
            let st: Json = (get_index steps si)
            let op: string = (get_string st "op")
            if (== op "call") {
                let tool: string = (get_string st "tool")
                let args_obj: Json = (get st "args")
                let args_out: Json = (new_object)
                let ks: array<string> = (keys args_obj)
                let mut ki: int = 0
                while (< ki (array_length ks)) {
                    let k: string = (at ks ki)
                    let vsrc: Json = (get args_obj k)
                    let v: Json = (eval_value env vsrc)
                    (free vsrc)
                    (object_set args_out k v)
                    (free v)
                    set ki (+ ki 1)
                }
                let res: Json = (call_tool tool args_out)
                if (object_has st "saveAs") {
                    let nm: string = (get_string st "saveAs")
                    (object_set env nm res)
                } else {}
                (free res)
                (free args_out)
                (free args_obj)
            } else {}
            if (== op "assert") {
                let csrc: Json = (get st "cond")
                let c: Json = (eval_value env csrc)
                (free csrc)
                let ok: bool = (value_to_bool c)
                (free c)
                if (not ok) {
                    (println "ASSERT_FAILED"))
                    return 1
                } else {}
            } else {}
            if (== op "emit") {
                let nm: string = (get_string st "name")
                let vsrc: Json = (get st "value")
                let v: Json = (eval_value env vsrc)
                (free vsrc)
                (println (+ "EMIT " nm))
                (println (stringify v))
                (free v)
            } else {}
            if (== op "if") {
                let csrc: Json = (get st "cond")
                let c: Json = (eval_value env csrc)
                (free csrc)
                let ok: bool = (value_to_bool c)
                (free c)
                if ok {
                    let inner: Json = (get st "then")
                    let mut ii: int = 0
                    let inn: int = (array_size inner)
                    while (< ii inn) {
                        # NOTE: nested steps not executed in this skeleton
                        set ii (+ ii 1)
                    }
                    (free inner)
                } else {
                    # else branch ignored in skeleton
                }
            } else {}
            (free st)
            set si (+ si 1)
        }
        (free steps)
        (free env)
        (free p)
        set pi (+ pi 1)
    }
    (free plans)
    return 0
}

fn main() -> int {
    # TODO: load plan JSON and execute
    return 0
}
shadow main { assert (== (main) 0) }
