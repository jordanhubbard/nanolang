import "examples/opl/opl_ast.nano"
import "examples/opl/opl_lexer.nano"
import "examples/opl/opl_parser.nano"
import "examples/opl/opl_json.nano"

module "modules/std/json/json.nano"

fn opl_str_cmp(a: string, b: string) -> int {
    let la: int = (str_length a)
    let lb: int = (str_length b)
    let mut i: int = 0

    while (and (< i la) (< i lb)) {
        let ca: int = (char_at a i)
        let cb: int = (char_at b i)
        if (< ca cb) { return (- 0 1) } else {}
        if (> ca cb) { return 1 } else {}
        set i (+ i 1)
    }

    if (== la lb) { return 0 } else {}
    if (< la lb) { return (- 0 1) } else { return 1 }
}

shadow opl_str_cmp {
    assert (== (opl_str_cmp "a" "a") 0)
    assert (== (opl_str_cmp "a" "b") (- 0 1))
    assert (== (opl_str_cmp "b" "a") 1)
    assert (== (opl_str_cmp "a" "aa") (- 0 1))
}

fn v_tok_text(t: OplTokensResult, i: int) -> string {
    let start: int = (at t.text_starts i)
    let ln: int = (at t.text_lens i)
    return (+ "" (str_substring t.text_buf start ln))
}

shadow v_tok_text {
    let lr: OplTokensResult = (opl_lex "agent")
    assert lr.ok
    assert (== (v_tok_text lr 0) "agent")
}

fn err_json(code: string, msg: string, line: int, col: int, path: string) -> Json {
    let e: Json = (new_object)
    (opl_json_set_str e "code" code)
    (opl_json_set_str e "msg" msg)
    (opl_json_obj_set e "loc" (opl_json_loc line col))
    (opl_json_set_str e "path" path)
    return e
}

shadow err_json {
    let e: Json = (err_json "E" "m" 1 2 "/x")
    assert (== (as_string (get e "code")) "E")
    (free e)
}

fn add_error(errors: Json, code: string, msg: string, line: int, col: int, path: string) -> void {
    (opl_json_arr_push errors (err_json code msg line col path))
}

shadow add_error {
    let a: Json = (new_array)
    (add_error a "E" "m" 1 1 "/")
    assert (== (array_size a) 1)
    (free a)
}

fn validate_call_arg_dupes_and_ids_from_tokens(src: string, env: Json, errors: Json) -> void {
    let t: OplTokensResult = (opl_lex src)
    if (not t.ok) { return } else {}

    let mut i: int = 0
    let n: int = (array_length t.kinds)

    while (< i n) {
        if (== (at t.kinds i) OplTokKind.KW_CALL) {
            let mut j: int = (+ i 1)
            while (and (< j n) (!= (at t.kinds j) OplTokKind.LBRACE)) {
                set j (+ j 1)
            }
            if (>= j n) {
                set i (+ i 1)
            } else {
                set j (+ j 1)
                let seen: Json = (new_object)

                while (and (< j n) (!= (at t.kinds j) OplTokKind.RBRACE)) {
                    if (== (at t.kinds j) OplTokKind.IDENT) {
                        let key: string = (v_tok_text t j)
                        let key_line: int = (at t.lines j)
                        let key_col: int = (at t.cols j)

                        let has_colon: bool = (and (< (+ j 1) n) (== (at t.kinds (+ j 1)) OplTokKind.COLON))

                        if (and (object_has seen key) has_colon) {
                            (add_error errors "E_DUPLICATE_KEY" (+ "Duplicate key: " key) key_line key_col "/call/args")
                        } else {
                            (object_set seen key (new_bool true))
                        }

                        if has_colon {
                            let vpos: int = (+ j 2)
                            if (< vpos n) {
                                if (== (at t.kinds vpos) OplTokKind.IDENT) {
                                    let nm: string = (v_tok_text t vpos)
                                    if (not (object_has env nm)) {
                                        let vline: int = (at t.lines vpos)
                                        let vcol: int = (at t.cols vpos)
                                        (add_error errors "E_UNRESOLVED_ID" (+ "Unresolved identifier: " nm) vline vcol "/expr")
                                    } else {}
                                } else {}
                            } else {}
                        } else {}
                    } else {}

                    set j (+ j 1)
                }

                (free seen)
                set i j
            }
        } else {
            set i (+ i 1)
        }
    }
}

shadow validate_call_arg_dupes_and_ids_from_tokens {
    let env: Json = (new_object)
    (object_set env "q" (new_bool true))
    let errs: Json = (new_array)
    (validate_call_arg_dupes_and_ids_from_tokens "agent a { uses web.search input q:string call web.search { query: q, query: q } as r }" env errs)
    assert (> (array_size errs) 0)
    (free env)
    (free errs)
}

fn collect_uses(block: Json) -> Json {
    let uses: Json = (new_object)
    let body: Json = (get block "body")
    let n: int = (array_size body)
    let mut i: int = 0

    while (< i n) {
        let node: Json = (get_index body i)
        if (and (== (as_string (get node "kind")) "decl") (== (as_string (get node "declType")) "uses")) {
            let v: Json = (get node "value")
            let ref: string = (as_string (get v "ref"))
            (object_set uses ref (new_bool true))
            (free v)
        } else {}
        (free node)
        set i (+ i 1)
    }

    (free body)
    return uses
}

shadow collect_uses {
    let p: OplParseResult = (opl_parse "agent a { uses web.search }")
    let nodes: Json = (get p.ast "nodes")
    let b: Json = (get_index nodes 0)
    let u: Json = (collect_uses b)
    assert (object_has u "web.search")
    (free u)
    (free b)
    (free nodes)
    (free p.ast)
}

fn collect_inputs(block: Json) -> Json {
    let env: Json = (new_object)
    let body: Json = (get block "body")
    let n: int = (array_size body)
    let mut i: int = 0

    while (< i n) {
        let node: Json = (get_index body i)
        if (and (== (as_string (get node "kind")) "decl") (== (as_string (get node "declType")) "input")) {
            let arr: Json = (get node "value")
            let m: int = (array_size arr)
            let mut j: int = 0
            while (< j m) {
                let p: Json = (get_index arr j)
                let nm: string = (as_string (get p "name"))
                (object_set env nm (new_bool true))
                (free p)
                set j (+ j 1)
            }
            (free arr)
        } else {}
        (free node)
        set i (+ i 1)
    }

    (free body)
    return env
}

shadow collect_inputs {
    let p: OplParseResult = (opl_parse "agent a { input q:string }")
    let nodes: Json = (get p.ast "nodes")
    let b: Json = (get_index nodes 0)
    let env: Json = (collect_inputs b)
    assert (object_has env "q")
    (free env)
    (free b)
    (free nodes)
    (free p.ast)
}

fn validate_unresolved_ids_in_expr(expr: Json, env: Json, errors: Json) -> void {
    let k: string = (as_string (get expr "kind"))
    if (== k "id") {
        let nm: string = (as_string (get expr "name"))
        if (not (object_has env nm)) {
            let loc: Json = (get expr "loc")
            let line: int = (as_int (get loc "line"))
            let col: int = (as_int (get loc "col"))
            (free loc)
            (add_error errors "E_UNRESOLVED_ID" (+ "Unresolved identifier: " nm) line col "/expr")
        } else {}
    } else {}
}

shadow validate_unresolved_ids_in_expr {
    let env: Json = (new_object)
    let errs: Json = (new_array)
    let id: Json = (new_object)
    (opl_json_set_str id "kind" "id")
    (opl_json_set_str id "name" "x")
    (opl_json_obj_set id "loc" (opl_json_loc 1 2))
    (validate_unresolved_ids_in_expr id env errs)
    assert (== (array_size errs) 1)
    (free id)
    (free env)
    (free errs)
}

fn validate_block(block: Json, src: string, errors: Json) -> void {
    let uses: Json = (collect_uses block)
    let env: Json = (collect_inputs block)

    # token-based: duplicates + unresolved ids in call args
    (validate_call_arg_dupes_and_ids_from_tokens src env errors)

    let emits_seen: Json = (new_object)

    let body: Json = (get block "body")
    let n: int = (array_size body)
    let mut i: int = 0

    while (< i n) {
        let node: Json = (get_index body i)
        let kind: string = (as_string (get node "kind"))

        if (== kind "call") {
            let ref: string = (as_string (get node "ref"))
            if (not (object_has uses ref)) {
                let loc: Json = (get node "loc")
                let line: int = (as_int (get loc "line"))
                let col: int = (as_int (get loc "col"))
                (free loc)
                (add_error errors "E_CALL_NOT_ALLOWED" (+ "Call not allowed: " ref) line col "/call")
            } else {}

            let asv: Json = (get node "as")
            if (and (!= asv 0) (not (is_null asv))) {
                let nm: string = (as_string asv)
                if (object_has env nm) {
                    let loc: Json = (get node "loc")
                    let line: int = (as_int (get loc "line"))
                    let col: int = (as_int (get loc "col"))
                    (free loc)
                    (add_error errors "E_DUPLICATE_NAME" (+ "Duplicate name: " nm) line col "/call/as")
                } else {}
                (object_set env nm (new_bool true))
            } else {}
            (opl_json_free_if_not_null asv)
        } else {
            if (== kind "assert") {
                let condj: Json = (get node "cond")
                # minimal boolean check: literal non-bool is rejected
                if (== (as_string (get condj "kind")) "lit") {
                    let v: Json = (get condj "v")
                    if (not (is_bool v)) {
                        let loc: Json = (get node "loc")
                        let line: int = (as_int (get loc "line"))
                        let col: int = (as_int (get loc "col"))
                        (free loc)
                        (add_error errors "E_ASSERT_NOT_BOOLEAN" "Assert condition must be boolean" line col "/assert")
                    } else {}
                    (free v)
                } else {}

                (validate_unresolved_ids_in_expr condj env errors)
                (free condj)
            } else {
                if (== kind "emit") {
                    let nm: string = (as_string (get node "name"))
                    if (object_has emits_seen nm) {
                        let loc: Json = (get node "loc")
                        let line: int = (as_int (get loc "line"))
                        let col: int = (as_int (get loc "col"))
                        (free loc)
                        (add_error errors "E_DUPLICATE_NAME" (+ "Duplicate emit: " nm) line col "/emit")
                    } else {
                        (object_set emits_seen nm (new_bool true))
                    }
                    let ex: Json = (get node "expr")
                    (validate_unresolved_ids_in_expr ex env errors)
                    (free ex)
                } else {
                    if (== kind "rule") {
                        let actions: Json = (get node "actions")
                        if (== (array_size actions) 0) {
                            let loc: Json = (get node "loc")
                            let line: int = (as_int (get loc "line"))
                            let col: int = (as_int (get loc "col"))
                            (free loc)
                            (add_error errors "E_RULE_EMPTY_ACTIONS" "Rule has no actions" line col "/rule")
                        } else {}
                        (free actions)

                        let condj: Json = (get node "cond")
                        (validate_unresolved_ids_in_expr condj env errors)
                        (free condj)
                    } else {}
                }
            }
        }

        (free node)
        set i (+ i 1)
    }

    (free body)
    (free uses)
    (free env)
    (free emits_seen)
}

shadow validate_block {
    let src: string = "agent a { uses web.search input q:string call web.search { query: q, query: q } as r assert r != null else \"x\" }"
    let p: OplParseResult = (opl_parse src)
    let nodes: Json = (get p.ast "nodes")
    let b: Json = (get_index nodes 0)
    let errs: Json = (new_array)
    (validate_block b src errs)
    assert (> (array_size errs) 0)
    (free errs)
    (free b)
    (free nodes)
    (free p.ast)
}

pub fn opl_validate(src: string) -> Json {
    let p: OplParseResult = (opl_parse src)
    if (not p.ok) {
        let out: Json = (new_object)
        (opl_json_set_bool out "ok" false)
        let errs: Json = (new_array)
        (opl_json_arr_push errs (err_json p.error.code p.error.msg p.error.loc.line p.error.loc.col p.error.path))
        (opl_json_obj_set out "errors" errs)
        return out
    } else {}

    let errors: Json = (new_array)

    let root: Json = p.ast
    let seen_blocks: Json = (new_object)

    let nodes: Json = (get root "nodes")
    let n: int = (array_size nodes)
    let mut i: int = 0
    while (< i n) {
        let node: Json = (get_index nodes i)
        if (== (as_string (get node "kind")) "block") {
            let bt: string = (as_string (get node "blockType"))
            let nm: string = (as_string (get node "name"))
            let mut key: string = (+ bt ":")
            set key (+ key nm)
            if (object_has seen_blocks key) {
                let loc: Json = (get node "loc")
                let line: int = (as_int (get loc "line"))
                let col: int = (as_int (get loc "col"))
                (free loc)
                (add_error errors "E_DUPLICATE_NAME" (+ "Duplicate block name: " nm) line col "/nodes")
            } else {
                (object_set seen_blocks key (new_bool true))
            }

            (validate_block node src errors)
        } else {
            (add_error errors "E_DECL_OUTSIDE_BLOCK" "Declaration outside block" 1 1 "/nodes")
        }
        (free node)
        set i (+ i 1)
    }
    (free nodes)
    (free seen_blocks)

    let out: Json = (new_object)
    if (== (array_size errors) 0) {
        (opl_json_set_bool out "ok" true)
        (opl_json_obj_set out "errors" (new_array))
    } else {
        (opl_json_set_bool out "ok" false)
        (opl_json_obj_set out "errors" errors)
    }

    (free root)
    return out
}

shadow opl_validate {
    let r1: Json = (opl_validate "agent a {\n  call web.search { query: \"x\" }\n}\n")
    assert (not (as_bool (get r1 "ok")))
    (free r1)

    let r2: Json = (opl_validate "agent a {\n  uses web.search\n  call web.search { query: q }\n}\n")
    assert (not (as_bool (get r2 "ok")))
    (free r2)

    let r3: Json = (opl_validate "agent a {\n  uses web.search\n  input q:string\n  call web.search { query: q, query: q }\n}\n")
    assert (not (as_bool (get r3 "ok")))
    (free r3)

    let r4: Json = (opl_validate "agent a {
  uses web.search
  assert null else "x"
}
")
    assert (not (as_bool (get r4 "ok")))
    (free r4)
}
