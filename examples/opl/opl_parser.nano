# Example: OPL Parser
# Purpose: Parse OPL token streams into abstract syntax trees
# Features: recursive descent parsing, JSON AST, error handling, structs
# Difficulty: Advanced
# Category: opl
# Prerequisites: opl_ast, opl_lexer, opl_json
# Expected Output: none

import "examples/opl/opl_ast.nano"
import "examples/opl/opl_lexer.nano"
import "examples/opl/opl_json.nano"

module "modules/std/json/json.nano"

pub struct OplParseResult {
    ok: bool,
    ast: Json,
    error: OplError
}

fn opl_parse_ok(ast: Json) -> OplParseResult {
    return OplParseResult {
        ok: true,
        ast: ast,
        error: OplError { code: "", msg: "", loc: OplLoc { line: 1, col: 1 }, path: "" }
    }
}

fn opl_parse_err(err: OplError) -> OplParseResult {
    return OplParseResult {
        ok: false,
        ast: (new_null),
        error: err
    }
}

shadow opl_parse_ok {
    let j: Json = (new_object)
    let r: OplParseResult = (opl_parse_ok j)
    assert r.ok
    (free r.ast)
}

shadow opl_parse_err {
    let e: OplError = OplError { code: "E", msg: "m", loc: OplLoc { line: 1, col: 1 }, path: "" }
    let r: OplParseResult = (opl_parse_err e)
    assert (not r.ok)
}

fn tok_kind(t: OplTokensResult, i: int) -> int { return (at t.kinds i) }
fn tok_line(t: OplTokensResult, i: int) -> int { return (at t.lines i) }
fn tok_col(t: OplTokensResult, i: int) -> int { return (at t.cols i) }
fn tok_text(t: OplTokensResult, i: int) -> string {
    let start: int = (at t.text_starts i)
    let ln: int = (at t.text_lens i)
    return (+ "" (str_substring t.text_buf start ln))
}

fn make_parse_error(code: string, msg: string, t: OplTokensResult, pos: int) -> OplError {
    return (opl_make_error code msg (tok_line t pos) (tok_col t pos) "")
}

fn skip_newlines(t: OplTokensResult, pos_in: int) -> int {
    let mut pos: int = pos_in
    while (== (tok_kind t pos) OplTokKind.NEWLINE) {
        set pos (+ pos 1)
    }
    return pos
}

pub struct JsonPos {
    ok: bool,
    value: Json,
    pos: int,
    error: OplError
}

fn jp_ok(v: Json, pos: int) -> JsonPos {
    return JsonPos {
        ok: true,
        value: v,
        pos: pos,
        error: OplError { code: "", msg: "", loc: OplLoc { line: 1, col: 1 }, path: "" }
    }
}

fn jp_err(e: OplError, pos: int) -> JsonPos {
    return JsonPos {
        ok: false,
        value: (new_null),
        pos: pos,
        error: e
    }
}

fn expr_lit_null(line: int, col: int) -> Json {
    let o: Json = (new_object)
    (opl_json_set_str o "kind" "lit")
    (opl_json_obj_set o "v" (new_null))
    (opl_json_obj_set o "loc" (opl_json_loc line col))
    return o
}

fn expr_lit_int(v: int, line: int, col: int) -> Json {
    let o: Json = (new_object)
    (opl_json_set_str o "kind" "lit")
    (opl_json_obj_set o "v" (new_int v))
    (opl_json_obj_set o "loc" (opl_json_loc line col))
    return o
}

fn expr_lit_str(v: string, line: int, col: int) -> Json {
    let o: Json = (new_object)
    (opl_json_set_str o "kind" "lit")
    (opl_json_obj_set o "v" (new_string v))
    (opl_json_obj_set o "loc" (opl_json_loc line col))
    return o
}

fn expr_id(name: string, line: int, col: int) -> Json {
    let o: Json = (new_object)
    (opl_json_set_str o "kind" "id")
    (opl_json_set_str o "name" name)
    (opl_json_obj_set o "loc" (opl_json_loc line col))
    return o
}

fn expr_bin(op: string, a: Json, b: Json, line: int, col: int) -> Json {
    let o: Json = (new_object)
    (opl_json_set_str o "kind" "bin")
    (opl_json_set_str o "op" op)
    (opl_json_obj_set o "a" a)
    (opl_json_obj_set o "b" b)
    (opl_json_obj_set o "loc" (opl_json_loc line col))
    return o
}

fn parse_primary(t: OplTokensResult, pos: int) -> JsonPos {
    let k: int = (tok_kind t pos)
    let line: int = (tok_line t pos)
    let col: int = (tok_col t pos)

    if (== k OplTokKind.STRING) {
        return (jp_ok (expr_lit_str (tok_text t pos) line col) (+ pos 1))
    } else {}
    if (== k OplTokKind.NUMBER) {
        return (jp_ok (expr_lit_int (string_to_int (tok_text t pos)) line col) (+ pos 1))
    } else {}
    if (== k OplTokKind.KW_NULL) {
        return (jp_ok (expr_lit_null line col) (+ pos 1))
    } else {}
    if (== k OplTokKind.IDENT) {
        return (jp_ok (expr_id (tok_text t pos) line col) (+ pos 1))
    } else {}

    return (jp_err (make_parse_error "E_PARSE_UNEXPECTED_TOKEN" "Expected primary" t pos) pos)
}

fn parse_primary_at_col(t: OplTokensResult, pos: int, col_override: int) -> JsonPos {
    let k: int = (tok_kind t pos)
    let line: int = (tok_line t pos)

    if (== k OplTokKind.STRING) {
        return (jp_ok (expr_lit_str (tok_text t pos) line col_override) (+ pos 1))
    } else {}
    if (== k OplTokKind.NUMBER) {
        return (jp_ok (expr_lit_int (string_to_int (tok_text t pos)) line col_override) (+ pos 1))
    } else {}
    if (== k OplTokKind.KW_NULL) {
        return (jp_ok (expr_lit_null line col_override) (+ pos 1))
    } else {}
    if (== k OplTokKind.IDENT) {
        return (jp_ok (expr_id (tok_text t pos) line col_override) (+ pos 1))
    } else {}

    return (jp_err (make_parse_error "E_PARSE_UNEXPECTED_TOKEN" "Expected primary" t pos) pos)
}

fn parse_expr_simple(t: OplTokensResult, pos: int) -> JsonPos {
    let a: JsonPos = (parse_primary t pos)
    if (not a.ok) { return a } else {}

    let opk: int = (tok_kind t a.pos)
    if (== opk OplTokKind.NOTEQ) {
        let op_line: int = (tok_line t a.pos)
        let op_col: int = (tok_col t a.pos)
        let b: JsonPos = (parse_primary t (+ a.pos 1))
        if (not b.ok) {
            (free a.value)
            return b
        } else {}
        return (jp_ok (expr_bin "!=" a.value b.value op_line op_col) b.pos)
    } else {}

    if (== opk OplTokKind.EQEQ) {
        let op_line: int = (tok_line t a.pos)
        let op_col: int = (tok_col t a.pos)
        let b: JsonPos = (parse_primary t (+ a.pos 1))
        if (not b.ok) {
            (free a.value)
            return b
        } else {}
        return (jp_ok (expr_bin "==" a.value b.value op_line op_col) b.pos)
    } else {}

    return a
}

fn parse_type_obj(type_name: string) -> Json {
    let o: Json = (new_object)
    (opl_json_set_str o "t" type_name)
    return o
}

fn parse_param_list(t: OplTokensResult, pos_in: int, decl_col: int) -> JsonPos {
    let mut pos: int = pos_in
    let out: Json = (new_array)

    if (!= (tok_kind t pos) OplTokKind.IDENT) {
        (free out)
        return (jp_err (make_parse_error "E_PARSE_EXPECTED_TOKEN" "Expected param name" t pos) pos)
    } else {}

    let base: int = (- (tok_col t pos) decl_col)

    let mut more: bool = true
    while more {
        if (!= (tok_kind t pos) OplTokKind.IDENT) {
            (free out)
            return (jp_err (make_parse_error "E_PARSE_EXPECTED_TOKEN" "Expected param name" t pos) pos)
        } else {}

        let pline: int = (tok_line t pos)
        let pcol: int = (- (tok_col t pos) base)
        let pname: string = (tok_text t pos)
        set pos (+ pos 1)

        if (!= (tok_kind t pos) OplTokKind.COLON) {
            (free out)
            return (jp_err (make_parse_error "E_PARSE_EXPECTED_TOKEN" "Expected ':'" t pos) pos)
        } else {}
        set pos (+ pos 1)

        if (!= (tok_kind t pos) OplTokKind.IDENT) {
            (free out)
            return (jp_err (make_parse_error "E_PARSE_EXPECTED_TOKEN" "Expected type" t pos) pos)
        } else {}
        let tname: string = (tok_text t pos)
        set pos (+ pos 1)

        let p: Json = (new_object)
        (opl_json_set_str p "name" pname)
        (opl_json_obj_set p "type" (parse_type_obj tname))

        if (== (tok_kind t pos) OplTokKind.EQ) {
            set pos (+ pos 1)
            let dv_col: int = (+ (- (tok_col t pos) base) 1)
            let dv: JsonPos = (parse_primary_at_col t pos dv_col)
            if (not dv.ok) {
                (free p)
                (free out)
                return dv
            } else {}
            (opl_json_obj_set p "default" dv.value)
            set pos dv.pos
        } else {
            (opl_json_obj_set p "default" (new_null))
        }

        (opl_json_obj_set p "loc" (opl_json_loc pline pcol))
        (opl_json_arr_push out p)

        if (== (tok_kind t pos) OplTokKind.COMMA) {
            set pos (+ pos 1)
        } else {
            set more false
        }
    }

    return (jp_ok out pos)
}

fn parse_args_object(t: OplTokensResult, pos_in: int, col_delta: int) -> JsonPos {
    let mut pos: int = pos_in
    let args: Json = (new_object)

    if (== (tok_kind t pos) OplTokKind.RBRACE) {
        return (jp_ok args (+ pos 1))
    } else {}

    let mut more: bool = true
    while more {
        if (!= (tok_kind t pos) OplTokKind.IDENT) {
            (free args)
            return (jp_err (make_parse_error "E_PARSE_EXPECTED_TOKEN" "Expected arg key" t pos) pos)
        } else {}
        let key: string = (tok_text t pos)
        set pos (+ pos 1)

        if (!= (tok_kind t pos) OplTokKind.COLON) {
            (free args)
            return (jp_err (make_parse_error "E_PARSE_EXPECTED_TOKEN" "Expected ':'" t pos) pos)
        } else {}
        set pos (+ pos 1)

        let ev_col: int = (+ (tok_col t pos) col_delta)
        let ev: JsonPos = (parse_primary_at_col t pos ev_col)
        if (not ev.ok) {
            (free args)
            return ev
        } else {}
        set pos ev.pos
        (opl_json_obj_set args key ev.value)

        if (== (tok_kind t pos) OplTokKind.COMMA) {
            set pos (+ pos 1)
        } else {
            set more false
        }
    }

    if (!= (tok_kind t pos) OplTokKind.RBRACE) {
        (free args)
        return (jp_err (make_parse_error "E_PARSE_EXPECTED_TOKEN" "Expected '}'" t pos) pos)
    } else {}

    return (jp_ok args (+ pos 1))
}

pub fn opl_parse(text: string) -> OplParseResult {
    let lr: OplTokensResult = (opl_lex text)
    if (not lr.ok) { return (opl_parse_err lr.error) } else {}

    let root: Json = (new_object)
    (opl_json_set_str root "version" "opl-0.1")

    let nodes: Json = (new_array)

    let mut pos: int = 0
    let mut done: bool = false

    while (not done) {
        set pos (skip_newlines lr pos)
        let k: int = (tok_kind lr pos)

        if (== k OplTokKind.EOF) {
            set done true
        } else {
            if (== k OplTokKind.KW_AGENT) {
                let bline: int = (tok_line lr pos)
                let bcol: int = (tok_col lr pos)
                set pos (+ pos 1)

                if (!= (tok_kind lr pos) OplTokKind.IDENT) {
                    return (opl_parse_err (make_parse_error "E_PARSE_EXPECTED_TOKEN" "Expected block name" lr pos))
                } else {}
                let name: string = (tok_text lr pos)
                set pos (+ pos 1)

                if (!= (tok_kind lr pos) OplTokKind.LBRACE) {
                    return (opl_parse_err (make_parse_error "E_PARSE_EXPECTED_TOKEN" "Expected '{'" lr pos))
                } else {}
                set pos (+ pos 1)

                let block: Json = (new_object)
                (opl_json_set_str block "kind" "block")
                (opl_json_set_str block "blockType" "agent")
                (opl_json_set_str block "name" name)
                (opl_json_obj_set block "loc" (opl_json_loc bline bcol))

                let body: Json = (new_array)

                while (!= (tok_kind lr pos) OplTokKind.RBRACE) {
                    let bk: int = (tok_kind lr pos)

                    if (== bk OplTokKind.KW_DOC) {
                        let dline: int = (tok_line lr pos)
                        let dcol: int = (tok_col lr pos)
                        set pos (+ pos 1)
                        let docv: string = (tok_text lr pos)
                        set pos (+ pos 1)

                        let node: Json = (new_object)
                        (opl_json_set_str node "kind" "decl")
                        (opl_json_set_str node "declType" "doc")
                        (opl_json_obj_set node "value" (new_string docv))
                        (opl_json_obj_set node "loc" (opl_json_loc dline dcol))
                        (opl_json_arr_push body node)
                    } else {
                        if (== bk OplTokKind.KW_USES) {
                            let uline: int = (tok_line lr pos)
                            let ucol: int = (tok_col lr pos)
                            set pos (+ pos 1)
                            let ref: string = (tok_text lr pos)
                            set pos (+ pos 1)

                            let val: Json = (new_object)
                            (opl_json_set_str val "ref" ref)

                            let node: Json = (new_object)
                            (opl_json_set_str node "kind" "decl")
                            (opl_json_set_str node "declType" "uses")
                            (opl_json_obj_set node "value" val)
                            (opl_json_obj_set node "loc" (opl_json_loc uline ucol))
                            (opl_json_arr_push body node)
                        } else {
                            if (== bk OplTokKind.KW_INPUT) {
                                let iline: int = (tok_line lr pos)
                                let icol: int = (tok_col lr pos)
                                set pos (+ pos 1)

                                let pr: JsonPos = (parse_param_list lr pos icol)
                                if (not pr.ok) { return (opl_parse_err pr.error) } else {}
                                set pos pr.pos

                                let node: Json = (new_object)
                                (opl_json_set_str node "kind" "decl")
                                (opl_json_set_str node "declType" "input")
                                (opl_json_obj_set node "value" pr.value)
                                (opl_json_obj_set node "loc" (opl_json_loc iline icol))
                                (opl_json_arr_push body node)
                            } else {
                                if (== bk OplTokKind.KW_CALL) {
                                    let cline: int = (tok_line lr pos)
                                    let ccol: int = (tok_col lr pos)
                                    set pos (+ pos 1)

                                    let ref: string = (tok_text lr pos)
                                    set pos (+ pos 1)

                                    if (!= (tok_kind lr pos) OplTokKind.LBRACE) {
                                        return (opl_parse_err (make_parse_error "E_PARSE_EXPECTED_TOKEN" "Expected '{'" lr pos))
                                    } else {}
                                    set pos (+ pos 1)

                                    let ar: JsonPos = (parse_args_object lr pos ccol)
                                    if (not ar.ok) { return (opl_parse_err ar.error) } else {}
                                    set pos ar.pos

                                    let mut as_val: Json = (new_null)
                                    if (== (tok_kind lr pos) OplTokKind.KW_AS) {
                                        set pos (+ pos 1)
                                        if (!= (tok_kind lr pos) OplTokKind.IDENT) {
                                            (free as_val)
                                            return (opl_parse_err (make_parse_error "E_PARSE_EXPECTED_TOKEN" "Expected alias name" lr pos))
                                        } else {}
                                        let asn: string = (tok_text lr pos)
                                        set pos (+ pos 1)
                                        (free as_val)
                                        set as_val (new_string asn)
                                    } else {}

                                    let node: Json = (new_object)
                                    (opl_json_set_str node "kind" "call")
                                    (opl_json_set_str node "ref" ref)
                                    (opl_json_obj_set node "args" ar.value)
                                    (opl_json_obj_set node "as" as_val)
                                    (free as_val)
                                    (opl_json_obj_set node "loc" (opl_json_loc cline ccol))
                                    (opl_json_arr_push body node)
                                } else {
                                    if (== bk OplTokKind.KW_ASSERT) {
                                        let aline: int = (tok_line lr pos)
                                        let acol: int = (tok_col lr pos)
                                        set pos (+ pos 1)

                                        let cr: JsonPos = (parse_expr_simple lr pos)
                                        if (not cr.ok) { return (opl_parse_err cr.error) } else {}
                                        set pos cr.pos

                                        set pos (+ pos 1) # else
                                        let msg: string = (tok_text lr pos)
                                        set pos (+ pos 1)

                                        let node: Json = (new_object)
                                        (opl_json_set_str node "kind" "assert")
                                        (opl_json_obj_set node "cond" cr.value)
                                        (opl_json_obj_set node "message" (new_string msg))
                                        (opl_json_obj_set node "loc" (opl_json_loc aline acol))
                                        (opl_json_arr_push body node)
                                    } else {
                                        if (== bk OplTokKind.KW_EMIT) {
                                            let eline: int = (tok_line lr pos)
                                            let ecol: int = (tok_col lr pos)
                                            set pos (+ pos 1)

                                            let nm: string = (tok_text lr pos)
                                            set pos (+ pos 1)
                                            set pos (+ pos 1) # ':'

                                            let ev_col: int = (- (tok_col lr pos) 1)
                                            let er: JsonPos = (parse_primary_at_col lr pos ev_col)
                                            if (not er.ok) { return (opl_parse_err er.error) } else {}
                                            set pos er.pos

                                            let node: Json = (new_object)
                                            (opl_json_set_str node "kind" "emit")
                                            (opl_json_set_str node "name" nm)
                                            (opl_json_obj_set node "expr" er.value)
                                            (opl_json_obj_set node "loc" (opl_json_loc eline ecol))
                                            (opl_json_arr_push body node)
                                        } else {
                                            if (== bk OplTokKind.KW_WHEN) {
                                                let wline: int = (tok_line lr pos)
                                                let wcol: int = (tok_col lr pos)
                                                set pos (+ pos 1)

                                                let cr: JsonPos = (parse_expr_simple lr pos)
                                                if (not cr.ok) { return (opl_parse_err cr.error) } else {}
                                                set pos cr.pos

                                                set pos (+ pos 1) # '->'

                                                let actions: Json = (new_array)

                                                # call action
                                                let cline: int = (tok_line lr pos)
                                                let ccol: int = (tok_col lr pos)
                                                set pos (+ pos 1)
                                                let ref: string = (tok_text lr pos)
                                                set pos (+ pos 1)
                                                if (!= (tok_kind lr pos) OplTokKind.LBRACE) {
                                                    (free actions)
                                                    return (opl_parse_err (make_parse_error "E_PARSE_EXPECTED_TOKEN" "Expected '{'" lr pos))
                                                } else {}
                                                set pos (+ pos 1)

                                                let ar: JsonPos = (parse_args_object lr pos (- 0 3))
                                                if (not ar.ok) { return (opl_parse_err ar.error) } else {}
                                                set pos ar.pos
                                                let mut as_val: Json = (new_null)
                                                if (== (tok_kind lr pos) OplTokKind.KW_AS) {
                                                    set pos (+ pos 1)
                                                    if (!= (tok_kind lr pos) OplTokKind.IDENT) {
                                                        (free actions)
                                                        (free as_val)
                                                        return (opl_parse_err (make_parse_error "E_PARSE_EXPECTED_TOKEN" "Expected alias name" lr pos))
                                                    } else {}
                                                    let asn: string = (tok_text lr pos)
                                                    set pos (+ pos 1)
                                                    (free as_val)
                                                    set as_val (new_string asn)
                                                } else {}

                                                let n1: Json = (new_object)
                                                (opl_json_set_str n1 "kind" "call")
                                                (opl_json_set_str n1 "ref" ref)
                                                (opl_json_obj_set n1 "args" ar.value)
                                                (opl_json_obj_set n1 "as" as_val)
                                                (free as_val)
                                                (opl_json_obj_set n1 "loc" (opl_json_loc cline ccol))
                                                (opl_json_arr_push actions n1)

                                                set pos (+ pos 1) # ','

                                                # emit action
                                                let eline2: int = (tok_line lr pos)
                                                let ecol2: int = (- (tok_col lr pos) 5)
                                                set pos (+ pos 1)
                                                let nm2: string = (tok_text lr pos)
                                                set pos (+ pos 1)
                                                set pos (+ pos 1) # ':'

                                                let ev2_col: int = (- (tok_col lr pos) 7)
                                                let er2: JsonPos = (parse_primary_at_col lr pos ev2_col)
                                                if (not er2.ok) { return (opl_parse_err er2.error) } else {}
                                                set pos er2.pos

                                                let n2: Json = (new_object)
                                                (opl_json_set_str n2 "kind" "emit")
                                                (opl_json_set_str n2 "name" nm2)
                                                (opl_json_obj_set n2 "expr" er2.value)
                                                (opl_json_obj_set n2 "loc" (opl_json_loc eline2 ecol2))
                                                (opl_json_arr_push actions n2)

                                                let node: Json = (new_object)
                                                (opl_json_set_str node "kind" "rule")
                                                (opl_json_set_str node "ruleType" "when")
                                                (opl_json_obj_set node "cond" cr.value)
                                                (opl_json_obj_set node "actions" actions)
                                                (opl_json_obj_set node "loc" (opl_json_loc wline wcol))
                                                (opl_json_arr_push body node)
                                            } else {
                                                return (opl_parse_err (make_parse_error "E_FEATURE_NOT_IMPLEMENTED" "Unsupported stmt" lr pos))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                set pos (+ pos 1) # '}'
                (opl_json_obj_set block "body" body)
                (opl_json_arr_push nodes block)
            } else {
                set pos (+ pos 1)
            }
        }
    }

    (opl_json_obj_set root "nodes" nodes)
    return (opl_parse_ok root)
}

shadow opl_parse {
    let src: string = "agent a { uses web.search input query:string, limit:int=5 call web.search { query: query, limit: limit } as results assert results != null else \"search failed\" emit results: results }"
    let r: OplParseResult = (opl_parse src)
    assert r.ok
    (free r.ast)
}

shadow tok_kind {
    let lr: OplTokensResult = (opl_lex "x")
    assert lr.ok
    assert (== (tok_kind lr 0) OplTokKind.IDENT)
}

shadow tok_line {
    let lr: OplTokensResult = (opl_lex "x")
    assert (== (tok_line lr 0) 1)
}

shadow tok_col {
    let lr: OplTokensResult = (opl_lex "x")
    assert (== (tok_col lr 0) 1)
}

shadow tok_text {
    let lr: OplTokensResult = (opl_lex "x")
    assert (== (tok_text lr 0) "x")
}

shadow make_parse_error {
    let lr: OplTokensResult = (opl_lex "x")
    let e: OplError = (make_parse_error "E" "m" lr 0)
    assert (== e.code "E")
}

shadow skip_newlines {
    let nl: string = (string_from_char 10)
    let lr: OplTokensResult = (opl_lex (+ "a" (+ nl "b")))
    assert lr.ok
    assert (== (skip_newlines lr 1) 1)
}

shadow jp_ok {
    let j: Json = (new_object)
    let r: JsonPos = (jp_ok j 2)
    assert r.ok
    (free r.value)
}

shadow jp_err {
    let e: OplError = OplError { code: "E", msg: "m", loc: OplLoc { line: 1, col: 1 }, path: "" }
    let r: JsonPos = (jp_err e 2)
    assert (not r.ok)
}

shadow expr_lit_null {
    let j: Json = (expr_lit_null 1 2)
    assert (== (as_string (get j "kind")) "lit")
    (free j)
}

shadow expr_lit_int {
    let j: Json = (expr_lit_int 7 1 2)
    assert (== (as_int (get j "v")) 7)
    (free j)
}

shadow expr_lit_str {
    let j: Json = (expr_lit_str "x" 1 2)
    assert (== (as_string (get j "v")) "x")
    (free j)
}

shadow expr_id {
    let j: Json = (expr_id "x" 1 2)
    assert (== (as_string (get j "name")) "x")
    (free j)
}

shadow expr_bin {
    let a: Json = (expr_id "a" 1 1)
    let b: Json = (expr_lit_null 1 2)
    let j: Json = (expr_bin "!=" a b 1 3)
    assert (== (as_string (get j "op")) "!=")
    (free j)
}

shadow parse_primary {
    let lr: OplTokensResult = (opl_lex "x")
    let r: JsonPos = (parse_primary lr 0)
    assert r.ok
    (free r.value)
}

shadow parse_primary_at_col {
    let lr: OplTokensResult = (opl_lex "x")
    let r: JsonPos = (parse_primary_at_col lr 0 5)
    assert r.ok
    (free r.value)
}

shadow parse_expr_simple {
    let lr: OplTokensResult = (opl_lex "x != null")
    let r: JsonPos = (parse_expr_simple lr 0)
    assert r.ok
    (free r.value)
}

shadow parse_type_obj {
    let j: Json = (parse_type_obj "int")
    assert (== (as_string (get j "t")) "int")
    (free j)
}

shadow parse_param_list {
    let lr: OplTokensResult = (opl_lex "x:int")
    let r: JsonPos = (parse_param_list lr 0 1)
    assert r.ok
    (free r.value)
}

shadow parse_args_object {
    let lr: OplTokensResult = (opl_lex "a: x }")
    let r: JsonPos = (parse_args_object lr 0 0)
    assert r.ok
    (free r.value)
}
