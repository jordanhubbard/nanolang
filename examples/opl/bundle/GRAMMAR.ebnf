# GRAMMAR.ebnf â€” OPL Grammar (EBNF)

program        := (stmt terminator)* EOF ;

terminator     := NEWLINE+ | ";" NEWLINE* ;

stmt           := decl
                | assignment
                | call_stmt
                | rule_stmt
                | assert_stmt
                | emit_stmt
                | include_stmt
                | block_stmt
                ;

block_stmt     := block_head "{" (stmt terminator)* "}" ;

block_head     := "agent" IDENT
                | "service" IDENT
                | "task" IDENT
                | "schema" IDENT
                ;

decl           := ("uses" ref)
                | ("input" param_list)
                | ("output" param_list)
                | ("returns" type_ref)
                | ("doc" STRING)
                ;

param_list     := param ("," param)* ;
param          := IDENT ":" type_ref ( "=" expr )? ;

type_ref       := IDENT ( "<" type_ref ("," type_ref)* ">" )? ;

assignment     := "let" IDENT "=" expr ;

call_stmt      := "call" ref ( call_args )? ( "as" IDENT )? ;
call_args      := "{" (kv ("," kv)*)? "}" ;
kv             := IDENT ":" expr ;

rule_stmt      := ("when" expr "->" action_list)
                | ("on" event "->" action_list) ;

event          := IDENT ( "." IDENT )* ( "(" (expr ("," expr)*)? ")" )? ;

action_list    := action ("," action)* ;
action         := call_stmt
                | emit_stmt
                | assignment
                ;

assert_stmt    := "assert" expr ( "else" STRING )? ;

emit_stmt      := "emit" IDENT ":" expr ;

include_stmt   := "include" STRING ;

ref            := IDENT ( "." IDENT )* ;

expr           := or_expr ;
or_expr        := and_expr ( "or" and_expr )* ;
and_expr       := eq_expr  ( "and" eq_expr )* ;
eq_expr        := rel_expr ( ("==" | "!=") rel_expr )* ;
rel_expr       := add_expr ( ("<" | "<=" | ">" | ">=") add_expr )* ;
add_expr       := mul_expr ( ("+" | "-") mul_expr )* ;
mul_expr       := unary    ( ("*" | "/") unary )* ;
unary          := ("not" | "-" ) unary | primary ;

primary        := literal
                | IDENT
                | "(" expr ")"
                | list
                | map
                | member
                | call_expr
                ;

member         := primary "." IDENT ;

call_expr      := ref "(" (expr ("," expr)*)? ")" ;

list           := "[" (expr ("," expr)*)? "]" ;
map            := "{" (kv ("," kv)*)? "}" ;

literal        := STRING | NUMBER | "true" | "false" | "null" ;
