import "examples/opl/opl_ast.nano"

fn opl_is_alpha(c: int) -> bool {
    return (or (and (>= c 65) (<= c 90)) (and (>= c 97) (<= c 122)))
}
shadow opl_is_alpha { assert (opl_is_alpha 65) }

fn opl_is_digit(c: int) -> bool {
    return (and (>= c 48) (<= c 57))
}
shadow opl_is_digit { assert (opl_is_digit 57) }

fn opl_is_ident_start(c: int) -> bool {
    return (or (opl_is_alpha c) (== c 95))
}
shadow opl_is_ident_start { assert (opl_is_ident_start 95) }

fn opl_is_ident_char(c: int) -> bool {
    if (opl_is_ident_start c) { return true } else {}
    if (opl_is_digit c) { return true } else {}
    if (or (== c 46) (== c 47)) { return true } else {}
    if (== c 45) { return true } else {}
    return false
}
shadow opl_is_ident_char { assert (not (opl_is_ident_char 58)) }

fn opl_keyword_kind(s: string) -> int {
    return (cond
        ((== s "agent") OplTokKind.KW_AGENT)
        ((== s "service") OplTokKind.KW_SERVICE)
        ((== s "task") OplTokKind.KW_TASK)
        ((== s "schema") OplTokKind.KW_SCHEMA)
        ((== s "uses") OplTokKind.KW_USES)
        ((== s "input") OplTokKind.KW_INPUT)
        ((== s "output") OplTokKind.KW_OUTPUT)
        ((== s "returns") OplTokKind.KW_RETURNS)
        ((== s "doc") OplTokKind.KW_DOC)
        ((== s "let") OplTokKind.KW_LET)
        ((== s "call") OplTokKind.KW_CALL)
        ((== s "as") OplTokKind.KW_AS)
        ((== s "when") OplTokKind.KW_WHEN)
        ((== s "on") OplTokKind.KW_ON)
        ((== s "assert") OplTokKind.KW_ASSERT)
        ((== s "else") OplTokKind.KW_ELSE)
        ((== s "emit") OplTokKind.KW_EMIT)
        ((== s "include") OplTokKind.KW_INCLUDE)
        ((== s "true") OplTokKind.KW_TRUE)
        ((== s "false") OplTokKind.KW_FALSE)
        ((== s "null") OplTokKind.KW_NULL)
        ((== s "and") OplTokKind.KW_AND)
        ((== s "or") OplTokKind.KW_OR)
        ((== s "not") OplTokKind.KW_NOT)
        (else OplTokKind.IDENT)
    )
}
shadow opl_keyword_kind { assert (== (opl_keyword_kind "agent") OplTokKind.KW_AGENT) }

fn opl_sub(s: string, start: int, end_excl: int) -> string {
    return (+ "" (str_substring s start (- end_excl start)))
}
shadow opl_sub { assert (== (opl_sub "abcd" 1 3) "bc") }

pub fn opl_make_error(code: string, msg: string, line: int, col: int, path: string) -> OplError {
    return OplError { code: code, msg: msg, loc: OplLoc { line: line, col: col }, path: path }
}
shadow opl_make_error {
    let e: OplError = (opl_make_error "E" "m" 1 1 "")
    assert (== e.code "E")
}

pub fn opl_lex(text: string) -> OplTokensResult {
    let n: int = (str_length text)
    let mut i: int = 0
    let mut line: int = 1
    let mut col: int = 1
    let mut depth: int = 0

    let mut kinds: array<int> = []
    let mut starts: array<int> = []
    let mut lens: array<int> = []
    let mut lines: array<int> = []
    let mut cols: array<int> = []
    let mut buf: string = ""

    while (< i n) {
        let c: int = (char_at text i)

        if (or (== c 32) (== c 9)) {
            set i (+ i 1)
            set col (+ col 1)
        } else {
            if (== c 13) {
                set i (+ i 1)
            } else {
                if (== c 35) {
                    while (and (< i n) (!= (char_at text i) 10)) {
                        set i (+ i 1)
                    }
                } else {
                    if (== c 10) {
                        if (== depth 0) {
                            let start: int = (str_length buf)
                            set buf (+ buf "\n")
                            set kinds (array_push kinds OplTokKind.NEWLINE)
                            set starts (array_push starts start)
                            set lens (array_push lens 1)
                            set lines (array_push lines line)
                            set cols (array_push cols col)
                        } else {}
                        set i (+ i 1)
                        set line (+ line 1)
                        set col 1
                    } else {
                        let start_line: int = line
                        let start_col: int = col

                        if (== c 34) {
                            set i (+ i 1)
                            set col (+ col 1)
                            let mut out: string = ""
                            let mut done: bool = false
                            while (and (< i n) (not done)) {
                                let d: int = (char_at text i)
                                if (== d 34) {
                                    set done true
                                    set i (+ i 1)
                                    set col (+ col 1)
                                } else {
                                    if (== d 92) {
                                        if (>= (+ i 1) n) {
                                            return (opl_tokens_result_err (opl_make_error "E_LEX_UNTERMINATED_STRING" "Unterminated string" start_line start_col ""))
                                        } else {}
                                        let e: int = (char_at text (+ i 1))
                                        if (== e 110) { set out (+ out "\n") } else {
                                            if (== e 116) { set out (+ out "\t") } else {
                                                if (== e 114) { set out (+ out "\r") } else {
                                                    if (== e 34) { set out (+ out "\"") } else {
                                                        if (== e 92) { set out (+ out "\\") } else {
                                                            return (opl_tokens_result_err (opl_make_error "E_LEX_INVALID_CHAR" "Invalid escape" line col ""))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        set i (+ i 2)
                                        set col (+ col 2)
                                    } else {
                                        set out (+ out (string_from_char d))
                                        set i (+ i 1)
                                        set col (+ col 1)
                                    }
                                }
                            }
                            if (not done) {
                                return (opl_tokens_result_err (opl_make_error "E_LEX_UNTERMINATED_STRING" "Unterminated string" start_line start_col ""))
                            } else {}

                            let start: int = (str_length buf)
                            set buf (+ buf out)
                            set kinds (array_push kinds OplTokKind.STRING)
                            set starts (array_push starts start)
                            set lens (array_push lens (str_length out))
                            set lines (array_push lines start_line)
                            set cols (array_push cols start_col)
                        } else {
                            let mut is_neg_num: bool = false
                            if (== c 45) {
                                if (and (< (+ i 1) n) (opl_is_digit (char_at text (+ i 1)))) {
                                    set is_neg_num true
                                } else {}
                            } else {}

                            if (or (opl_is_digit c) is_neg_num) {
                                let start_i: int = i
                                if is_neg_num {
                                    set i (+ i 1)
                                    set col (+ col 1)
                                } else {}
                                while (and (< i n) (opl_is_digit (char_at text i))) {
                                    set i (+ i 1)
                                    set col (+ col 1)
                                }
                                if (and (< i n) (== (char_at text i) 46)) {
                                    if (and (< (+ i 1) n) (opl_is_digit (char_at text (+ i 1)))) {
                                        set i (+ i 1)
                                        set col (+ col 1)
                                        while (and (< i n) (opl_is_digit (char_at text i))) {
                                            set i (+ i 1)
                                            set col (+ col 1)
                                        }
                                    } else {}
                                } else {}

                                let num_text: string = (opl_sub text start_i i)
                                let start: int = (str_length buf)
                                set buf (+ buf num_text)
                                set kinds (array_push kinds OplTokKind.NUMBER)
                                set starts (array_push starts start)
                                set lens (array_push lens (str_length num_text))
                                set lines (array_push lines start_line)
                                set cols (array_push cols start_col)
                            } else {
                                if (opl_is_ident_start c) {
                                    let start_i: int = i
                                    while (and (< i n) (opl_is_ident_char (char_at text i))) {
                                        set i (+ i 1)
                                        set col (+ col 1)
                                    }
                                    let name: string = (opl_sub text start_i i)
                                    let k: int = (opl_keyword_kind name)

                                    let start: int = (str_length buf)
                                    set buf (+ buf name)
                                    set kinds (array_push kinds k)
                                    set starts (array_push starts start)
                                    set lens (array_push lens (str_length name))
                                    set lines (array_push lines start_line)
                                    set cols (array_push cols start_col)
                                } else {
                                    if (and (== c 45) (and (< (+ i 1) n) (== (char_at text (+ i 1)) 62))) {
                                        let start: int = (str_length buf)
                                        set buf (+ buf "->")
                                        set kinds (array_push kinds OplTokKind.ARROW)
                                        set starts (array_push starts start)
                                        set lens (array_push lens 2)
                                        set lines (array_push lines start_line)
                                        set cols (array_push cols start_col)
                                        set i (+ i 2)
                                        set col (+ col 2)
                                    } else {
                                        if (and (== c 61) (and (< (+ i 1) n) (== (char_at text (+ i 1)) 61))) {
                                            let start: int = (str_length buf)
                                            set buf (+ buf "==")
                                            set kinds (array_push kinds OplTokKind.EQEQ)
                                            set starts (array_push starts start)
                                            set lens (array_push lens 2)
                                            set lines (array_push lines start_line)
                                            set cols (array_push cols start_col)
                                            set i (+ i 2)
                                            set col (+ col 2)
                                        } else {
                                            if (and (== c 33) (and (< (+ i 1) n) (== (char_at text (+ i 1)) 61))) {
                                                let start: int = (str_length buf)
                                                set buf (+ buf "!=")
                                                set kinds (array_push kinds OplTokKind.NOTEQ)
                                                set starts (array_push starts start)
                                                set lens (array_push lens 2)
                                                set lines (array_push lines start_line)
                                                set cols (array_push cols start_col)
                                                set i (+ i 2)
                                                set col (+ col 2)
                                            } else {
                                                let mut kind: int = -1
                                                let mut txt: string = (string_from_char c)

                                                if (== c 123) {
                                                    set kind OplTokKind.LBRACE
                                                    set depth (+ depth 1)
                                                } else {}
                                                if (== c 125) {
                                                    set kind OplTokKind.RBRACE
                                                    set depth (- depth 1)
                                                } else {}
                                                if (== c 91) {
                                                    set kind OplTokKind.LBRACKET
                                                    set depth (+ depth 1)
                                                } else {}
                                                if (== c 93) {
                                                    set kind OplTokKind.RBRACKET
                                                    set depth (- depth 1)
                                                } else {}
                                                if (== c 40) {
                                                    set kind OplTokKind.LPAREN
                                                    set depth (+ depth 1)
                                                } else {}
                                                if (== c 41) {
                                                    set kind OplTokKind.RPAREN
                                                    set depth (- depth 1)
                                                } else {}
                                                if (== c 44) { set kind OplTokKind.COMMA } else {}
                                                if (== c 58) { set kind OplTokKind.COLON } else {}
                                                if (== c 46) { set kind OplTokKind.DOT } else {}
                                                if (== c 59) { set kind OplTokKind.SEMI } else {}
                                                if (== c 61) { set kind OplTokKind.EQ } else {}
                                                if (== c 60) { set kind OplTokKind.LT } else {}
                                                if (== c 62) { set kind OplTokKind.GT } else {}
                                                if (== c 43) { set kind OplTokKind.PLUS } else {}
                                                if (== c 45) { set kind OplTokKind.MINUS } else {}
                                                if (== c 42) { set kind OplTokKind.STAR } else {}
                                                if (== c 47) { set kind OplTokKind.SLASH } else {}

                                                if (== kind -1) {
                                                    return (opl_tokens_result_err (opl_make_error "E_LEX_INVALID_CHAR" (+ "Invalid character: " (string_from_char c)) start_line start_col ""))
                                                } else {}

                                                let start: int = (str_length buf)
                                                set buf (+ buf txt)
                                                set kinds (array_push kinds kind)
                                                set starts (array_push starts start)
                                                set lens (array_push lens (str_length txt))
                                                set lines (array_push lines start_line)
                                                set cols (array_push cols start_col)

                                                set i (+ i 1)
                                                set col (+ col 1)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    let start: int = (str_length buf)
    set kinds (array_push kinds OplTokKind.EOF)
    set starts (array_push starts start)
    set lens (array_push lens 0)
    set lines (array_push lines line)
    set cols (array_push cols col)

    return (opl_tokens_result_ok kinds buf starts lens lines cols)
}

shadow opl_lex {
    let r: OplTokensResult = (opl_lex "agent a { uses web.search }")
    assert r.ok
    assert (== (at r.kinds 0) OplTokKind.KW_AGENT)
}
