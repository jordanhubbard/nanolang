/* OPL AST + shared structs for the examples/opl toolchain */

/* Source location */
pub struct OplLoc {
    line: int,
    col: int
}

/* Canonical error shape (ERRORS.md) */
pub struct OplError {
    code: string,
    msg: string,
    loc: OplLoc,
    path: string
}

/* Token kinds for lexer/parser */
pub enum OplTokKind {
    EOF = 0,
    NEWLINE = 1,
    IDENT = 2,
    STRING = 3,
    NUMBER = 4,

    /* Keywords */
    KW_AGENT = 10,
    KW_SERVICE = 11,
    KW_TASK = 12,
    KW_SCHEMA = 13,
    KW_USES = 14,
    KW_INPUT = 15,
    KW_OUTPUT = 16,
    KW_RETURNS = 17,
    KW_DOC = 18,
    KW_LET = 19,
    KW_CALL = 20,
    KW_AS = 21,
    KW_WHEN = 22,
    KW_ON = 23,
    KW_ASSERT = 24,
    KW_ELSE = 25,
    KW_EMIT = 26,
    KW_INCLUDE = 27,
    KW_TRUE = 28,
    KW_FALSE = 29,
    KW_NULL = 30,
    KW_AND = 31,
    KW_OR = 32,
    KW_NOT = 33,

    /* Punctuation */
    LBRACE = 40,
    RBRACE = 41,
    LBRACKET = 42,
    RBRACKET = 43,
    LPAREN = 44,
    RPAREN = 45,
    COMMA = 46,
    COLON = 47,
    DOT = 48,
    SEMI = 49,
    EQ = 50,

    /* Operators */
    ARROW = 60,
    EQEQ = 61,
    NOTEQ = 62,
    LT = 63,
    LTE = 64,
    GT = 65,
    GTE = 66,
    PLUS = 67,
    MINUS = 68,
    STAR = 69,
    SLASH = 70
}

/*
Flattened token stream.

We avoid `array<string>` here because it appears unstable under heavy use (strings get corrupted).
Instead store a single `text_buf` plus parallel `text_starts` + `text_lens`.
*/
pub struct OplTokensResult {
    ok: bool,
    kinds: array<int>,
    text_buf: string,
    text_starts: array<int>,
    text_lens: array<int>,
    lines: array<int>,
    cols: array<int>,
    error: OplError
}

pub fn opl_tokens_result_ok(kinds: array<int>, text_buf: string, text_starts: array<int>, text_lens: array<int>, lines: array<int>, cols: array<int>) -> OplTokensResult {
    return OplTokensResult {
        ok: true,
        kinds: kinds,
        text_buf: text_buf,
        text_starts: text_starts,
        text_lens: text_lens,
        lines: lines,
        cols: cols,
        error: OplError { code: "", msg: "", loc: OplLoc { line: 1, col: 1 }, path: "" }
    }
}

shadow opl_tokens_result_ok {
    let mut kinds: array<int> = []
    let mut starts: array<int> = []
    let mut lens: array<int> = []
    let mut lines: array<int> = []
    let mut cols: array<int> = []
    let mut buf: string = ""

    set kinds (array_push kinds OplTokKind.EOF)
    set starts (array_push starts 0)
    set lens (array_push lens 0)
    set lines (array_push lines 1)
    set cols (array_push cols 1)

    let r: OplTokensResult = (opl_tokens_result_ok kinds buf starts lens lines cols)
    assert r.ok
    assert (== (array_length r.kinds) 1)
}

pub fn opl_tokens_result_err(err: OplError) -> OplTokensResult {
    return OplTokensResult {
        ok: false,
        kinds: [],
        text_buf: "",
        text_starts: [],
        text_lens: [],
        lines: [],
        cols: [],
        error: err
    }
}

shadow opl_tokens_result_err {
    let err: OplError = OplError { code: "E", msg: "m", loc: OplLoc { line: 2, col: 3 }, path: "/x" }
    let r: OplTokensResult = (opl_tokens_result_err err)
    assert (not r.ok)
    assert (str_equals r.error.code "E")
    assert (== (array_length r.kinds) 0)
}

pub fn opl_tokens_len(r: OplTokensResult) -> int {
    return (array_length r.kinds)
}

shadow opl_tokens_len {
    let mut kinds: array<int> = []
    let mut starts: array<int> = []
    let mut lens: array<int> = []
    let mut lines: array<int> = []
    let mut cols: array<int> = []
    let mut buf: string = ""

    set kinds (array_push kinds OplTokKind.EOF)
    set starts (array_push starts 0)
    set lens (array_push lens 0)
    set lines (array_push lines 1)
    set cols (array_push cols 1)

    let r: OplTokensResult = (opl_tokens_result_ok kinds buf starts lens lines cols)
    assert (== (opl_tokens_len r) 1)
}

fn opl_ast_smoke() -> int {
    let e: OplError = OplError { code: "E_X", msg: "m", loc: OplLoc { line: 1, col: 2 }, path: "/x" }
    assert (str_equals e.code "E_X")

    let mut kinds: array<int> = []
    let mut starts: array<int> = []
    let mut lens: array<int> = []
    let mut lines: array<int> = []
    let mut cols: array<int> = []
    let mut buf: string = ""

    set kinds (array_push kinds OplTokKind.EOF)
    set starts (array_push starts 0)
    set lens (array_push lens 0)
    set lines (array_push lines 1)
    set cols (array_push cols 1)

    let r: OplTokensResult = (opl_tokens_result_ok kinds buf starts lens lines cols)
    assert r.ok
    return 0
}

shadow opl_ast_smoke {
    assert (== (opl_ast_smoke) 0)
}
