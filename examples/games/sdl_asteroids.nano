# Example: Asteroids
# Purpose: Full arcade Asteroids game with lives, score, asteroid breaking mechanics, and thrust physics
# Features: float arithmetic, trigonometry, arrays, SDL graphics, keyboard input, ui_widgets, collision detection
# Difficulty: Advanced
# Category: games
# Prerequisites: sdl_drawing_primitives, sdl_particles
# Expected Output: interactive

unsafe module "modules/sdl/sdl.nano"
unsafe module "modules/sdl_helpers/sdl_helpers.nano"
unsafe module "modules/sdl_ttf/sdl_ttf.nano"
unsafe module "modules/sdl_ttf/sdl_ttf_helpers.nano"
module "modules/ui_widgets/ui_widgets.nano"

# === CONSTANTS ===
let WINDOW_WIDTH: int = 800
let WINDOW_HEIGHT: int = 600
let SHIP_SIZE: float = 15.0
let BULLET_SPEED: float = 400.0
let SHIP_THRUST: float = 200.0
let SHIP_DRAG: float = 0.98
let SHIP_ROTATION_SPEED: float = 4.0
let PI: float = 3.14159
let DEG_TO_RAD: float = 0.017453

# Asteroid sizes
let ASTEROID_SIZE_LARGE: int = 3
let ASTEROID_SIZE_MEDIUM: int = 2
let ASTEROID_SIZE_SMALL: int = 1

# Asteroid radii by size
let ASTEROID_RADIUS_LARGE: float = 30.0
let ASTEROID_RADIUS_MEDIUM: float = 20.0
let ASTEROID_RADIUS_SMALL: float = 10.0

# Scoring (updated values)
let SCORE_LARGE: int = 10
let SCORE_MEDIUM: int = 30
let SCORE_SMALL: int = 50

# Game state
let STATE_PLAYING: int = 0
let STATE_DEAD: int = 1
let STATE_GAME_OVER: int = 2

# Lives
let STARTING_LIVES: int = 3
let RESPAWN_DELAY: float = 2.0

# === HELPER FUNCTIONS ===

fn wrap_position(pos: float, max: float) -> float {
    return (cond
        ((< pos 0.0) max)
        ((> pos max) 0.0)
        (else pos)
    )
}

shadow wrap_position {
    assert (== (wrap_position -1.0 100.0) 100.0)
    assert (== (wrap_position 101.0 100.0) 0.0)
    assert (== (wrap_position 50.0 100.0) 50.0)
}

fn distance_squared(x1: float, y1: float, x2: float, y2: float) -> float {
    let dx: float = (- x2 x1)
    let dy: float = (- y2 y1)
    return (+ (* dx dx) (* dy dy))
}

fn circles_collide(x1: float, y1: float, r1: float, x2: float, y2: float, r2: float) -> bool {
    let dist_sq: float = (distance_squared x1 y1 x2 y2)
    let radii_sum: float = (+ r1 r2)
    return (< dist_sq (* radii_sum radii_sum))
}

fn get_asteroid_radius(size: int) -> float {
    return (cond
        ((== size ASTEROID_SIZE_LARGE) ASTEROID_RADIUS_LARGE)
        ((== size ASTEROID_SIZE_MEDIUM) ASTEROID_RADIUS_MEDIUM)
        (else ASTEROID_RADIUS_SMALL)
    )
}

fn get_asteroid_score(size: int) -> int {
    return (cond
        ((== size ASTEROID_SIZE_LARGE) SCORE_LARGE)
        ((== size ASTEROID_SIZE_MEDIUM) SCORE_MEDIUM)
        (else SCORE_SMALL)
    )
}

shadow get_asteroid_score {
    assert (== (get_asteroid_score ASTEROID_SIZE_LARGE) SCORE_LARGE)
    assert (== (get_asteroid_score ASTEROID_SIZE_MEDIUM) SCORE_MEDIUM)
    assert (== (get_asteroid_score ASTEROID_SIZE_SMALL) SCORE_SMALL)
}

fn get_asteroid_gray(size: int) -> int {
    return (cond
        ((== size ASTEROID_SIZE_LARGE) 180)
        ((== size ASTEROID_SIZE_MEDIUM) 150)
        (else 120)
    )
}

shadow get_asteroid_gray {
    assert (== (get_asteroid_gray ASTEROID_SIZE_LARGE) 180)
    assert (== (get_asteroid_gray ASTEROID_SIZE_SMALL) 120)
}

# === MAIN GAME ===

fn main() -> int {
    # Initialize SDL
    (SDL_Init SDL_INIT_VIDEO) 
    let window: SDL_Window = (SDL_CreateWindow "Asteroids Complete" 100 100 WINDOW_WIDTH WINDOW_HEIGHT SDL_WINDOW_SHOWN)
    let renderer: SDL_Renderer = (SDL_CreateRenderer window -1 SDL_RENDERER_ACCELERATED)
    
    # Initialize SDL_TTF
    (TTF_Init) 
    let font: TTF_Font = (nl_open_font_portable "Arial" 24)
    let help_font: TTF_Font = (nl_open_font_portable "Arial" 12)
    if (== font 0) {
        (println "Warning: Failed to load font. HUD text will not display.")
    } else {
        (println "âœ“ Font loaded successfully")
    }
    let font_large: TTF_Font = (nl_open_font_portable "Arial" 48)
    
    # Game state
    let mut game_state: int = STATE_PLAYING
    let mut lives: int = STARTING_LIVES
    let mut score: int = 0
    let mut respawn_timer: float = 0.0
    let mut running: bool = true
    let mut debug_mode: int = 0  # Checkbox state for debug visualization
    
    # Ship state
    let mut ship_x: float = (/ (cast_float WINDOW_WIDTH) 2.0)
    let mut ship_y: float = (/ (cast_float WINDOW_HEIGHT) 2.0)
    let mut ship_vx: float = 0.0
    let mut ship_vy: float = 0.0
    let mut ship_angle: float = 0.0
    let mut ship_alive: bool = true
    
    # Asteroids (parallel arrays) - now with size!
    let mut asteroid_x: array<float> = []
    let mut asteroid_y: array<float> = []
    let mut asteroid_vx: array<float> = []
    let mut asteroid_vy: array<float> = []
    let mut asteroid_size: array<int> = []
    let mut asteroid_active: array<bool> = []
    
    # Bullets (parallel arrays)
    let mut bullet_x: array<float> = []
    let mut bullet_y: array<float> = []
    let mut bullet_vx: array<float> = []
    let mut bullet_vy: array<float> = []
    let mut bullet_life: array<float> = []
    let mut bullet_active: array<bool> = []
    
    # Particles for explosions (parallel arrays)
    let mut particle_x: array<float> = []
    let mut particle_y: array<float> = []
    let mut particle_vx: array<float> = []
    let mut particle_vy: array<float> = []
    let mut particle_life: array<float> = []
    
    # Spawn initial large asteroids
    set asteroid_x (array_push asteroid_x 100.0)
    set asteroid_y (array_push asteroid_y 100.0)
    set asteroid_vx (array_push asteroid_vx 50.0)
    set asteroid_vy (array_push asteroid_vy 30.0)
    set asteroid_size (array_push asteroid_size ASTEROID_SIZE_LARGE)
    set asteroid_active (array_push asteroid_active true)
    
    set asteroid_x (array_push asteroid_x 700.0)
    set asteroid_y (array_push asteroid_y 100.0)
    set asteroid_vx (array_push asteroid_vx -40.0)
    set asteroid_vy (array_push asteroid_vy 25.0)
    set asteroid_size (array_push asteroid_size ASTEROID_SIZE_LARGE)
    set asteroid_active (array_push asteroid_active true)
    
    set asteroid_x (array_push asteroid_x 400.0)
    set asteroid_y (array_push asteroid_y 500.0)
    set asteroid_vx (array_push asteroid_vx 30.0)
    set asteroid_vy (array_push asteroid_vy -50.0)
    set asteroid_size (array_push asteroid_size ASTEROID_SIZE_LARGE)
    set asteroid_active (array_push asteroid_active true)
    
    # Game timing
    let mut last_time: int = (SDL_GetTicks)
    let mut shoot_cooldown: float = 0.0
    
    # Main loop
    while running {
        # Delta time
        let current_time: int = (SDL_GetTicks)
        let dt: float = (/ (cast_float (- current_time last_time)) 1000.0)
        set last_time current_time
        
        # Input - check keyboard state for continuous input
        let thrust: bool = (== (nl_sdl_key_state 82) 1)       # Up arrow
        let rotate_left: bool = (== (nl_sdl_key_state 80) 1)  # Left arrow
        let rotate_right: bool = (== (nl_sdl_key_state 79) 1) # Right arrow
        let shoot: bool = (== (nl_sdl_key_state 44) 1)        # Space
        
        # Check for keypresses (one-time events)
        let key: int = (nl_sdl_poll_keypress)
        if (== key 21) {                                       # R key
            if (== game_state STATE_GAME_OVER) {
                # Restart game
                set game_state STATE_PLAYING
                set lives STARTING_LIVES
                set score 0
                set ship_alive true
                set ship_x (/ (cast_float WINDOW_WIDTH) 2.0)
                set ship_y (/ (cast_float WINDOW_HEIGHT) 2.0)
                set ship_vx 0.0
                set ship_vy 0.0
                set ship_angle 0.0
                
                # Clear all asteroids and spawn new ones
                set asteroid_x []
                set asteroid_y []
                set asteroid_vx []
                set asteroid_vy []
                set asteroid_size []
                set asteroid_active []
                
                set asteroid_x (array_push asteroid_x 100.0)
                set asteroid_y (array_push asteroid_y 100.0)
                set asteroid_vx (array_push asteroid_vx 50.0)
                set asteroid_vy (array_push asteroid_vy 30.0)
                set asteroid_size (array_push asteroid_size ASTEROID_SIZE_LARGE)
                set asteroid_active (array_push asteroid_active true)
                
                set asteroid_x (array_push asteroid_x 700.0)
                set asteroid_y (array_push asteroid_y 100.0)
                set asteroid_vx (array_push asteroid_vx -40.0)
                set asteroid_vy (array_push asteroid_vy 25.0)
                set asteroid_size (array_push asteroid_size ASTEROID_SIZE_LARGE)
                set asteroid_active (array_push asteroid_active true)
                
                set asteroid_x (array_push asteroid_x 400.0)
                set asteroid_y (array_push asteroid_y 500.0)
                set asteroid_vx (array_push asteroid_vx 30.0)
                set asteroid_vy (array_push asteroid_vy -50.0)
                set asteroid_size (array_push asteroid_size ASTEROID_SIZE_LARGE)
                set asteroid_active (array_push asteroid_active true)
                
                # Clear bullets and particles
                set bullet_x []
                set bullet_y []
                set bullet_vx []
                set bullet_vy []
                set bullet_life []
                set bullet_active []
                set particle_x []
                set particle_y []
                set particle_vx []
                set particle_vy []
                set particle_life []
            }
        }
        
        if (== (nl_sdl_poll_event_quit) 1) { set running false }
        
        # Update respawn timer if dead
        if (== game_state STATE_DEAD) {
            set respawn_timer (- respawn_timer dt)
            if (<= respawn_timer 0.0) {
                if (> lives 0) {
                    # Respawn
                    set ship_alive true
                    set ship_x (/ (cast_float WINDOW_WIDTH) 2.0)
                    set ship_y (/ (cast_float WINDOW_HEIGHT) 2.0)
                    set ship_vx 0.0
                    set ship_vy 0.0
                    set ship_angle 0.0
                    set game_state STATE_PLAYING
                } else {
                    # Game over
                    set game_state STATE_GAME_OVER
                }
            }
        }
        
        # Only update gameplay if playing
        if (== game_state STATE_PLAYING) {
            # Update cooldown
            set shoot_cooldown (- shoot_cooldown dt)
            
            # Shoot
            if shoot {
                if (< shoot_cooldown 0.0) {
                    if ship_alive {
                        set bullet_x (array_push bullet_x ship_x)
                        set bullet_y (array_push bullet_y ship_y)
                        set bullet_vx (array_push bullet_vx (* (cos ship_angle) BULLET_SPEED))
                        set bullet_vy (array_push bullet_vy (* (sin ship_angle) BULLET_SPEED))
                        set bullet_life (array_push bullet_life 2.0)
                        set bullet_active (array_push bullet_active true)
                        set shoot_cooldown 0.25
                    }
                }
            }
            
            # Update ship
            if ship_alive {
                if rotate_left {
                    set ship_angle (- ship_angle (* SHIP_ROTATION_SPEED dt))
                }
                if rotate_right {
                    set ship_angle (+ ship_angle (* SHIP_ROTATION_SPEED dt))
                }
                
                if thrust {
                    set ship_vx (+ ship_vx (* (cos ship_angle) (* SHIP_THRUST dt)))
                    set ship_vy (+ ship_vy (* (sin ship_angle) (* SHIP_THRUST dt)))
                }
                
                set ship_vx (* ship_vx SHIP_DRAG)
                set ship_vy (* ship_vy SHIP_DRAG)
                set ship_x (wrap_position (+ ship_x (* ship_vx dt)) (cast_float WINDOW_WIDTH))
                set ship_y (wrap_position (+ ship_y (* ship_vy dt)) (cast_float WINDOW_HEIGHT))
            }
        }
        
        # Always update asteroids, bullets, particles (even when dead)
        let mut i: int = 0
        while (< i (array_length asteroid_x)) {
            if (at asteroid_active i) {
                let ax: float = (at asteroid_x i)
                let ay: float = (at asteroid_y i)
                let avx: float = (at asteroid_vx i)
                let avy: float = (at asteroid_vy i)
                
                let new_x: float = (wrap_position (+ ax (* avx dt)) (cast_float WINDOW_WIDTH))
                let new_y: float = (wrap_position (+ ay (* avy dt)) (cast_float WINDOW_HEIGHT))
                
                (array_set asteroid_x i new_x)
                (array_set asteroid_y i new_y)
            }
            set i (+ i 1)
        }
        
        # Update bullets (only if playing)
        if (== game_state STATE_PLAYING) {
            set i 0
            while (< i (array_length bullet_x)) {
                let active: bool = (at bullet_active i)
                if active {
                    let bx: float = (at bullet_x i)
                    let by: float = (at bullet_y i)
                    let bvx: float = (at bullet_vx i)
                    let bvy: float = (at bullet_vy i)
                    let life: float = (at bullet_life i)
                    
                    let new_x: float = (+ bx (* bvx dt))
                    let new_y: float = (+ by (* bvy dt))
                    let new_life: float = (- life dt)
                    
                    (array_set bullet_x i new_x)
                    (array_set bullet_y i new_y)
                    (array_set bullet_life i new_life)
                    
                    # Deactivate if off screen or life expired
                    if (< new_life 0.0) {
                        (array_set bullet_active i false)
                    } else {
                        if (< new_x 0.0) { (array_set bullet_active i false) }
                        if (> new_x (cast_float WINDOW_WIDTH)) { (array_set bullet_active i false) }
                        if (< new_y 0.0) { (array_set bullet_active i false) }
                        if (> new_y (cast_float WINDOW_HEIGHT)) { (array_set bullet_active i false) }
                    }
                }
                set i (+ i 1)
            }
        }
        
        # Update particles
        set i 0
        while (< i (array_length particle_x)) {
            let px: float = (at particle_x i)
            let py: float = (at particle_y i)
            let pvx: float = (at particle_vx i)
            let pvy: float = (at particle_vy i)
            let plife: float = (at particle_life i)
            
            (array_set particle_x i (+ px (* pvx dt)))
            (array_set particle_y i (+ py (* pvy dt)))
            (array_set particle_life i (- plife dt))
            set i (+ i 1)
        }
        
        # Collision: bullets vs asteroids (only if playing)
        if (== game_state STATE_PLAYING) {
            set i 0
            while (< i (array_length bullet_x)) {
                let bullet_is_active: bool = (at bullet_active i)
                if bullet_is_active {
                    let bx: float = (at bullet_x i)
                    let by: float = (at bullet_y i)
                    
                    let mut j: int = 0
                    while (< j (array_length asteroid_x)) {
                        let asteroid_is_active: bool = (at asteroid_active j)
                        if asteroid_is_active {
                            let ax: float = (at asteroid_x j)
                            let ay: float = (at asteroid_y j)
                            let asize: int = (at asteroid_size j)
                            let aradius: float = (get_asteroid_radius asize)
                            
                            if (circles_collide bx by 2.0 ax ay aradius) {
                                # Hit! Deactivate bullet and asteroid
                                (array_set bullet_active i false)
                                (array_set asteroid_active j false)
                                
                                # Add score based on size
                                set score (+ score (get_asteroid_score asize))
                                
                                # Create explosion particles
                                let mut k: int = 0
                                let particle_count: int = (* asize 10)
                                while (< k particle_count) {
                                    let angle: float = (* (cast_float k) (/ (* 2.0 PI) (cast_float particle_count)))
                                    let speed: float = (+ 50.0 (* (cast_float (% k 20)) 3.0))
                                    
                                    set particle_x (array_push particle_x ax)
                                    set particle_y (array_push particle_y ay)
                                    set particle_vx (array_push particle_vx (* (cos angle) speed))
                                    set particle_vy (array_push particle_vy (* (sin angle) speed))
                                    set particle_life (array_push particle_life 0.8)
                                    set k (+ k 1)
                                }
                                
                                # BREAK ASTEROID INTO SMALLER ONES!
                                if (== asize ASTEROID_SIZE_LARGE) {
                                    # Large -> 2 Medium
                                    let avx: float = (at asteroid_vx j)
                                    let avy: float = (at asteroid_vy j)
                                    
                                    # Medium 1 (rotate velocity +90 degrees)
                                    set asteroid_x (array_push asteroid_x ax)
                                    set asteroid_y (array_push asteroid_y ay)
                                    set asteroid_vx (array_push asteroid_vx (* (- avy) 1.5))
                                    set asteroid_vy (array_push asteroid_vy (* avx 1.5))
                                    set asteroid_size (array_push asteroid_size ASTEROID_SIZE_MEDIUM)
                                    set asteroid_active (array_push asteroid_active true)
                                    
                                    # Medium 2 (rotate velocity -90 degrees)
                                    set asteroid_x (array_push asteroid_x ax)
                                    set asteroid_y (array_push asteroid_y ay)
                                    set asteroid_vx (array_push asteroid_vx (* avy 1.5))
                                    set asteroid_vy (array_push asteroid_vy (* (- avx) 1.5))
                                    set asteroid_size (array_push asteroid_size ASTEROID_SIZE_MEDIUM)
                                    set asteroid_active (array_push asteroid_active true)
                                } else {
                                    if (== asize ASTEROID_SIZE_MEDIUM) {
                                        # Medium -> 3 Small
                                        let avx: float = (at asteroid_vx j)
                                        let avy: float = (at asteroid_vy j)
                                        
                                        # Small 1 (velocity * 2)
                                        set asteroid_x (array_push asteroid_x ax)
                                        set asteroid_y (array_push asteroid_y ay)
                                        set asteroid_vx (array_push asteroid_vx (* avx 2.0))
                                        set asteroid_vy (array_push asteroid_vy (* avy 2.0))
                                        set asteroid_size (array_push asteroid_size ASTEROID_SIZE_SMALL)
                                        set asteroid_active (array_push asteroid_active true)
                                        
                                        # Small 2 (rotate +120 degrees)
                                        let cos120: float = -0.5
                                        let sin120: float = 0.866
                                        let vx2: float = (- (* avx cos120) (* avy sin120))
                                        let vy2: float = (+ (* avx sin120) (* avy cos120))
                                        set asteroid_x (array_push asteroid_x ax)
                                        set asteroid_y (array_push asteroid_y ay)
                                        set asteroid_vx (array_push asteroid_vx (* vx2 2.0))
                                        set asteroid_vy (array_push asteroid_vy (* vy2 2.0))
                                        set asteroid_size (array_push asteroid_size ASTEROID_SIZE_SMALL)
                                        set asteroid_active (array_push asteroid_active true)
                                        
                                        # Small 3 (rotate -120 degrees)
                                        let vx3: float = (- (* avx cos120) (* avy (- sin120)))
                                        let vy3: float = (+ (* avx (- sin120)) (* avy cos120))
                                        set asteroid_x (array_push asteroid_x ax)
                                        set asteroid_y (array_push asteroid_y ay)
                                        set asteroid_vx (array_push asteroid_vx (* vx3 2.0))
                                        set asteroid_vy (array_push asteroid_vy (* vy3 2.0))
                                        set asteroid_size (array_push asteroid_size ASTEROID_SIZE_SMALL)
                                        set asteroid_active (array_push asteroid_active true)
                                    } else {
                                        # Small -> Destroyed (no children)
                                    }
                                }
                            }
                        }
                        set j (+ j 1)
                    }
                }
                set i (+ i 1)
            }
        }
        
        # Collision: ship vs asteroids (only if playing)
        if (== game_state STATE_PLAYING) {
            if ship_alive {
                set i 0
                while (< i (array_length asteroid_x)) {
                    let asteroid_is_active: bool = (at asteroid_active i)
                    if asteroid_is_active {
                        let ax: float = (at asteroid_x i)
                        let ay: float = (at asteroid_y i)
                        let asize: int = (at asteroid_size i)
                        let aradius: float = (get_asteroid_radius asize)
                        
                        if (circles_collide ship_x ship_y SHIP_SIZE ax ay aradius) {
                            set ship_alive false
                            set lives (- lives 1)
                            set game_state STATE_DEAD
                            set respawn_timer RESPAWN_DELAY
                            
                            # Ship explosion (40 particles)
                            let mut k: int = 0
                            while (< k 40) {
                                let angle: float = (* (cast_float k) (/ (* 2.0 PI) 40.0))
                                let speed: float = (+ 80.0 (* (cast_float (% k 25)) 4.0))
                                
                                set particle_x (array_push particle_x ship_x)
                                set particle_y (array_push particle_y ship_y)
                                set particle_vx (array_push particle_vx (* (cos angle) speed))
                                set particle_vy (array_push particle_vy (* (sin angle) speed))
                                set particle_life (array_push particle_life 1.0)
                                set k (+ k 1)
                            }
                        }
                    }
                    set i (+ i 1)
                }
            }
        }
        
        # Render
        (SDL_SetRenderDrawColor renderer 0 0 0 255) 
        (SDL_RenderClear renderer) 
        
        # Draw ship (only if alive)
        if ship_alive {
            (SDL_SetRenderDrawColor renderer 255 255 255 255) 
            
            let cos_a: float = (cos ship_angle)
            let sin_a: float = (sin ship_angle)
            
            let fx: int = (cast_int (+ ship_x (* cos_a SHIP_SIZE)))
            let fy: int = (cast_int (+ ship_y (* sin_a SHIP_SIZE)))
            
            let back_angle1: float = (+ ship_angle 2.5)
            let bx1: int = (cast_int (+ ship_x (* (cos back_angle1) (* SHIP_SIZE 0.6))))
            let by1: int = (cast_int (+ ship_y (* (sin back_angle1) (* SHIP_SIZE 0.6))))
            
            let back_angle2: float = (- ship_angle 2.5)
            let bx2: int = (cast_int (+ ship_x (* (cos back_angle2) (* SHIP_SIZE 0.6))))
            let by2: int = (cast_int (+ ship_y (* (sin back_angle2) (* SHIP_SIZE 0.6))))
            
            (SDL_RenderDrawLine renderer (cast_int ship_x) (cast_int ship_y) fx fy) 
            (SDL_RenderDrawLine renderer fx fy bx1 by1) 
            (SDL_RenderDrawLine renderer bx1 by1 bx2 by2) 
            (SDL_RenderDrawLine renderer bx2 by2 fx fy) 
            
            # Draw thrust cone if thrusting (only when playing)
            if (== game_state STATE_PLAYING) {
                if thrust {
                    (SDL_SetRenderDrawColor renderer 255 200 0 255) 
                    
                    # Thrust cone points backward from ship center
                    let thrust_length: float = (* SHIP_SIZE 0.8)
                    let thrust_angle: float = (+ ship_angle PI)
                    
                    let tx: int = (cast_int (+ ship_x (* (cos thrust_angle) thrust_length)))
                    let ty: int = (cast_int (+ ship_y (* (sin thrust_angle) thrust_length)))
                    
                    # Draw thrust cone as lines
                    (SDL_RenderDrawLine renderer (cast_int ship_x) (cast_int ship_y) tx ty) 
                    (SDL_RenderDrawLine renderer bx1 by1 tx ty) 
                    (SDL_RenderDrawLine renderer bx2 by2 tx ty) 
                }
            }
        }
        
        # Draw asteroids (different sizes!)
        set i 0
        while (< i (array_length asteroid_x)) {
            let active: bool = (at asteroid_active i)
            if active {
                let asize: int = (at asteroid_size i)
                
                # Color by size using helper
                let gray: int = (get_asteroid_gray asize)
                (SDL_SetRenderDrawColor renderer gray gray gray 255)
                
                let ax: int = (cast_int (at asteroid_x i))
                let ay: int = (cast_int (at asteroid_y i))
                let aradius: float = (get_asteroid_radius asize)
                
                # Draw circle using points
                let mut angle: int = 0
                while (< angle 360) {
                    let rad: float = (* (cast_float angle) DEG_TO_RAD)
                    let px: int = (cast_int (+ (cast_float ax) (* aradius (cos rad))))
                    let py: int = (cast_int (+ (cast_float ay) (* aradius (sin rad))))
                    (SDL_RenderDrawPoint renderer px py) 
                    set angle (+ angle 10)
                }
            }
            set i (+ i 1)
        }
        
        # Draw bullets
        set i 0
        while (< i (array_length bullet_x)) {
            let active: bool = (at bullet_active i)
            if active {
                (SDL_SetRenderDrawColor renderer 255 255 0 255) 
                let bx: int = (cast_int (at bullet_x i))
                let by: int = (cast_int (at bullet_y i))
                (SDL_RenderDrawPoint renderer bx by) 
                (SDL_RenderDrawPoint renderer (+ bx 1) by) 
                (SDL_RenderDrawPoint renderer bx (+ by 1)) 
                (SDL_RenderDrawPoint renderer (+ bx 1) (+ by 1)) 
            }
            set i (+ i 1)
        }
        
        # Draw particles
        set i 0
        while (< i (array_length particle_x)) {
            let plife: float = (at particle_life i)
            if (> plife 0.0) {
                let alpha: int = (cast_int (* plife 255.0))
                (SDL_SetRenderDrawColor renderer 255 150 0 alpha) 
                (SDL_RenderDrawPoint renderer (cast_int (at particle_x i)) (cast_int (at particle_y i))) 
            }
            set i (+ i 1)
        }
        
        # Draw HUD
        if (!= font 0) {
            # Draw Lives (top left)
            let lives_text: string = (+ "Lives: " (int_to_string lives))
            (nl_draw_text_blended renderer font lives_text 10 10 255 255 255 255) 
            
            # Draw Score (top center)
            let score_text: string = (+ "Score: " (int_to_string score))
            (nl_draw_text_blended renderer font score_text 350 10 255 255 0 255) 
            
            # Debug mode checkbox (bottom left)
            set debug_mode (nl_ui_checkbox renderer font "Debug" 10 560 debug_mode)
            
            # Draw debug info if enabled
            if (== debug_mode 1) {
                let asteroid_count: int = (array_length asteroid_x)
                let bullet_count: int = (array_length bullet_x)
                let mut debug_text: string = (+ "Asteroids: " (int_to_string asteroid_count))
                set debug_text (+ debug_text " Bullets: ")
                set debug_text (+ debug_text (int_to_string bullet_count))
                (nl_draw_text_blended renderer font debug_text 150 563 100 255 100 255) 
            }
        } else {
            # Fallback: Draw simple HUD with rectangles if font didn't load
            (SDL_SetRenderDrawColor renderer 255 255 255 255) 
            
            # Lives indicator (top left) - draw small rectangles for each life
            let mut life_i: int = 0
            while (< life_i lives) {
                let lx: int = (+ 10 (* life_i 20))
                (nl_sdl_render_fill_rect renderer lx 10 15 15) 
                set life_i (+ life_i 1)
            }
            
            # Score indicator (bottom right) - draw rectangles proportional to score
            (SDL_SetRenderDrawColor renderer 255 255 0 255) 
            let mut score_width: int = (/ score 10)
            if (> score_width 200) { set score_width 200 }
            (nl_sdl_render_fill_rect renderer (- 790 score_width) 570 score_width 20) 
        }
        
        # Draw GAME OVER screen
        if (== game_state STATE_GAME_OVER) {
            # Draw semi-transparent overlay
            (SDL_SetRenderDrawColor renderer 0 0 0 128) 
            (nl_sdl_render_fill_rect renderer 0 0 WINDOW_WIDTH WINDOW_HEIGHT) 
            
            if (!= font 0) {
                # Draw GAME OVER text with fonts
                (nl_draw_text_blended renderer font_large "GAME OVER" 250 250 255 0 0 255) 
                
                # Draw final score
                let final_score_text: string = (+ "Final Score: " (int_to_string score))
                (nl_draw_text_blended renderer font final_score_text 280 320 255 255 255 255) 
                
                # Restart button
                if (== (nl_ui_button renderer font "Restart Game" 325 380 150 40) 1) {
                    # Restart game
                    set game_state STATE_PLAYING
                    set lives STARTING_LIVES
                    set score 0
                    set ship_alive true
                    set ship_x (/ (cast_float WINDOW_WIDTH) 2.0)
                    set ship_y (/ (cast_float WINDOW_HEIGHT) 2.0)
                    set ship_vx 0.0
                    set ship_vy 0.0
                    set ship_angle 0.0
                    
                    # Clear all arrays
                    set asteroid_x []
                    set asteroid_y []
                    set asteroid_vx []
                    set asteroid_vy []
                    set asteroid_size []
                    set bullet_x []
                    set bullet_y []
                    set bullet_vx []
                    set bullet_vy []
                    set bullet_life []
                    
                    # Spawn new asteroids
                    let mut spawn_i: int = 0
                    while (< spawn_i 3) {
                        let rand_x: float = (cast_float (* (% spawn_i 7) 100))
                        let rand_y: float = (cast_float (* (% spawn_i 5) 100))
                        let rand_vx: float = (- (cast_float (* (% spawn_i 3) 30)) 45.0)
                        let rand_vy: float = (- (cast_float (* (% spawn_i 4) 30)) 45.0)
                        
                        set asteroid_x (array_push asteroid_x rand_x)
                        set asteroid_y (array_push asteroid_y rand_y)
                        set asteroid_vx (array_push asteroid_vx rand_vx)
                        set asteroid_vy (array_push asteroid_vy rand_vy)
                        set asteroid_size (array_push asteroid_size ASTEROID_SIZE_LARGE)
                        
                        set spawn_i (+ spawn_i 1)
                    }
                }
            } else {
                # Fallback: Draw large red rectangle for GAME OVER
                (SDL_SetRenderDrawColor renderer 255 0 0 255) 
                (nl_sdl_render_fill_rect renderer 250 250 300 50) 
                
                # Draw white border
                (SDL_SetRenderDrawColor renderer 255 255 255 255) 
                (SDL_RenderDrawLine renderer 250 250 550 250) 
                (SDL_RenderDrawLine renderer 550 250 550 300) 
                (SDL_RenderDrawLine renderer 550 300 250 300) 
                (SDL_RenderDrawLine renderer 250 300 250 250) 
            }
        }
        
        # Draw on-screen help
        
        (SDL_RenderPresent renderer) 
        (SDL_Delay 16) 
    }
    
    (TTF_CloseFont font) 
    (TTF_CloseFont font_large) 
    (TTF_CloseFont help_font) 
    (TTF_Quit) 
    (SDL_DestroyRenderer renderer) 
    (SDL_DestroyWindow window) 
    (SDL_Quit) 
    
    return 0
}

shadow wrap_position {
    assert (== (wrap_position -5.0 100.0) 100.0)
    assert (== (wrap_position 105.0 100.0) 0.0)
    assert (== (wrap_position 50.0 100.0) 50.0)
}

shadow distance_squared {
    assert (== (distance_squared 0.0 0.0 3.0 4.0) 25.0)
    assert (== (distance_squared 1.0 1.0 1.0 1.0) 0.0)
}

shadow circles_collide {
    assert (circles_collide 0.0 0.0 10.0 5.0 5.0 10.0)
    assert (not (circles_collide 0.0 0.0 5.0 100.0 100.0 5.0))
}

shadow get_asteroid_radius {
    assert (== (get_asteroid_radius ASTEROID_SIZE_LARGE) ASTEROID_RADIUS_LARGE)
    assert (== (get_asteroid_radius ASTEROID_SIZE_MEDIUM) ASTEROID_RADIUS_MEDIUM)
    assert (== (get_asteroid_radius ASTEROID_SIZE_SMALL) ASTEROID_RADIUS_SMALL)
}

shadow get_asteroid_score {
    assert (== (get_asteroid_score ASTEROID_SIZE_LARGE) SCORE_LARGE)
    assert (== (get_asteroid_score ASTEROID_SIZE_MEDIUM) SCORE_MEDIUM)
    assert (== (get_asteroid_score ASTEROID_SIZE_SMALL) SCORE_SMALL)
}

shadow main {
    assert true
}
