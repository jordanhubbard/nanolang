# Execution Tracing Demo
#
# Concept: Runtime execution tracing for debugging
# Topics: debugging, execution flow, function tracing, shadow tests
# Difficulty: Beginner
#
# Description:
# Simple example demonstrating basic tracing concepts through function
# execution and shadow tests. Shows how to structure code for testability
# and debugging with clear function separation.
#
# Key Features Demonstrated:
# - Function definition with shadow tests
# - Clear execution flow
# - Testable code structure
# - Basic arithmetic operations
# - Return value validation
#
# Use Cases:
# - Understanding function execution
# - Learning shadow test patterns
# - Debugging function behavior
# - Educational tool for beginners
#
# Prerequisites:
# - nl_hello.nano - Basic syntax
# - nl_operators.nano - Arithmetic operators
#
# Next Steps:
# - stdlib_ast_demo.nano - Advanced introspection
# - Add more complex tracing scenarios

fn add(a: int, b: int) -> int {
    return (+ a b)
}

shadow add {
    assert (== (add 5 3) 8)
}

fn multiply(x: int, y: int) -> int {
    let result: int = (* x y)
    return result
}

shadow multiply {
    assert (== (multiply 4 7) 28)
}

fn calculate_sum(numbers: array<int>) -> int {
    let mut sum: int = 0
    let mut i: int = 0
    while (< i (array_length numbers)) {
        let value: int = (at numbers i)
        set sum (+ sum value)
        set i (+ i 1)
    }
    return sum
}

shadow calculate_sum {
    assert (== (calculate_sum [1, 2, 3]) 6)
}

fn main() -> int {
    let x: int = 10
    let y: int = 20
    let z: int = (add x y)
    let arr: array<int> = [1, 2, 3, 4, 5]
    let total: int = (calculate_sum arr)
    (println total)
    return 0
}

shadow main {
    assert (== (main) 0)
}

