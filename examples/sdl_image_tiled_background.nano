# SDL_image Tiled Background Example
# Demonstrates creating tiled/repeating backgrounds
#
# This example shows:
# - Loading a tile texture
# - Rendering tiles in a grid pattern
# - Creating seamless tiled backgrounds
# - Scrolling backgrounds

import "modules/sdl/sdl.nano"
import "modules/sdl_helpers/sdl_helpers.nano"
import "modules/sdl_image/sdl_image.nano"

fn main() -> int {
    (println "=== SDL_image Tiled Background Demo ===")
    (println "")
    (println "Creating scrolling tiled background...")
    (println "")
    
    # Initialize SDL and SDL_image
    unsafe { (SDL_Init 32) }
    let img_init: int = (IMG_Init IMG_INIT_PNG)
    if (== img_init 0) {
        (println "Failed to initialize SDL_image")
        return 1
    } else {}
    
    # Create window and renderer
    let window: SDL_Window = (SDL_CreateWindow "Tiled Background Demo"
                                                100 100 800 600 4)
    let renderer: SDL_Renderer = (SDL_CreateRenderer window -1 2)
    
    # Load tile textures (using icons as tiles)
    (println "Loading tile textures...")
    let tile1: int = (nl_img_load_png_texture renderer "examples/icons/sdl_particles.png")
    let tile2: int = (nl_img_load_png_texture renderer "examples/icons/sdl_fire.png")
    let tile3: int = (nl_img_load_png_texture renderer "examples/icons/sdl_boids.png")
    
    if (== tile1 0) {
        (println "Failed to load tile textures")
        return 1
    } else {
        (println "✓ Loaded tile textures")
    }
    
    let tile_size: int = 80
    let tiles_x: int = (+ (/ 800 tile_size) 2)  # Extra tiles for scrolling
    let tiles_y: int = (+ (/ 600 tile_size) 2)
    
    # Scrolling state
    let mut scroll_x: int = 0
    let mut scroll_y: int = 0
    let scroll_speed: int = 1
    
    (println "")
    (println "Controls:")
    (println "  - Watch the tiled background scroll")
    (println "  - Arrow keys to control scroll (when implemented)")
    (println "  - Close window to exit")
    (println "")
    
    # Main loop
    let mut running: bool = true
    let mut frame: int = 0
    while running {
        # Check for quit
        let quit: int = (nl_sdl_poll_event_quit)
        if (== quit 1) {
            set running false
        } else {}
        
        # Update scroll position
        set scroll_x (+ scroll_x scroll_speed)
        set scroll_y (+ scroll_y scroll_speed)
        
        # Wrap scrolling
        if (>= scroll_x tile_size) {
            set scroll_x (- scroll_x tile_size)
        } else {}
        if (>= scroll_y tile_size) {
            set scroll_y (- scroll_y tile_size)
        } else {}
        
        set frame (+ frame 1)
        
        # Clear screen
        unsafe { (SDL_SetRenderDrawColor renderer 20 20 30 255) }
        unsafe { (SDL_RenderClear renderer) }
        
        # Draw tiled background
        let mut tile_y_idx: int = 0
        while (<= tile_y_idx tiles_y) {
            let mut tile_x_idx: int = 0
            while (<= tile_x_idx tiles_x) {
                # Calculate tile position with scroll offset
                let tile_x: int = (- (* tile_x_idx tile_size) scroll_x)
                let tile_y: int = (- (* tile_y_idx tile_size) scroll_y)
                
                # Select tile pattern (checkerboard with 3 types)
                let tile_pattern: int = (% (+ tile_x_idx tile_y_idx) 3)
                let mut current_tile: int = tile1
                if (== tile_pattern 1) {
                    set current_tile tile2
                } else {}
                if (== tile_pattern 2) {
                    set current_tile tile3
                } else {}
                
                # Set alpha for depth effect (tiles further from center are more transparent)
                let center_x: int = 400
                let center_y: int = 300
                let mut dist_x: int = (- tile_x center_x)
                let mut dist_y: int = (- tile_y center_y)
                if (< dist_x 0) {
                    set dist_x (* dist_x -1)
                } else {}
                if (< dist_y 0) {
                    set dist_y (* dist_y -1)
                } else {}
                let dist: int = (+ dist_x dist_y)
                let mut alpha: int = (- 255 (/ dist 4))
                if (< alpha 100) {
                    set alpha 100
                } else {}
                if (> alpha 255) {
                    set alpha 255
                } else {}
                
                unsafe { (nl_img_set_texture_alpha current_tile alpha) }
                
                # Draw tile
                unsafe { (nl_img_render_texture renderer current_tile tile_x tile_y tile_size tile_size) }
                
                set tile_x_idx (+ tile_x_idx 1)
            }
            set tile_y_idx (+ tile_y_idx 1)
        }
        
        # Draw info overlay
        unsafe { (SDL_SetRenderDrawColor renderer 0 0 0 180) }
        unsafe { (nl_sdl_render_fill_rect renderer 10 10 200 60) }
        
        # Present
        unsafe { (SDL_RenderPresent renderer) }
        unsafe { (SDL_Delay 16) }
    }
    
    # Cleanup
    (println "")
    (println "Cleaning up...")
    unsafe { (nl_img_destroy_texture tile1) }
    unsafe { (nl_img_destroy_texture tile2) }
    unsafe { (nl_img_destroy_texture tile3) }
    
    unsafe { (SDL_DestroyRenderer renderer) }
    unsafe { (SDL_DestroyWindow window) }
    unsafe { (IMG_Quit) }
    unsafe { (SDL_Quit) }
    
    (println "✓ Tiled background demo completed")
    return 0
}

shadow main {
    assert (== 1 1)  # Cannot test with shadow as it requires SDL context
}

