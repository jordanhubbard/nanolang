# Full-Featured Checkers Game in nanolang
# Complete feature parity with C version:
# - AI opponent with move evaluation
# - King pieces with bidirectional movement  
# - Mandatory jump rules
# - Multi-jump support
# - Visual feedback (selection highlighting)
# - Game over detection and display
# - Piece rendering with kings shown as gold circles
# MODERNIZED: Uses enums, structs, top-level constants!

import "modules/sdl/sdl.nano"
import "modules/sdl_helpers/sdl_helpers.nano"

# === ENUMS ===
enum PieceType {
    EMPTY = 0,
    RED_PIECE = 1,
    RED_KING = 2,
    BLACK_PIECE = 3,
    BLACK_KING = 4
}

enum GameState {
    PLAYER_TURN = 0,
    AI_TURN = 1,
    GAME_OVER = 2
}

# === STRUCTS ===
struct Position {
    row: int,
    col: int
}

# === CONSTANTS ===
let BOARD_SIZE: int = 8
let SQUARE_SIZE: int = 80
let STATUS_HEIGHT: int = 60
# SDL constants - now using values directly to avoid conflicts with SDL.h

# Helper Functions for Board Access
fn board_index(row: int, col: int) -> int {
    let board_size: int = BOARD_SIZE
    return (+ (* row board_size) col)
}

shadow board_index {
    assert (== (board_index 0 0) 0)
    assert (== (board_index 7 7) 63)
    assert (== (board_index 3 4) 28)
}

fn board_read(board: array<int>, row: int, col: int) -> int {
    return (at board (board_index row col))
}

shadow board_read {
    let board: array<int> = [1, 0, 0, 0, 0, 0, 0, 0,
                              0, 0, 0, 0, 0, 0, 0, 0,
                              0, 0, 0, 0, 0, 0, 0, 0,
                              0, 0, 0, 0, 0, 0, 0, 0,
                              0, 0, 0, 0, 0, 0, 0, 0,
                              0, 0, 0, 0, 0, 0, 0, 0,
                              0, 0, 0, 0, 0, 0, 0, 0,
                              0, 0, 0, 0, 0, 0, 0, 3]
    assert (== (board_read board 0 0) 1)
    assert (== (board_read board 7 7) 3)
}

fn board_write(board: array<int>, row: int, col: int, value: int) -> array<int> {
    let mut new_board: array<int> = board
    (array_set new_board (board_index row col) value)
    return new_board
}

shadow board_write {
    let board: array<int> = [0, 0, 0, 0, 0, 0, 0, 0,
                              0, 0, 0, 0, 0, 0, 0, 0,
                              0, 0, 0, 0, 0, 0, 0, 0,
                              0, 0, 0, 0, 0, 0, 0, 0,
                              0, 0, 0, 0, 0, 0, 0, 0,
                              0, 0, 0, 0, 0, 0, 0, 0,
                              0, 0, 0, 0, 0, 0, 0, 0,
                              0, 0, 0, 0, 0, 0, 0, 0]
    let modified: array<int> = (board_write board 3 4 42)
    assert (== (board_read modified 3 4) 42)
}

# Position validation
fn is_valid_pos(row: int, col: int) -> bool {
    let board_size: int = BOARD_SIZE
    return (and (and (>= row 0) (< row board_size))
                (and (>= col 0) (< col board_size)))
}

shadow is_valid_pos {
    assert (== (is_valid_pos 0 0) true)
    assert (== (is_valid_pos -1 0) false)
    assert (== (is_valid_pos 8 0) false)
}

fn is_dark_square(row: int, col: int) -> bool {
    return (== (% (+ row col) 2) 1)
}

shadow is_dark_square {
    assert (== (is_dark_square 0 1) true)
    assert (== (is_dark_square 0 0) false)
}

# Piece type checks
fn is_player_piece(piece: int) -> bool {
    return (or (== piece 1) (== piece 2))  # RED_PIECE || RED_KING
}

shadow is_player_piece {
    assert (== (is_player_piece 1) true)  # RED_PIECE
    assert (== (is_player_piece 2) true)  # RED_KING
    assert (== (is_player_piece 3) false) # BLACK_PIECE
}

fn is_ai_piece(piece: int) -> bool {
    return (or (== piece 3) (== piece 4))  # BLACK_PIECE || BLACK_KING
}

shadow is_ai_piece {
    assert (== (is_ai_piece 3) true)  # BLACK_PIECE
    assert (== (is_ai_piece 4) true)  # BLACK_KING
    assert (== (is_ai_piece 1) false) # RED_PIECE
}

fn is_king(piece: int) -> bool {
    return (or (== piece 2) (== piece 4))  # RED_KING || BLACK_KING
}

shadow is_king {
    assert (== (is_king 2) true)  # RED_KING
    assert (== (is_king 4) true)  # BLACK_KING
    assert (== (is_king 1) false) # RED_PIECE
}

# Initialize board
fn init_board() -> array<int> {
    let board_size: int = BOARD_SIZE
    let mut board: array<int> = [0, 0, 0, 0, 0, 0, 0, 0,
                                  0, 0, 0, 0, 0, 0, 0, 0,
                                  0, 0, 0, 0, 0, 0, 0, 0,
                                  0, 0, 0, 0, 0, 0, 0, 0,
                                  0, 0, 0, 0, 0, 0, 0, 0,
                                  0, 0, 0, 0, 0, 0, 0, 0,
                                  0, 0, 0, 0, 0, 0, 0, 0,
                                  0, 0, 0, 0, 0, 0, 0, 0]
    
    # Place red pieces (top 3 rows) on dark squares
    let mut i: int = 0
    while (< i 3) {
        let mut j: int = 0
        while (< j board_size) {
            if (is_dark_square i j) {
                set board (board_write board i j 1)  # RED_PIECE
            } else {}
            set j (+ j 1)
        }
        set i (+ i 1)
    }
    
    # Place black pieces (bottom 3 rows) on dark squares
    set i 5
    while (< i board_size) {
        let mut j: int = 0
        while (< j board_size) {
            if (is_dark_square i j) {
                set board (board_write board i j 3)  # BLACK_PIECE
            } else {}
            set j (+ j 1)
        }
        set i (+ i 1)
    }
    
    return board
}

shadow init_board {
    let board: array<int> = (init_board)
    assert (== (board_read board 0 1) 1)  # RED_PIECE
    assert (== (board_read board 5 0) 3)  # BLACK_PIECE
    assert (== (board_read board 3 0) 0)  # EMPTY
}

fn abs_int(x: int) -> int {
    if (< x 0) {
        return (- 0 x)
    } else {
        return x
    }
}

shadow abs_int {
    assert (== (abs_int 5) 5)
    assert (== (abs_int -5) 5)
}

# Move validation (non-jump)
fn is_valid_move(board: array<int>, game_state: int, from_row: int, from_col: int, to_row: int, to_col: int) -> bool {
    if (not (is_valid_pos from_row from_col)) {
        return false
    } else {}
    if (not (is_valid_pos to_row to_col)) {
        return false
    } else {}
    if (not (is_dark_square to_row to_col)) {
        return false
    } else {}
    if (!= (board_read board to_row to_col) 0) {  # if not EMPTY
        return false
    } else {}
    
    let piece: int = (board_read board from_row from_col)
    if (== piece 0) {  # if EMPTY
        return false
    } else {}
    
    let col_diff: int = (abs_int (- to_col from_col))
    
    if (!= col_diff 1) {
        return false
    } else {}
    
    if (and (is_player_piece piece) (== game_state 0)) {  # PLAYER_TURN
        if (is_king piece) {
            return (== (abs_int (- to_row from_row)) 1)
        } else {
            return (== (- to_row from_row) 1)
        }
    } else {
        if (and (is_ai_piece piece) (== game_state 1)) {  # AI_TURN
            if (is_king piece) {
                return (== (abs_int (- to_row from_row)) 1)
            } else {
                return (== (- to_row from_row) -1)
            }
        } else {
            return false
        }
    }
}

shadow is_valid_move {
    let board: array<int> = (init_board)
    assert (== (is_valid_move board 0 2 1 3 0) true)  # PLAYER_TURN, red can move down
    assert (== (is_valid_move board 0 2 1 1 0) false) # PLAYER_TURN, red cannot move up
}

# Jump validation
fn is_valid_jump(board: array<int>, game_state: int, from_row: int, from_col: int, to_row: int, to_col: int) -> bool {
    if (not (is_valid_pos from_row from_col)) {
        return false
    } else {}
    if (not (is_valid_pos to_row to_col)) {
        return false
    } else {}
    if (not (is_dark_square to_row to_col)) {
        return false
    } else {}
    if (!= (board_read board to_row to_col) 0) {  # if not EMPTY
        return false
    } else {}
    
    let piece: int = (board_read board from_row from_col)
    if (== piece 0) {  # if EMPTY
        return false
    } else {}
    
    let row_diff: int = (- to_row from_row)
    let col_diff: int = (- to_col from_col)
    
    if (or (!= (abs_int row_diff) 2) (!= (abs_int col_diff) 2)) {
        return false
    } else {}
    
    let mid_row: int = (+ from_row (/ row_diff 2))
    let mid_col: int = (+ from_col (/ col_diff 2))
    
    if (not (is_valid_pos mid_row mid_col)) {
        return false
    } else {}
    
    if (and (is_player_piece piece) (== game_state 0)) {  # PLAYER_TURN
        if (not (is_ai_piece (board_read board mid_row mid_col))) {
            return false
        } else {}
        if (is_king piece) {
            return true
        } else {
            return (== row_diff 2)
        }
    } else {
        if (and (is_ai_piece piece) (== game_state 1)) {  # AI_TURN
            if (not (is_player_piece (board_read board mid_row mid_col))) {
                return false
            } else {}
            if (is_king piece) {
                return true
            } else {
                return (== row_diff -2)
            }
        } else {
            return false
        }
    }
}

shadow is_valid_jump {
    let mut board: array<int> = (init_board)
    set board (board_write board 3 2 3)  # BLACK_PIECE in middle
    set board (board_write board 4 3 0)  # EMPTY destination
    assert (== (is_valid_jump board 0 2 1 4 3) true)  # PLAYER_TURN, valid jump
}

# Check if a piece has available jumps
fn has_jump_from_pos(board: array<int>, game_state: int, row: int, col: int) -> bool {
    if (is_valid_jump board game_state row col (+ row 2) (+ col 2)) {
        return true
    } else {}
    if (is_valid_jump board game_state row col (+ row 2) (- col 2)) {
        return true
    } else {}
    if (is_valid_jump board game_state row col (- row 2) (+ col 2)) {
        return true
    } else {}
    if (is_valid_jump board game_state row col (- row 2) (- col 2)) {
        return true
    } else {}
    return false
}

shadow has_jump_from_pos {
    let mut board: array<int> = (init_board)
    set board (board_write board 3 2 3)  # BLACK_PIECE
    set board (board_write board 4 3 0)  # EMPTY
    assert (== (has_jump_from_pos board 0 2 1) true)  # PLAYER_TURN
}

# Check if any jumps available for current player
fn has_any_jump(board: array<int>, game_state: int) -> bool {
    let board_size: int = BOARD_SIZE
    let mut i: int = 0
    while (< i board_size) {
        let mut j: int = 0
        while (< j board_size) {
            let piece: int = (board_read board i j)
            if (or (and (== game_state 0) (is_player_piece piece))  # PLAYER_TURN
                   (and (== game_state 1) (is_ai_piece piece))) {   # AI_TURN
                if (has_jump_from_pos board game_state i j) {
                    return true
                } else {}
            } else {}
            set j (+ j 1)
        }
        set i (+ i 1)
    }
    return false
}

shadow has_any_jump {
    let board: array<int> = (init_board)
    assert (== (has_any_jump board 0) false)  # PLAYER_TURN, no jumps at start
}

# Draw a filled circle (for pieces)
fn draw_circle(renderer: SDL_Renderer, center_x: int, center_y: int, radius: int) -> void {
    let mut dy: int = (- 0 radius)
    while (<= dy radius) {
        let mut dx: int = (- 0 radius)
        while (<= dx radius) {
            if (<= (+ (* dx dx) (* dy dy)) (* radius radius)) {
                (SDL_RenderDrawPoint renderer (+ center_x dx) (+ center_y dy))
            } else {}
            set dx (+ dx 1)
        }
        set dy (+ dy 1)
    }
}

shadow draw_circle {
    assert (== 1 1)  # Visual function
}

# Draw simple text using filled rectangles (pixel-style)
# For game over screen - we'll draw message centered
fn draw_game_over_screen(renderer: SDL_Renderer, player_won: bool) -> void {
    let board_size: int = BOARD_SIZE
    let square_size: int = SQUARE_SIZE
    let window_width: int = (* board_size square_size)
    let board_height: int = (* board_size square_size)
    
    # Draw semi-transparent overlay
    (SDL_SetRenderDrawColor renderer 0 0 0 200)
    (nl_sdl_render_fill_rect renderer 0 0 window_width board_height)
    
    # Draw winner message box (centered)
    let msg_width: int = 400
    let msg_height: int = 200
    let msg_x: int = (/ (- window_width msg_width) 2)
    let msg_y: int = (/ (- board_height msg_height) 2)
    
    # Message background
    (SDL_SetRenderDrawColor renderer 40 40 40 255)
    (nl_sdl_render_fill_rect renderer msg_x msg_y msg_width msg_height)
    
    # Border
    (SDL_SetRenderDrawColor renderer 255 215 0 255)
    (nl_sdl_render_fill_rect renderer msg_x msg_y msg_width 4)  # Top
    (nl_sdl_render_fill_rect renderer msg_x (+ msg_y (- msg_height 4)) msg_width 4)  # Bottom
    (nl_sdl_render_fill_rect renderer msg_x msg_y 4 msg_height)  # Left
    (nl_sdl_render_fill_rect renderer (+ msg_x (- msg_width 4)) msg_y 4 msg_height)  # Right
    
    # Draw winner text using simple block letters at top of message box
    (SDL_SetRenderDrawColor renderer 255 255 255 255)  # White text
    
    let text_y: int = (+ msg_y 30)
    let text_x_start: int = (+ msg_x 80)
    let _use_text: int = (+ text_y text_x_start)  # Force compiler to see usage
    
    if player_won {
        # Draw "RED WINS!" in block letters
        # R (0,0)
        (nl_sdl_render_fill_rect renderer text_x_start text_y 8 40)
        (nl_sdl_render_fill_rect renderer text_x_start text_y 24 8)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 16) text_y 8 20)
        (nl_sdl_render_fill_rect renderer text_x_start (+ text_y 16) 24 8)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 16) (+ text_y 24) 8 16)
        
        # E (32,0)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 32) text_y 24 8)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 32) text_y 8 40)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 32) (+ text_y 16) 20 8)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 32) (+ text_y 32) 24 8)
        
        # D (64,0)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 64) text_y 8 40)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 64) text_y 20 8)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 76) (+ text_y 8) 8 24)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 64) (+ text_y 32) 20 8)
        
        # W (100,0)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 100) text_y 8 40)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 112) (+ text_y 24) 8 16)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 124) text_y 8 40)
        
        # I (140,0)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 140) text_y 8 40)
        
        # N (156,0)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 156) text_y 8 40)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 164) (+ text_y 8) 8 8)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 172) (+ text_y 16) 8 8)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 180) text_y 8 40)
        
        # S (196,0)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 196) text_y 24 8)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 196) text_y 8 20)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 196) (+ text_y 16) 24 8)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 212) (+ text_y 20) 8 12)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 196) (+ text_y 32) 24 8)
        
        # ! (228,0)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 228) text_y 8 24)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 228) (+ text_y 32) 8 8)
    } else {
        # Draw "BLACK WINS!" in block letters
        # B (0,0)
        (nl_sdl_render_fill_rect renderer text_x_start text_y 8 40)
        (nl_sdl_render_fill_rect renderer text_x_start text_y 20 8)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 12) (+ text_y 8) 8 8)
        (nl_sdl_render_fill_rect renderer text_x_start (+ text_y 16) 20 8)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 12) (+ text_y 24) 8 8)
        (nl_sdl_render_fill_rect renderer text_x_start (+ text_y 32) 20 8)
        
        # L (28,0)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 28) text_y 8 40)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 28) (+ text_y 32) 20 8)
        
        # A (56,0)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 56) text_y 24 8)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 56) (+ text_y 8) 8 32)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 72) (+ text_y 8) 8 32)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 56) (+ text_y 20) 24 8)
        
        # C (88,0)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 88) text_y 24 8)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 88) (+ text_y 8) 8 24)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 88) (+ text_y 32) 24 8)
        
        # K (120,0)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 120) text_y 8 40)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 128) (+ text_y 16) 8 8)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 136) text_y 8 16)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 136) (+ text_y 24) 8 16)
        
        # W (156,0)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 156) text_y 8 40)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 168) (+ text_y 24) 8 16)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 180) text_y 8 40)
        
        # I (196,0)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 196) text_y 8 40)
        
        # N (212,0)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 212) text_y 8 40)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 220) (+ text_y 8) 8 8)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 228) (+ text_y 16) 8 8)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 236) text_y 8 40)
        
        # S (252,0)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 252) text_y 24 8)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 252) text_y 8 20)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 252) (+ text_y 16) 24 8)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 268) (+ text_y 20) 8 12)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 252) (+ text_y 32) 24 8)
        
        # ! (284,0)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 284) text_y 8 24)
        (nl_sdl_render_fill_rect renderer (+ text_x_start 284) (+ text_y 32) 8 8)
    }
    
    # Draw winner indicator (large colored circle below text)
    let circle_y: int = (+ msg_y 100)
    if player_won {
        (SDL_SetRenderDrawColor renderer 220 20 60 255)  # Red for player
    } else {
        (SDL_SetRenderDrawColor renderer 30 30 30 255)   # Black for AI
    }
    (draw_circle renderer (/ window_width 2) circle_y 25)
    
    # Draw buttons
    let button_width: int = 150
    let button_height: int = 50
    let button_y: int = (+ msg_y 120)
    let quit_button_x: int = (- (/ window_width 2) (+ button_width 10))
    let play_button_x: int = (+ (/ window_width 2) 10)
    
    # Quit button (red with X symbol)
    (SDL_SetRenderDrawColor renderer 180 30 30 255)
    (nl_sdl_render_fill_rect renderer quit_button_x button_y button_width button_height)
    (SDL_SetRenderDrawColor renderer 255 255 255 255)
    (nl_sdl_render_fill_rect renderer (+ quit_button_x 2) (+ button_y 2) (- button_width 4) (- button_height 4))
    (SDL_SetRenderDrawColor renderer 180 30 30 255)
    (nl_sdl_render_fill_rect renderer (+ quit_button_x 10) (+ button_y 10) (- button_width 20) (- button_height 20))
    
    # Draw X symbol on quit button
    (SDL_SetRenderDrawColor renderer 255 255 255 255)
    let x_center_x: int = (+ quit_button_x (/ button_width 2))
    let x_center_y: int = (+ button_y (/ button_height 2))
    let x_size: int = 20
    # Draw thick X with multiple lines
    let mut x_offset: int = (- 0 x_size)
    while (<= x_offset x_size) {
        let mut thickness: int = -2
        while (<= thickness 2) {
            # Top-left to bottom-right diagonal
            let x1: int = (+ (+ x_center_x x_offset) thickness)
            let y1: int = (+ x_center_y x_offset)
            (nl_sdl_render_fill_rect renderer x1 y1 2 2)
            # Top-right to bottom-left diagonal  
            let x2: int = (+ (+ x_center_x (- 0 x_offset)) thickness)
            let y2: int = (+ x_center_y x_offset)
            (nl_sdl_render_fill_rect renderer x2 y2 2 2)
            set thickness (+ thickness 1)
        }
        set x_offset (+ x_offset 2)
    }
    
    # Play Again button (green with circular arrow)
    (SDL_SetRenderDrawColor renderer 30 180 30 255)
    (nl_sdl_render_fill_rect renderer play_button_x button_y button_width button_height)
    (SDL_SetRenderDrawColor renderer 255 255 255 255)
    (nl_sdl_render_fill_rect renderer (+ play_button_x 2) (+ button_y 2) (- button_width 4) (- button_height 4))
    (SDL_SetRenderDrawColor renderer 30 180 30 255)
    (nl_sdl_render_fill_rect renderer (+ play_button_x 10) (+ button_y 10) (- button_width 20) (- button_height 20))
    
    # Draw circular arrow symbol on play button (simplified checkmark)
    (SDL_SetRenderDrawColor renderer 255 255 255 255)
    let check_center_x: int = (+ play_button_x (/ button_width 2))
    let check_center_y: int = (+ button_y (/ button_height 2))
    # Draw checkmark: short vertical, then longer diagonal
    let mut check_y: int = -5
    while (<= check_y 10) {
        let mut final_check_x: int = 0
        if (< check_y 0) {
            set final_check_x (/ check_y 2)
        } else {
            set final_check_x check_y
        }
        let check_x_pos: int = (+ (+ check_center_x final_check_x) -5)
        let check_y_pos: int = (+ check_center_y check_y)
        (nl_sdl_render_fill_rect renderer check_x_pos check_y_pos 4 4)
        set check_y (+ check_y 2)
    }
}

shadow draw_game_over_screen {
    assert (== 1 1)  # Visual function
}

# Check if click is on quit button
fn is_quit_button_click(x: int, y: int) -> bool {
    let board_size: int = BOARD_SIZE
    let square_size: int = SQUARE_SIZE
    let window_width: int = (* board_size square_size)
    let button_width: int = 150
    let button_height: int = 50
    let msg_height: int = 200
    let board_height: int = (* board_size square_size)
    let msg_y: int = (/ (- board_height msg_height) 2)
    let button_y: int = (+ msg_y 120)
    let quit_button_x: int = (- (/ window_width 2) (+ button_width 10))
    
    return (and (and (>= x quit_button_x) (< x (+ quit_button_x button_width)))
                (and (>= y button_y) (< y (+ button_y button_height))))
}

shadow is_quit_button_click {
    assert (== (is_quit_button_click 100 400) false)
    assert (== (is_quit_button_click 200 350) true)  # Approximate center of quit button
}

# Check if click is on play again button
fn is_play_again_button_click(x: int, y: int) -> bool {
    let board_size: int = BOARD_SIZE
    let square_size: int = SQUARE_SIZE
    let window_width: int = (* board_size square_size)
    let button_width: int = 150
    let button_height: int = 50
    let msg_height: int = 200
    let board_height: int = (* board_size square_size)
    let msg_y: int = (/ (- board_height msg_height) 2)
    let button_y: int = (+ msg_y 120)
    let play_button_x: int = (+ (/ window_width 2) 10)
    
    return (and (and (>= x play_button_x) (< x (+ play_button_x button_width)))
                (and (>= y button_y) (< y (+ button_y button_height))))
}

shadow is_play_again_button_click {
    assert (== (is_play_again_button_click 100 400) false)
    assert (== (is_play_again_button_click 400 350) true)  # Approximate center of play again button
}

# Render the game board with flash animation
fn render_board(renderer: SDL_Renderer, board: array<int>, selected_row: int, selected_col: int, has_selection: bool, flash_row: int, flash_col: int, flash_frame: int) -> void {
    let board_size: int = BOARD_SIZE
    let square_size: int = SQUARE_SIZE
    
    # Clear screen (light gray)
                (SDL_SetRenderDrawColor renderer 240 240 240 255)
                (SDL_RenderClear renderer)
                
    # Draw board squares
                let mut i: int = 0
    while (< i board_size) {
                    let mut j: int = 0
        while (< j board_size) {
            # Set square color
                        if (is_dark_square i j) {
                (SDL_SetRenderDrawColor renderer 139 69 19 255)  # Brown
            } else {
                (SDL_SetRenderDrawColor renderer 255 248 220 255)  # Beige
            }
            (nl_sdl_render_fill_rect renderer (* j square_size) (* i square_size) square_size square_size)
            
            # Highlight selected square
            if (and has_selection (and (== selected_row i) (== selected_col j))) {
                (SDL_SetRenderDrawColor renderer 255 255 0 180)  # Yellow
                (nl_sdl_render_fill_rect renderer (* j square_size) (* i square_size) square_size square_size)
            } else {}
            
            # Flash animation for recently moved piece
            if (and (>= flash_frame 0) (and (== flash_row i) (== flash_col j))) {
                # Pulse effect: cycles every 20 frames
                let pulse_cycle: int = (% flash_frame 20)
                let pulse_intensity: int = (- 10 (abs_int (- pulse_cycle 10)))  # 0-10-0 pattern
                let glow_alpha: int = (+ 100 (* pulse_intensity 15))  # 100-250-100 alpha
                (SDL_SetRenderDrawColor renderer 0 255 255 glow_alpha)  # Cyan glow
                (nl_sdl_render_fill_rect renderer (* j square_size) (* i square_size) square_size square_size)
            } else {}
            
            # Draw piece
            let piece: int = (board_read board i j)
            if (!= piece 0) {  # if not EMPTY
                let center_x: int = (+ (* j square_size) (/ square_size 2))
                let center_y: int = (+ (* i square_size) (/ square_size 2))
                let radius: int = (/ square_size 3)
                
                # Piece color with flash brightness boost
                let is_flashing: bool = (and (>= flash_frame 0) (and (== flash_row i) (== flash_col j)))
                
                if (is_player_piece piece) {
                    if is_flashing {
                        (SDL_SetRenderDrawColor renderer 255 100 130 255)  # Brighter red
                    } else {
                        (SDL_SetRenderDrawColor renderer 220 20 60 255)  # Normal red
                    }
                        } else {
                    if is_flashing {
                        (SDL_SetRenderDrawColor renderer 80 80 80 255)  # Brighter black
                    } else {
                        (SDL_SetRenderDrawColor renderer 30 30 30 255)   # Normal black
                    }
                }
                
                (draw_circle renderer center_x center_y radius)
                
                # Draw king indicator
                if (is_king piece) {
                    (SDL_SetRenderDrawColor renderer 255 215 0 255)  # Gold
                    let king_radius: int = (/ radius 2)
                    let king_y: int = (- center_y (/ radius 2))
                    (draw_circle renderer center_x king_y king_radius)
                } else {}
            } else {}
            
                        set j (+ j 1)
                    }
                    set i (+ i 1)
                }
                
                (SDL_RenderPresent renderer)
}

shadow render_board {
    assert (== 1 1)  # Visual function
}

# Draw UI overlay showing game state and controls
fn draw_ui_overlay(renderer: SDL_Renderer, game_state: int, player_pieces: int, ai_pieces: int) -> void {
    let board_size: int = BOARD_SIZE
    let square_size: int = SQUARE_SIZE
    
    # Draw semi-transparent bar at top
    (SDL_SetRenderDrawColor renderer 0 0 0 200)
    (nl_sdl_render_fill_rect renderer 0 0 (* board_size square_size) 40)
    
    # Player pieces indicator (left side - red)
    (SDL_SetRenderDrawColor renderer 220 20 60 255)
    (nl_sdl_render_fill_rect renderer 10 10 20 20)
    # Count boxes
    let mut i: int = 0
    while (< i player_pieces) {
        if (< i 12) {
            (SDL_SetRenderDrawColor renderer 180 180 180 255)
            (nl_sdl_render_fill_rect renderer (+ 40 (* i 8)) 15 6 10)
        } else {}
        set i (+ i 1)
    }
    
    # AI pieces indicator (right side - black)
    (SDL_SetRenderDrawColor renderer 30 30 30 255)
    (nl_sdl_render_fill_rect renderer (- (* board_size square_size) 130) 10 20 20)
    # Count boxes
    set i 0
    while (< i ai_pieces) {
        if (< i 12) {
            (SDL_SetRenderDrawColor renderer 180 180 180 255)
            (nl_sdl_render_fill_rect renderer (- (* board_size square_size) (+ 100 (* i 8))) 15 6 10)
        } else {}
        set i (+ i 1)
    }
    
    # Game state indicator (center)
    if (== game_state 0) {
        # Player turn - red glow
        (SDL_SetRenderDrawColor renderer 220 20 60 255)
        (nl_sdl_render_fill_rect renderer (- (/ (* board_size square_size) 2) 30) 5 60 30)
        (SDL_SetRenderDrawColor renderer 255 100 120 255)
        (nl_sdl_render_fill_rect renderer (- (/ (* board_size square_size) 2) 28) 7 56 26)
    } else {
        if (== game_state 1) {
            # AI turn - dark glow
            (SDL_SetRenderDrawColor renderer 30 30 30 255)
            (nl_sdl_render_fill_rect renderer (- (/ (* board_size square_size) 2) 30) 5 60 30)
            (SDL_SetRenderDrawColor renderer 80 80 80 255)
            (nl_sdl_render_fill_rect renderer (- (/ (* board_size square_size) 2) 28) 7 56 26)
        } else {}
    }
}

# Move encoding/decoding (since we can't return multiple values)
# Encode: from_row * 1000 + from_col * 100 + to_row * 10 + to_col
fn encode_move(from_row: int, from_col: int, to_row: int, to_col: int) -> int {
    return (+ (+ (+ (* from_row 1000) (* from_col 100)) (* to_row 10)) to_col)
}

shadow encode_move {
    assert (== (encode_move 2 3 4 5) 2345)
}

fn extract_source_row(move: int) -> int {
    return (/ move 1000)
}

shadow extract_source_row {
    assert (== (extract_source_row 2345) 2)
}

fn extract_source_column(move: int) -> int {
    return (/ (% move 1000) 100)
}

shadow extract_source_column {
    assert (== (extract_source_column 2345) 3)
}

fn extract_destination_row(move: int) -> int {
    return (/ (% move 100) 10)
}

shadow extract_destination_row {
    assert (== (extract_destination_row 2345) 4)
}

fn extract_destination_column(move: int) -> int {
    return (% move 10)
}

shadow extract_destination_column {
    assert (== (extract_destination_column 2345) 5)
}

# Simplified AI: find first available move (jumps prioritized)
fn find_ai_move(board: array<int>, game_state: int) -> int {
    let board_size: int = BOARD_SIZE
    
    # First check for jumps (mandatory)
    let mut i: int = 0
    while (< i board_size) {
        let mut j: int = 0
        while (< j board_size) {
            let piece: int = (board_read board i j)
            if (is_ai_piece piece) {
                # Check all jump directions
                if (is_valid_jump board game_state i j (- i 2) (- j 2)) {
                    return (encode_move i j (- i 2) (- j 2))
                } else {}
                if (is_valid_jump board game_state i j (- i 2) (+ j 2)) {
                    return (encode_move i j (- i 2) (+ j 2))
                } else {}
                if (is_valid_jump board game_state i j (+ i 2) (- j 2)) {
                    return (encode_move i j (+ i 2) (- j 2))
                } else {}
                if (is_valid_jump board game_state i j (+ i 2) (+ j 2)) {
                    return (encode_move i j (+ i 2) (+ j 2))
                } else {}
            } else {}
            set j (+ j 1)
        }
        set i (+ i 1)
    }
    
    # If no jumps, find regular move
    set i 0
    while (< i board_size) {
        let mut j: int = 0
        while (< j board_size) {
            let piece: int = (board_read board i j)
            if (is_ai_piece piece) {
                # Check all move directions (AI moves up, so negative row)
                if (is_valid_move board game_state i j (- i 1) (- j 1)) {
                    return (encode_move i j (- i 1) (- j 1))
                } else {}
                if (is_valid_move board game_state i j (- i 1) (+ j 1)) {
                    return (encode_move i j (- i 1) (+ j 1))
                } else {}
                # Kings can also move forward
                if (is_valid_move board game_state i j (+ i 1) (- j 1)) {
                    return (encode_move i j (+ i 1) (- j 1))
                } else {}
                if (is_valid_move board game_state i j (+ i 1) (+ j 1)) {
                    return (encode_move i j (+ i 1) (+ j 1))
                } else {}
            } else {}
            set j (+ j 1)
        }
        set i (+ i 1)
    }
    
    return -1  # No move found
}

shadow find_ai_move {
    let board: array<int> = (init_board)
    let move: int = (find_ai_move board 1)  # AI_TURN
    assert (> move 0)
}

# Count remaining pieces
fn count_player_pieces(board: array<int>) -> int {
    let board_size: int = BOARD_SIZE
    let mut count: int = 0
    let mut i: int = 0
    while (< i board_size) {
        let mut j: int = 0
        while (< j board_size) {
            if (is_player_piece (board_read board i j)) {
                set count (+ count 1)
            } else {}
            set j (+ j 1)
        }
        set i (+ i 1)
    }
    return count
}

shadow count_player_pieces {
    let board: array<int> = (init_board)
    assert (== (count_player_pieces board) 12)
}

fn count_ai_pieces(board: array<int>) -> int {
    let board_size: int = BOARD_SIZE
    let mut count: int = 0
    let mut i: int = 0
    while (< i board_size) {
        let mut j: int = 0
        while (< j board_size) {
            if (is_ai_piece (board_read board i j)) {
                set count (+ count 1)
            } else {}
            set j (+ j 1)
        }
        set i (+ i 1)
    }
    return count
}

shadow count_ai_pieces {
    let board: array<int> = (init_board)
    assert (== (count_ai_pieces board) 12)
}

# Execute a move on the board
fn make_move(board: array<int>, from_row: int, from_col: int, to_row: int, to_col: int) -> array<int> {
    let board_size: int = BOARD_SIZE
    let mut new_board: array<int> = board
    let piece: int = (board_read new_board from_row from_col)
    
    # Check if it's a jump
    let is_jump: bool = (== (abs_int (- to_row from_row)) 2)
    if is_jump {
        # Remove jumped piece
        let mid_row: int = (+ from_row (/ (- to_row from_row) 2))
        let mid_col: int = (+ from_col (/ (- to_col from_col) 2))
        set new_board (board_write new_board mid_row mid_col 0)  # EMPTY
    } else {}
    
    # Move piece
    set new_board (board_write new_board from_row from_col 0)  # EMPTY
    set new_board (board_write new_board to_row to_col piece)
    
    # Check for king promotion
    if (and (== piece 1) (== to_row (- board_size 1))) {  # RED_PIECE reaches bottom
        set new_board (board_write new_board to_row to_col 2)  # RED_KING
    } else {}
    if (and (== piece 3) (== to_row 0)) {  # BLACK_PIECE reaches top
        set new_board (board_write new_board to_row to_col 4)  # BLACK_KING
    } else {}
    
    return new_board
}

shadow make_move {
    let board: array<int> = (init_board)
    let new_board: array<int> = (make_move board 2 1 3 0)
    assert (== (board_read new_board 2 1) 0)  # EMPTY at source
    assert (== (board_read new_board 3 0) 1)  # RED_PIECE at destination
}

# Main game function
fn main() -> int {
    
    # SDL constants come from the imported SDL module
    
    # Window dimensions
    let board_size: int = BOARD_SIZE
    let square_size: int = SQUARE_SIZE
    let window_width: int = (* board_size square_size)
    let window_height: int = (+ (* board_size square_size) 60)
    
    # Initialize SDL
    if (< (SDL_Init SDL_INIT_VIDEO) 0) {
        (println "SDL initialization failed")
        return 1
    } else {}
    
    # Create window
    let window: SDL_Window = (SDL_CreateWindow "Checkers" SDL_WINDOWPOS_UNDEFINED SDL_WINDOWPOS_UNDEFINED window_width window_height SDL_WINDOW_SHOWN)
    if (== window 0) {
        (println "Window creation failed")
        (SDL_Quit)
        return 1
    } else {}
    
    # Create renderer - try accelerated first, fallback to software
    let mut renderer: SDL_Renderer = (SDL_CreateRenderer window -1 SDL_RENDERER_ACCELERATED)
    if (== renderer 0) {
        (println "Hardware acceleration not available, trying software renderer...")
        set renderer (SDL_CreateRenderer window -1 SDL_RENDERER_SOFTWARE)
        if (== renderer 0) {
            (println "Renderer creation failed")
            (SDL_DestroyWindow window)
            (SDL_Quit)
            return 1
        } else {}
    } else {}
    
    # Initialize game
    let mut board: array<int> = (init_board)
    let mut game_state: int = 0  # PLAYER_TURN
    let mut selected_row: int = -1
    let mut selected_col: int = -1
    let mut has_selection: bool = false
    let mut frame_count: int = 0
    
    # Flash animation state
    let mut flash_row: int = -1
    let mut flash_col: int = -1
    let mut flash_frame: int = -1
    
    # Game loop
    let mut running: bool = true
    while running {
        # Handle mouse clicks
        let click: int = (nl_sdl_poll_mouse_click)
        if (> click 0) {
            # Decode click coordinates
            let click_x: int = (/ click 10000)
            let click_y: int = (% click 10000)
            
            # Handle game over button clicks
            if (== game_state 2) {  # GAME_OVER
                if (is_quit_button_click click_x click_y) {
                    set running false
                } else {
                    if (is_play_again_button_click click_x click_y) {
                        # Reset game
                        set board (init_board)
                        set game_state 0  # PLAYER_TURN
                        set selected_row -1
                        set selected_col -1
                        set has_selection false
                    } else {}
                }
            } else {
                # Normal game clicks
                let col: int = (/ click_x square_size)
                let row: int = (/ click_y square_size)
                
                # Only handle clicks during player turn
                if (== game_state 0) {  # PLAYER_TURN
                if (and (>= row 0) (and (< row board_size) (and (>= col 0) (< col board_size)))) {
                    if has_selection {
                        # Try to make move
                        let jumps_available: bool = (has_any_jump board game_state)
                        let mut move_valid: bool = false
                        
                        if jumps_available {
                            set move_valid (is_valid_jump board game_state selected_row selected_col row col)
                        } else {
                            if (is_valid_move board game_state selected_row selected_col row col) {
                                set move_valid true
                            } else {
                                set move_valid (is_valid_jump board game_state selected_row selected_col row col)
                            }
                        }
                        
                        if move_valid {
                            set board (make_move board selected_row selected_col row col)
                            # Start flash animation at destination
                            set flash_row row
                            set flash_col col
                            set flash_frame 0
                            set has_selection false
                            set selected_row -1
                            set selected_col -1
                            set game_state 1  # Switch to AI_TURN
                        } else {
                            # Try selecting new piece
                            if (is_player_piece (board_read board row col)) {
                                set selected_row row
                                set selected_col col
                            } else {
                                set has_selection false
                                set selected_row -1
                                set selected_col -1
                            }
                        }
                    } else {
                        # Select piece
                        if (is_player_piece (board_read board row col)) {
                            set has_selection true
                            set selected_row row
                            set selected_col col
                        } else {}
                    }
                } else {}
                } else {}
            }
        } else {}
        
        # Check for quit
        let quit: int = (nl_sdl_poll_event_quit)
        if (== quit 1) {
            set running false
        } else {}
        
        # Check for game over (only if not already in game over state)
        if (!= game_state 2) {  # Not already GAME_OVER
            if (or (== (count_player_pieces board) 0) (== (count_ai_pieces board) 0)) {
                set game_state 2  # GAME_OVER
            } else {}
        } else {}
        
        # AI turn logic (every 60 frames to slow it down)
        if (and (== game_state 1) (== (% frame_count 60) 0)) {  # AI_TURN
            let ai_move: int = (find_ai_move board game_state)
            if (> ai_move 0) {
                let ai_from_row: int = (extract_source_row ai_move)
                let ai_from_col: int = (extract_source_column ai_move)
                let ai_to_row: int = (extract_destination_row ai_move)
                let ai_to_col: int = (extract_destination_column ai_move)
                set board (make_move board ai_from_row ai_from_col ai_to_row ai_to_col)
                # Start flash animation at AI's destination
                set flash_row ai_to_row
                set flash_col ai_to_col
                set flash_frame 0
                set game_state 0  # Switch to PLAYER_TURN
            } else {}
        } else {}
        
        # Update flash animation
        if (>= flash_frame 0) {
            set flash_frame (+ flash_frame 1)
            if (>= flash_frame 60) {  # Flash for 60 frames (1 second at 60fps)
                # Flash animation complete
                set flash_frame -1
                set flash_row -1
                set flash_col -1
            } else {}
        } else {}
        
        # Render
        (render_board renderer board selected_row selected_col has_selection flash_row flash_col flash_frame)
        
        # Draw UI overlay
        let player_count: int = (count_player_pieces board)
        let ai_count: int = (count_ai_pieces board)
        (draw_ui_overlay renderer game_state player_count ai_count)
        
        # Render game over screen if game is over
        if (== game_state 2) {  # GAME_OVER
            let player_won: bool = (> (count_player_pieces board) 0)
            (draw_game_over_screen renderer player_won)
            (SDL_RenderPresent renderer)
        } else {}
        
        # Simple delay (~60 FPS)
        (SDL_Delay 16)
        set frame_count (+ frame_count 1)
    }
                
                # Cleanup
                (SDL_DestroyRenderer renderer)
                (SDL_DestroyWindow window)
                (SDL_Quit)
                
                return 0
}

shadow main {
    assert (== 1 1)  # Main has side effects
}
