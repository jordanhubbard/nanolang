/* =============================================================================
 * AST Module Demo - Metaprogramming Showcase
 * 
 * Concept: Direct access to Abstract Syntax Tree for code analysis
 * Topics: AST, metaprogramming, compiler internals, programmatic code generation
 * Difficulty: Advanced
 * 
 * Description:
 * Demonstrates NanoLang's unique capability to build and manipulate Abstract
 * Syntax Trees programmatically. Shows how to construct AST nodes, create
 * code structures, and perform metaprogramming tasks.
 * 
 * Key Features Demonstrated:
 * - Programmatic AST node creation
 * - AST construction for literals, identifiers, calls
 * - Code structure building
 * - Metaprogramming capabilities
 * - Compiler internals exposure
 * 
 * Use Cases:
 * - Building code generators
 * - Creating DSLs (Domain Specific Languages)
 * - Implementing macros and code transformations
 * - Automated refactoring tools
 * - Template engines
 * 
 * Prerequisites:
 * - Understanding of Abstract Syntax Trees
 * - Knowledge of compiler design basics
 * - Advanced NanoLang features
 * 
 * Next Steps:
 * - Build a simple code generator
 * - Create a custom DSL
 * - Implement macro system
 * - Explore code transformation tools
 * =============================================================================
 */

import "stdlib/ast.nano"

fn demo_basic_nodes() -> void {
    (println "=== Demo 1: Basic Node Creation ===")
    
    /* Create various node types */
    let int_lit: AST = (ast_int "100")
    let str_lit: AST = (ast_string "Hello, AST!")
    let identifier: AST = (ast_identifier "myVariable")
    let function: AST = (ast_function "calculate")
    let call: AST = (ast_call "println" 2)
    
    /* Pretty print them */
    (println (ast_to_string int_lit))
    (println (ast_to_string str_lit))
    (println (ast_to_string identifier))
    (println (ast_to_string function))
    (println (ast_to_string call))
    (println "")
}

shadow demo_basic_nodes {
    (demo_basic_nodes)
}

fn demo_type_checking() -> void {
    (println "=== Demo 2: Type Checking ===")
    
    let num: AST = (ast_int "42")
    let text: AST = (ast_string "test")
    let var: AST = (ast_identifier "x")
    let func_call: AST = (ast_call "add" 2)
    
    /* Check types */
    (println "Type checks:")
    if (== (ast_is_literal num) true) {
        (println "  42 is a literal ✓")
    } else {
        (println "  ERROR")
    }
    
    if (== (ast_is_identifier var) true) {
        (println "  x is an identifier ✓")
    } else {
        (println "  ERROR")
    }
    
    if (== (ast_is_call func_call) true) {
        (println "  add() is a call ✓")
    } else {
        (println "  ERROR")
    }
    
    (println "")
}

shadow demo_type_checking {
    (demo_type_checking)
}

fn demo_program_structure() -> void {
    (println "=== Demo 3: Building Program Structure ===")
    
    /* Build: program with main function */
    let prog: AST = (ast_program)
    let main_func: AST = (ast_function "main")
    let body: AST = (ast_block 2)
    
    (println "Built program structure:")
    (println (+ "  " (ast_to_string prog)))
    (println (+ "    " (ast_to_string main_func)))
    (println (+ "      " (ast_to_string body)))
    (println "")
}

shadow demo_program_structure {
    (demo_program_structure)
}

fn demo_ast_queries() -> void {
    (println "=== Demo 4: AST Queries ===")
    
    let node1: AST = (ast_int "999")
    let node2: AST = (ast_call "compute" 3)
    
    /* Get type names */
    let type1: string = (ast_type_name node1)
    let type2: string = (ast_type_name node2)
    
    (println (+ "Node 1 type: " type1))
    (println (+ "Node 2 type: " type2))
    
    /* Check child counts */
    (println (+ "Node 2 has " (+ (cast_string node2.child_count) " children")))
    (println "")
}

shadow demo_ast_queries {
    (demo_ast_queries)
}

fn demo_use_cases() -> void {
    (println "=== Demo 5: Real-World Use Cases ===")
    (println "")
    (println "The AST module enables:")
    (println "  • Code generation tools")
    (println "  • AST transformations (optimizers)")
    (println "  • Static analysis tools")
    (println "  • Domain-specific languages (DSLs)")
    (println "  • Parser generators")
    (println "  • Macro systems")
    (println "")
    (println "Next: LALR Parser Generator will use this module!")
    (println "")
}

shadow demo_use_cases {
    (demo_use_cases)
}

fn main() -> int {
    (println "")
    (println "╔════════════════════════════════════════╗")
    (println "║   AST Module - Feature Demonstration   ║")
    (println "╚════════════════════════════════════════╝")
    (println "")
    
    (demo_basic_nodes)
    (demo_type_checking)
    (demo_program_structure)
    (demo_ast_queries)
    (demo_use_cases)
    
    (println "╔════════════════════════════════════════╗")
    (println "║         Demo Complete! ✓               ║")
    (println "╚════════════════════════════════════════╝")
    (println "")
    
    return 0
}
