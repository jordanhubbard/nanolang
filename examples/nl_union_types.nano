/* Example: Union Types (Tagged Unions/Sum Types) */

/* Define a Result union for error handling */
union Result {
    Ok { value: int },
    Error { code: int, message: string }
}

/* Function that returns a union type */
fn divide(a: int, b: int) -> Result {
    if (== b 0) {
        return Result.Error { code: 1, message: "Division by zero" }
    } else {
        return Result.Ok { value: (/ a b) }
    }
}

shadow divide {
    let ok: Result = (divide 10 2)
    let err: Result = (divide 10 0)
    # Both should execute without crashing
    assert (== 1 1)
}

/* Union with empty variants */
union Status {
    Pending {},
    Running {},
    Complete {}
}

fn get_status() -> Status {
    return Status.Running {}
}

shadow get_status {
    let s: Status = (get_status)
    assert (== 1 1)
}

/* Union with mixed field types */
union Data {
    Empty {},
    Integer { value: int },
    Text { message: string },
    Pair { first: int, second: int }
}

fn create_pair(a: int, b: int) -> Data {
    return Data.Pair { first: a, second: b }
}

shadow create_pair {
    let d: Data = (create_pair 1 2)
    assert (== 1 1)
}

fn main() -> int {
    /* Create union values */
    let result1: Result = (divide 10 2)
    let result2: Result = (divide 10 0)
    
    let status: Status = (get_status)
    
    let data1: Data = Data.Empty {}
    let data2: Data = Data.Integer { value: 42 }
    let data3: Data = Data.Text { message: "Hello" }
    let data4: Data = (create_pair 5 10)
    
    (println "Union types demonstration complete!")
    return 0
}

shadow main {
    assert (== (main) 0)
}

