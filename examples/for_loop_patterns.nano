# Comprehensive for-loop patterns demonstration
# Shows various ways to use for-loops effectively

# === BASIC FOR LOOP - Array Iteration ===

fn sum_array(arr: array<int>) -> int {
    let mut sum: int = 0
    for i in arr {
        set sum (+ sum i)
    }
    return sum
}

shadow sum_array {
    let numbers: array<int> = [1, 2, 3, 4, 5]
    assert (== (sum_array numbers) 15)
}

# === COUNTING WITH FOR LOOP ===

fn count_evens(arr: array<int>) -> int {
    let mut count: int = 0
    for num in arr {
        if (== (% num 2) 0) {
            set count (+ count 1)
        } else {
            (print "")
        }
    }
    return count
}

shadow count_evens {
    let numbers: array<int> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    assert (== (count_evens numbers) 5)
}

# === FINDING MAXIMUM ===

fn find_max(arr: array<int>) -> int {
    let mut max: int = (at arr 0)
    for num in arr {
        if (> num max) {
            set max num
        } else {
            (print "")
        }
    }
    return max
}

shadow find_max {
    let numbers: array<int> = [3, 7, 2, 9, 1, 5]
    assert (== (find_max numbers) 9)
}

# === FINDING MINIMUM ===

fn find_min(arr: array<int>) -> int {
    let mut min: int = (at arr 0)
    for num in arr {
        if (< num min) {
            set min num
        } else {
            (print "")
        }
    }
    return min
}

shadow find_min {
    let numbers: array<int> = [3, 7, 2, 9, 1, 5]
    assert (== (find_min numbers) 1)
}

# === STRING CONCATENATION ===

fn join_strings(words: array<string>) -> string {
    let mut result: string = ""
    for word in words {
        set result (str_concat result word)
        set result (str_concat result " ")
    }
    return result
}

shadow join_strings {
    let words: array<string> = ["Hello", "from", "nanolang"]
    let result: string = (join_strings words)
    assert (== result "Hello from nanolang ")
}

# === PRODUCT OF ELEMENTS ===

fn product_array(arr: array<int>) -> int {
    let mut product: int = 1
    for num in arr {
        set product (* product num)
    }
    return product
}

shadow product_array {
    let numbers: array<int> = [2, 3, 4]
    assert (== (product_array numbers) 24)
}

# === CHECKING ALL ELEMENTS (AND logic) ===

fn all_positive(arr: array<int>) -> bool {
    let mut result: bool = true
    for num in arr {
        if (<= num 0) {
            set result false
        } else {
            (print "")
        }
    }
    return result
}

shadow all_positive {
    let positive: array<int> = [1, 2, 3, 4, 5]
    let mixed: array<int> = [1, -2, 3]
    assert (== (all_positive positive) true)
    assert (== (all_positive mixed) false)
}

# === CHECKING ANY ELEMENT (OR logic) ===

fn contains_negative(arr: array<int>) -> bool {
    let mut found: bool = false
    for num in arr {
        if (< num 0) {
            set found true
        } else {
            (print "")
        }
    }
    return found
}

shadow contains_negative {
    let positive: array<int> = [1, 2, 3]
    let mixed: array<int> = [1, -2, 3]
    assert (== (contains_negative positive) false)
    assert (== (contains_negative mixed) true)
}

# === ARRAY TRANSFORMATION ===

fn double_all(arr: array<int>) -> array<int> {
    let mut result: array<int> = [0, 0, 0, 0, 0]
    let mut i: int = 0
    let len: int = (array_length arr)
    while (< i len) {
        let num: int = (at arr i)
        (array_set result i (* num 2))
        set i (+ i 1)
    }
    return result
}

shadow double_all {
    let numbers: array<int> = [1, 2, 3, 4, 5]
    let doubled: array<int> = (double_all numbers)
    assert (== (at doubled 0) 2)
    assert (== (at doubled 1) 4)
    assert (== (at doubled 2) 6)
    assert (== (at doubled 3) 8)
    assert (== (at doubled 4) 10)
}

# === FLOAT ARRAYS ===

fn average(arr: array<float>) -> float {
    let mut sum: float = 0.0
    let mut count: int = 0
    for num in arr {
        set sum (+ sum num)
        set count (+ count 1)
    }
    return (/ sum (cast_float count))
}

shadow average {
    let numbers: array<float> = [1.0, 2.0, 3.0, 4.0, 5.0]
    let avg: float = (average numbers)
    assert (== avg 3.0)
}

# === SEARCHING ===

fn find_index(arr: array<int>, target: int) -> int {
    let mut index: int = 0
    let mut found: int = -1
    for num in arr {
        if (== num target) {
            set found index
        } else {
            (print "")
        }
        set index (+ index 1)
    }
    return found
}

shadow find_index {
    let numbers: array<int> = [10, 20, 30, 40, 50]
    assert (== (find_index numbers 30) 2)
    assert (== (find_index numbers 99) -1)
}

# === DEMONSTRATION MAIN ===

fn main() -> int {
    (println "=== For Loop Patterns Demo ===")
    (println "")
    
    # Sum
    let numbers: array<int> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    (print "Sum of 1-10: ")
    (println (int_to_string (sum_array numbers)))
    
    # Count evens
    (print "Even count in 1-10: ")
    (println (int_to_string (count_evens numbers)))
    
    # Max/Min
    let data: array<int> = [42, 17, 99, 3, 55, 8]
    (print "Max value: ")
    (println (int_to_string (find_max data)))
    (print "Min value: ")
    (println (int_to_string (find_min data)))
    
    # String joining
    let words: array<string> = ["For", "loops", "are", "powerful"]
    (print "Joined: ")
    (println (join_strings words))
    
    # Product
    let factors: array<int> = [2, 3, 4, 5]
    (print "Product of [2,3,4,5]: ")
    (println (int_to_string (product_array factors)))
    
    # Average
    let floats: array<float> = [2.5, 3.5, 4.5, 5.5]
    (print "Average: ")
    (print (int_to_string (cast_int (average floats))))
    (println "")
    
    # Search
    (print "Index of 99 in data: ")
    (println (int_to_string (find_index data 99)))
    
    (println "")
    (println "All tests passed! âœ“")
    return 0
}

shadow main {
    assert true
}
