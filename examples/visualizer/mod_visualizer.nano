# MOD Player with Real-Time Audio Visualizer
# Shows animated waveform and VU meters with real audio analysis

import "modules/sdl/sdl.nano"
import "modules/sdl_mixer/sdl_mixer.nano"
import "modules/sdl_helpers/sdl_helpers.nano"
import "modules/audio_viz/audio_viz.nano"

let WINDOW_WIDTH: int = 800
let WINDOW_HEIGHT: int = 600

# Command-line argument support
extern fn get_argc() -> int
extern fn get_argv(index: int) -> string

fn main() -> int {
    # Check command-line arguments first (before SDL init)
    let argc: int = (get_argc)
    
    # Get MOD file path from command line or use default
    let mod_file: string = ""
    if (< argc 2) {
        # Use default MOD file for instant gratification!
        set mod_file "examples/gabba-studies-12.mod"
        (println "")
        (println "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
        (println "‚ïë  NANOLANG MOD PLAYER WITH VISUALIZER                  ‚ïë")
        (println "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
        (println "")
        (println "No file specified - using default:")
        (println "  üìÄ gabba-studies-12.mod")
        (println "")
        (println "Usage: sdl_mod_player [path/to/file.mod]")
        (println "       (defaults to examples/gabba-studies-12.mod)")
        (println "")
    } else {
        set mod_file (get_argv 1)
    }
    
    (println "")
    (println "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
    (println "‚ïë  NANOLANG MOD PLAYER WITH VISUALIZER                  ‚ïë")
    (println "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
    (println "")
    
    # Initialize SDL
    (SDL_Init (+ SDL_INIT_VIDEO SDL_INIT_AUDIO))
    
    # Initialize SDL_mixer
    let mixer_init: int = (Mix_Init 2)  # MOD support
    if (!= mixer_init 2) {
        (println "‚úó SDL_mixer failed to initialize with MOD support")
        (SDL_Quit)
        return 1
    } else {}
    
    # Open audio device
    # 44100 Hz, signed 16-bit, stereo, 2048 byte chunks
    let audio_result: int = (Mix_OpenAudio 44100 32784 2 2048)
    if (!= audio_result 0) {
        (println "‚úó Failed to open audio device")
        (Mix_Quit)
        (SDL_Quit)
        return 1
    } else {}
    
    (println "‚úì SDL_mixer initialized with MOD support")
    (println "")
    
    # Initialize audio visualization
    (nl_audio_viz_init 32784 2)  # MIX_DEFAULT_FORMAT, stereo
    (println "‚úì Audio visualization initialized")
    (println "")
    
    # Create window and renderer
    let window: SDL_Window = (SDL_CreateWindow "MOD Visualizer" SDL_WINDOWPOS_CENTERED SDL_WINDOWPOS_CENTERED WINDOW_WIDTH WINDOW_HEIGHT SDL_WINDOW_SHOWN)
    let renderer: SDL_Renderer = (SDL_CreateRenderer window -1 (+ SDL_RENDERER_ACCELERATED SDL_RENDERER_PRESENTVSYNC))
    
    # Load MOD file
    if (< argc 2) {
        (print "Loading default: ")
    } else {
        (print "Loading: ")
    }
    (println mod_file)
    
    let music: Mix_Music = (Mix_LoadMUS mod_file)
    if (== music 0) {
        (println "‚úó Failed to load MOD file")
        (SDL_DestroyRenderer renderer)
        (SDL_DestroyWindow window)
        (Mix_CloseAudio)
        (Mix_Quit)
        (SDL_Quit)
        return 1
    } else {
        (println "‚úì MOD file loaded successfully")
        (println "")
    }
    
    # Display controls
    (println "Controls:")
    (println "  SPACE - Play/Pause")
    (println "  TAB   - Cycle Visualizer Mode")
    (println "  ESC   - Quit")
    (println "")
    
    # Set volume to 80% (100 out of 128 max)
    (Mix_VolumeMusic 100)
    
    # Play music  
    (Mix_PlayMusic music -1)  # -1 = loop forever
    (println "‚ñ∂ Playing... Press ESC to quit")
    (println "")
    
    # Main loop
    let mut running: bool = true
    let mut playing: bool = true
    let mut frame: int = 0
    let mut viz_mode: int = 0  # 0=Circular, 1=Bars, 2=Spiral, 3=Starburst, 4=Tunnel
    let num_viz_modes: int = 5
    
    while running {
        # Poll for keyboard events
        let key: int = (nl_sdl_poll_keypress)
        if (> key -1) {
            # SPACE = 44
            if (== key 44) {
                if playing {
                    (Mix_PauseMusic)
                    (println "‚è∏ Paused")
                    set playing false
                } else {
                    (Mix_ResumeMusic)
                    (println "‚ñ∂ Playing")
                    set playing true
                }
            } else {
                # TAB = 43
                if (== key 43) {
                    set viz_mode (% (+ viz_mode 1) num_viz_modes)
                    if (== viz_mode 0) { (println "üåÄ Visualizer: Circular Spectrum") } else {}
                    if (== viz_mode 1) { (println "üìä Visualizer: Frequency Bars") } else {}
                    if (== viz_mode 2) { (println "üåä Visualizer: Spiral Vortex") } else {}
                    if (== viz_mode 3) { (println "‚ú® Visualizer: Starburst") } else {}
                    if (== viz_mode 4) { (println "üéÜ Visualizer: Tunnel") } else {}
                } else {
                    # ESC = 41
                    if (== key 41) {
                        set running false
                        (println "")
                        (println "Stopping playback...")
                    } else {}
                }
            }
        } else {}
        
        # Check for window close button
        if (== (nl_sdl_poll_event_quit) 1) { set running false } else {}
        
        # Check if music is still playing
        let is_playing: int = (Mix_PlayingMusic)
        if (== is_playing 0) {
            if playing {
                (println "")
                (println "‚úì Playback finished")
                set running false
            } else {}
        } else {}
        
        # Clear
        (SDL_SetRenderDrawColor renderer 10 10 15 255)
        (SDL_RenderClear renderer)
        
        # Get real-time audio volumes for each channel (0-100)
        let vol1: int = (nl_audio_viz_get_channel_volume_int 0)
        let vol2: int = (nl_audio_viz_get_channel_volume_int 1)
        let vol3: int = (nl_audio_viz_get_channel_volume_int 2)
        let vol4: int = (nl_audio_viz_get_channel_volume_int 3)
        
        # === REAL OSCILLOSCOPE WAVEFORM (Top) ===
        # Draw actual audio waveform - mixed mono (L+R) for full signal
        let waveform_size: int = (nl_audio_viz_get_waveform_size)
        let mut i: int = 0
        let waveform_width: int = 700
        let waveform_step: int = (/ waveform_size waveform_width)
        
        # Draw waveform with glow effect
        (SDL_SetRenderDrawColor renderer 0 255 255 200)  # Cyan
        while (< i waveform_width) {
            let sample_idx: int = (* i waveform_step)
            # Mix left and right channels for full audio representation
            let left: float = (nl_audio_viz_get_waveform_sample 0 sample_idx)
            let right: float = (nl_audio_viz_get_waveform_sample 1 sample_idx)
            let mixed: float = (* (+ left right) 0.5)  # Average of both channels
            let y: int = (+ 100 (cast_int (* mixed 150.0)))
            
            # Draw thicker line for visibility
            (SDL_RenderDrawPoint renderer (+ 50 i) y)
            (SDL_RenderDrawPoint renderer (+ 50 i) (+ y 1))
            set i (+ i 1)
        }
        
        # === TRIPPY VISUALIZER (Middle) - Multiple Modes ===
        let center_x: int = 400
        let center_y: int = 300
        
        # Mode 0: Circular Spectrum with Lissajous
        if (== viz_mode 0) {
            let mut angle: int = 0
            while (< angle 360) {
                let idx: int = (* angle 2)
                if (< idx waveform_size) {
                    let left_sample: float = (nl_audio_viz_get_waveform_sample 0 idx)
                    let right_sample: float = (nl_audio_viz_get_waveform_sample 1 idx)
                    let amplitude: float = (+ (abs left_sample) (abs right_sample))
                    let radius: int = (+ 70 (cast_int (* amplitude 100.0)))  # Increased from 50+60 to 70+100
                    
                    let angle_float: float = (cast_float angle)
                    let rad: float = (* angle_float 0.01745)
                    let x: int = (+ center_x (cast_int (* (cast_float radius) (cos rad))))
                    let y: int = (+ center_y (cast_int (* (cast_float radius) (sin rad))))
                    
                    let color_offset: int = (+ angle frame)
                    let r: int = (+ 128 (cast_int (* 127.0 (sin (* (cast_float color_offset) 0.05)))))
                    let g: int = (+ 128 (cast_int (* 127.0 (sin (* (cast_float (+ color_offset 120)) 0.05)))))
                    let b: int = (+ 128 (cast_int (* 127.0 (sin (* (cast_float (+ color_offset 240)) 0.05)))))
                    
                    (SDL_SetRenderDrawColor renderer r g b 255)
                    (SDL_RenderDrawPoint renderer x y)
                    (SDL_RenderDrawPoint renderer (+ x 1) y)
                } else {}
                set angle (+ angle 3)
            }
            
            # Lissajous curve
            set i 0
            (SDL_SetRenderDrawColor renderer 255 100 255 200)
            while (< i (- waveform_size 1)) {
                let left: float = (nl_audio_viz_get_waveform_sample 0 i)
                let right: float = (nl_audio_viz_get_waveform_sample 1 i)
                let x: int = (+ center_x (cast_int (* left 120.0)))  # Increased from 80 to 120
                let y: int = (+ center_y (cast_int (* right 120.0)))
                (SDL_RenderDrawPoint renderer x y)
                set i (+ i 4)
            }
        } else {}
        
        # Mode 1: Frequency Bars (Classic Spectrum Analyzer)
        if (== viz_mode 1) {
            let num_bars: int = 64
            let bar_width: int = (/ 700 num_bars)
            let mut bar: int = 0
            while (< bar num_bars) {
                let idx: int = (* bar (/ waveform_size num_bars))
                let left_sample: float = (nl_audio_viz_get_waveform_sample 0 idx)
                let right_sample: float = (nl_audio_viz_get_waveform_sample 1 idx)
                let amplitude: float = (+ (abs left_sample) (abs right_sample))
                let height: int = (+ 20 (cast_int (* amplitude 180.0)))  # Increased from 10+120 to 20+180
                
                let bar_x: int = (+ 50 (* bar bar_width))
                let bar_y: int = (- 350 height)
                
                # Color based on height
                let color_val: int = (+ bar frame)
                let r: int = (+ 128 (cast_int (* 127.0 (sin (* (cast_float color_val) 0.1)))))
                let g: int = (+ 128 (cast_int (* 127.0 (cos (* (cast_float color_val) 0.08)))))
                let b: int = 255
                
                (SDL_SetRenderDrawColor renderer r g b 255)
                (nl_sdl_render_fill_rect renderer bar_x bar_y bar_width height)
                set bar (+ bar 1)
            }
        } else {}
        
        # Mode 2: Spiral Vortex
        if (== viz_mode 2) {
            let mut angle: int = 0
            while (< angle 720) {
                let idx: int = (% (* angle 3) waveform_size)
                let sample: float = (nl_audio_viz_get_waveform_sample 0 idx)
                let amplitude: float = (abs sample)
                
                # Spiral grows outward
                let spiral_radius: float = (+ 30.0 (* 0.2 (cast_float angle)))
                let spiral_amp: float = (+ spiral_radius (* amplitude 70.0))  # Increased from 40 to 70
                
                let angle_float: float = (cast_float angle)
                let rad: float = (* angle_float 0.01745)
                let x: int = (+ center_x (cast_int (* spiral_amp (cos rad))))
                let y: int = (+ center_y (cast_int (* spiral_amp (sin rad))))
                
                let color_offset: int = (+ angle frame)
                let r: int = (+ 128 (cast_int (* 127.0 (sin (* (cast_float color_offset) 0.03)))))
                let g: int = (+ 128 (cast_int (* 127.0 (sin (* (cast_float (+ color_offset 90)) 0.03)))))
                let b: int = (+ 128 (cast_int (* 127.0 (sin (* (cast_float (+ color_offset 180)) 0.03)))))
                
                (SDL_SetRenderDrawColor renderer r g b 255)
                (SDL_RenderDrawPoint renderer x y)
                (SDL_RenderDrawPoint renderer (+ x 1) y)
                (SDL_RenderDrawPoint renderer x (+ y 1))
                set angle (+ angle 5)
            }
        } else {}
        
        # Mode 3: Starburst (Radiating Lines)
        if (== viz_mode 3) {
            let mut ray: int = 0
            while (< ray 36) {
                let idx: int = (* ray 28)
                if (< idx waveform_size) {
                    let sample: float = (nl_audio_viz_get_waveform_sample 0 idx)
                    let amplitude: float = (abs sample)
                    let ray_length: int = (+ 80 (cast_int (* amplitude 200.0)))  # Increased from 50+150 to 80+200
                    
                    let angle_float: float = (* (cast_float ray) 10.0)
                    let rad: float = (* angle_float 0.01745)
                    
                    # Draw line from center outward
                    let mut r: int = 0
                    while (< r ray_length) {
                        let x: int = (+ center_x (cast_int (* (cast_float r) (cos rad))))
                        let y: int = (+ center_y (cast_int (* (cast_float r) (sin rad))))
                        
                        let color_offset: int = (+ r frame)
                        let cr: int = (+ 128 (cast_int (* 127.0 (sin (* (cast_float color_offset) 0.02)))))
                        let cg: int = (+ 128 (cast_int (* 127.0 (sin (* (cast_float (+ color_offset 120)) 0.02)))))
                        let cb: int = (+ 128 (cast_int (* 127.0 (sin (* (cast_float (+ color_offset 240)) 0.02)))))
                        
                        (SDL_SetRenderDrawColor renderer cr cg cb 255)
                        (SDL_RenderDrawPoint renderer x y)
                        set r (+ r 3)
                    }
                } else {}
                set ray (+ ray 1)
            }
        } else {}
        
        # Mode 4: Tunnel Effect
        if (== viz_mode 4) {
            let mut ring: int = 0
            while (< ring 20) {
                let idx: int = (* ring 50)
                if (< idx waveform_size) {
                    let sample: float = (nl_audio_viz_get_waveform_sample 0 idx)
                    let amplitude: float = (abs sample)
                    let base_radius: int = (+ (* ring 15) 20)
                    let radius: int = (+ base_radius (cast_int (* amplitude 50.0)))  # Increased from 30 to 50
                    
                    let mut angle: int = 0
                    while (< angle 360) {
                        let angle_float: float = (cast_float angle)
                        let rad: float = (* angle_float 0.01745)
                        let x: int = (+ center_x (cast_int (* (cast_float radius) (cos rad))))
                        let y: int = (+ center_y (cast_int (* (cast_float radius) (sin rad))))
                        
                        let color_offset: int = (+ (+ ring angle) frame)
                        let r: int = (+ 128 (cast_int (* 127.0 (sin (* (cast_float color_offset) 0.04)))))
                        let g: int = (+ 128 (cast_int (* 127.0 (sin (* (cast_float (+ color_offset 120)) 0.04)))))
                        let b: int = (+ 128 (cast_int (* 127.0 (sin (* (cast_float (+ color_offset 240)) 0.04)))))
                        
                        (SDL_SetRenderDrawColor renderer r g b 255)
                        (SDL_RenderDrawPoint renderer x y)
                        set angle (+ angle 15)
                    }
                } else {}
                set ring (+ ring 1)
            }
        } else {}
        
        # Draw VU meters with real audio data (scale 0-100 to 0-200 pixels)
        let vu1: int = (* vol1 2)
        let vu2: int = (* vol2 2)
        let vu3: int = (* vol3 2)
        let vu4: int = (* vol4 2)
        
        # === VU METERS WITH IMPROVED COLOR GRADIENTS (Bottom) ===
        # Channel 1 - Green to Yellow to Red gradient (thresholds: 30%, 60%)
        if (> vol1 60) {
            (SDL_SetRenderDrawColor renderer 255 0 0 255)  # Red - PEAK!
        } else {
            if (> vol1 30) {
                (SDL_SetRenderDrawColor renderer 255 255 0 255)  # Yellow - Hot
            } else {
                (SDL_SetRenderDrawColor renderer 0 255 0 255)  # Green - Good
            }
        }
        (nl_sdl_render_fill_rect renderer 150 (- 500 vu1) 30 vu1)
        
        # Channel 2
        if (> vol2 60) {
            (SDL_SetRenderDrawColor renderer 255 0 0 255)
        } else {
            if (> vol2 30) {
                (SDL_SetRenderDrawColor renderer 255 255 0 255)
            } else {
                (SDL_SetRenderDrawColor renderer 0 255 0 255)
            }
        }
        (nl_sdl_render_fill_rect renderer 280 (- 500 vu2) 30 vu2)
        
        # Channel 3
        if (> vol3 60) {
            (SDL_SetRenderDrawColor renderer 255 0 0 255)
        } else {
            if (> vol3 30) {
                (SDL_SetRenderDrawColor renderer 255 255 0 255)
            } else {
                (SDL_SetRenderDrawColor renderer 0 255 0 255)
            }
        }
        (nl_sdl_render_fill_rect renderer 410 (- 500 vu3) 30 vu3)
        
        # Channel 4
        if (> vol4 60) {
            (SDL_SetRenderDrawColor renderer 255 0 0 255)
        } else {
            if (> vol4 30) {
                (SDL_SetRenderDrawColor renderer 255 255 0 255)
            } else {
                (SDL_SetRenderDrawColor renderer 0 255 0 255)
            }
        }
        (nl_sdl_render_fill_rect renderer 540 (- 500 vu4) 30 vu4)
        
        # Present
        (SDL_RenderPresent renderer)
        (SDL_Delay 16)
        
        set frame (+ frame 1)
    }
    
    # Cleanup
    (println "Cleaning up...")
    (Mix_HaltMusic)
    (Mix_FreeMusic music)
    (nl_audio_viz_shutdown)
    (SDL_DestroyRenderer renderer)
    (SDL_DestroyWindow window)
    (Mix_CloseAudio)
    (Mix_Quit)
    (SDL_Quit)
    
    (println "‚úì Done")
    (println "")
    return 0
}

shadow main { assert true }
