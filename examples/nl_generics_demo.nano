# Comprehensive Generics Demo - List<T> Type System
#
# Concept: Demonstrates NanoLang's generic type system with List<T>
# Topics: generics, monomorphization, type safety, polymorphism, List<T>
# Difficulty: Advanced
#
# Description:
# Comprehensive demonstration of NanoLang's generic type system using List<T>.
# Shows how the compiler performs monomorphization (generating specialized
# code for each type), type-safe operations, and generic data structures.
#
# Key Features Demonstrated:
# - Generic List<T> type with multiple specializations
# - Monomorphization (compile-time type specialization)
# - Type-safe operations (no casting required)
# - Generics with primitive types (int, string)
# - Generics with user-defined structs (Point, Player)
# - Automatic function generation per type
#
# How Generics Work in NanoLang:
# When you write `List<Point>`, the compiler automatically generates:
#   - List_Point struct type
#   - List_Point_new() → List<Point>
#   - List_Point_push(list, value) → void
#   - List_Point_get(list, index) → Point
#   - List_Point_length(list) → int
#
# This is called "monomorphization" - one generic definition creates
# multiple specialized implementations at compile time.
#
# Prerequisites:
# - nl_struct.nano - User-defined types
# - nl_types.nano - Type system basics
# - Understanding of polymorphism
#
# Next Steps:
# - nl_generic_stack.nano - Stack data structure
# - nl_generic_queue.nano - Queue data structure
# - Implement your own generic types

# ==============================================================================
# User-Defined Types for Generic Examples
# ==============================================================================

struct Point {
    x: int,
    y: int
}

struct Player {
    name: string,
    score: int,
    position: Point
}

struct Token {
    type: int,
    value: string,
    line: int,
    column: int
}

# ==============================================================================
# External Functions for Built-in Generic Types
# ==============================================================================
# These are provided by the runtime for common primitive types

# List<int> operations
extern fn list_int_new() -> int64_t
extern fn list_int_push(list: int64_t, value: int) -> void
extern fn list_int_get(list: int64_t, index: int) -> int
extern fn list_int_length(list: int64_t) -> int

# List<string> operations
extern fn list_string_new() -> int64_t
extern fn list_string_push(list: int64_t, value: string) -> void
extern fn list_string_get(list: int64_t, index: int) -> string
extern fn list_string_length(list: int64_t) -> int

# Note: For user-defined structs (Point, Player, Token), the compiler
# automatically generates specialized functions. No extern needed!

# ==============================================================================
# Example 1: List<int> - Generic List of Integers
# ==============================================================================

fn demo_list_int() -> int {
    (println "")
    (println "=== Example 1: List<int> - Integer List ===")
    
    # Create list with generic syntax
    let numbers: List<int> = (list_int_new)
    
    # Add numbers
    (list_int_push numbers 10)
    (list_int_push numbers 20)
    (list_int_push numbers 30)
    (list_int_push numbers 40)
    (list_int_push numbers 50)
    
    # Access and display
    let len: int = (list_int_length numbers)
    (print "  Length: ")
    (println len)
    
    (print "  First element: ")
    (println (list_int_get numbers 0))
    
    (print "  Last element: ")
    let last_idx: int = (- len 1)
    (println (list_int_get numbers last_idx))
    
    # Type safety: This list can ONLY hold integers
    # (list_int_push numbers "string") # Would be a compile error!
    
    (println "  ✓ List<int> works perfectly")
    return 0
}

shadow demo_list_int {
    assert (== (demo_list_int) 0)
}

# ==============================================================================
# Example 2: List<string> - Generic List of Strings
# ==============================================================================

fn demo_list_string() -> int {
    (println "")
    (println "=== Example 2: List<string> - String List ===")
    
    let names: List<string> = (list_string_new)
    
    (list_string_push names "Alice")
    (list_string_push names "Bob")
    (list_string_push names "Charlie")
    (list_string_push names "Diana")
    
    let count: int = (list_string_length names)
    (print "  Names in list: ")
    (println count)
    
    (print "  First name: ")
    (println (list_string_get names 0))
    
    (print "  Second name: ")
    (println (list_string_get names 1))
    
    (println "  ✓ List<string> works perfectly")
    return 0
}

shadow demo_list_string {
    assert (== (demo_list_string) 0)
}

# ==============================================================================
# Example 3: List<Point> - Generic List of User-Defined Structs
# ==============================================================================

fn demo_list_point() -> int {
    (println "")
    (println "=== Example 3: List<Point> - Custom Struct List ===")
    
    # Compiler generates List_Point_* functions automatically!
    let points: List<Point> = (list_Point_new)
    
    # Create and add points
    let p1: Point = Point { x: 10, y: 20 }
    let p2: Point = Point { x: 30, y: 40 }
    let p3: Point = Point { x: 50, y: 60 }
    
    (list_Point_push points p1)
    (list_Point_push points p2)
    (list_Point_push points p3)
    
    (print "  Added ")
    (print (list_Point_length points))
    (println " points")
    
    # Retrieve and use points (type-safe!)
    let first: Point = (list_Point_get points 0)
    (print "  First point: (")
    (print first.x)
    (print ", ")
    (print first.y)
    (println ")")
    
    let last: Point = (list_Point_pop points)
    (print "  Popped point: (")
    (print last.x)
    (print ", ")
    (print last.y)
    (println ")")
    
    (print "  Remaining: ")
    (println (list_Point_length points))
    
    (println "  ✓ List<Point> with custom structs works!")
    return 0
}

shadow demo_list_point {
    # Skip - uses extern functions
    assert true
}

# ==============================================================================
# Example 4: List<Player> - Nested Structs in Generics
# ==============================================================================

fn demo_list_player() -> int {
    (println "")
    (println "=== Example 4: List<Player> - Nested Struct List ===")
    
    let players: List<Player> = (list_Player_new)
    
    let pos1: Point = Point { x: 100, y: 200 }
    let player1: Player = Player { name: "Hero", score: 1000, position: pos1 }
    
    let pos2: Point = Point { x: 150, y: 250 }
    let player2: Player = Player { name: "Warrior", score: 850, position: pos2 }
    
    (list_Player_push players player1)
    (list_Player_push players player2)
    
    (print "  Players in game: ")
    (println (list_Player_length players))
    
    let first_player: Player = (list_Player_get players 0)
    (print "  First player: ")
    (print first_player.name)
    (print " (Score: ")
    (print first_player.score)
    (println ")")
    
    (print "    Position: (")
    (print first_player.position.x)
    (print ", ")
    (print first_player.position.y)
    (println ")")
    
    (println "  ✓ List<Player> with nested structs works!")
    return 0
}

shadow demo_list_player {
    # Skip - uses extern functions
    assert true
}

# ==============================================================================
# Example 5: List<Token> - Compiler/Lexer Use Case
# ==============================================================================

fn demo_list_token() -> int {
    (println "")
    (println "=== Example 5: List<Token> - Real-World Use Case ===")
    
    # Tokens for a simple lexer - like building a compiler!
    let tokens: List<Token> = (list_Token_new)
    
    let tok1: Token = Token { type: 1, value: "fn", line: 1, column: 1 }
    let tok2: Token = Token { type: 2, value: "main", line: 1, column: 4 }
    let tok3: Token = Token { type: 3, value: "(", line: 1, column: 8 }
    
    (list_Token_push tokens tok1)
    (list_Token_push tokens tok2)
    (list_Token_push tokens tok3)
    
    let token_count: int = (list_Token_length tokens)
    (print "  Tokens parsed: ")
    (println token_count)
    
    let first_token: Token = (list_Token_get tokens 0)
    (print "  First token: '")
    (print first_token.value)
    (print "' at line ")
    (print first_token.line)
    (print ", col ")
    (println first_token.column)
    
    (println "  ✓ List<Token> - perfect for lexer/parser!")
    return 0
}

shadow demo_list_token {
    # Skip - uses extern functions
    assert true
}

# ==============================================================================
# Example 6: Type Safety Demonstration
# ==============================================================================

fn demo_type_safety() -> int {
    (println "")
    (println "=== Example 6: Type Safety - Compile-Time Guarantees ===")
    
    let numbers: List<int> = (list_int_new)
    let names: List<string> = (list_string_new)
    
    (list_int_push numbers 42)
    (list_string_push names "Alice")
    
    # These are type-safe operations:
    let num: int = (list_int_get numbers 0)
    let name: string = (list_string_get names 0)
    
    (print "  Number: ")
    (println num)
    (print "  Name: ")
    (println name)
    
    # The following would NOT compile (type errors):
    # (list_int_push numbers "string")  # Error: int expected, string given
    # (list_string_push names 42)       # Error: string expected, int given
    # let wrong: string = (list_int_get numbers 0)  # Error: type mismatch
    
    (println "  ✓ Type system prevents errors at compile time!")
    return 0
}

shadow demo_type_safety {
    assert (== (demo_type_safety) 0)
}

# ==============================================================================
# Main Function - Run All Demonstrations
# ==============================================================================

fn main() -> int {
    (println "")
    (println "╔════════════════════════════════════════════════╗")
    (println "║  COMPREHENSIVE GENERICS DEMO - List<T>        ║")
    (println "╚════════════════════════════════════════════════╝")
    (println "")
    (println "Demonstrating NanoLang's generic type system:")
    (println "  - Monomorphization (compile-time specialization)")
    (println "  - Type-safe operations")
    (println "  - Generics with primitives and structs")
    (println "  - Real-world use cases")
    
    # Run all examples
    (demo_list_int)
    (demo_list_string)
    (demo_list_point)
    (demo_list_player)
    (demo_list_token)
    (demo_type_safety)
    
    (println "")
    (println "════════════════════════════════════════════════")
    (println "✅ All generic type demonstrations completed!")
    (println "")
    (println "Key Takeaways:")
    (println "  1. One generic definition (List<T>) → many types")
    (println "  2. Type safety enforced at compile time")
    (println "  3. No runtime overhead (fully monomorphized)")
    (println "  4. Works with any type (primitives, structs)")
    (println "  5. Perfect for building data structures")
    (println "════════════════════════════════════════════════")
    (println "")
    
    return 0
}

shadow main {
    # Skip - uses extern functions
    assert true
}
