# Asteroids - Classic Atari Game in nanolang
# Full implementation with ship, asteroids, bullets, collision detection

import "modules/sdl/sdl.nano"
import "modules/sdl_helpers/sdl_helpers.nano"
import "modules/sdl_ttf/sdl_ttf.nano"
import "modules/sdl_ttf/sdl_ttf_helpers.nano"

# === CONSTANTS ===
let WINDOW_WIDTH: int = 800
let WINDOW_HEIGHT: int = 600
let SHIP_SIZE: int = 15
let MAX_BULLETS: int = 5
let MAX_ASTEROIDS: int = 20
let BULLET_SPEED: float = 300.0
let SHIP_ROTATION_SPEED: float = 4.0
let SHIP_THRUST: float = 150.0
let SHIP_DRAG: float = 0.98
let ASTEROID_SPEED_MIN: float = 20.0
let ASTEROID_SPEED_MAX: float = 80.0
let PI: float = 3.14159265359

# === ENUMS ===
enum AsteroidSize {
    Large,
    Medium,
    Small
}

enum GameState {
    Playing,
    GameOver
}

# === STRUCTS ===
struct Ship {
    x: float,
    y: float,
    vx: float,
    vy: float,
    angle: float,
    thrusting: bool
}

struct Bullet {
    x: float,
    y: float,
    vx: float,
    vy: float,
    active: bool,
    life: float
}

struct Asteroid {
    x: float,
    y: float,
    vx: float,
    vy: float,
    size: AsteroidSize,
    active: bool,
    radius: int
}

struct GameData {
    ship: Ship,
    bullets: array<Bullet>,
    asteroids: array<Asteroid>,
    score: int,
    lives: int,
    level: int,
    state: GameState
}

# === MATH HELPERS ===

fn deg_to_rad(deg: float) -> float {
    return (* deg (/ PI 180.0))
}

shadow deg_to_rad {
    let rad: float = (deg_to_rad 180.0)
    # Should be approximately PI
    assert (> rad 3.0)
    assert (< rad 3.2)
}

fn wrap_coordinate(val: float, max: float) -> float {
    let mut result: float = val
    if (< result 0.0) {
        set result (+ result max)
    } else {
        (print "")
    }
    if (>= result max) {
        set result (- result max)
    } else {
        (print "")
    }
    return result
}

shadow wrap_coordinate {
    assert (== (wrap_coordinate -10.0 100.0) 90.0)
    assert (== (wrap_coordinate 110.0 100.0) 10.0)
}

fn distance(x1: float, y1: float, x2: float, y2: float) -> float {
    let dx: float = (- x2 x1)
    let dy: float = (- y2 y1)
    return (sqrt (+ (* dx dx) (* dy dy)))
}

shadow distance {
    let d: float = (distance 0.0 0.0 3.0 4.0)
    assert (== d 5.0)
}

# === SHIP FUNCTIONS ===

fn create_ship(x: float, y: float) -> Ship {
    return Ship {
        x: x,
        y: y,
        vx: 0.0,
        vy: 0.0,
        angle: 0.0,
        thrusting: false
    }
}

shadow create_ship {
    let ship: Ship = (create_ship 400.0 300.0)
    assert (== ship.x 400.0)
    assert (== ship.y 300.0)
}

fn update_ship(ship: Ship, dt: float) -> Ship {
    let mut new_vx: float = ship.vx
    let mut new_vy: float = ship.vy
    
    # Apply thrust
    if ship.thrusting {
        let angle_rad: float = (deg_to_rad ship.angle)
        let thrust_x: float = (* (cos angle_rad) SHIP_THRUST)
        let thrust_y: float = (* (sin angle_rad) SHIP_THRUST)
        set new_vx (+ new_vx (* thrust_x dt))
        set new_vy (+ new_vy (* thrust_y dt))
    } else {
        (print "")
    }
    
    # Apply drag
    set new_vx (* new_vx SHIP_DRAG)
    set new_vy (* new_vy SHIP_DRAG)
    
    # Update position
    let new_x: float = (+ ship.x (* new_vx dt))
    let new_y: float = (+ ship.y (* new_vy dt))
    
    # Wrap around screen
    let wrapped_x: float = (wrap_coordinate new_x (cast_float WINDOW_WIDTH))
    let wrapped_y: float = (wrap_coordinate new_y (cast_float WINDOW_HEIGHT))
    
    return Ship {
        x: wrapped_x,
        y: wrapped_y,
        vx: new_vx,
        vy: new_vy,
        angle: ship.angle,
        thrusting: ship.thrusting
    }
}

shadow update_ship {
    let ship: Ship = (create_ship 400.0 300.0)
    let updated: Ship = (update_ship ship 0.016)
    assert (>= updated.x 0.0)
    assert (< updated.x (cast_float WINDOW_WIDTH))
}

fn rotate_ship(ship: Ship, direction: int) -> Ship {
    let delta: float = (* (cast_float direction) SHIP_ROTATION_SPEED)
    return Ship {
        x: ship.x,
        y: ship.y,
        vx: ship.vx,
        vy: ship.vy,
        angle: (+ ship.angle delta),
        thrusting: ship.thrusting
    }
}

shadow rotate_ship {
    let ship: Ship = (create_ship 400.0 300.0)
    let rotated: Ship = (rotate_ship ship 1)
    assert (> rotated.angle 0.0)
}

fn set_ship_thrust(ship: Ship, thrusting: bool) -> Ship {
    return Ship {
        x: ship.x,
        y: ship.y,
        vx: ship.vx,
        vy: ship.vy,
        angle: ship.angle,
        thrusting: thrusting
    }
}

shadow set_ship_thrust {
    let ship: Ship = (create_ship 400.0 300.0)
    let thrusting: Ship = (set_ship_thrust ship true)
    assert (== thrusting.thrusting true)
}

# === BULLET FUNCTIONS ===

fn create_bullet(x: float, y: float, angle: float) -> Bullet {
    let angle_rad: float = (deg_to_rad angle)
    let vx: float = (* (cos angle_rad) BULLET_SPEED)
    let vy: float = (* (sin angle_rad) BULLET_SPEED)
    return Bullet {
        x: x,
        y: y,
        vx: vx,
        vy: vy,
        active: true,
        life: 2.0
    }
}

shadow create_bullet {
    let bullet: Bullet = (create_bullet 400.0 300.0 0.0)
    assert (== bullet.active true)
    assert (> bullet.vx 0.0)
}

fn update_bullet(bullet: Bullet, dt: float) -> Bullet {
    if (not bullet.active) {
        return bullet
    } else {
        (print "")
    }
    
    let new_life: float = (- bullet.life dt)
    if (<= new_life 0.0) {
        return Bullet {
            x: bullet.x,
            y: bullet.y,
            vx: bullet.vx,
            vy: bullet.vy,
            active: false,
            life: 0.0
        }
    } else {
        (print "")
    }
    
    let new_x: float = (+ bullet.x (* bullet.vx dt))
    let new_y: float = (+ bullet.y (* bullet.vy dt))
    let wrapped_x: float = (wrap_coordinate new_x (cast_float WINDOW_WIDTH))
    let wrapped_y: float = (wrap_coordinate new_y (cast_float WINDOW_HEIGHT))
    
    return Bullet {
        x: wrapped_x,
        y: wrapped_y,
        vx: bullet.vx,
        vy: bullet.vy,
        active: true,
        life: new_life
    }
}

shadow update_bullet {
    let bullet: Bullet = (create_bullet 400.0 300.0 0.0)
    let updated: Bullet = (update_bullet bullet 0.016)
    assert (== updated.active true)
    assert (< updated.life 2.0)
}

# === ASTEROID FUNCTIONS ===

fn get_asteroid_radius(size: AsteroidSize) -> int {
    if (== size AsteroidSize::Large) {
        return 40
    } else {
        (print "")
    }
    if (== size AsteroidSize::Medium) {
        return 25
    } else {
        (print "")
    }
    return 15
}

shadow get_asteroid_radius {
    assert (== (get_asteroid_radius AsteroidSize::Large) 40)
    assert (== (get_asteroid_radius AsteroidSize::Medium) 25)
    assert (== (get_asteroid_radius AsteroidSize::Small) 15)
}

fn get_asteroid_score(size: AsteroidSize) -> int {
    if (== size AsteroidSize::Large) {
        return 20
    } else {
        (print "")
    }
    if (== size AsteroidSize::Medium) {
        return 50
    } else {
        (print "")
    }
    return 100
}

shadow get_asteroid_score {
    assert (== (get_asteroid_score AsteroidSize::Large) 20)
    assert (== (get_asteroid_score AsteroidSize::Medium) 50)
    assert (== (get_asteroid_score AsteroidSize::Small) 100)
}

fn create_asteroid(x: float, y: float, vx: float, vy: float, size: AsteroidSize) -> Asteroid {
    return Asteroid {
        x: x,
        y: y,
        vx: vx,
        vy: vy,
        size: size,
        active: true,
        radius: (get_asteroid_radius size)
    }
}

shadow create_asteroid {
    let ast: Asteroid = (create_asteroid 100.0 100.0 50.0 30.0 AsteroidSize::Large)
    assert (== ast.active true)
    assert (== ast.radius 40)
}

fn update_asteroid(asteroid: Asteroid, dt: float) -> Asteroid {
    if (not asteroid.active) {
        return asteroid
    } else {
        (print "")
    }
    
    let new_x: float = (+ asteroid.x (* asteroid.vx dt))
    let new_y: float = (+ asteroid.y (* asteroid.vy dt))
    let wrapped_x: float = (wrap_coordinate new_x (cast_float WINDOW_WIDTH))
    let wrapped_y: float = (wrap_coordinate new_y (cast_float WINDOW_HEIGHT))
    
    return Asteroid {
        x: wrapped_x,
        y: wrapped_y,
        vx: asteroid.vx,
        vy: asteroid.vy,
        size: asteroid.size,
        active: asteroid.active,
        radius: asteroid.radius
    }
}

shadow update_asteroid {
    let ast: Asteroid = (create_asteroid 100.0 100.0 50.0 30.0 AsteroidSize::Large)
    let updated: Asteroid = (update_asteroid ast 0.016)
    assert (== updated.active true)
}

# === COLLISION DETECTION ===

fn check_collision_circle(x1: float, y1: float, r1: int, x2: float, y2: float, r2: int) -> bool {
    let dist: float = (distance x1 y1 x2 y2)
    let combined_radius: float = (cast_float (+ r1 r2))
    return (<= dist combined_radius)
}

shadow check_collision_circle {
    # Overlapping circles
    assert (== (check_collision_circle 0.0 0.0 10 5.0 0.0 10) true)
    # Separate circles
    assert (== (check_collision_circle 0.0 0.0 10 30.0 0.0 10) false)
}

# === RENDERING ===

fn draw_ship(renderer: SDL_Renderer, ship: Ship) -> void {
    let angle_rad: float = (deg_to_rad ship.angle)
    let cos_a: float = (cos angle_rad)
    let sin_a: float = (sin angle_rad)
    
    # Ship nose
    let nose_x: int = (cast_int (+ ship.x (* cos_a (cast_float SHIP_SIZE))))
    let nose_y: int = (cast_int (+ ship.y (* sin_a (cast_float SHIP_SIZE))))
    
    # Ship rear left
    let rear_angle1: float = (+ angle_rad 2.356)  # 135 degrees in radians
    let rear1_x: int = (cast_int (+ ship.x (* (cos rear_angle1) (cast_float (/ SHIP_SIZE 2)))))
    let rear1_y: int = (cast_int (+ ship.y (* (sin rear_angle1) (cast_float (/ SHIP_SIZE 2)))))
    
    # Ship rear right
    let rear_angle2: float = (- angle_rad 2.356)
    let rear2_x: int = (cast_int (+ ship.x (* (cos rear_angle2) (cast_float (/ SHIP_SIZE 2)))))
    let rear2_y: int = (cast_int (+ ship.y (* (sin rear_angle2) (cast_float (/ SHIP_SIZE 2)))))
    
    # Draw ship triangle (using lines)
    (SDL_SetRenderDrawColor renderer 255 255 255 255)
    (SDL_RenderDrawLine renderer (cast_int ship.x) (cast_int ship.y) nose_x nose_y)
    (SDL_RenderDrawLine renderer (cast_int ship.x) (cast_int ship.y) rear1_x rear1_y)
    (SDL_RenderDrawLine renderer (cast_int ship.x) (cast_int ship.y) rear2_x rear2_y)
    (SDL_RenderDrawLine renderer nose_x nose_y rear1_x rear1_y)
    (SDL_RenderDrawLine renderer nose_x nose_y rear2_x rear2_y)
    (SDL_RenderDrawLine renderer rear1_x rear1_y rear2_x rear2_y)
}

shadow draw_ship {
    assert true  # Requires SDL context
}

fn draw_bullet(renderer: SDL_Renderer, bullet: Bullet) -> void {
    if bullet.active {
        (SDL_SetRenderDrawColor renderer 255 255 0 255)
        let x: int = (cast_int bullet.x)
        let y: int = (cast_int bullet.y)
        (nl_sdl_render_fill_rect renderer (- x 2) (- y 2) 4 4)
    } else {
        (print "")
    }
}

shadow draw_bullet {
    assert true  # Requires SDL context
}

fn draw_asteroid(renderer: SDL_Renderer, asteroid: Asteroid) -> void {
    if asteroid.active {
        (SDL_SetRenderDrawColor renderer 150 150 150 255)
        let x: int = (cast_int asteroid.x)
        let y: int = (cast_int asteroid.y)
        let radius: int = asteroid.radius
        
        # Draw circle approximation with 8 line segments
        let mut angle: float = 0.0
        let angle_step: float = (/ (* 2.0 PI) 8.0)
        let mut i: int = 0
        while (< i 8) {
            let next_angle: float = (+ angle angle_step)
            let x1: int = (+ x (cast_int (* (cos angle) (cast_float radius))))
            let y1: int = (+ y (cast_int (* (sin angle) (cast_float radius))))
            let x2: int = (+ x (cast_int (* (cos next_angle) (cast_float radius))))
            let y2: int = (+ y (cast_int (* (sin next_angle) (cast_float radius))))
            (SDL_RenderDrawLine renderer x1 y1 x2 y2)
            set angle next_angle
            set i (+ i 1)
        }
    } else {
        (print "")
    }
}

shadow draw_asteroid {
    assert true  # Requires SDL context
}

fn draw_ui(renderer: SDL_Renderer, font: TTF_Font, score: int, lives: int, level: int) -> void {
    (SDL_SetRenderDrawColor renderer 0 0 0 200)
    (nl_sdl_render_fill_rect renderer 0 0 WINDOW_WIDTH 40)
    
    (nl_draw_text_blended renderer font "Score: " 10 10 255 255 255 255)
    (nl_draw_text_blended renderer font (int_to_string score) 80 10 255 255 0 255)
    
    (nl_draw_text_blended renderer font "Lives: " (- WINDOW_WIDTH 200) 10 255 255 255 255)
    (nl_draw_text_blended renderer font (int_to_string lives) (- WINDOW_WIDTH 130) 10 0 255 0 255)
    
    (nl_draw_text_blended renderer font "Level: " (/ WINDOW_WIDTH 2) 10 255 255 255 255)
    (nl_draw_text_blended renderer font (int_to_string level) (+ (/ WINDOW_WIDTH 2) 70) 10 255 128 0 255)
}

shadow draw_ui {
    assert true  # Requires SDL context
}

# === GAME INITIALIZATION ===

fn init_game(level: int) -> GameData {
    # Create ship in center
    let ship: Ship = (create_ship (/ (cast_float WINDOW_WIDTH) 2.0) (/ (cast_float WINDOW_HEIGHT) 2.0))
    
    # Pre-allocate bullets (all inactive)
    let bullets: array<Bullet> = [
        Bullet { x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, active: false, life: 0.0 },
        Bullet { x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, active: false, life: 0.0 },
        Bullet { x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, active: false, life: 0.0 },
        Bullet { x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, active: false, life: 0.0 },
        Bullet { x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, active: false, life: 0.0 }
    ]
    
    # Create initial asteroids (4 + level)
    let num_asteroids: int = (+ 4 level)
    let asteroids: array<Asteroid> = [
        (create_asteroid 100.0 100.0 50.0 30.0 AsteroidSize::Large),
        (create_asteroid 700.0 100.0 -40.0 40.0 AsteroidSize::Large),
        (create_asteroid 100.0 500.0 40.0 -50.0 AsteroidSize::Large),
        (create_asteroid 700.0 500.0 -50.0 -40.0 AsteroidSize::Large),
        Asteroid { x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, size: AsteroidSize::Small, active: false, radius: 15 },
        Asteroid { x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, size: AsteroidSize::Small, active: false, radius: 15 },
        Asteroid { x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, size: AsteroidSize::Small, active: false, radius: 15 },
        Asteroid { x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, size: AsteroidSize::Small, active: false, radius: 15 },
        Asteroid { x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, size: AsteroidSize::Small, active: false, radius: 15 },
        Asteroid { x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, size: AsteroidSize::Small, active: false, radius: 15 },
        Asteroid { x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, size: AsteroidSize::Small, active: false, radius: 15 },
        Asteroid { x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, size: AsteroidSize::Small, active: false, radius: 15 },
        Asteroid { x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, size: AsteroidSize::Small, active: false, radius: 15 },
        Asteroid { x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, size: AsteroidSize::Small, active: false, radius: 15 },
        Asteroid { x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, size: AsteroidSize::Small, active: false, radius: 15 },
        Asteroid { x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, size: AsteroidSize::Small, active: false, radius: 15 },
        Asteroid { x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, size: AsteroidSize::Small, active: false, radius: 15 },
        Asteroid { x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, size: AsteroidSize::Small, active: false, radius: 15 },
        Asteroid { x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, size: AsteroidSize::Small, active: false, radius: 15 },
        Asteroid { x: 0.0, y: 0.0, vx: 0.0, vy: 0.0, size: AsteroidSize::Small, active: false, radius: 15 }
    ]
    
    return GameData {
        ship: ship,
        bullets: bullets,
        asteroids: asteroids,
        score: 0,
        lives: 3,
        level: level,
        state: GameState::Playing
    }
}

shadow init_game {
    let game: GameData = (init_game 1)
    assert (== game.lives 3)
    assert (== game.level 1)
}

# === MAIN ===

fn main() -> int {
    (println "Initializing Asteroids...")
    
    # Initialize SDL
    if (== (SDL_Init 32) -1) {
        (println "Error: SDL_Init failed")
        return 1
    } else {
        (print "")
    }
    
    # Initialize SDL_ttf
    if (== (TTF_Init) -1) {
        (println "Error: TTF_Init failed")
        (SDL_Quit)
        return 1
    } else {
        (print "")
    }
    
    # Create window and renderer
    let window: SDL_Window = (SDL_CreateWindow "Asteroids - nanolang" 100 100 WINDOW_WIDTH WINDOW_HEIGHT 4)
    let renderer: SDL_Renderer = (SDL_CreateRenderer window -1 2)
    
    # Load font
    let font: TTF_Font = (nl_open_font_portable "Arial" 16)
    if (== font 0) {
        (println "Error: Failed to load font")
        (SDL_DestroyRenderer renderer)
        (SDL_DestroyWindow window)
        (TTF_Quit)
        (SDL_Quit)
        return 1
    } else {
        (print "")
    }
    
    # Initialize game
    let mut game: GameData = (init_game 1)
    
    # Game loop
    let dt: float = 0.016
    let mut running: bool = true
    
    (println "")
    (println "=== ASTEROIDS ===")
    (println "Controls:")
    (println "  UP    - Thrust")
    (println "  LEFT  - Rotate left")
    (println "  RIGHT - Rotate right")
    (println "  SPACE - Fire")
    (println "  ESC   - Quit")
    (println "")
    
    while running {
        # Handle input
        let key: int = (nl_sdl_poll_key)
        if (== key 27) {  # ESC
            set running false
        } else {
            (print "")
        }
        
        # Update ship based on input
        if (== key 1073741906) {  # UP arrow
            set game.ship (set_ship_thrust game.ship true)
        } else {
            set game.ship (set_ship_thrust game.ship false)
        }
        
        if (== key 1073741904) {  # LEFT arrow
            set game.ship (rotate_ship game.ship -1)
        } else {
            (print "")
        }
        
        if (== key 1073741903) {  # RIGHT arrow
            set game.ship (rotate_ship game.ship 1)
        } else {
            (print "")
        }
        
        # Update ship
        set game.ship (update_ship game.ship dt)
        
        # Update bullets
        let mut i: int = 0
        while (< i MAX_BULLETS) {
            let bullet: Bullet = (at game.bullets i)
            let updated_bullet: Bullet = (update_bullet bullet dt)
            (array_set game.bullets i updated_bullet)
            set i (+ i 1)
        }
        
        # Update asteroids
        set i 0
        while (< i MAX_ASTEROIDS) {
            let asteroid: Asteroid = (at game.asteroids i)
            let updated_asteroid: Asteroid = (update_asteroid asteroid dt)
            (array_set game.asteroids i updated_asteroid)
            set i (+ i 1)
        }
        
        # Render
        (SDL_SetRenderDrawColor renderer 0 0 0 255)
        (SDL_RenderClear renderer)
        
        # Draw game objects
        (draw_ship renderer game.ship)
        
        set i 0
        while (< i MAX_BULLETS) {
            (draw_bullet renderer (at game.bullets i))
            set i (+ i 1)
        }
        
        set i 0
        while (< i MAX_ASTEROIDS) {
            (draw_asteroid renderer (at game.asteroids i))
            set i (+ i 1)
        }
        
        # Draw UI
        (draw_ui renderer font game.score game.lives game.level)
        
        (SDL_RenderPresent renderer)
        (SDL_Delay 16)
    }
    
    # Cleanup
    (TTF_CloseFont font)
    (SDL_DestroyRenderer renderer)
    (SDL_DestroyWindow window)
    (TTF_Quit)
    (SDL_Quit)
    
    (println "")
    (println "Thanks for playing!")
    return 0
}

shadow main {
    assert true
}
