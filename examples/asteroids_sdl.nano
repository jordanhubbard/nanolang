# ASTEROIDS - Classic arcade game using parallel arrays pattern
# Workaround for array<struct> limitation - uses separate arrays for each field

import "modules/sdl/sdl.nano"
import "modules/sdl_helpers/sdl_helpers.nano"

# === CONSTANTS ===
let WINDOW_WIDTH: int = 800
let WINDOW_HEIGHT: int = 600
let SHIP_SIZE: float = 15.0
let ASTEROID_RADIUS: float = 20.0
let BULLET_SPEED: float = 400.0
let SHIP_THRUST: float = 200.0
let SHIP_DRAG: float = 0.98
let SHIP_ROTATION_SPEED: float = 4.0
let PI: float = 3.14159
let DEG_TO_RAD: float = 0.017453

# === HELPER FUNCTIONS ===

fn wrap_position(pos: float, max: float) -> float {
    if (< pos 0.0) {
        return max
    } else {
        if (> pos max) {
            return 0.0
        } else {
            return pos
        }
    }
}

fn distance_squared(x1: float, y1: float, x2: float, y2: float) -> float {
    let dx: float = (- x2 x1)
    let dy: float = (- y2 y1)
    return (+ (* dx dx) (* dy dy))
}

fn circles_collide(x1: float, y1: float, r1: float, x2: float, y2: float, r2: float) -> bool {
    let dist_sq: float = (distance_squared x1 y1 x2 y2)
    let radii_sum: float = (+ r1 r2)
    return (< dist_sq (* radii_sum radii_sum))
}

# === MAIN GAME ===

fn main() -> int {
    (println "╔════════════════════════════════════════════╗")
    (println "║   ASTEROIDS - Nanolang Edition            ║")
    (println "╚════════════════════════════════════════════╝")
    (println "")
    (println "Controls:")
    (println "  Up Arrow    - Thrust")
    (println "  Left/Right  - Rotate")
    (println "  Space       - Shoot")
    (println "  ESC         - Quit")
    (println "")
    (println "Note: Uses parallel arrays pattern")
    (println "      (workaround for array<struct>)")
    (println "")
    
    # Initialize SDL
    (SDL_Init SDL_INIT_VIDEO)
    let window: SDL_Window = (SDL_CreateWindow "Asteroids" 100 100 WINDOW_WIDTH WINDOW_HEIGHT SDL_WINDOW_SHOWN)
    let renderer: SDL_Renderer = (SDL_CreateRenderer window -1 SDL_RENDERER_ACCELERATED)
    
    # Ship state (single entity)
    let mut ship_x: float = (/ (cast_float WINDOW_WIDTH) 2.0)
    let mut ship_y: float = (/ (cast_float WINDOW_HEIGHT) 2.0)
    let mut ship_vx: float = 0.0
    let mut ship_vy: float = 0.0
    let mut ship_angle: float = 0.0
    let mut ship_alive: bool = true
    
    # Asteroids (parallel arrays)
    let mut asteroid_x: array<float> = []
    let mut asteroid_y: array<float> = []
    let mut asteroid_vx: array<float> = []
    let mut asteroid_vy: array<float> = []
    let mut asteroid_active: array<bool> = []
    
    # Bullets (parallel arrays)
    let mut bullet_x: array<float> = []
    let mut bullet_y: array<float> = []
    let mut bullet_vx: array<float> = []
    let mut bullet_vy: array<float> = []
    let mut bullet_life: array<float> = []
    let mut bullet_active: array<bool> = []
    
    # Particles for explosions (parallel arrays)
    let mut particle_x: array<float> = []
    let mut particle_y: array<float> = []
    let mut particle_vx: array<float> = []
    let mut particle_vy: array<float> = []
    let mut particle_life: array<float> = []
    
    # Spawn initial asteroids
    set asteroid_x (array_push asteroid_x 100.0)
    set asteroid_y (array_push asteroid_y 100.0)
    set asteroid_vx (array_push asteroid_vx 50.0)
    set asteroid_vy (array_push asteroid_vy 30.0)
    set asteroid_active (array_push asteroid_active true)
    
    set asteroid_x (array_push asteroid_x 700.0)
    set asteroid_y (array_push asteroid_y 100.0)
    set asteroid_vx (array_push asteroid_vx -40.0)
    set asteroid_vy (array_push asteroid_vy 25.0)
    set asteroid_active (array_push asteroid_active true)
    
    set asteroid_x (array_push asteroid_x 400.0)
    set asteroid_y (array_push asteroid_y 500.0)
    set asteroid_vx (array_push asteroid_vx 30.0)
    set asteroid_vy (array_push asteroid_vy -50.0)
    set asteroid_active (array_push asteroid_active true)
    
    set asteroid_x (array_push asteroid_x 200.0)
    set asteroid_y (array_push asteroid_y 300.0)
    set asteroid_vx (array_push asteroid_vx -30.0)
    set asteroid_vy (array_push asteroid_vy 40.0)
    set asteroid_active (array_push asteroid_active true)
    
    set asteroid_x (array_push asteroid_x 600.0)
    set asteroid_y (array_push asteroid_y 400.0)
    set asteroid_vx (array_push asteroid_vx -50.0)
    set asteroid_vy (array_push asteroid_vy -30.0)
    set asteroid_active (array_push asteroid_active true)
    
    # Game state
    let mut score: int = 0
    let mut running: bool = true
    let mut last_time: int = (SDL_GetTicks)
    let mut shoot_cooldown: float = 0.0
    
    # Main loop
    while running {
        # Delta time
        let current_time: int = (SDL_GetTicks)
        let dt: float = (/ (cast_float (- current_time last_time)) 1000.0)
        set last_time current_time
        
        # Input
        let key: int = (nl_sdl_poll_keypress)
        let mut thrust: bool = false
        let mut rotate_left: bool = false
        let mut rotate_right: bool = false
        let mut shoot: bool = false
        
        if (== key 1073741906) { set thrust true } else {}      # Up
        if (== key 1073741904) { set rotate_left true } else {} # Left
        if (== key 1073741903) { set rotate_right true } else {} # Right
        if (== key 32) { set shoot true } else {}                # Space
        if (== key 41) { set running false } else {}             # ESC
        
        if (== (nl_sdl_poll_event_quit) 1) { set running false } else {}
        
        # Update cooldown
        set shoot_cooldown (- shoot_cooldown dt)
        
        # Shoot
        if shoot {
            if (< shoot_cooldown 0.0) {
                if ship_alive {
                    set bullet_x (array_push bullet_x ship_x)
                    set bullet_y (array_push bullet_y ship_y)
                    set bullet_vx (array_push bullet_vx (* (cos ship_angle) BULLET_SPEED))
                    set bullet_vy (array_push bullet_vy (* (sin ship_angle) BULLET_SPEED))
                    set bullet_life (array_push bullet_life 2.0)
                    set bullet_active (array_push bullet_active true)
                    set shoot_cooldown 0.25
                } else {}
            } else {}
        } else {}
        
        # Update ship
        if ship_alive {
            if rotate_left {
                set ship_angle (- ship_angle (* SHIP_ROTATION_SPEED dt))
            } else {}
            if rotate_right {
                set ship_angle (+ ship_angle (* SHIP_ROTATION_SPEED dt))
            } else {}
            
            if thrust {
                set ship_vx (+ ship_vx (* (cos ship_angle) (* SHIP_THRUST dt)))
                set ship_vy (+ ship_vy (* (sin ship_angle) (* SHIP_THRUST dt)))
            } else {}
            
            set ship_vx (* ship_vx SHIP_DRAG)
            set ship_vy (* ship_vy SHIP_DRAG)
            set ship_x (wrap_position (+ ship_x (* ship_vx dt)) (cast_float WINDOW_WIDTH))
            set ship_y (wrap_position (+ ship_y (* ship_vy dt)) (cast_float WINDOW_HEIGHT))
        } else {}
        
        # Update asteroids
        let mut i: int = 0
        while (< i (array_length asteroid_x)) {
            let ax: float = (at asteroid_x i)
            let ay: float = (at asteroid_y i)
            let avx: float = (at asteroid_vx i)
            let avy: float = (at asteroid_vy i)
            
            let new_x: float = (wrap_position (+ ax (* avx dt)) (cast_float WINDOW_WIDTH))
            let new_y: float = (wrap_position (+ ay (* avy dt)) (cast_float WINDOW_HEIGHT))
            
            (array_set asteroid_x i new_x)
            (array_set asteroid_y i new_y)
            set i (+ i 1)
        }
        
        # Update bullets
        set i 0
        while (< i (array_length bullet_x)) {
            let active: bool = (at bullet_active i)
            if active {
                let bx: float = (at bullet_x i)
                let by: float = (at bullet_y i)
                let bvx: float = (at bullet_vx i)
                let bvy: float = (at bullet_vy i)
                let life: float = (at bullet_life i)
                
                let new_x: float = (+ bx (* bvx dt))
                let new_y: float = (+ by (* bvy dt))
                let new_life: float = (- life dt)
                
                (array_set bullet_x i new_x)
                (array_set bullet_y i new_y)
                (array_set bullet_life i new_life)
                
                # Deactivate if off screen or life expired
                if (< new_life 0.0) {
                    (array_set bullet_active i false)
                } else {
                    if (< new_x 0.0) { (array_set bullet_active i false) } else {}
                    if (> new_x (cast_float WINDOW_WIDTH)) { (array_set bullet_active i false) } else {}
                    if (< new_y 0.0) { (array_set bullet_active i false) } else {}
                    if (> new_y (cast_float WINDOW_HEIGHT)) { (array_set bullet_active i false) } else {}
                }
            } else {}
            set i (+ i 1)
        }
        
        # Update particles
        set i 0
        while (< i (array_length particle_x)) {
            let px: float = (at particle_x i)
            let py: float = (at particle_y i)
            let pvx: float = (at particle_vx i)
            let pvy: float = (at particle_vy i)
            let plife: float = (at particle_life i)
            
            (array_set particle_x i (+ px (* pvx dt)))
            (array_set particle_y i (+ py (* pvy dt)))
            (array_set particle_life i (- plife dt))
            set i (+ i 1)
        }
        
        # Collision: bullets vs asteroids
        set i 0
        while (< i (array_length bullet_x)) {
            let bullet_is_active: bool = (at bullet_active i)
            if bullet_is_active {
                let bx: float = (at bullet_x i)
                let by: float = (at bullet_y i)
                
                let mut j: int = 0
                while (< j (array_length asteroid_x)) {
                    let asteroid_is_active: bool = (at asteroid_active j)
                    if asteroid_is_active {
                        let ax: float = (at asteroid_x j)
                        let ay: float = (at asteroid_y j)
                        
                        if (circles_collide bx by 2.0 ax ay ASTEROID_RADIUS) {
                            # Deactivate both
                            (array_set bullet_active i false)
                            (array_set asteroid_active j false)
                            
                            # Create explosion particles (30 particles)
                            let mut k: int = 0
                            while (< k 30) {
                                let angle: float = (* (cast_float k) (/ (* 2.0 PI) 30.0))
                                let speed: float = (+ 50.0 (* (cast_float (% k 20)) 3.0))
                                
                                set particle_x (array_push particle_x ax)
                                set particle_y (array_push particle_y ay)
                                set particle_vx (array_push particle_vx (* (cos angle) speed))
                                set particle_vy (array_push particle_vy (* (sin angle) speed))
                                set particle_life (array_push particle_life 0.8)
                                set k (+ k 1)
                            }
                            
                            set score (+ score 100)
                        } else {}
                    } else {}
                    set j (+ j 1)
                }
            } else {}
            set i (+ i 1)
        }
        
        # Collision: ship vs asteroids
        if ship_alive {
            set i 0
            while (< i (array_length asteroid_x)) {
                let asteroid_is_active: bool = (at asteroid_active i)
                if asteroid_is_active {
                    let ax: float = (at asteroid_x i)
                    let ay: float = (at asteroid_y i)
                    
                    if (circles_collide ship_x ship_y SHIP_SIZE ax ay ASTEROID_RADIUS) {
                        set ship_alive false
                        
                        # Ship explosion (40 particles)
                        let mut k: int = 0
                        while (< k 40) {
                            let angle: float = (* (cast_float k) (/ (* 2.0 PI) 40.0))
                            let speed: float = (+ 80.0 (* (cast_float (% k 25)) 4.0))
                            
                            set particle_x (array_push particle_x ship_x)
                            set particle_y (array_push particle_y ship_y)
                            set particle_vx (array_push particle_vx (* (cos angle) speed))
                            set particle_vy (array_push particle_vy (* (sin angle) speed))
                            set particle_life (array_push particle_life 1.0)
                            set k (+ k 1)
                        }
                    } else {}
                } else {}
                set i (+ i 1)
            }
        } else {}
        
        # Render
        (SDL_SetRenderDrawColor renderer 0 0 0 255)
        (SDL_RenderClear renderer)
        
        # Draw ship
        if ship_alive {
            (SDL_SetRenderDrawColor renderer 255 255 255 255)
            
            let cos_a: float = (cos ship_angle)
            let sin_a: float = (sin ship_angle)
            
            let fx: int = (cast_int (+ ship_x (* cos_a SHIP_SIZE)))
            let fy: int = (cast_int (+ ship_y (* sin_a SHIP_SIZE)))
            
            let back_angle1: float = (+ ship_angle 2.5)
            let bx1: int = (cast_int (+ ship_x (* (cos back_angle1) (* SHIP_SIZE 0.6))))
            let by1: int = (cast_int (+ ship_y (* (sin back_angle1) (* SHIP_SIZE 0.6))))
            
            let back_angle2: float = (- ship_angle 2.5)
            let bx2: int = (cast_int (+ ship_x (* (cos back_angle2) (* SHIP_SIZE 0.6))))
            let by2: int = (cast_int (+ ship_y (* (sin back_angle2) (* SHIP_SIZE 0.6))))
            
            (SDL_RenderDrawLine renderer (cast_int ship_x) (cast_int ship_y) fx fy)
            (SDL_RenderDrawLine renderer fx fy bx1 by1)
            (SDL_RenderDrawLine renderer bx1 by1 bx2 by2)
            (SDL_RenderDrawLine renderer bx2 by2 fx fy)
        } else {}
        
        # Draw asteroids
        set i 0
        while (< i (array_length asteroid_x)) {
            let active: bool = (at asteroid_active i)
            if active {
                (SDL_SetRenderDrawColor renderer 150 150 150 255)
                let ax: int = (cast_int (at asteroid_x i))
                let ay: int = (cast_int (at asteroid_y i))
                
                # Draw circle using points
                let mut angle: int = 0
                while (< angle 360) {
                    let rad: float = (* (cast_float angle) DEG_TO_RAD)
                    let px: int = (cast_int (+ (cast_float ax) (* ASTEROID_RADIUS (cos rad))))
                    let py: int = (cast_int (+ (cast_float ay) (* ASTEROID_RADIUS (sin rad))))
                    (SDL_RenderDrawPoint renderer px py)
                    set angle (+ angle 10)
                }
            } else {}
            set i (+ i 1)
        }
        
        # Draw bullets
        set i 0
        while (< i (array_length bullet_x)) {
            let active: bool = (at bullet_active i)
            if active {
                (SDL_SetRenderDrawColor renderer 255 255 0 255)
                let bx: int = (cast_int (at bullet_x i))
                let by: int = (cast_int (at bullet_y i))
                (SDL_RenderDrawPoint renderer bx by)
                (SDL_RenderDrawPoint renderer (+ bx 1) by)
                (SDL_RenderDrawPoint renderer bx (+ by 1))
                (SDL_RenderDrawPoint renderer (+ bx 1) (+ by 1))
            } else {}
            set i (+ i 1)
        }
        
        # Draw particles
        set i 0
        while (< i (array_length particle_x)) {
            let plife: float = (at particle_life i)
            if (> plife 0.0) {
                let alpha: int = (cast_int (* plife 255.0))
                (SDL_SetRenderDrawColor renderer 255 150 0 alpha)
                (SDL_RenderDrawPoint renderer (cast_int (at particle_x i)) (cast_int (at particle_y i)))
            } else {}
            set i (+ i 1)
        }
        
        (SDL_RenderPresent renderer)
        (SDL_Delay 16)
    }
    
    (SDL_DestroyRenderer renderer)
    (SDL_DestroyWindow window)
    (SDL_Quit)
    
    (println "")
    (println "Game Over!")
    (print "Final Score: ")
    (println score)
    
    return 0
}

shadow main {
    assert true
}
