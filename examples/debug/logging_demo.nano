# Example: Logging Demo
# Purpose: Demonstrates the structured logging API with fibonacci calculation and validation
# Features: imports, structured logging, recursion, shadow tests
# Difficulty: Beginner
# Category: debug
# Prerequisites: none
# Expected Output: [INFO] [app] Starting logging demo

from "stdlib/log.nano" import log_debug, log_info, log_trace, log_error

fn calculate_fibonacci(n: int) -> int {
    (log_debug "fibonacci" (+ "Calculating fibonacci(" (+ (int_to_string n) ")")))
    
    if (<= n 1) {
        (log_trace "fibonacci" (+ "Base case: n=" (int_to_string n)))
        return n
    } else {
        (print "")
    }
    
    let a: int = (calculate_fibonacci (- n 1))
    let b: int = (calculate_fibonacci (- n 2))
    let result: int = (+ a b)
    
    (log_debug "fibonacci" (+ "Result: fibonacci(" (+ (int_to_string n) (+ ") = " (int_to_string result)))))
    return result
}

fn main() -> int {
    (log_info "app" "Starting logging demo")
    
    (log_info "math" "Calculating fibonacci sequence")
    let fib10: int = (calculate_fibonacci 10)
    
    (log_info "result" (+ "Fibonacci(10) = " (int_to_string fib10)))
    
    if (!= fib10 55) {
        (log_error "validation" (+ "Expected 55, got " (int_to_string fib10)))
        return 1
    } else {
        (print "")
    }
    
    (log_info "app" "Demo complete - all tests passed!")
    return 0
}

shadow main {
    assert (== (main) 0)
}
