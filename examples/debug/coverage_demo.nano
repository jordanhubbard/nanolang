# examples/coverage_demo.nano - Demonstrate coverage and instrumentation APIs
#
# Shows how to use stdlib/coverage.nano for execution tracing and coverage tracking

from "stdlib/coverage.nano" import coverage_init, coverage_record, coverage_report, coverage_reset
from "stdlib/coverage.nano" import trace_init, trace_record, trace_report, trace_reset

# Example function with manual instrumentation
fn fibonacci(n: int) -> int {
    (trace_record "CALL" "fibonacci" (int_to_string n))
    (coverage_record "coverage_demo.nano" 12 5)
    
    if (<= n 1) {
        (coverage_record "coverage_demo.nano" 15 9)
        (trace_record "RETURN" "fibonacci" "base_case")
        return n
    }
    
    (coverage_record "coverage_demo.nano" 20 5)
    let fib1: int = (fibonacci (- n 1))
    let fib2: int = (fibonacci (- n 2))
    let result: int = (+ fib1 fib2)
    
    (trace_record "RETURN" "fibonacci" (int_to_string result))
    return result
}

shadow fibonacci {
    assert (== (fibonacci 0) 0)
    assert (== (fibonacci 1) 1)
    assert (== (fibonacci 5) 5)
}

# Function demonstrating conditional coverage
fn classify_number(x: int) -> string {
    (trace_record "CALL" "classify_number" (int_to_string x))
    (coverage_record "coverage_demo.nano" 31 5)
    
    if (< x 0) {
        (coverage_record "coverage_demo.nano" 34 9)
        (trace_record "RETURN" "classify_number" "negative")
        return "negative"
    } else {
        if (== x 0) {
            (coverage_record "coverage_demo.nano" 39 13)
            (trace_record "RETURN" "classify_number" "zero")
            return "zero"
        } else {
            (coverage_record "coverage_demo.nano" 43 13)
            (trace_record "RETURN" "classify_number" "positive")
            return "positive"
        }
    }
}

shadow classify_number {
    assert (str_equals (classify_number -3) "negative")
    assert (str_equals (classify_number 0) "zero")
    assert (str_equals (classify_number 4) "positive")
}

# Function with loop coverage
fn sum_array(arr: array<int>) -> int {
    (trace_record "CALL" "sum_array" (int_to_string (array_length arr)))
    (coverage_record "coverage_demo.nano" 53 5)
    
    let mut total: int = 0
    let mut i: int = 0
    
    while (< i (array_length arr)) {
        (coverage_record "coverage_demo.nano" 59 9)
        set total (+ total (at arr i))
        set i (+ i 1)
    }
    
    (trace_record "RETURN" "sum_array" (int_to_string total))
    return total
}

shadow sum_array {
    assert (== (sum_array []) 0)
    assert (== (sum_array [1, 2, 3]) 6)
}

fn main() -> int {
    (println "========================================")
    (println "Coverage and Instrumentation Demo")
    (println "========================================")
    (println "")
    
    # Initialize coverage and tracing
    (coverage_init)
    (trace_init)
    
    (println "=== Test 1: Fibonacci Sequence ===")
    let fib5: int = (fibonacci 5)
    (println (+ "fibonacci(5) = " (int_to_string fib5)))
    (println "")
    
    (println "=== Test 2: Number Classification ===")
    let c1: string = (classify_number -5)
    (println (+ "classify_number(-5) = " c1))
    
    let c2: string = (classify_number 0)
    (println (+ "classify_number(0) = " c2))
    
    let c3: string = (classify_number 10)
    (println (+ "classify_number(10) = " c3))
    (println "")
    
    (println "=== Test 3: Array Sum ===")
    let numbers: array<int> = [1, 2, 3, 4, 5]
    let sum: int = (sum_array numbers)
    (println (+ "sum([1,2,3,4,5]) = " (int_to_string sum)))
    (println "")
    
    # Print coverage report
    (coverage_report)
    (println "")
    
    # Print execution trace (first 20 events)
    (println "Execution Trace (sample):")
    (trace_report)
    
    return 0
}
