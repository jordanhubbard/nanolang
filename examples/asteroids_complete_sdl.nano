# ASTEROIDS COMPLETE - Full arcade game with lives, game over, and HUD
# Features: 3 lives, game over/restart, score display, breaking mechanics, thrust cone

import "modules/sdl/sdl.nano"
import "modules/sdl_helpers/sdl_helpers.nano"
import "modules/sdl_ttf/sdl_ttf.nano"
import "modules/sdl_ttf/sdl_ttf_helpers.nano"

# === CONSTANTS ===
let WINDOW_WIDTH: int = 800
let WINDOW_HEIGHT: int = 600
let SHIP_SIZE: float = 15.0
let BULLET_SPEED: float = 400.0
let SHIP_THRUST: float = 200.0
let SHIP_DRAG: float = 0.98
let SHIP_ROTATION_SPEED: float = 4.0
let PI: float = 3.14159
let DEG_TO_RAD: float = 0.017453

# Asteroid sizes
let ASTEROID_SIZE_LARGE: int = 3
let ASTEROID_SIZE_MEDIUM: int = 2
let ASTEROID_SIZE_SMALL: int = 1

# Asteroid radii by size
let ASTEROID_RADIUS_LARGE: float = 30.0
let ASTEROID_RADIUS_MEDIUM: float = 20.0
let ASTEROID_RADIUS_SMALL: float = 10.0

# Scoring (updated values)
let SCORE_LARGE: int = 10
let SCORE_MEDIUM: int = 30
let SCORE_SMALL: int = 50

# Game state
let STATE_PLAYING: int = 0
let STATE_DEAD: int = 1
let STATE_GAME_OVER: int = 2

# Lives
let STARTING_LIVES: int = 3
let RESPAWN_DELAY: float = 2.0

# === HELPER FUNCTIONS ===

fn wrap_position(pos: float, max: float) -> float {
    if (< pos 0.0) {
        return max
    } else {
        if (> pos max) {
            return 0.0
        } else {
            return pos
        }
    }
}

fn distance_squared(x1: float, y1: float, x2: float, y2: float) -> float {
    let dx: float = (- x2 x1)
    let dy: float = (- y2 y1)
    return (+ (* dx dx) (* dy dy))
}

fn circles_collide(x1: float, y1: float, r1: float, x2: float, y2: float, r2: float) -> bool {
    let dist_sq: float = (distance_squared x1 y1 x2 y2)
    let radii_sum: float = (+ r1 r2)
    return (< dist_sq (* radii_sum radii_sum))
}

fn get_asteroid_radius(size: int) -> float {
    if (== size ASTEROID_SIZE_LARGE) {
        return ASTEROID_RADIUS_LARGE
    } else {
        if (== size ASTEROID_SIZE_MEDIUM) {
            return ASTEROID_RADIUS_MEDIUM
        } else {
            return ASTEROID_RADIUS_SMALL
        }
    }
}

fn get_asteroid_score(size: int) -> int {
    if (== size ASTEROID_SIZE_LARGE) {
        return SCORE_LARGE
    } else {
        if (== size ASTEROID_SIZE_MEDIUM) {
            return SCORE_MEDIUM
        } else {
            return SCORE_SMALL
        }
    }
}

# === MAIN GAME ===

fn main() -> int {
    (println "╔════════════════════════════════════════════╗")
    (println "║   ASTEROIDS COMPLETE - Nanolang           ║")
    (println "╚════════════════════════════════════════════╝")
    (println "")
    (println "Controls:")
    (println "  Up Arrow    - Thrust")
    (println "  Left/Right  - Rotate")
    (println "  Space       - Shoot")
    (println "  R           - Restart (after game over)")
    (println "  ESC         - Quit")
    (println "")
    (println "Features:")
    (println "  • 3 Lives!")
    (println "  • Score: Large=10, Medium=30, Small=50")
    (println "  • Game Over screen with restart")
    (println "  • Live score display")
    (println "")
    
    # Initialize SDL
    (SDL_Init SDL_INIT_VIDEO)
    let window: SDL_Window = (SDL_CreateWindow "Asteroids Complete" 100 100 WINDOW_WIDTH WINDOW_HEIGHT SDL_WINDOW_SHOWN)
    let renderer: SDL_Renderer = (SDL_CreateRenderer window -1 SDL_RENDERER_ACCELERATED)
    
    # Initialize SDL_TTF
    (TTF_Init)
    let font: TTF_Font = (nl_open_font_portable "Arial" 24)
    let font_large: TTF_Font = (nl_open_font_portable "Arial" 48)
    
    # Game state
    let mut game_state: int = STATE_PLAYING
    let mut lives: int = STARTING_LIVES
    let mut score: int = 0
    let mut respawn_timer: float = 0.0
    let mut running: bool = true
    
    # Ship state
    let mut ship_x: float = (/ (cast_float WINDOW_WIDTH) 2.0)
    let mut ship_y: float = (/ (cast_float WINDOW_HEIGHT) 2.0)
    let mut ship_vx: float = 0.0
    let mut ship_vy: float = 0.0
    let mut ship_angle: float = 0.0
    let mut ship_alive: bool = true
    
    # Asteroids (parallel arrays) - now with size!
    let mut asteroid_x: array<float> = []
    let mut asteroid_y: array<float> = []
    let mut asteroid_vx: array<float> = []
    let mut asteroid_vy: array<float> = []
    let mut asteroid_size: array<int> = []
    let mut asteroid_active: array<bool> = []
    
    # Bullets (parallel arrays)
    let mut bullet_x: array<float> = []
    let mut bullet_y: array<float> = []
    let mut bullet_vx: array<float> = []
    let mut bullet_vy: array<float> = []
    let mut bullet_life: array<float> = []
    let mut bullet_active: array<bool> = []
    
    # Particles for explosions (parallel arrays)
    let mut particle_x: array<float> = []
    let mut particle_y: array<float> = []
    let mut particle_vx: array<float> = []
    let mut particle_vy: array<float> = []
    let mut particle_life: array<float> = []
    
    # Spawn initial large asteroids
    set asteroid_x (array_push asteroid_x 100.0)
    set asteroid_y (array_push asteroid_y 100.0)
    set asteroid_vx (array_push asteroid_vx 50.0)
    set asteroid_vy (array_push asteroid_vy 30.0)
    set asteroid_size (array_push asteroid_size ASTEROID_SIZE_LARGE)
    set asteroid_active (array_push asteroid_active true)
    
    set asteroid_x (array_push asteroid_x 700.0)
    set asteroid_y (array_push asteroid_y 100.0)
    set asteroid_vx (array_push asteroid_vx -40.0)
    set asteroid_vy (array_push asteroid_vy 25.0)
    set asteroid_size (array_push asteroid_size ASTEROID_SIZE_LARGE)
    set asteroid_active (array_push asteroid_active true)
    
    set asteroid_x (array_push asteroid_x 400.0)
    set asteroid_y (array_push asteroid_y 500.0)
    set asteroid_vx (array_push asteroid_vx 30.0)
    set asteroid_vy (array_push asteroid_vy -50.0)
    set asteroid_size (array_push asteroid_size ASTEROID_SIZE_LARGE)
    set asteroid_active (array_push asteroid_active true)
    
    # Game timing
    let mut last_time: int = (SDL_GetTicks)
    let mut shoot_cooldown: float = 0.0
    
    # Main loop
    while running {
        # Delta time
        let current_time: int = (SDL_GetTicks)
        let dt: float = (/ (cast_float (- current_time last_time)) 1000.0)
        set last_time current_time
        
        # Input - check keyboard state for continuous input
        let thrust: bool = (== (nl_sdl_key_state 82) 1)       # Up arrow
        let rotate_left: bool = (== (nl_sdl_key_state 80) 1)  # Left arrow
        let rotate_right: bool = (== (nl_sdl_key_state 79) 1) # Right arrow
        let shoot: bool = (== (nl_sdl_key_state 44) 1)        # Space
        
        # Check for keypresses (one-time events)
        let key: int = (nl_sdl_poll_keypress)
        if (== key 41) { set running false } else {}           # ESC
        if (== key 21) {                                       # R key
            if (== game_state STATE_GAME_OVER) {
                # Restart game
                set game_state STATE_PLAYING
                set lives STARTING_LIVES
                set score 0
                set ship_alive true
                set ship_x (/ (cast_float WINDOW_WIDTH) 2.0)
                set ship_y (/ (cast_float WINDOW_HEIGHT) 2.0)
                set ship_vx 0.0
                set ship_vy 0.0
                set ship_angle 0.0
                
                # Clear all asteroids and spawn new ones
                set asteroid_x []
                set asteroid_y []
                set asteroid_vx []
                set asteroid_vy []
                set asteroid_size []
                set asteroid_active []
                
                set asteroid_x (array_push asteroid_x 100.0)
                set asteroid_y (array_push asteroid_y 100.0)
                set asteroid_vx (array_push asteroid_vx 50.0)
                set asteroid_vy (array_push asteroid_vy 30.0)
                set asteroid_size (array_push asteroid_size ASTEROID_SIZE_LARGE)
                set asteroid_active (array_push asteroid_active true)
                
                set asteroid_x (array_push asteroid_x 700.0)
                set asteroid_y (array_push asteroid_y 100.0)
                set asteroid_vx (array_push asteroid_vx -40.0)
                set asteroid_vy (array_push asteroid_vy 25.0)
                set asteroid_size (array_push asteroid_size ASTEROID_SIZE_LARGE)
                set asteroid_active (array_push asteroid_active true)
                
                set asteroid_x (array_push asteroid_x 400.0)
                set asteroid_y (array_push asteroid_y 500.0)
                set asteroid_vx (array_push asteroid_vx 30.0)
                set asteroid_vy (array_push asteroid_vy -50.0)
                set asteroid_size (array_push asteroid_size ASTEROID_SIZE_LARGE)
                set asteroid_active (array_push asteroid_active true)
                
                # Clear bullets and particles
                set bullet_x []
                set bullet_y []
                set bullet_vx []
                set bullet_vy []
                set bullet_life []
                set bullet_active []
                set particle_x []
                set particle_y []
                set particle_vx []
                set particle_vy []
                set particle_life []
            } else {}
        } else {}
        
        if (== (nl_sdl_poll_event_quit) 1) { set running false } else {}
        
        # Update respawn timer if dead
        if (== game_state STATE_DEAD) {
            set respawn_timer (- respawn_timer dt)
            if (<= respawn_timer 0.0) {
                if (> lives 0) {
                    # Respawn
                    set ship_alive true
                    set ship_x (/ (cast_float WINDOW_WIDTH) 2.0)
                    set ship_y (/ (cast_float WINDOW_HEIGHT) 2.0)
                    set ship_vx 0.0
                    set ship_vy 0.0
                    set ship_angle 0.0
                    set game_state STATE_PLAYING
                } else {
                    # Game over
                    set game_state STATE_GAME_OVER
                }
            } else {}
        } else {}
        
        # Only update gameplay if playing
        if (== game_state STATE_PLAYING) {
            # Update cooldown
            set shoot_cooldown (- shoot_cooldown dt)
            
            # Shoot
            if shoot {
                if (< shoot_cooldown 0.0) {
                    if ship_alive {
                        set bullet_x (array_push bullet_x ship_x)
                        set bullet_y (array_push bullet_y ship_y)
                        set bullet_vx (array_push bullet_vx (* (cos ship_angle) BULLET_SPEED))
                        set bullet_vy (array_push bullet_vy (* (sin ship_angle) BULLET_SPEED))
                        set bullet_life (array_push bullet_life 2.0)
                        set bullet_active (array_push bullet_active true)
                        set shoot_cooldown 0.25
                    } else {}
                } else {}
            } else {}
            
            # Update ship
            if ship_alive {
                if rotate_left {
                    set ship_angle (- ship_angle (* SHIP_ROTATION_SPEED dt))
                } else {}
                if rotate_right {
                    set ship_angle (+ ship_angle (* SHIP_ROTATION_SPEED dt))
                } else {}
                
                if thrust {
                    set ship_vx (+ ship_vx (* (cos ship_angle) (* SHIP_THRUST dt)))
                    set ship_vy (+ ship_vy (* (sin ship_angle) (* SHIP_THRUST dt)))
                } else {}
                
                set ship_vx (* ship_vx SHIP_DRAG)
                set ship_vy (* ship_vy SHIP_DRAG)
                set ship_x (wrap_position (+ ship_x (* ship_vx dt)) (cast_float WINDOW_WIDTH))
                set ship_y (wrap_position (+ ship_y (* ship_vy dt)) (cast_float WINDOW_HEIGHT))
            } else {}
        } else {}
        
        # Always update asteroids, bullets, particles (even when dead)
        let mut i: int = 0
        while (< i (array_length asteroid_x)) {
            if (at asteroid_active i) {
                let ax: float = (at asteroid_x i)
                let ay: float = (at asteroid_y i)
                let avx: float = (at asteroid_vx i)
                let avy: float = (at asteroid_vy i)
                
                let new_x: float = (wrap_position (+ ax (* avx dt)) (cast_float WINDOW_WIDTH))
                let new_y: float = (wrap_position (+ ay (* avy dt)) (cast_float WINDOW_HEIGHT))
                
                (array_set asteroid_x i new_x)
                (array_set asteroid_y i new_y)
            } else {}
            set i (+ i 1)
        }
        
        # Update bullets (only if playing)
        if (== game_state STATE_PLAYING) {
            set i 0
            while (< i (array_length bullet_x)) {
                let active: bool = (at bullet_active i)
                if active {
                    let bx: float = (at bullet_x i)
                    let by: float = (at bullet_y i)
                    let bvx: float = (at bullet_vx i)
                    let bvy: float = (at bullet_vy i)
                    let life: float = (at bullet_life i)
                    
                    let new_x: float = (+ bx (* bvx dt))
                    let new_y: float = (+ by (* bvy dt))
                    let new_life: float = (- life dt)
                    
                    (array_set bullet_x i new_x)
                    (array_set bullet_y i new_y)
                    (array_set bullet_life i new_life)
                    
                    # Deactivate if off screen or life expired
                    if (< new_life 0.0) {
                        (array_set bullet_active i false)
                    } else {
                        if (< new_x 0.0) { (array_set bullet_active i false) } else {}
                        if (> new_x (cast_float WINDOW_WIDTH)) { (array_set bullet_active i false) } else {}
                        if (< new_y 0.0) { (array_set bullet_active i false) } else {}
                        if (> new_y (cast_float WINDOW_HEIGHT)) { (array_set bullet_active i false) } else {}
                    }
                } else {}
                set i (+ i 1)
            }
        } else {}
        
        # Update particles
        set i 0
        while (< i (array_length particle_x)) {
            let px: float = (at particle_x i)
            let py: float = (at particle_y i)
            let pvx: float = (at particle_vx i)
            let pvy: float = (at particle_vy i)
            let plife: float = (at particle_life i)
            
            (array_set particle_x i (+ px (* pvx dt)))
            (array_set particle_y i (+ py (* pvy dt)))
            (array_set particle_life i (- plife dt))
            set i (+ i 1)
        }
        
        # Collision: bullets vs asteroids (only if playing)
        if (== game_state STATE_PLAYING) {
            set i 0
            while (< i (array_length bullet_x)) {
                let bullet_is_active: bool = (at bullet_active i)
                if bullet_is_active {
                    let bx: float = (at bullet_x i)
                    let by: float = (at bullet_y i)
                    
                    let mut j: int = 0
                    while (< j (array_length asteroid_x)) {
                        let asteroid_is_active: bool = (at asteroid_active j)
                        if asteroid_is_active {
                            let ax: float = (at asteroid_x j)
                            let ay: float = (at asteroid_y j)
                            let asize: int = (at asteroid_size j)
                            let aradius: float = (get_asteroid_radius asize)
                            
                            if (circles_collide bx by 2.0 ax ay aradius) {
                                # Hit! Deactivate bullet and asteroid
                                (array_set bullet_active i false)
                                (array_set asteroid_active j false)
                                
                                # Add score based on size
                                set score (+ score (get_asteroid_score asize))
                                
                                # Create explosion particles
                                let mut k: int = 0
                                let particle_count: int = (* asize 10)
                                while (< k particle_count) {
                                    let angle: float = (* (cast_float k) (/ (* 2.0 PI) (cast_float particle_count)))
                                    let speed: float = (+ 50.0 (* (cast_float (% k 20)) 3.0))
                                    
                                    set particle_x (array_push particle_x ax)
                                    set particle_y (array_push particle_y ay)
                                    set particle_vx (array_push particle_vx (* (cos angle) speed))
                                    set particle_vy (array_push particle_vy (* (sin angle) speed))
                                    set particle_life (array_push particle_life 0.8)
                                    set k (+ k 1)
                                }
                                
                                # BREAK ASTEROID INTO SMALLER ONES!
                                if (== asize ASTEROID_SIZE_LARGE) {
                                    # Large -> 2 Medium
                                    let avx: float = (at asteroid_vx j)
                                    let avy: float = (at asteroid_vy j)
                                    
                                    # Medium 1 (rotate velocity +90 degrees)
                                    set asteroid_x (array_push asteroid_x ax)
                                    set asteroid_y (array_push asteroid_y ay)
                                    set asteroid_vx (array_push asteroid_vx (* (- avy) 1.5))
                                    set asteroid_vy (array_push asteroid_vy (* avx 1.5))
                                    set asteroid_size (array_push asteroid_size ASTEROID_SIZE_MEDIUM)
                                    set asteroid_active (array_push asteroid_active true)
                                    
                                    # Medium 2 (rotate velocity -90 degrees)
                                    set asteroid_x (array_push asteroid_x ax)
                                    set asteroid_y (array_push asteroid_y ay)
                                    set asteroid_vx (array_push asteroid_vx (* avy 1.5))
                                    set asteroid_vy (array_push asteroid_vy (* (- avx) 1.5))
                                    set asteroid_size (array_push asteroid_size ASTEROID_SIZE_MEDIUM)
                                    set asteroid_active (array_push asteroid_active true)
                                } else {
                                    if (== asize ASTEROID_SIZE_MEDIUM) {
                                        # Medium -> 3 Small
                                        let avx: float = (at asteroid_vx j)
                                        let avy: float = (at asteroid_vy j)
                                        
                                        # Small 1 (velocity * 2)
                                        set asteroid_x (array_push asteroid_x ax)
                                        set asteroid_y (array_push asteroid_y ay)
                                        set asteroid_vx (array_push asteroid_vx (* avx 2.0))
                                        set asteroid_vy (array_push asteroid_vy (* avy 2.0))
                                        set asteroid_size (array_push asteroid_size ASTEROID_SIZE_SMALL)
                                        set asteroid_active (array_push asteroid_active true)
                                        
                                        # Small 2 (rotate +120 degrees)
                                        let cos120: float = -0.5
                                        let sin120: float = 0.866
                                        let vx2: float = (- (* avx cos120) (* avy sin120))
                                        let vy2: float = (+ (* avx sin120) (* avy cos120))
                                        set asteroid_x (array_push asteroid_x ax)
                                        set asteroid_y (array_push asteroid_y ay)
                                        set asteroid_vx (array_push asteroid_vx (* vx2 2.0))
                                        set asteroid_vy (array_push asteroid_vy (* vy2 2.0))
                                        set asteroid_size (array_push asteroid_size ASTEROID_SIZE_SMALL)
                                        set asteroid_active (array_push asteroid_active true)
                                        
                                        # Small 3 (rotate -120 degrees)
                                        let vx3: float = (- (* avx cos120) (* avy (- sin120)))
                                        let vy3: float = (+ (* avx (- sin120)) (* avy cos120))
                                        set asteroid_x (array_push asteroid_x ax)
                                        set asteroid_y (array_push asteroid_y ay)
                                        set asteroid_vx (array_push asteroid_vx (* vx3 2.0))
                                        set asteroid_vy (array_push asteroid_vy (* vy3 2.0))
                                        set asteroid_size (array_push asteroid_size ASTEROID_SIZE_SMALL)
                                        set asteroid_active (array_push asteroid_active true)
                                    } else {
                                        # Small -> Destroyed (no children)
                                    }
                                }
                            } else {}
                        } else {}
                        set j (+ j 1)
                    }
                } else {}
                set i (+ i 1)
            }
        } else {}
        
        # Collision: ship vs asteroids (only if playing)
        if (== game_state STATE_PLAYING) {
            if ship_alive {
                set i 0
                while (< i (array_length asteroid_x)) {
                    let asteroid_is_active: bool = (at asteroid_active i)
                    if asteroid_is_active {
                        let ax: float = (at asteroid_x i)
                        let ay: float = (at asteroid_y i)
                        let asize: int = (at asteroid_size i)
                        let aradius: float = (get_asteroid_radius asize)
                        
                        if (circles_collide ship_x ship_y SHIP_SIZE ax ay aradius) {
                            set ship_alive false
                            set lives (- lives 1)
                            set game_state STATE_DEAD
                            set respawn_timer RESPAWN_DELAY
                            
                            # Ship explosion (40 particles)
                            let mut k: int = 0
                            while (< k 40) {
                                let angle: float = (* (cast_float k) (/ (* 2.0 PI) 40.0))
                                let speed: float = (+ 80.0 (* (cast_float (% k 25)) 4.0))
                                
                                set particle_x (array_push particle_x ship_x)
                                set particle_y (array_push particle_y ship_y)
                                set particle_vx (array_push particle_vx (* (cos angle) speed))
                                set particle_vy (array_push particle_vy (* (sin angle) speed))
                                set particle_life (array_push particle_life 1.0)
                                set k (+ k 1)
                            }
                        } else {}
                    } else {}
                    set i (+ i 1)
                }
            } else {}
        } else {}
        
        # Render
        (SDL_SetRenderDrawColor renderer 0 0 0 255)
        (SDL_RenderClear renderer)
        
        # Draw ship (only if alive)
        if ship_alive {
            (SDL_SetRenderDrawColor renderer 255 255 255 255)
            
            let cos_a: float = (cos ship_angle)
            let sin_a: float = (sin ship_angle)
            
            let fx: int = (cast_int (+ ship_x (* cos_a SHIP_SIZE)))
            let fy: int = (cast_int (+ ship_y (* sin_a SHIP_SIZE)))
            
            let back_angle1: float = (+ ship_angle 2.5)
            let bx1: int = (cast_int (+ ship_x (* (cos back_angle1) (* SHIP_SIZE 0.6))))
            let by1: int = (cast_int (+ ship_y (* (sin back_angle1) (* SHIP_SIZE 0.6))))
            
            let back_angle2: float = (- ship_angle 2.5)
            let bx2: int = (cast_int (+ ship_x (* (cos back_angle2) (* SHIP_SIZE 0.6))))
            let by2: int = (cast_int (+ ship_y (* (sin back_angle2) (* SHIP_SIZE 0.6))))
            
            (SDL_RenderDrawLine renderer (cast_int ship_x) (cast_int ship_y) fx fy)
            (SDL_RenderDrawLine renderer fx fy bx1 by1)
            (SDL_RenderDrawLine renderer bx1 by1 bx2 by2)
            (SDL_RenderDrawLine renderer bx2 by2 fx fy)
            
            # Draw thrust cone if thrusting (only when playing)
            if (== game_state STATE_PLAYING) {
                if thrust {
                    (SDL_SetRenderDrawColor renderer 255 200 0 255)
                    
                    # Thrust cone points backward from ship center
                    let thrust_length: float = (* SHIP_SIZE 0.8)
                    let thrust_angle: float = (+ ship_angle PI)
                    
                    let tx: int = (cast_int (+ ship_x (* (cos thrust_angle) thrust_length)))
                    let ty: int = (cast_int (+ ship_y (* (sin thrust_angle) thrust_length)))
                    
                    # Draw thrust cone as lines
                    (SDL_RenderDrawLine renderer (cast_int ship_x) (cast_int ship_y) tx ty)
                    (SDL_RenderDrawLine renderer bx1 by1 tx ty)
                    (SDL_RenderDrawLine renderer bx2 by2 tx ty)
                } else {}
            } else {}
        } else {}
        
        # Draw asteroids (different sizes!)
        set i 0
        while (< i (array_length asteroid_x)) {
            let active: bool = (at asteroid_active i)
            if active {
                let asize: int = (at asteroid_size i)
                
                # Color by size
                if (== asize ASTEROID_SIZE_LARGE) {
                    (SDL_SetRenderDrawColor renderer 180 180 180 255)
                } else {
                    if (== asize ASTEROID_SIZE_MEDIUM) {
                        (SDL_SetRenderDrawColor renderer 150 150 150 255)
                    } else {
                        (SDL_SetRenderDrawColor renderer 120 120 120 255)
                    }
                }
                
                let ax: int = (cast_int (at asteroid_x i))
                let ay: int = (cast_int (at asteroid_y i))
                let aradius: float = (get_asteroid_radius asize)
                
                # Draw circle using points
                let mut angle: int = 0
                while (< angle 360) {
                    let rad: float = (* (cast_float angle) DEG_TO_RAD)
                    let px: int = (cast_int (+ (cast_float ax) (* aradius (cos rad))))
                    let py: int = (cast_int (+ (cast_float ay) (* aradius (sin rad))))
                    (SDL_RenderDrawPoint renderer px py)
                    set angle (+ angle 10)
                }
            } else {}
            set i (+ i 1)
        }
        
        # Draw bullets
        set i 0
        while (< i (array_length bullet_x)) {
            let active: bool = (at bullet_active i)
            if active {
                (SDL_SetRenderDrawColor renderer 255 255 0 255)
                let bx: int = (cast_int (at bullet_x i))
                let by: int = (cast_int (at bullet_y i))
                (SDL_RenderDrawPoint renderer bx by)
                (SDL_RenderDrawPoint renderer (+ bx 1) by)
                (SDL_RenderDrawPoint renderer bx (+ by 1))
                (SDL_RenderDrawPoint renderer (+ bx 1) (+ by 1))
            } else {}
            set i (+ i 1)
        }
        
        # Draw particles
        set i 0
        while (< i (array_length particle_x)) {
            let plife: float = (at particle_life i)
            if (> plife 0.0) {
                let alpha: int = (cast_int (* plife 255.0))
                (SDL_SetRenderDrawColor renderer 255 150 0 alpha)
                (SDL_RenderDrawPoint renderer (cast_int (at particle_x i)) (cast_int (at particle_y i)))
            } else {}
            set i (+ i 1)
        }
        
        # Draw HUD - Lives (top left)
        let lives_text: string = (str_concat "Lives: " (int_to_string lives))
        (nl_draw_text_blended renderer font lives_text 10 10 255 255 255 255)
        
        # Draw HUD - Score (bottom right)
        let score_text: string = (str_concat "Score: " (int_to_string score))
        (nl_draw_text_blended renderer font score_text 620 560 255 255 0 255)
        
        # Draw GAME OVER screen
        if (== game_state STATE_GAME_OVER) {
            # Draw semi-transparent overlay
            (SDL_SetRenderDrawColor renderer 0 0 0 128)
            (nl_sdl_render_fill_rect renderer 0 0 WINDOW_WIDTH WINDOW_HEIGHT)
            
            # Draw GAME OVER text
            (nl_draw_text_blended renderer font_large "GAME OVER" 250 250 255 0 0 255)
            
            # Draw final score
            let final_score_text: string = (str_concat "Final Score: " (int_to_string score))
            (nl_draw_text_blended renderer font final_score_text 280 320 255 255 255 255)
            
            # Draw restart instruction
            (nl_draw_text_blended renderer font "Press R to Restart or ESC to Quit" 180 380 255 255 255 255)
        } else {}
        
        (SDL_RenderPresent renderer)
        (SDL_Delay 16)
    }
    
    (TTF_CloseFont font)
    (TTF_CloseFont font_large)
    (TTF_Quit)
    (SDL_DestroyRenderer renderer)
    (SDL_DestroyWindow window)
    (SDL_Quit)
    
    (println "")
    (println "Game Over!")
    (print "Final Score: ")
    (println score)
    
    return 0
}

shadow wrap_position {
    assert (== (wrap_position -5.0 100.0) 100.0)
    assert (== (wrap_position 105.0 100.0) 0.0)
    assert (== (wrap_position 50.0 100.0) 50.0)
}

shadow distance_squared {
    assert (== (distance_squared 0.0 0.0 3.0 4.0) 25.0)
    assert (== (distance_squared 1.0 1.0 1.0 1.0) 0.0)
}

shadow circles_collide {
    assert (circles_collide 0.0 0.0 10.0 5.0 5.0 10.0)
    assert (not (circles_collide 0.0 0.0 5.0 100.0 100.0 5.0))
}

shadow get_asteroid_radius {
    assert (== (get_asteroid_radius ASTEROID_SIZE_LARGE) ASTEROID_RADIUS_LARGE)
    assert (== (get_asteroid_radius ASTEROID_SIZE_MEDIUM) ASTEROID_RADIUS_MEDIUM)
    assert (== (get_asteroid_radius ASTEROID_SIZE_SMALL) ASTEROID_RADIUS_SMALL)
}

shadow get_asteroid_score {
    assert (== (get_asteroid_score ASTEROID_SIZE_LARGE) SCORE_LARGE)
    assert (== (get_asteroid_score ASTEROID_SIZE_MEDIUM) SCORE_MEDIUM)
    assert (== (get_asteroid_score ASTEROID_SIZE_SMALL) SCORE_SMALL)
}

shadow main {
    assert true
}
