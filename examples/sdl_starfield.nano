# STARFIELD - 3D Space Travel Effect
# Classic effect from every 80s/90s game intro

import "modules/sdl/sdl.nano"
import "modules/sdl_helpers/sdl_helpers.nano"
import "modules/sdl_ttf/sdl_ttf.nano"
import "modules/sdl_ttf/sdl_ttf_helpers.nano"

# === CONSTANTS ===
let WINDOW_WIDTH: int = 800
let WINDOW_HEIGHT: int = 600
let NUM_STARS: int = 200
let STAR_SPEED: float = 100.0

# === EXTERNAL FUNCTIONS ===
extern fn rand() -> int
extern fn srand(seed: int) -> void
extern fn time(t: int) -> int

# === STAR STRUCTURE ===
# Stars have X, Y, Z coordinates
# Z controls depth and speed

fn init_stars(count: int) -> array<float> {
    # Returns flat array: [x1, y1, z1, x2, y2, z2, ...]
    let mut stars: array<float> = []
    
    let mut i: int = 0
    while (< i count) {
        # Random X (-400 to 400)
        let rx: int = (- (% (rand) 800) 400)
        let x: float = (cast_float rx)
        
        # Random Y (-300 to 300)
        let ry: int = (- (% (rand) 600) 300)
        let y: float = (cast_float ry)
        
        # Random Z (1 to 800)
        let rz: int = (+ (% (rand) 800) 1)
        let z: float = (cast_float rz)
        
        set stars (array_push stars x)
        set stars (array_push stars y)
        set stars (array_push stars z)
        
        set i (+ i 1)
    }
    
    return stars
}

fn get_star_x(stars: array<float>, idx: int) -> float {
    return (at stars (* idx 3))
}

shadow get_star_x {
    let stars: array<float> = [1.0, 2.0, 3.0,
                               4.0, 5.0, 6.0]
    assert (== (get_star_x stars 0) 1.0)
    assert (== (get_star_x stars 1) 4.0)
}

fn get_star_y(stars: array<float>, idx: int) -> float {
    return (at stars (+ (* idx 3) 1))
}

shadow get_star_y {
    let stars: array<float> = [1.0, 2.0, 3.0,
                               4.0, 5.0, 6.0]
    assert (== (get_star_y stars 0) 2.0)
    assert (== (get_star_y stars 1) 5.0)
}

fn get_star_z(stars: array<float>, idx: int) -> float {
    return (at stars (+ (* idx 3) 2))
}

shadow get_star_z {
    let stars: array<float> = [1.0, 2.0, 3.0,
                               4.0, 5.0, 6.0]
    assert (== (get_star_z stars 0) 3.0)
    assert (== (get_star_z stars 1) 6.0)
}

fn set_star_x(stars: array<float>, idx: int, val: float) -> array<float> {
    (array_set stars (* idx 3) val)
    return stars
}

shadow set_star_x {
    let mut stars: array<float> = [1.0, 2.0, 3.0]
    set stars (set_star_x stars 0 9.0)
    assert (== (at stars 0) 9.0)
}

fn set_star_y(stars: array<float>, idx: int, val: float) -> array<float> {
    (array_set stars (+ (* idx 3) 1) val)
    return stars
}

shadow set_star_y {
    let mut stars: array<float> = [1.0, 2.0, 3.0]
    set stars (set_star_y stars 0 9.0)
    assert (== (at stars 1) 9.0)
}

fn set_star_z(stars: array<float>, idx: int, val: float) -> array<float> {
    (array_set stars (+ (* idx 3) 2) val)
    return stars
}

shadow set_star_z {
    let mut stars: array<float> = [1.0, 2.0, 3.0]
    set stars (set_star_z stars 0 9.0)
    assert (== (at stars 2) 9.0)
}

fn reset_star(stars: array<float>, idx: int) -> array<float> {
    # Reset star to far distance
    let rx: int = (- (% (rand) 800) 400)
    let x: float = (cast_float rx)
    
    let ry: int = (- (% (rand) 600) 300)
    let y: float = (cast_float ry)
    
    let rz: int = (+ (% (rand) 400) 600)
    let z: float = (cast_float rz)
    
    let mut result: array<float> = (set_star_x stars idx x)
    set result (set_star_y result idx y)
    set result (set_star_z result idx z)
    
    return result
}

fn update_stars(stars: array<float>, count: int, dt: float) -> array<float> {
    let mut i: int = 0
    let mut result: array<float> = stars
    
    while (< i count) {
        let z: float = (get_star_z result i)
        let new_z: float = (- z (* STAR_SPEED dt))
        
        # If star passes camera, reset it
        if (< new_z 1.0) {
            set result (reset_star result i)
        } else {
            set result (set_star_z result i new_z)
        }
        
        set i (+ i 1)
    }
    
    return result
}

shadow update_stars {
    /* update_stars may call reset_star(), which uses rand(); keep shadow test side-effect free. */
    assert true
}

# === MAIN ===

fn main() -> int {
    (println "╔════════════════════════════════════════════╗")
    (println "║          STARFIELD - Space Travel         ║")
    (println "╚════════════════════════════════════════════╝")
    (println "")
    (println "")
    
    # Seed random
    let t: int = (time 0)
    unsafe { (srand t) }
    
    # Initialize SDL
    unsafe { (SDL_Init SDL_INIT_VIDEO) }
    unsafe { (TTF_Init) }
    let window: SDL_Window = (SDL_CreateWindow "Starfield" 100 100 WINDOW_WIDTH WINDOW_HEIGHT SDL_WINDOW_SHOWN)
    let renderer: SDL_Renderer = (SDL_CreateRenderer window -1 SDL_RENDERER_ACCELERATED)
    
    # Load font for help text
    let font: TTF_Font = (nl_open_font_portable "Arial" 12)
    
    # Initialize stars
    let mut stars: array<float> = (init_stars NUM_STARS)
    
    # Timing
    let mut last_time: int = (SDL_GetTicks)
    let mut running: bool = true
    
    # Center of screen (calculated once for projection, used every frame)
    let center_x: float = (/ (cast_float WINDOW_WIDTH) 2.0)
    let center_y: float = (/ (cast_float WINDOW_HEIGHT) 2.0)
    
    # Main loop
    while running {
        # Delta time
        let current_time: int = (SDL_GetTicks)
        let dt: float = (/ (cast_float (- current_time last_time)) 1000.0)
        set last_time current_time
        
        # Check for quit
        unsafe {         (nl_sdl_poll_keypress) }
        if (== (nl_sdl_poll_event_quit) 1) { set running false } else {}
        
        # Update stars
        set stars (update_stars stars NUM_STARS dt)
        
        # Render
        # Clear screen (black)
        unsafe { (SDL_SetRenderDrawColor renderer 0 0 0 255) }
        unsafe { (SDL_RenderClear renderer) }
        
        # Draw stars
        let mut i: int = 0
        while (< i NUM_STARS) {
            let x: float = (get_star_x stars i)
            let z: float = (get_star_z stars i)
            
            # Size based on distance (closer = bigger) - clamped 1-4
            let size_raw: int = (cast_int (/ 400.0 z))
            let size: int = (cond
                ((< size_raw 1) 1)
                ((> size_raw 4) 4)
                (else size_raw)
            )
            
            # Brightness based on distance (closer = brighter) - clamped 50-255
            let brightness_raw: int = (cast_int (* (/ 400.0 z) 255.0))
            let brightness: int = (cond
                ((> brightness_raw 255) 255)
                ((< brightness_raw 50) 50)
                (else brightness_raw)
            )
            
            # 3D projection X - check if star is visible horizontally
            let screen_x: float = (+ center_x (/ x z))
            let sx: int = (cast_int screen_x)
            
            if (>= sx 0) {
                if (< sx WINDOW_WIDTH) {
                    # Only get Y and project if X is on screen (optimization)
                    let y: float = (get_star_y stars i)
                    let screen_y: float = (+ center_y (/ y z))
                    let sy: int = (cast_int screen_y)
                    if (>= sy 0) {
                        if (< sy WINDOW_HEIGHT) {
                            unsafe { (SDL_SetRenderDrawColor renderer brightness brightness brightness 255) }
                            unsafe { (nl_sdl_render_fill_rect renderer sx sy size size) }
                        } else {}
                    } else {}
                } else {}
            } else {}
            
            set i (+ i 1)
        }
        
        # Draw on-screen help
        
        unsafe { (SDL_RenderPresent renderer) }
        
        # Small delay
        unsafe { (SDL_Delay 16) }
    }
    
    # Cleanup
    unsafe { (TTF_CloseFont font) }
    unsafe { (SDL_DestroyRenderer renderer) }
    unsafe { (SDL_DestroyWindow window) }
    unsafe { (TTF_Quit) }
    unsafe { (SDL_Quit) }
    
    return 0
}
