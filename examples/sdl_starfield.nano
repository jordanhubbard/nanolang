# STARFIELD - 3D Space Travel Effect
# Classic effect from every 80s/90s game intro
# ESC to exit

import "modules/sdl/sdl.nano"
import "modules/sdl_helpers/sdl_helpers.nano"

# === CONSTANTS ===
let WINDOW_WIDTH: int = 800
let WINDOW_HEIGHT: int = 600
let NUM_STARS: int = 200
let STAR_SPEED: float = 100.0

# === EXTERNAL FUNCTIONS ===
extern fn rand() -> int
extern fn srand(seed: int) -> void
extern fn time(t: int) -> int

# === STAR STRUCTURE ===
# Stars have X, Y, Z coordinates
# Z controls depth and speed

fn init_stars(count: int) -> array<float> {
    # Returns flat array: [x1, y1, z1, x2, y2, z2, ...]
    let mut stars: array<float> = []
    
    let mut i: int = 0
    while (< i count) {
        # Random X (-400 to 400)
        let rx: int = (- (% (rand) 800) 400)
        let x: float = (cast_float rx)
        
        # Random Y (-300 to 300)
        let ry: int = (- (% (rand) 600) 300)
        let y: float = (cast_float ry)
        
        # Random Z (1 to 800)
        let rz: int = (+ (% (rand) 800) 1)
        let z: float = (cast_float rz)
        
        set stars (array_push stars x)
        set stars (array_push stars y)
        set stars (array_push stars z)
        
        set i (+ i 1)
    }
    
    return stars
}

fn get_star_x(stars: array<float>, idx: int) -> float {
    return (at stars (* idx 3))
}

shadow get_star_x {
    let stars: array<float> = [1.0, 2.0, 3.0,
                               4.0, 5.0, 6.0]
    assert (== (get_star_x stars 0) 1.0)
    assert (== (get_star_x stars 1) 4.0)
}

fn get_star_y(stars: array<float>, idx: int) -> float {
    return (at stars (+ (* idx 3) 1))
}

shadow get_star_y {
    let stars: array<float> = [1.0, 2.0, 3.0,
                               4.0, 5.0, 6.0]
    assert (== (get_star_y stars 0) 2.0)
    assert (== (get_star_y stars 1) 5.0)
}

fn get_star_z(stars: array<float>, idx: int) -> float {
    return (at stars (+ (* idx 3) 2))
}

shadow get_star_z {
    let stars: array<float> = [1.0, 2.0, 3.0,
                               4.0, 5.0, 6.0]
    assert (== (get_star_z stars 0) 3.0)
    assert (== (get_star_z stars 1) 6.0)
}

fn set_star_x(stars: array<float>, idx: int, val: float) -> array<float> {
    (array_set stars (* idx 3) val)
    return stars
}

shadow set_star_x {
    let mut stars: array<float> = [1.0, 2.0, 3.0]
    set stars (set_star_x stars 0 9.0)
    assert (== (at stars 0) 9.0)
}

fn set_star_y(stars: array<float>, idx: int, val: float) -> array<float> {
    (array_set stars (+ (* idx 3) 1) val)
    return stars
}

shadow set_star_y {
    let mut stars: array<float> = [1.0, 2.0, 3.0]
    set stars (set_star_y stars 0 9.0)
    assert (== (at stars 1) 9.0)
}

fn set_star_z(stars: array<float>, idx: int, val: float) -> array<float> {
    (array_set stars (+ (* idx 3) 2) val)
    return stars
}

shadow set_star_z {
    let mut stars: array<float> = [1.0, 2.0, 3.0]
    set stars (set_star_z stars 0 9.0)
    assert (== (at stars 2) 9.0)
}

fn reset_star(stars: array<float>, idx: int) -> array<float> {
    # Reset star to far distance
    let rx: int = (- (% (rand) 800) 400)
    let x: float = (cast_float rx)
    
    let ry: int = (- (% (rand) 600) 300)
    let y: float = (cast_float ry)
    
    let rz: int = (+ (% (rand) 400) 600)
    let z: float = (cast_float rz)
    
    let mut result: array<float> = (set_star_x stars idx x)
    set result (set_star_y result idx y)
    set result (set_star_z result idx z)
    
    return result
}

fn update_stars(stars: array<float>, count: int, dt: float) -> array<float> {
    let mut i: int = 0
    let mut result: array<float> = stars
    
    while (< i count) {
        let z: float = (get_star_z result i)
        let new_z: float = (- z (* STAR_SPEED dt))
        
        # If star passes camera, reset it
        if (< new_z 1.0) {
            set result (reset_star result i)
        } else {
            set result (set_star_z result i new_z)
        }
        
        set i (+ i 1)
    }
    
    return result
}

shadow update_stars {
    /* update_stars may call reset_star(), which uses rand(); keep shadow test side-effect free. */
    assert true
}

# === MAIN ===

fn main() -> int {
    (println "╔════════════════════════════════════════════╗")
    (println "║          STARFIELD - Space Travel         ║")
    (println "╚════════════════════════════════════════════╝")
    (println "")
    (println "Press ESC to exit")
    (println "")
    
    # Seed random
    let t: int = (time 0)
    (srand t)
    
    # Initialize SDL
    (SDL_Init SDL_INIT_VIDEO)
    let window: SDL_Window = (SDL_CreateWindow "Starfield" 100 100 WINDOW_WIDTH WINDOW_HEIGHT SDL_WINDOW_SHOWN)
    let renderer: SDL_Renderer = (SDL_CreateRenderer window -1 SDL_RENDERER_ACCELERATED)
    
    # Initialize stars
    let mut stars: array<float> = (init_stars NUM_STARS)
    
    # Timing
    let mut last_time: int = (SDL_GetTicks)
    let mut running: bool = true
    
    # Center of screen (calculated once for projection, used every frame)
    let center_x: float = (/ (cast_float WINDOW_WIDTH) 2.0)
    let center_y: float = (/ (cast_float WINDOW_HEIGHT) 2.0)
    
    # Main loop
    while running {
        # Delta time
        let current_time: int = (SDL_GetTicks)
        let dt: float = (/ (cast_float (- current_time last_time)) 1000.0)
        set last_time current_time
        
        # Check for quit
        let key: int = (nl_sdl_poll_keypress)
        if (== key 41) { set running false } else {}  # ESC
        if (== (nl_sdl_poll_event_quit) 1) { set running false } else {}
        
        # Update stars
        set stars (update_stars stars NUM_STARS dt)
        
        # Render
        # Clear screen (black)
        (SDL_SetRenderDrawColor renderer 0 0 0 255)
        (SDL_RenderClear renderer)
        
        # Draw stars
        let mut i: int = 0
        while (< i NUM_STARS) {
            let x: float = (get_star_x stars i)
            let z: float = (get_star_z stars i)
            
            # Size based on distance (closer = bigger)
            let mut size: int = (cast_int (/ 400.0 z))
            if (< size 1) { set size 1 } else {}
            if (> size 4) { set size 4 } else {}
            
            # Brightness based on distance (closer = brighter)
            let brightness_f: float = (/ 400.0 z)
            let mut brightness: int = (cast_int (* brightness_f 255.0))
            if (> brightness 255) { set brightness 255 } else {}
            if (< brightness 50) { set brightness 50 } else {}
            
            # 3D projection X - check if star is visible horizontally
            let screen_x: float = (+ center_x (/ x z))
            let sx: int = (cast_int screen_x)
            
            if (>= sx 0) {
                if (< sx WINDOW_WIDTH) {
                    # Only get Y and project if X is on screen (optimization)
                    let y: float = (get_star_y stars i)
                    let screen_y: float = (+ center_y (/ y z))
                    let sy: int = (cast_int screen_y)
                    if (>= sy 0) {
                        if (< sy WINDOW_HEIGHT) {
                            (SDL_SetRenderDrawColor renderer brightness brightness brightness 255)
                            (nl_sdl_render_fill_rect renderer sx sy size size)
                        } else {}
                    } else {}
                } else {}
            } else {}
            
            set i (+ i 1)
        }
        
        (SDL_RenderPresent renderer)
        
        # Small delay
        (SDL_Delay 16)
    }
    
    # Cleanup
    (SDL_DestroyRenderer renderer)
    (SDL_DestroyWindow window)
    (SDL_Quit)
    
    (println "Hyperdrive disengaged.")
    
    return 0
}
