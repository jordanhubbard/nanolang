# OpenGL Textured Rotating Teapot Demo
# Demonstrates GLFW + GLEW with procedural geometry and dynamic textures
#
# Installation:
#   macOS:  brew install glfw glew
#   Linux:  sudo apt install libglfw3-dev libglew-dev
#
# This demo features:
# - Rotating 3D teapot (simplified geometry)
# - Procedurally generated textures
# - Random texture cycling
# - Smooth rotation animation

import "modules/glfw/glfw.nano"
import "modules/glew/glew.nano"

# Note: All OpenGL functions are now available from GLEW module
# No manual extern declarations needed!

# Window dimensions
let WINDOW_WIDTH: int = 800
let WINDOW_HEIGHT: int = 600

# Texture state
struct TextureState {
    current_texture: int,
    r: float,
    g: float,
    b: float,
    pattern: int
}

# === Geometry: Simplified Teapot ===

fn draw_teapot_body(size: float) -> void {
    # Draw teapot body as SQUASHED sphere (wider than tall) with quads and normals
    let mut lat: int = 0
    let lat_bands: int = 20
    let long_bands: int = 24
    
    while (< lat lat_bands) {
        let lat1: float = (* (* (cast_float lat) 3.14159) (/ 1.0 (cast_float lat_bands)))
        let lat2: float = (* (* (+ (cast_float lat) 1.0) 3.14159) (/ 1.0 (cast_float lat_bands)))
        
        let mut lon: int = 0
        while (< lon long_bands) {
            let lon1: float = (* (* (cast_float lon) 2.0) (/ 3.14159 (cast_float long_bands)))
            let lon2: float = (* (* (+ (cast_float lon) 1.0) 2.0) (/ 3.14159 (cast_float long_bands)))
            
            # Calculate vertices - SQUASH vertically (y *= 0.7) to make it teapot-shaped
            let x1_base: float = (* (sin lat1) (cos lon1))
            let y1_base: float = (* (cos lat1) 0.7)  # Squash!
            let z1_base: float = (* (sin lat1) (sin lon1))
            
            let x2_base: float = (* (sin lat1) (cos lon2))
            let y2_base: float = (* (cos lat1) 0.7)  # Squash!
            let z2_base: float = (* (sin lat1) (sin lon2))
            
            let x3_base: float = (* (sin lat2) (cos lon2))
            let y3_base: float = (* (cos lat2) 0.7)  # Squash!
            let z3_base: float = (* (sin lat2) (sin lon2))
            
            let x4_base: float = (* (sin lat2) (cos lon1))
            let y4_base: float = (* (cos lat2) 0.7)  # Squash!
            let z4_base: float = (* (sin lat2) (sin lon1))
            
            # Apply size
            let x1: float = (* size x1_base)
            let y1: float = (* size y1_base)
            let z1: float = (* size z1_base)
            
            let x2: float = (* size x2_base)
            let y2: float = (* size y2_base)
            let z2: float = (* size z2_base)
            
            let x3: float = (* size x3_base)
            let y3: float = (* size y3_base)
            let z3: float = (* size z3_base)
            
            let x4: float = (* size x4_base)
            let y4: float = (* size y4_base)
            let z4: float = (* size z4_base)
            
            # Calculate normals (normalized vertex positions for sphere)
            let len1: float = (sqrt (+ (+ (* x1 x1) (* y1 y1)) (* z1 z1)))
            let len2: float = (sqrt (+ (+ (* x2 x2) (* y2 y2)) (* z2 z2)))
            let len3: float = (sqrt (+ (+ (* x3 x3) (* y3 y3)) (* z3 z3)))
            let len4: float = (sqrt (+ (+ (* x4 x4) (* y4 y4)) (* z4 z4)))
            
            # Draw quad with normals
            (glBegin GL_QUADS)
            (glNormal3f (/ x1 len1) (/ y1 len1) (/ z1 len1))
            (glVertex3f x1 y1 z1)
            (glNormal3f (/ x2 len2) (/ y2 len2) (/ z2 len2))
            (glVertex3f x2 y2 z2)
            (glNormal3f (/ x3 len3) (/ y3 len3) (/ z3 len3))
            (glVertex3f x3 y3 z3)
            (glNormal3f (/ x4 len4) (/ y4 len4) (/ z4 len4))
            (glVertex3f x4 y4 z4)
            (glEnd)
            
            set lon (+ lon 1)
        }
        set lat (+ lat 1)
    }
}

fn draw_teapot_spout(size: float) -> void {
    # Draw spout as a LARGE cone (actually visible!)
    (glPushMatrix)
    (glTranslatef (* size 0.9) (* size -0.2) 0.0)  # Position at side, slightly down
    (glRotatef 90.0 0.0 1.0 0.0)
    (glRotatef -20.0 1.0 0.0 0.0)  # Tilt upward
    
    let mut i: int = 0
    while (< i 16) {
        let angle1: float = (* (* (cast_float i) 2.0) (/ 3.14159 16.0))
        let angle2: float = (* (* (+ (cast_float i) 1.0) 2.0) (/ 3.14159 16.0))
        
        # Cone from wide base to narrow tip
        (glBegin GL_TRIANGLES)
        (glNormal3f 0.5 0.0 0.0)
        (glVertex3f 0.0 0.0 (* size 0.6))  # Tip
        (glVertex3f (* (* size 0.35) (cos angle1)) (* (* size 0.35) (sin angle1)) 0.0)  # Base
        (glVertex3f (* (* size 0.35) (cos angle2)) (* (* size 0.35) (sin angle2)) 0.0)
        (glEnd)
        
        set i (+ i 1)
    }
    (glPopMatrix)
}

fn draw_teapot_handle(size: float) -> void {
    # Draw handle as a LARGE curved loop
    (glPushMatrix)
    (glTranslatef (* size -0.8) 0.0 0.0)  # Position on back
    
    let mut i: int = 0
    while (< i 16) {
        let angle1: float = (* (* (cast_float i) 3.14159) (/ 1.0 16.0))
        let angle2: float = (* (* (+ (cast_float i) 1.0) 3.14159) (/ 1.0 16.0))
        
        # Arc from top to bottom
        let x1: float = (* (* size 0.5) (cos angle1))
        let y1: float = (* (* size 0.6) (sin angle1))
        let x2: float = (* (* size 0.5) (cos angle2))
        let y2: float = (* (* size 0.6) (sin angle2))
        
        # Draw thick handle with quads
        (glBegin GL_QUADS)
        (glNormal3f -1.0 0.0 0.0)
        (glVertex3f x1 y1 (* size 0.15))
        (glVertex3f x1 y1 (* size -0.15))
        (glVertex3f x2 y2 (* size -0.15))
        (glVertex3f x2 y2 (* size 0.15))
        (glEnd)
        
        set i (+ i 1)
    }
    (glPopMatrix)
}

fn get_texture_color(pattern: int, r: float, g: float, b: float) -> void {
    # Apply different procedural "textures" based on pattern
    if (== pattern 0) {
        # Solid color
        (glColor3f r g b)
    } else {
        if (== pattern 1) {
            # Inverted color
            (glColor3f (- 1.0 r) (- 1.0 g) (- 1.0 b))
        } else {
            if (== pattern 2) {
                # Shifted hue
                (glColor3f g b r)
            } else {
                if (== pattern 3) {
                    # Grayscale
                    let gray: float = (/ (+ (+ r g) b) 3.0)
                    (glColor3f gray gray gray)
                } else {
                    # Complementary
                    (glColor3f (- 1.0 r) g b)
                }
            }
        }
    }
}

fn draw_textured_teapot(rotation: float, manual_rot_x: float, manual_rot_y: float, zoom: float, tex_state: TextureState) -> void {
    # Clear buffers
    (glClear (+ GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
    
    # Reset modelview matrix
    (glLoadIdentity)
    
    # Position camera with zoom
    (glTranslatef 0.0 0.0 (* -5.0 zoom))
    
    # Tilt view to see teapot from the side (not from bottom)
    (glRotatef -45.0 1.0 0.0 0.0)
    
    # Apply manual rotation controls
    (glRotatef manual_rot_y 0.0 1.0 0.0)
    (glRotatef manual_rot_x 1.0 0.0 0.0)
    
    # Rotate teapot (auto rotation)
    (glRotatef rotation 0.0 1.0 0.0)
    (glRotatef (* rotation 0.5) 1.0 0.0 0.0)
    
    # Apply texture color
    (get_texture_color tex_state.pattern tex_state.r tex_state.g tex_state.b)
    
    # Draw teapot parts
    (draw_teapot_body 1.0)
    (draw_teapot_spout 1.0)
    (draw_teapot_handle 1.0)
}

fn random_texture_state(seed: int) -> TextureState {
    # Generate pseudo-random texture parameters
    let r_val: int = (% (* seed 1103515245) 256)
    let g_val: int = (% (* (+ seed 12345) 1664525) 256)
    let b_val: int = (% (* (+ seed 54321) 1013904223) 256)
    
    let r: float = (/ (cast_float r_val) 255.0)
    let g: float = (/ (cast_float g_val) 255.0)
    let b: float = (/ (cast_float b_val) 255.0)
    
    let pattern: int = (% seed 5)
    
    return TextureState {
        current_texture: seed,
        r: r,
        g: g,
        b: b,
        pattern: pattern
    }
}

fn setup_opengl() -> void {
    # Enable depth testing
    (glEnable GL_DEPTH_TEST)
    
    # Enable smooth shading
    (glShadeModel GL_SMOOTH)
    
    # Enable lighting for 3D shading
    (glEnable GL_LIGHTING)
    (glEnable GL_LIGHT0)
    
    # Enable color material tracking so glColor3f sets the material color
    (glEnable GL_COLOR_MATERIAL)
    (glColorMaterial GL_FRONT_AND_BACK GL_AMBIENT_AND_DIFFUSE)
    
    # Set up projection matrix with PERSPECTIVE (this is key for 3D!)
    (glMatrixMode GL_PROJECTION)
    (glLoadIdentity)
    
    # Perspective projection - makes far objects smaller
    # Parameters: left, right, bottom, top, near, far
    (glFrustum -0.5 0.5 -0.375 0.375 0.1 100.0)
    
    # Switch to modelview
    (glMatrixMode GL_MODELVIEW)
}

fn main() -> int {
    # Initialize GLFW
    if (== (glfwInit) 0) {
        (println "❌ Failed to initialize GLFW!")
        return 1
    } else {
        (println "✓ GLFW initialized")
    }
    
    # Create window
    let window: GLFWwindow = (glfwCreateWindow WINDOW_WIDTH WINDOW_HEIGHT "OpenGL Textured Teapot - nanolang" 0 0)
    if (== window 0) {
        (println "❌ Failed to create window!")
        (glfwTerminate)
        return 1
    } else {
        (println "✓ Window created")
    }
    
    # Make OpenGL context current
    (glfwMakeContextCurrent window)
    
    # Initialize GLEW
    let glew_status: int = (glewInit)
    if (!= glew_status GLEW_OK) {
        (println "❌ Failed to initialize GLEW!")
        (glfwTerminate)
        return 1
    } else {
        (println "✓ GLEW initialized - OpenGL ready")
    }
    
    # Setup OpenGL state
    (setup_opengl)
    (glClearColor 0.05 0.05 0.1 1.0)
    
    (println "✓ Teapot demo ready")
    (println "")
    (println "Controls:")
    (println "  SPACE      - Change texture")
    (println "  Arrow Keys - Manual rotation")
    (println "  + / =      - Zoom in")
    (println "  - / _      - Zoom out")
    (println "  ESC        - Exit")
    (println "")
    
    # Animation state
    let mut rotation: float = 0.0
    let mut manual_rot_x: float = 0.0
    let mut manual_rot_y: float = 0.0
    let mut zoom: float = 1.0
    let mut texture_seed: int = 1
    let mut tex_state: TextureState = (random_texture_state texture_seed)
    let mut frame_count: int = 0
    let mut last_space_state: int = 0
    
    # Main render loop
    while (== (glfwWindowShouldClose window) 0) {
        # Update rotation
        set rotation (+ rotation 0.8)
        if (>= rotation 360.0) {
            set rotation (- rotation 360.0)
        } else {}
        
        # Handle arrow keys for manual rotation
        if (== (glfwGetKey window GLFW_KEY_UP) 1) {
            set manual_rot_x (- manual_rot_x 2.0)
        } else {}
        if (== (glfwGetKey window GLFW_KEY_DOWN) 1) {
            set manual_rot_x (+ manual_rot_x 2.0)
        } else {}
        if (== (glfwGetKey window GLFW_KEY_LEFT) 1) {
            set manual_rot_y (- manual_rot_y 2.0)
        } else {}
        if (== (glfwGetKey window GLFW_KEY_RIGHT) 1) {
            set manual_rot_y (+ manual_rot_y 2.0)
        } else {}
        
        # Handle zoom controls (+ / - keys)
        if (or (== (glfwGetKey window GLFW_KEY_EQUAL) 1) (== (glfwGetKey window GLFW_KEY_KP_ADD) 1)) {
            set zoom (* zoom 0.98)
            if (< zoom 0.3) {
                set zoom 0.3
            } else {}
        } else {}
        if (or (== (glfwGetKey window GLFW_KEY_MINUS) 1) (== (glfwGetKey window GLFW_KEY_KP_SUBTRACT) 1)) {
            set zoom (* zoom 1.02)
            if (> zoom 3.0) {
                set zoom 3.0
            } else {}
        } else {}
        
        # Draw scene
        (draw_textured_teapot rotation manual_rot_x manual_rot_y zoom tex_state)
        
        # Swap buffers and poll events
        (glfwSwapBuffers window)
        (glfwPollEvents)
        
        # Check for space key (change texture)
        let space_state: int = (glfwGetKey window GLFW_KEY_SPACE)
        if (and (== space_state 1) (== last_space_state 0)) {
            set texture_seed (+ texture_seed 1)
            set tex_state (random_texture_state texture_seed)
            let pat: int = tex_state.pattern
            let red: float = tex_state.r
            let green: float = tex_state.g
            let blue: float = tex_state.b
            (print "Texture changed: pattern ")
            (print pat)
            (print " (R=")
            (print red)
            (print " G=")
            (print green)
            (print " B=")
            (print blue)
            (println ")")
        } else {}
        set last_space_state space_state
        
        # Check for ESC key
        if (== (glfwGetKey window GLFW_KEY_ESCAPE) 1) {
            (glfwSetWindowShouldClose window 1)
        } else {}
        
        set frame_count (+ frame_count 1)
    }
    
    (println "")
    (print "Rendered ")
    (print frame_count)
    (println " frames")
    
    # Cleanup
    (glfwDestroyWindow window)
    (glfwTerminate)
    (println "✓ Cleanup complete")
    
    return 0
}

shadow random_texture_state {
    let state: TextureState = (random_texture_state 42)
    assert (== state.current_texture 42)
    assert (>= state.r 0.0)
    assert (<= state.r 1.0)
    assert (>= state.pattern 0)
    assert (< state.pattern 5)
}

shadow setup_opengl {
    # OpenGL functions can't be tested in interpreter
    (setup_opengl)
}

shadow draw_textured_teapot {
    let state: TextureState = TextureState { current_texture: 0, r: 1.0, g: 0.5, b: 0.3, pattern: 0 }
    (draw_textured_teapot 45.0 0.0 0.0 1.0 state)
}

shadow main {
    # GLFW requires window system - can't test in interpreter
    # assert (== (main) 0)
}

