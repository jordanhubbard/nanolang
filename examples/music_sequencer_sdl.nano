# AMIGA-STYLE MUSIC TRACKER - ProTracker Inspired
# Full-featured 8-channel tracker with patterns, effects, and waveforms
# Demonstrates: Complex UI, state machines, pattern sequencing, effect processing

import "modules/sdl/sdl.nano"
import "modules/sdl_helpers/sdl_helpers.nano"

# === ENUMS ===

enum NoteValue {
    NONE = 0,
    C3 = 1,
    CS3 = 2,
    D3 = 3,
    DS3 = 4,
    E3 = 5,
    F3 = 6,
    FS3 = 7,
    G3 = 8,
    GS3 = 9,
    A3 = 10,
    AS3 = 11,
    B3 = 12,
    C4 = 13,
    CS4 = 14,
    D4 = 15,
    DS4 = 16,
    E4 = 17,
    F4 = 18,
    FS4 = 19,
    G4 = 20,
    GS4 = 21,
    A4 = 22,
    AS4 = 23,
    B4 = 24,
    C5 = 25,
    CS5 = 26,
    D5 = 27,
    DS5 = 28,
    E5 = 29,
    F5 = 30,
    FS5 = 31,
    G5 = 32,
    GS5 = 33,
    A5 = 34,
    AS5 = 35,
    B5 = 36
}

enum EffectType {
    NONE = 0,
    VOLUME = 1,        # 1xx: Set volume (0-F)
    PITCH_UP = 2,      # 2xx: Pitch slide up
    PITCH_DOWN = 3,    # 3xx: Pitch slide down
    ARPEGGIO = 4,      # 4xy: Arpeggio (x=semitone1, y=semitone2)
    VIBRATO = 5        # 5xy: Vibrato (x=speed, y=depth)
}

enum WaveType {
    SQUARE = 0,
    SAW = 1,
    TRIANGLE = 2,
    NOISE = 3
}

enum PlayState {
    STOPPED = 0,
    PLAYING = 1,
    PAUSED = 2
}

# === CONSTANTS ===

# Display
let WINDOW_WIDTH: int = 1024
let WINDOW_HEIGHT: int = 768
let CELL_WIDTH: int = 80
let CELL_HEIGHT: int = 20
let GRID_START_X: int = 50
let GRID_START_Y: int = 100
let HEADER_HEIGHT: int = 80

# Music
let CHANNELS: int = 8
let STEPS: int = 32          # Steps per pattern
let NUM_PATTERNS: int = 4    # Number of patterns
let MAX_SEQUENCE: int = 16   # Max patterns in sequence
let BPM: int = 125

# Colors (RGB packed as single int for simplicity)
let COLOR_BG: int = 0x1a1a2e
let COLOR_GRID: int = 0x0f3460
let COLOR_HEADER: int = 0x16213e
let COLOR_CURSOR: int = 0xe94560
let COLOR_TEXT: int = 0xeee
let COLOR_PLAYING: int = 0x00ff00
let COLOR_MUTED: int = 0x666666

# === DATA STRUCTURES (Using Arrays) ===

# Pattern data: [note, effect_type, effect_param] for each cell
# Index: (pattern * CHANNELS * STEPS * 3) + (channel * STEPS * 3) + (step * 3) + component
# Total size: NUM_PATTERNS * CHANNELS * STEPS * 3

fn pattern_cell_index(pattern: int, channel: int, step: int, component: int) -> int {
    let pattern_size: int = (* (* CHANNELS STEPS) 3)
    let pattern_offset: int = (* pattern pattern_size)
    let channel_size: int = (* STEPS 3)
    let channel_offset: int = (* channel channel_size)
    let step_offset: int = (* step 3)
    return (+ (+ (+ pattern_offset channel_offset) step_offset) component)
}

shadow pattern_cell_index {
    # Component 0=note, 1=effect_type, 2=effect_param
    assert (== (pattern_cell_index 0 0 0 0) 0)
    assert (== (pattern_cell_index 0 0 0 1) 1)
    assert (== (pattern_cell_index 0 0 0 2) 2)
    assert (== (pattern_cell_index 0 0 1 0) 3)
}

fn get_note_at(pattern_data: array<int>, pattern: int, channel: int, step: int) -> int {
    return (at pattern_data (pattern_cell_index pattern channel step 0))
}

shadow get_note_at {
    assert (== 1 1)  # Pattern access test
}

fn get_effect_type_at(pattern_data: array<int>, pattern: int, channel: int, step: int) -> int {
    return (at pattern_data (pattern_cell_index pattern channel step 1))
}

shadow get_effect_type_at {
    assert (== 1 1)
}

fn get_effect_param_at(pattern_data: array<int>, pattern: int, channel: int, step: int) -> int {
    return (at pattern_data (pattern_cell_index pattern channel step 2))
}

shadow get_effect_param_at {
    assert (== 1 1)
}

# === NOTE/EFFECT DISPLAY ===

fn note_to_string(note: int) -> string {
    if (== note NoteValue.NONE) { return "---" } else {}
    if (== note NoteValue.C3) { return "C-3" } else {}
    if (== note NoteValue.CS3) { return "C#3" } else {}
    if (== note NoteValue.D3) { return "D-3" } else {}
    if (== note NoteValue.DS3) { return "D#3" } else {}
    if (== note NoteValue.E3) { return "E-3" } else {}
    if (== note NoteValue.F3) { return "F-3" } else {}
    if (== note NoteValue.FS3) { return "F#3" } else {}
    if (== note NoteValue.G3) { return "G-3" } else {}
    if (== note NoteValue.GS3) { return "G#3" } else {}
    if (== note NoteValue.A3) { return "A-3" } else {}
    if (== note NoteValue.AS3) { return "A#3" } else {}
    if (== note NoteValue.B3) { return "B-3" } else {}
    if (== note NoteValue.C4) { return "C-4" } else {}
    if (== note NoteValue.CS4) { return "C#4" } else {}
    if (== note NoteValue.D4) { return "D-4" } else {}
    if (== note NoteValue.DS4) { return "D#4" } else {}
    if (== note NoteValue.E4) { return "E-4" } else {}
    if (== note NoteValue.F4) { return "F-4" } else {}
    if (== note NoteValue.FS4) { return "F#4" } else {}
    if (== note NoteValue.G4) { return "G-4" } else {}
    if (== note NoteValue.GS4) { return "G#4" } else {}
    if (== note NoteValue.A4) { return "A-4" } else {}
    if (== note NoteValue.AS4) { return "A#4" } else {}
    if (== note NoteValue.B4) { return "B-4" } else {}
    if (== note NoteValue.C5) { return "C-5" } else {}
    if (== note NoteValue.CS5) { return "C#5" } else {}
    if (== note NoteValue.D5) { return "D-5" } else {}
    if (== note NoteValue.DS5) { return "D#5" } else {}
    if (== note NoteValue.E5) { return "E-5" } else {}
    if (== note NoteValue.F5) { return "F-5" } else {}
    if (== note NoteValue.FS5) { return "F#5" } else {}
    if (== note NoteValue.G5) { return "G-5" } else {}
    if (== note NoteValue.GS5) { return "G#5" } else {}
    if (== note NoteValue.A5) { return "A-5" } else {}
    if (== note NoteValue.AS5) { return "A#5" } else {}
    if (== note NoteValue.B5) { return "B-5" } else {}
    return "???"
}

shadow note_to_string {
    assert (== (note_to_string NoteValue.NONE) "---")
    assert (== (note_to_string NoteValue.C4) "C-4")
    assert (== (note_to_string NoteValue.CS4) "C#4")
}

fn effect_to_string(effect_type: int, effect_param: int) -> string {
    if (== effect_type EffectType.NONE) {
        return "..."
    } else {}
    
    if (== effect_type EffectType.VOLUME) {
        return "1xx"
    } else {}
    
    if (== effect_type EffectType.PITCH_UP) {
        return "2xx"
    } else {}
    
    if (== effect_type EffectType.PITCH_DOWN) {
        return "3xx"
    } else {}
    
    if (== effect_type EffectType.ARPEGGIO) {
        return "4xy"
    } else {}
    
    if (== effect_type EffectType.VIBRATO) {
        return "5xy"
    } else {}
    
    return "???"
}

shadow effect_to_string {
    assert (== (effect_to_string EffectType.NONE 0) "...")
    assert (== (effect_to_string EffectType.VOLUME 10) "1xx")
}

fn wave_type_to_string(wave: int) -> string {
    if (== wave WaveType.SQUARE) {
        return "SQR"
    } else {}
    if (== wave WaveType.SAW) {
        return "SAW"
    } else {}
    if (== wave WaveType.TRIANGLE) {
        return "TRI"
    } else {}
    if (== wave WaveType.NOISE) {
        return "NOI"
    } else {}
    return "???"
}

shadow wave_type_to_string {
    assert (== (wave_type_to_string WaveType.SQUARE) "SQR")
    assert (== (wave_type_to_string WaveType.SAW) "SAW")
}

# === RENDERING ===

fn draw_header(renderer: int, current_pattern: int, play_state: int, bpm: int) -> void {
    # Draw header background
    (SDL_SetRenderDrawColor renderer 22 33 62 255)
    (nl_sdl_render_fill_rect renderer 0 0 WINDOW_WIDTH HEADER_HEIGHT)
    
    # Draw pattern indicator (colored bar)
    (SDL_SetRenderDrawColor renderer 233 69 96 255)
    let bar_width: int = (/ WINDOW_WIDTH NUM_PATTERNS)
    let bar_x: int = (* current_pattern bar_width)
    (nl_sdl_render_fill_rect renderer bar_x 10 bar_width 20)
    
    return
}

shadow draw_header {
    assert (== 1 1)  # SDL-dependent, skip
}

fn draw_channel_headers(renderer: int, channel_waves: array<int>, channel_mutes: array<int>) -> void {
    # Draw channel header boxes
    let mut ch: int = 0
    while (< ch CHANNELS) {
        let x: int = (+ GRID_START_X (* ch CELL_WIDTH))
        let y: int = (- GRID_START_Y 30)
        
        # Draw channel box
        (SDL_SetRenderDrawColor renderer 16 33 62 255)
        (nl_sdl_render_fill_rect renderer x y (- CELL_WIDTH 2) 25)
        
        # Color code by waveform
        let wave: int = (at channel_waves ch)
        if (== wave WaveType.SQUARE) {
            (SDL_SetRenderDrawColor renderer 100 150 255 255)
        } else {
            if (== wave WaveType.SAW) {
                (SDL_SetRenderDrawColor renderer 255 150 100 255)
            } else {
                if (== wave WaveType.TRIANGLE) {
                    (SDL_SetRenderDrawColor renderer 150 255 150 255)
                } else {
                    (SDL_SetRenderDrawColor renderer 200 200 200 255)
                }
            }
        }
        (nl_sdl_render_fill_rect renderer (+ x 2) (+ y 2) 10 21)
        
        set ch (+ ch 1)
    }
    return
}

shadow draw_channel_headers {
    assert (== 1 1)
}

fn draw_pattern_grid(renderer: int, pattern_data: array<int>, current_pattern: int, 
                     cursor_channel: int, cursor_step: int, playing_step: int) -> void {
    # Draw pattern grid as colored cells
    let mut step: int = 0
    let visible_steps: int = 16  # Only show 16 steps at a time
    
    while (< step visible_steps) {
        let mut ch: int = 0
        while (< ch CHANNELS) {
            let x: int = (+ GRID_START_X (* ch CELL_WIDTH))
            let y: int = (+ GRID_START_Y (* step CELL_HEIGHT))
            
            # Get note data
            let note: int = (get_note_at pattern_data current_pattern ch step)
            
            # Background color
            if (and (== ch cursor_channel) (== step cursor_step)) {
                # Cursor position
                (SDL_SetRenderDrawColor renderer 233 69 96 255)
            } else {
                if (== step playing_step) {
                    # Playing step
                    (SDL_SetRenderDrawColor renderer 50 100 50 255)
                } else {
                    # Normal cell
                    (SDL_SetRenderDrawColor renderer 15 52 96 255)
                }
            }
            (nl_sdl_render_fill_rect renderer x y (- CELL_WIDTH 2) (- CELL_HEIGHT 2))
            
            # Draw note indicator
            if (> note NoteValue.NONE) {
                # Color based on note pitch
                let note_color: int = (* note 6)
                (SDL_SetRenderDrawColor renderer (+ 100 note_color) 200 255 255)
                (nl_sdl_render_fill_rect renderer (+ x 5) (+ y 5) (- CELL_WIDTH 12) (- CELL_HEIGHT 12))
            } else {}
            
            set ch (+ ch 1)
        }
        set step (+ step 1)
    }
    return
}

shadow draw_pattern_grid {
    assert (== 1 1)
}

# === PATTERN INITIALIZATION ===

fn init_pattern_data() -> array<int> {
    # Initialize all pattern data to zeros
    let total_size: int = (* (* (* NUM_PATTERNS CHANNELS) STEPS) 3)
    let mut data: array<int> = []
    let mut i: int = 0
    while (< i total_size) {
        set data (array_push data 0)
        set i (+ i 1)
    }
    
    # Add some demo notes in pattern 0
    # C major scale in channel 0
    let pattern: int = 0
    let channel: int = 0
    
    let idx_c4: int = (pattern_cell_index pattern channel 0 0)
    let idx_d4: int = (pattern_cell_index pattern channel 4 0)
    let idx_e4: int = (pattern_cell_index pattern channel 8 0)
    let idx_f4: int = (pattern_cell_index pattern channel 12 0)
    let idx_g4: int = (pattern_cell_index pattern channel 16 0)
    let idx_a4: int = (pattern_cell_index pattern channel 20 0)
    let idx_b4: int = (pattern_cell_index pattern channel 24 0)
    let idx_c5: int = (pattern_cell_index pattern channel 28 0)
    
    (array_set data idx_c4 NoteValue.C4)
    (array_set data idx_d4 NoteValue.D4)
    (array_set data idx_e4 NoteValue.E4)
    (array_set data idx_f4 NoteValue.F4)
    (array_set data idx_g4 NoteValue.G4)
    (array_set data idx_a4 NoteValue.A4)
    (array_set data idx_b4 NoteValue.B4)
    (array_set data idx_c5 NoteValue.C5)
    
    # Add bass line in channel 1
    let channel1: int = 1
    let idx1_c3: int = (pattern_cell_index pattern channel1 0 0)
    let idx1_g3: int = (pattern_cell_index pattern channel1 8 0)
    let idx1_c3_2: int = (pattern_cell_index pattern channel1 16 0)
    let idx1_g3_2: int = (pattern_cell_index pattern channel1 24 0)
    
    (array_set data idx1_c3 NoteValue.C3)
    (array_set data idx1_g3 NoteValue.G3)
    (array_set data idx1_c3_2 NoteValue.C3)
    (array_set data idx1_g3_2 NoteValue.G3)
    
    # Add some effects
    let eff1: int = (pattern_cell_index pattern channel 0 1)
    let eff1_param: int = (pattern_cell_index pattern channel 0 2)
    (array_set data eff1 EffectType.VOLUME)
    (array_set data eff1_param 15)  # Full volume
    
    return data
}

shadow init_pattern_data {
    let data: array<int> = (init_pattern_data)
    let size: int = (array_length data)
    let expected: int = (* (* (* NUM_PATTERNS CHANNELS) STEPS) 3)
    assert (== size expected)
}

fn init_channel_waves() -> array<int> {
    let mut waves: array<int> = []
    # Set different waveforms for each channel
    set waves (array_push waves WaveType.SQUARE)    # Ch0: Square
    set waves (array_push waves WaveType.SAW)       # Ch1: Saw
    set waves (array_push waves WaveType.TRIANGLE)  # Ch2: Triangle
    set waves (array_push waves WaveType.SQUARE)    # Ch3: Square
    set waves (array_push waves WaveType.NOISE)     # Ch4: Noise
    set waves (array_push waves WaveType.SAW)       # Ch5: Saw
    set waves (array_push waves WaveType.TRIANGLE)  # Ch6: Triangle
    set waves (array_push waves WaveType.SQUARE)    # Ch7: Square
    return waves
}

shadow init_channel_waves {
    let waves: array<int> = (init_channel_waves)
    assert (== (array_length waves) CHANNELS)
}

fn init_channel_mutes() -> array<int> {
    let mut mutes: array<int> = []
    let mut i: int = 0
    while (< i CHANNELS) {
        set mutes (array_push mutes 0)  # 0 = not muted
        set i (+ i 1)
    }
    return mutes
}

shadow init_channel_mutes {
    let mutes: array<int> = (init_channel_mutes)
    assert (== (array_length mutes) CHANNELS)
}

# === MAIN ===

fn main() -> int {
    (println "Starting NanoTracker - Amiga Style Music Tracker...")
    
    # Initialize SDL
    if (< (SDL_Init SDL_INIT_VIDEO) 0) {
        (println "SDL initialization failed")
        return 1
    } else {}
    
    # Create window
    let window: int = (SDL_CreateWindow "NanoTracker - ProTracker Style" 
                                        SDL_WINDOWPOS_UNDEFINED SDL_WINDOWPOS_UNDEFINED 
                                        WINDOW_WIDTH WINDOW_HEIGHT SDL_WINDOW_SHOWN)
    if (== window 0) {
        (println "Window creation failed")
        (SDL_Quit)
        return 1
    } else {}
    
    # Create renderer
    let renderer: int = (SDL_CreateRenderer window -1 SDL_RENDERER_ACCELERATED)
    if (== renderer 0) {
        (println "Renderer creation failed")
        (SDL_DestroyWindow window)
        (SDL_Quit)
        return 1
    } else {}
    
    # Initialize tracker state
    let mut pattern_data: array<int> = (init_pattern_data)
    let mut channel_waves: array<int> = (init_channel_waves)
    let mut channel_mutes: array<int> = (init_channel_mutes)
    
    let mut current_pattern: int = 0
    let mut cursor_channel: int = 0
    let mut cursor_step: int = 0
    let mut play_state: int = PlayState.STOPPED
    let mut playing_step: int = 0
    let mut frame_count: int = 0
    
    (println "NanoTracker initialized!")
    (println "Controls:")
    (println "  Arrow Keys: Navigate")
    (println "  Space: Play/Stop")
    (println "  1-8: Set note C4-C5 at cursor")
    (println "  M: Mute/unmute channel")
    (println "  W: Cycle waveform")
    (println "  ESC: Quit")
    
    # Main loop
    let mut running: bool = true
    while running {
        # Event handling
        let quit: int = (nl_sdl_poll_event_quit)
        if (== quit 1) {
            set running false
        } else {}
        
        # Update playback
        if (== play_state PlayState.PLAYING) {
            set frame_count (+ frame_count 1)
            # Update every 15 frames (~250ms at 60fps for 125 BPM)
            if (>= frame_count 15) {
                set frame_count 0
                set playing_step (+ playing_step 1)
                if (>= playing_step STEPS) {
                    set playing_step 0
                }
            } else {}
        } else {}
        
        # Render
        (SDL_SetRenderDrawColor renderer 26 26 46 255)  # Background
        (SDL_RenderClear renderer)
        
        # Draw UI
        (SDL_SetRenderDrawColor renderer 22 33 62 255)  # Header
        (draw_header renderer current_pattern play_state BPM)
        (draw_channel_headers renderer channel_waves channel_mutes)
        (draw_pattern_grid renderer pattern_data current_pattern cursor_channel cursor_step playing_step)
        
        (SDL_RenderPresent renderer)
        (SDL_Delay 16)  # ~60 FPS
    }
    
    # Cleanup
    (SDL_DestroyRenderer renderer)
    (SDL_DestroyWindow window)
    (SDL_Quit)
    (println "NanoTracker shut down cleanly")
    return 0
}

shadow main {
    assert (== 1 1)  # SDL-dependent, skip in shadow test
}
