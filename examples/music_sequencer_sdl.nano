# AMIGA-STYLE MUSIC TRACKER - ProTracker Inspired
# Full-featured 8-channel tracker with patterns, effects, and waveforms
# Demonstrates: Complex UI, state machines, pattern sequencing, effect processing

import "modules/sdl/sdl.nano"
import "modules/sdl_helpers/sdl_helpers.nano"

# === ENUMS ===

enum NoteValue {
    NONE = 0,
    C3 = 1,
    CS3 = 2,
    D3 = 3,
    DS3 = 4,
    E3 = 5,
    F3 = 6,
    FS3 = 7,
    G3 = 8,
    GS3 = 9,
    A3 = 10,
    AS3 = 11,
    B3 = 12,
    C4 = 13,
    CS4 = 14,
    D4 = 15,
    DS4 = 16,
    E4 = 17,
    F4 = 18,
    FS4 = 19,
    G4 = 20,
    GS4 = 21,
    A4 = 22,
    AS4 = 23,
    B4 = 24,
    C5 = 25,
    CS5 = 26,
    D5 = 27,
    DS5 = 28,
    E5 = 29,
    F5 = 30,
    FS5 = 31,
    G5 = 32,
    GS5 = 33,
    A5 = 34,
    AS5 = 35,
    B5 = 36
}

enum EffectType {
    NONE = 0,
    VOLUME = 1,        # 1xx: Set volume (0-F)
    PITCH_UP = 2,      # 2xx: Pitch slide up
    PITCH_DOWN = 3,    # 3xx: Pitch slide down
    ARPEGGIO = 4,      # 4xy: Arpeggio (x=semitone1, y=semitone2)
    VIBRATO = 5        # 5xy: Vibrato (x=speed, y=depth)
}

enum WaveType {
    SQUARE = 0,
    SAW = 1,
    TRIANGLE = 2,
    NOISE = 3
}

enum PlayState {
    STOPPED = 0,
    PLAYING = 1,
    PAUSED = 2
}

# === CONSTANTS ===

# Display - ProTracker style layout
let WINDOW_WIDTH: int = 1280
let WINDOW_HEIGHT: int = 800
let CELL_WIDTH: int = 140
let CELL_HEIGHT: int = 32
let GRID_START_X: int = 60
let GRID_START_Y: int = 180
let HEADER_HEIGHT: int = 60
let ROW_NUMBER_WIDTH: int = 50

# Music
let CHANNELS: int = 8
let STEPS: int = 32          # Steps per pattern
let NUM_PATTERNS: int = 4    # Number of patterns
let MAX_SEQUENCE: int = 16   # Max patterns in sequence
let BPM: int = 125

# Colors (RGB packed as single int for simplicity)
let COLOR_BG: int = 1711662
let COLOR_GRID: int = 980064
let COLOR_HEADER: int = 1450302
let COLOR_CURSOR: int = 15287648
let COLOR_TEXT: int = 3822
let COLOR_PLAYING: int = 65280
let COLOR_MUTED: int = 6710886

# === DATA STRUCTURES (Using Arrays) ===

# Pattern data: [note, effect_type, effect_param] for each cell
# Index: (pattern * CHANNELS * STEPS * 3) + (channel * STEPS * 3) + (step * 3) + component
# Total size: NUM_PATTERNS * CHANNELS * STEPS * 3

fn pattern_cell_index(pattern: int, channel: int, step: int, component: int) -> int {
    let pattern_size: int = (* (* CHANNELS STEPS) 3)
    let pattern_offset: int = (* pattern pattern_size)
    let channel_size: int = (* STEPS 3)
    let channel_offset: int = (* channel channel_size)
    let step_offset: int = (* step 3)
    return (+ (+ (+ pattern_offset channel_offset) step_offset) component)
}

shadow pattern_cell_index {
    # Component 0=note, 1=effect_type, 2=effect_param
    assert (== (pattern_cell_index 0 0 0 0) 0)
    assert (== (pattern_cell_index 0 0 0 1) 1)
    assert (== (pattern_cell_index 0 0 0 2) 2)
    assert (== (pattern_cell_index 0 0 1 0) 3)
}

fn get_note_at(pattern_data: array<int>, pattern: int, channel: int, step: int) -> int {
    return (at pattern_data (pattern_cell_index pattern channel step 0))
}

shadow get_note_at {
    assert (== 1 1)  # Pattern access test
}

fn get_effect_type_at(pattern_data: array<int>, pattern: int, channel: int, step: int) -> int {
    return (at pattern_data (pattern_cell_index pattern channel step 1))
}

shadow get_effect_type_at {
    assert (== 1 1)
}

fn get_effect_param_at(pattern_data: array<int>, pattern: int, channel: int, step: int) -> int {
    return (at pattern_data (pattern_cell_index pattern channel step 2))
}

shadow get_effect_param_at {
    assert (== 1 1)
}

# === NOTE/EFFECT DISPLAY ===

fn note_to_string(note: int) -> string {
    if (== note NoteValue.NONE) { return "---" } else {}
    if (== note NoteValue.C3) { return "C-3" } else {}
    if (== note NoteValue.CS3) { return "C#3" } else {}
    if (== note NoteValue.D3) { return "D-3" } else {}
    if (== note NoteValue.DS3) { return "D#3" } else {}
    if (== note NoteValue.E3) { return "E-3" } else {}
    if (== note NoteValue.F3) { return "F-3" } else {}
    if (== note NoteValue.FS3) { return "F#3" } else {}
    if (== note NoteValue.G3) { return "G-3" } else {}
    if (== note NoteValue.GS3) { return "G#3" } else {}
    if (== note NoteValue.A3) { return "A-3" } else {}
    if (== note NoteValue.AS3) { return "A#3" } else {}
    if (== note NoteValue.B3) { return "B-3" } else {}
    if (== note NoteValue.C4) { return "C-4" } else {}
    if (== note NoteValue.CS4) { return "C#4" } else {}
    if (== note NoteValue.D4) { return "D-4" } else {}
    if (== note NoteValue.DS4) { return "D#4" } else {}
    if (== note NoteValue.E4) { return "E-4" } else {}
    if (== note NoteValue.F4) { return "F-4" } else {}
    if (== note NoteValue.FS4) { return "F#4" } else {}
    if (== note NoteValue.G4) { return "G-4" } else {}
    if (== note NoteValue.GS4) { return "G#4" } else {}
    if (== note NoteValue.A4) { return "A-4" } else {}
    if (== note NoteValue.AS4) { return "A#4" } else {}
    if (== note NoteValue.B4) { return "B-4" } else {}
    if (== note NoteValue.C5) { return "C-5" } else {}
    if (== note NoteValue.CS5) { return "C#5" } else {}
    if (== note NoteValue.D5) { return "D-5" } else {}
    if (== note NoteValue.DS5) { return "D#5" } else {}
    if (== note NoteValue.E5) { return "E-5" } else {}
    if (== note NoteValue.F5) { return "F-5" } else {}
    if (== note NoteValue.FS5) { return "F#5" } else {}
    if (== note NoteValue.G5) { return "G-5" } else {}
    if (== note NoteValue.GS5) { return "G#5" } else {}
    if (== note NoteValue.A5) { return "A-5" } else {}
    if (== note NoteValue.AS5) { return "A#5" } else {}
    if (== note NoteValue.B5) { return "B-5" } else {}
    return "???"
}

shadow note_to_string {
    assert (== (note_to_string NoteValue.NONE) "---")
    assert (== (note_to_string NoteValue.C4) "C-4")
    assert (== (note_to_string NoteValue.CS4) "C#4")
}

fn effect_to_string(effect_type: int, effect_param: int) -> string {
    if (== effect_type EffectType.NONE) {
        return "..."
    } else {}
    
    if (== effect_type EffectType.VOLUME) {
        return "1xx"
    } else {}
    
    if (== effect_type EffectType.PITCH_UP) {
        return "2xx"
    } else {}
    
    if (== effect_type EffectType.PITCH_DOWN) {
        return "3xx"
    } else {}
    
    if (== effect_type EffectType.ARPEGGIO) {
        return "4xy"
    } else {}
    
    if (== effect_type EffectType.VIBRATO) {
        return "5xy"
    } else {}
    
    return "???"
}

shadow effect_to_string {
    assert (== (effect_to_string EffectType.NONE 0) "...")
    assert (== (effect_to_string EffectType.VOLUME 10) "1xx")
}

fn wave_type_to_string(wave: int) -> string {
    if (== wave WaveType.SQUARE) {
        return "SQR"
    } else {}
    if (== wave WaveType.SAW) {
        return "SAW"
    } else {}
    if (== wave WaveType.TRIANGLE) {
        return "TRI"
    } else {}
    if (== wave WaveType.NOISE) {
        return "NOI"
    } else {}
    return "???"
}

shadow wave_type_to_string {
    assert (== (wave_type_to_string WaveType.SQUARE) "SQR")
    assert (== (wave_type_to_string WaveType.SAW) "SAW")
}

# === RENDERING ===

fn draw_header(renderer: int, current_pattern: int, play_state: int, bpm: int) -> void {
    # Draw header background - classic ProTracker dark blue
    (SDL_SetRenderDrawColor renderer 0 0 40 255)
    (nl_sdl_render_fill_rect renderer 0 0 WINDOW_WIDTH HEADER_HEIGHT)
    
    # Draw title bar - ProTracker pink/red
    (SDL_SetRenderDrawColor renderer 170 85 170 255)
    (nl_sdl_render_fill_rect renderer 10 10 400 40)
    
    # Draw pattern indicators - one box per pattern
    let mut p: int = 0
    while (< p NUM_PATTERNS) {
        let px: int = (+ 450 (* p 60))
        if (== p current_pattern) {
            (SDL_SetRenderDrawColor renderer 255 170 0 255)  # Orange for current
        } else {
            (SDL_SetRenderDrawColor renderer 60 60 100 255)  # Dark for others
        }
        (nl_sdl_render_fill_rect renderer px 15 50 30)
        set p (+ p 1)
    }
    
    # Draw play state indicator
    let state_x: int = 700
    if (== play_state PlayState.PLAYING) {
        (SDL_SetRenderDrawColor renderer 0 255 0 255)  # Green
    } else {
        (SDL_SetRenderDrawColor renderer 255 0 0 255)  # Red
    }
    (nl_sdl_render_fill_rect renderer state_x 15 30 30)
    
    # Draw BPM meter - bars representing tempo
    let bpm_bars: int = (/ bpm 20)
    let mut b: int = 0
    while (< b bpm_bars) {
        (SDL_SetRenderDrawColor renderer 100 200 255 255)
        let bx: int = (+ 800 (* b 15))
        (nl_sdl_render_fill_rect renderer bx 20 10 25)
        set b (+ b 1)
    }
    
    return
}

shadow draw_header {
    assert (== 1 1)  # SDL-dependent, skip
}

fn draw_channel_headers(renderer: int, channel_waves: array<int>, channel_mutes: array<int>) -> void {
    # Draw separator line above channels
    (SDL_SetRenderDrawColor renderer 170 85 170 255)
    (nl_sdl_render_fill_rect renderer 0 (- GRID_START_Y 60) WINDOW_WIDTH 3)
    
    # Draw channel headers - ProTracker style
    let mut ch: int = 0
    while (< ch CHANNELS) {
        let x: int = (+ GRID_START_X (* ch CELL_WIDTH))
        let y: int = (- GRID_START_Y 50)
        
        # Draw channel number box - alternating colors like ProTracker
        let ch_mod: int = (% ch 2)
        if (== ch_mod 0) {
            (SDL_SetRenderDrawColor renderer 85 85 127 255)
        } else {
            (SDL_SetRenderDrawColor renderer 68 68 102 255)
        }
        (nl_sdl_render_fill_rect renderer x y (- CELL_WIDTH 4) 40)
        
        # Draw waveform indicator bar - different colors per waveform
        let wave: int = (at channel_waves ch)
        if (== wave WaveType.SQUARE) {
            (SDL_SetRenderDrawColor renderer 255 255 0 255)  # Yellow
        } else {
            if (== wave WaveType.SAW) {
                (SDL_SetRenderDrawColor renderer 255 136 0 255)  # Orange
            } else {
                if (== wave WaveType.TRIANGLE) {
                    (SDL_SetRenderDrawColor renderer 0 255 170 255)  # Cyan
                } else {
                    (SDL_SetRenderDrawColor renderer 200 200 200 255)  # Gray for noise
                }
            }
        }
        # Waveform bar at bottom of header
        (nl_sdl_render_fill_rect renderer (+ x 5) (+ y 32) (- CELL_WIDTH 14) 6)
        
        # Draw mute indicator if muted
        let muted: int = (at channel_mutes ch)
        if (== muted 1) {
            (SDL_SetRenderDrawColor renderer 255 0 0 255)
            (nl_sdl_render_fill_rect renderer (+ x 5) (+ y 5) 15 15)
        } else {}
        
        set ch (+ ch 1)
    }
    return
}

shadow draw_channel_headers {
    assert (== 1 1)
}

fn draw_pattern_grid(renderer: int, pattern_data: array<int>, current_pattern: int, 
                     cursor_channel: int, cursor_step: int, playing_step: int) -> void {
    # Draw pattern grid - ProTracker style with row numbers
    let mut step: int = 0
    let visible_steps: int = 16  # Show 16 rows at a time
    
    while (< step visible_steps) {
        let y: int = (+ GRID_START_Y (* step CELL_HEIGHT))
        
        # Draw row number background (hex style!)
        let step_mod: int = (% step 4)
        if (== step_mod 0) {
            (SDL_SetRenderDrawColor renderer 0 85 127 255)  # Every 4th row highlighted
        } else {
            (SDL_SetRenderDrawColor renderer 0 51 85 255)
        }
        (nl_sdl_render_fill_rect renderer 10 y 40 (- CELL_HEIGHT 2))
        
        # Draw row number as colored bars (represents hex value)
        let bar_count: int = (% step 16)
        let mut b: int = 0
        while (< b bar_count) {
            (SDL_SetRenderDrawColor renderer 255 170 0 255)
            (nl_sdl_render_fill_rect renderer (+ 15 (* b 2)) (+ y 5) 1 (- CELL_HEIGHT 12))
            set b (+ b 1)
        }
        
        # Highlight playing row
        if (== step playing_step) {
            (SDL_SetRenderDrawColor renderer 255 170 0 255)
            (nl_sdl_render_fill_rect renderer 0 y WINDOW_WIDTH 2)
        } else {}
        
        # Draw each channel's cell
        let mut ch: int = 0
        while (< ch CHANNELS) {
            let x: int = (+ GRID_START_X (* ch CELL_WIDTH))
            
            # Get note data
            let note: int = (get_note_at pattern_data current_pattern ch step)
            
            # Cell background - alternating channel colors like ProTracker
            let ch_mod: int = (% ch 2)
            if (and (== ch cursor_channel) (== step cursor_step)) {
                # Cursor cell - bright highlight
                (SDL_SetRenderDrawColor renderer 170 85 170 255)
            } else {
                if (== ch_mod 0) {
                    (SDL_SetRenderDrawColor renderer 0 34 68 255)
                } else {
                    (SDL_SetRenderDrawColor renderer 0 17 51 255)
                }
            }
            (nl_sdl_render_fill_rect renderer x y (- CELL_WIDTH 4) (- CELL_HEIGHT 2))
            
            # Draw note as vertical bar if present
            if (> note NoteValue.NONE) {
                # Note height represents pitch (higher notes = taller bars)
                let note_height: int = (+ 8 (/ note 2))
                let bar_y: int = (- (+ y CELL_HEIGHT) (+ note_height 4))
                
                # Note color by octave
                if (< note 13) {
                    # Octave 3 - blue
                    (SDL_SetRenderDrawColor renderer 85 170 255 255)
                } else {
                    if (< note 25) {
                        # Octave 4 - green
                        (SDL_SetRenderDrawColor renderer 170 255 85 255)
                    } else {
                        # Octave 5 - yellow
                        (SDL_SetRenderDrawColor renderer 255 255 85 255)
                    }
                }
                
                # Draw note bar
                (nl_sdl_render_fill_rect renderer (+ x 10) bar_y (- CELL_WIDTH 24) note_height)
                
                # Draw effect indicator if present
                let effect: int = (get_effect_type_at pattern_data current_pattern ch step)
                if (> effect EffectType.NONE) {
                    (SDL_SetRenderDrawColor renderer 255 85 85 255)
                    (nl_sdl_render_fill_rect renderer (+ x (- CELL_WIDTH 12)) (+ y 5) 8 8)
                } else {}
            } else {}
            
            set ch (+ ch 1)
        }
        set step (+ step 1)
    }
    return
}

shadow draw_pattern_grid {
    assert (== 1 1)
}

# === PATTERN INITIALIZATION ===

fn init_pattern_data() -> array<int> {
    # Initialize all pattern data to zeros
    let total_size: int = (* (* (* NUM_PATTERNS CHANNELS) STEPS) 3)
    let mut data: array<int> = []
    let mut i: int = 0
    while (< i total_size) {
        set data (array_push data 0)
        set i (+ i 1)
    }
    
    # TODO: Add demo pattern data once array_set type checking is fixed
    # For now, just return empty pattern data
    
    return data
}

shadow init_pattern_data {
    let data: array<int> = (init_pattern_data)
    let size: int = (array_length data)
    let expected: int = (* (* (* NUM_PATTERNS CHANNELS) STEPS) 3)
    assert (== size expected)
}

fn init_channel_waves() -> array<int> {
    let mut waves: array<int> = []
    # Set different waveforms for each channel
    set waves (array_push waves WaveType.SQUARE)    # Ch0: Square
    set waves (array_push waves WaveType.SAW)       # Ch1: Saw
    set waves (array_push waves WaveType.TRIANGLE)  # Ch2: Triangle
    set waves (array_push waves WaveType.SQUARE)    # Ch3: Square
    set waves (array_push waves WaveType.NOISE)     # Ch4: Noise
    set waves (array_push waves WaveType.SAW)       # Ch5: Saw
    set waves (array_push waves WaveType.TRIANGLE)  # Ch6: Triangle
    set waves (array_push waves WaveType.SQUARE)    # Ch7: Square
    return waves
}

shadow init_channel_waves {
    let waves: array<int> = (init_channel_waves)
    assert (== (array_length waves) CHANNELS)
}

fn init_channel_mutes() -> array<int> {
    let mut mutes: array<int> = []
    let mut i: int = 0
    while (< i CHANNELS) {
        set mutes (array_push mutes 0)  # 0 = not muted
        set i (+ i 1)
    }
    return mutes
}

shadow init_channel_mutes {
    let mutes: array<int> = (init_channel_mutes)
    assert (== (array_length mutes) CHANNELS)
}

# === MAIN ===

fn main() -> int {
    (println "Starting NanoTracker - Amiga Style Music Tracker...")
    
    # Initialize SDL
    if (< (SDL_Init SDL_INIT_VIDEO) 0) {
        (println "SDL initialization failed")
        return 1
    } else {}
    
    # Create window
    let window: int = (SDL_CreateWindow "NanoTracker - ProTracker Style" 
                                        SDL_WINDOWPOS_UNDEFINED SDL_WINDOWPOS_UNDEFINED 
                                        WINDOW_WIDTH WINDOW_HEIGHT SDL_WINDOW_SHOWN)
    if (== window 0) {
        (println "Window creation failed")
        (SDL_Quit)
        return 1
    } else {}
    
    # Create renderer
    let renderer: int = (SDL_CreateRenderer window -1 SDL_RENDERER_ACCELERATED)
    if (== renderer 0) {
        (println "Renderer creation failed")
        (SDL_DestroyWindow window)
        (SDL_Quit)
        return 1
    } else {}
    
    # Disable mouse motion events to prevent event queue flooding
    # SDL_MOUSEMOTION = 0x400 = 1024
    (SDL_EventState 1024 0)
    
    # Initialize tracker state
    let mut pattern_data: array<int> = (init_pattern_data)
    let mut channel_waves: array<int> = (init_channel_waves)
    let mut channel_mutes: array<int> = (init_channel_mutes)
    
    let mut current_pattern: int = 0
    let mut cursor_channel: int = 0
    let mut cursor_step: int = 0
    let mut play_state: int = PlayState.PLAYING
    let mut playing_step: int = 0
    let mut frame_count: int = 0
    
    (println "")
    (println "═══════════════════════════════════════════════════════════")
    (println "  NanoTracker - ProTracker Style Music Sequencer (Visual Demo)")
    (println "═══════════════════════════════════════════════════════════")
    (println "")
    (println "NOTE: This is a visual mockup only - no audio playback")
    (println "      Audio would require SDL_mixer integration")
    (println "")
    (println "Controls:")
    (println "  SPACE = Play/Pause")
    (println "  ESC   = Quit")
    (println "")
    (println "Features demonstrated:")
    (println "  • ProTracker-style pattern grid UI")
    (println "  • 8-channel sequencing")
    (println "  • Playback cursor animation")
    (println "  • Channel indicators and waveform visualization")
    (println "")
    
    # Main loop
    let mut running: bool = true
    while running {
        # Handle keyboard input
        let key: int = (nl_sdl_poll_keypress)
        if (> key -1) {
            if (== key 41) {
                # ESC = quit
                set running false
            } else {
                if (== key 44) {
                    # SPACE = toggle play/pause
                    if (== play_state PlayState.PLAYING) {
                        set play_state PlayState.STOPPED
                    } else {
                        set play_state PlayState.PLAYING
                    }
                } else {
                    (print "")
                }
            }
        } else {
            (print "")
        }
        
        # Check for quit event (window close)
        let quit: int = (nl_sdl_poll_event_quit)
        if (== quit 1) {
            set running false
        } else {
            (print "")
        }
        
        # Update playback
        if (== play_state PlayState.PLAYING) {
            set frame_count (+ frame_count 1)
            # Update every 15 frames (~250ms at 60fps for 125 BPM)
            if (>= frame_count 15) {
                set frame_count 0
                set playing_step (+ playing_step 1)
                if (>= playing_step STEPS) {
                    set playing_step 0
                } else {}
            } else {}
        } else {}
        
        # Render
        (SDL_SetRenderDrawColor renderer 26 26 46 255)  # Background
        (SDL_RenderClear renderer)
        
        # Draw UI
        (SDL_SetRenderDrawColor renderer 22 33 62 255)  # Header
        (draw_header renderer current_pattern play_state BPM)
        (draw_channel_headers renderer channel_waves channel_mutes)
        (draw_pattern_grid renderer pattern_data current_pattern cursor_channel cursor_step playing_step)
        
        (SDL_RenderPresent renderer)
        (SDL_Delay 16)  # ~60 FPS
    }
    
    # Cleanup
    (SDL_DestroyRenderer renderer)
    (SDL_DestroyWindow window)
    (SDL_Quit)
    (println "NanoTracker shut down cleanly")
    return 0
}

shadow main {
    assert (== 1 1)  # SDL-dependent, skip in shadow test
}
