# Generic Queue Implementation  
# Demonstrates generic programming with FIFO data structure

struct Queue<T> {
    data: array<T>,
    front: int,
    rear: int,
    size: int,
    capacity: int
}

# Create an empty queue with given capacity
fn make_queue<T>(capacity: int) -> Queue<T> {
    return Queue<T> {
        data: [],  # Empty for interpreter
        front: 0,
        rear: 0,
        size: 0,
        capacity: capacity
    }
}

shadow make_queue {
    let q: Queue<int> = (make_queue<int> 10)
    assert (== q.size 0)
    assert (== q.capacity 10)
    assert (== q.front 0)
    assert (== q.rear 0)
}

# Check if queue is empty
fn queue_is_empty<T>(queue: Queue<T>) -> bool {
    return (== queue.size 0)
}

shadow queue_is_empty {
    let q: Queue<int> = (make_queue<int> 5)
    assert (== (queue_is_empty<int> q) true)
}

# Check if queue is full
fn queue_is_full<T>(queue: Queue<T>) -> bool {
    return (== queue.size queue.capacity)
}

shadow queue_is_full {
    let q: Queue<int> = (make_queue<int> 5)
    assert (== (queue_is_full<int> q) false)
}

# Get queue size
fn queue_size<T>(queue: Queue<T>) -> int {
    return queue.size
}

shadow queue_size {
    let q: Queue<int> = (make_queue<int> 5)
    assert (== (queue_size<int> q) 0)
}

# === INTEGER QUEUE EXAMPLE ===

fn demo_int_queue() -> int {
    (println "Integer Queue Demo:")
    let q: Queue<int> = (make_queue<int> 10)
    (print "  Created queue with capacity ")
    (println (int_to_string q.capacity))
    (print "  Queue size: ")
    (println (int_to_string (queue_size<int> q)))
    (print "  Is empty? ")
    if (queue_is_empty<int> q) {
        (println "Yes")
    } else {
        (println "No")
    }
    (print "  Is full? ")
    if (queue_is_full<int> q) {
        (println "Yes")
    } else {
        (println "No")
    }
    return 0
}

shadow demo_int_queue {
    assert (== (demo_int_queue) 0)
}

# === FLOAT QUEUE EXAMPLE ===

fn demo_float_queue() -> int {
    (println "")
    (println "Float Queue Demo:")
    let q: Queue<float> = (make_queue<float> 5)
    (print "  Created queue with capacity ")
    (println (int_to_string q.capacity))
    (print "  Queue size: ")
    (println (int_to_string (queue_size<float> q)))
    return 0
}

shadow demo_float_queue {
    assert (== (demo_float_queue) 0)
}

# === STRING QUEUE EXAMPLE ===

fn demo_string_queue() -> int {
    (println "")
    (println "String Queue Demo:")
    let q: Queue<string> = (make_queue<string> 20)
    (print "  Created queue with capacity ")
    (println (int_to_string q.capacity))
    (print "  Queue size: ")
    (println (int_to_string (queue_size<string> q)))
    return 0
}

shadow demo_string_queue {
    assert (== (demo_string_queue) 0)
}

# === MAIN ===

fn main() -> int {
    (println "=== Generic Queue Demo ===")
    (println "")
    
    let _int: int = (demo_int_queue)
    let _float: int = (demo_float_queue)
    let _string: int = (demo_string_queue)
    
    (println "")
    (println "Generic queue types work! âœ“")
    (println "")
    (println "Note: Full queue operations (enqueue/dequeue) require")
    (println "array_push support which is interpreter-only.")
    (println "For compiled code, use circular buffer with pre-allocated arrays.")
    
    return 0
}

shadow main {
    assert true
}
