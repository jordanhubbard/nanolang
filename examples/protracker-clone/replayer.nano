# ProTracker Replayer Engine
# Core playback and effect processing
# Based on pt2_replayer.c from pt2-clone by Olav SÃ¸rensen
#
# NOTE: Uses extern C functions for state storage because nanolang
# doesn't allow mutable variables at top level

import "examples/protracker-clone/types.nano"
import "examples/protracker-clone/pattern.nano"
import "modules/pt2_state/pt2_state.nano"

# === INITIALIZATION ===

fn init_replayer() -> int {
    return (pt2_init_state)
}

shadow init_replayer {
    let result: int = (init_replayer)
    assert (== result 0)
}

# === PLAYBACK CONTROL ===

fn start_playback() -> int {
    return (pt2_start_playback)
}

fn stop_playback() -> int {
    return (pt2_stop_playback)
}

fn is_playing() -> int {
    return (pt2_is_playing)
}

shadow is_playing {
    (init_replayer)
    (start_playback)
    assert (== (is_playing) 1)
    (stop_playback)
    assert (== (is_playing) 0)
}

# === PATTERN NAVIGATION ===

fn set_pattern(pattern: int) -> int {
    let mut result: int = pattern
    
    if (< pattern 0) {
        set result 0
    } else {
        if (>= pattern PT_PATTERNS) {
            set result (- PT_PATTERNS 1)
        } else {}
    }
    
    (pt2_set_current_pattern result)
    (pt2_set_current_row 0)
    return result
}

shadow set_pattern {
    (init_replayer)
    let result: int = (set_pattern 0)
    assert (== result 0)
}

fn next_row() -> int {
    let mut row: int = (pt2_get_current_row)
    set row (+ row 1)
    
    # Check if we reached end of pattern
    if (>= row PT_ROWS) {
        set row 0
        (pt2_set_current_row row)
        
        # Advance to next pattern in song
        let mut pos: int = (pt2_get_song_pos)
        set pos (+ pos 1)
        
        let song_length: int = (pt2_get_song_length)
        if (>= pos song_length) {
            set pos 0  # Loop back to start
        } else {}
        (pt2_set_song_pos pos)
        
        # Get pattern from order table
        let next_pattern: int = (pt2_get_pattern_table_entry pos)
        (pt2_set_current_pattern next_pattern)
    } else {
        (pt2_set_current_row row)
    }
    
    return row
}

shadow next_row {
    (init_replayer)
    (set_pattern 0)
    let row1: int = (next_row)
    assert (== row1 1)
}

# === NOTE TRIGGERING ===

fn trigger_note(channel: int, note: int, sample: int, volume: int) -> int {
    # Set period from note
    let period: int = (note_to_period note)
    
    # Update channel state
    (pt2_set_channel_note channel note)
    (pt2_set_channel_period channel period)
    (pt2_set_channel_sample channel sample)
    
    if (> volume 0) {
        (pt2_set_channel_volume channel volume)
    } else {}
    
    return period
}

shadow trigger_note {
    (init_replayer)
    let period: int = (trigger_note 0 1 1 64)  # Channel 0, C-1, sample 1, volume 64
    assert (== period 856)  # C-1 period
    let note: int = (pt2_get_channel_note 0)
    assert (== note 1)
    let vol: int = (pt2_get_channel_volume 0)
    assert (== vol 64)
}

# === EFFECT PROCESSING ===

fn process_effect_speed(param: int) -> int {
    # Effect 0xF - Set speed/tempo
    if (<= param 32) {
        # 1-32: Set speed (ticks per row)
        if (> param 0) {
            (pt2_set_speed param)
        } else {}
    } else {
        # 33+: Set BPM
        (pt2_set_bpm param)
    }
    return (pt2_get_speed)
}

shadow process_effect_speed {
    (init_replayer)
    (process_effect_speed 8)  # Set speed to 8
    assert (== (pt2_get_speed) 8)
}

fn process_effect_volume(channel: int, param: int) -> int {
    # Effect 0xC - Set volume
    # param is 0-64 (0x00-0x40)
    let mut vol: int = param
    if (> vol 64) {
        set vol 64
    } else {}
    
    (pt2_set_channel_volume channel vol)
    return vol
}

shadow process_effect_volume {
    (init_replayer)
    (process_effect_volume 0 48)
    assert (== (pt2_get_channel_volume 0) 48)
}

# === TICK HANDLER ===

fn process_tick(pattern_data: array<int>) -> int {
    # Main replayer tick - called once per tick
    
    let playing: int = (pt2_is_playing)
    if (== playing 0) {
        return 0
    } else {}
    
    let tick: int = (pt2_get_tick)
    let speed: int = (pt2_get_speed)
    let current_pattern: int = (pt2_get_current_pattern)
    let current_row: int = (pt2_get_current_row)
    
    # On tick 0, process new notes
    if (== tick 0) {
        # Process all 4 channels
        let mut ch: int = 0
        while (< ch PT_CHANNELS) {
            # Get note data for this channel
            let note: int = (get_note pattern_data current_pattern ch current_row)
            let sample: int = (get_sample pattern_data current_pattern ch current_row)
            let effect: int = (get_effect pattern_data current_pattern ch current_row)
            let param: int = (get_param pattern_data current_pattern ch current_row)
            
            # Trigger note if present
            if (> note 0) {
                (trigger_note ch note sample 64)
            } else {}
            
            # Process effects
            if (== effect EffectType.SPEED) {
                (process_effect_speed param)
            } else {
            if (== effect EffectType.VOLUME) {
                (process_effect_volume ch param)
            } else {}}
            
            set ch (+ ch 1)
        }
    } else {}
    
    # Advance tick
    let mut new_tick: int = (+ tick 1)
    
    # Check if we should advance to next row
    if (>= new_tick speed) {
        set new_tick 0
        (pt2_set_tick new_tick)
        (next_row)
    } else {
        (pt2_set_tick new_tick)
    }
    
    return new_tick
}

shadow process_tick {
    (init_replayer)
    (start_playback)
    let data: array<int> = (create_pattern_data)
    
    # Process one full row (6 ticks at speed 6)
    let mut i: int = 0
    while (< i 6) {
        (process_tick data)
        set i (+ i 1)
    }
    
    # Should have advanced to row 1
    let row: int = (pt2_get_current_row)
    assert (== row 1)
}

# === PLAYBACK INFO GETTERS ===

fn get_current_row() -> int {
    return (pt2_get_current_row)
}

shadow get_current_row {
    (init_replayer)
    assert (== (get_current_row) 0)
}

fn get_current_pattern() -> int {
    return (pt2_get_current_pattern)
}

shadow get_current_pattern {
    (init_replayer)
    assert (== (get_current_pattern) 0)
}

fn get_current_speed() -> int {
    return (pt2_get_speed)
}

shadow get_current_speed {
    (init_replayer)
    assert (== (get_current_speed) 6)
}

fn get_current_bpm() -> int {
    return (pt2_get_bpm)
}

shadow get_current_bpm {
    (init_replayer)
    assert (== (get_current_bpm) 125)
}

fn get_channel_note(channel: int) -> int {
    return (pt2_get_channel_note channel)
}

shadow get_channel_note {
    (init_replayer)
    (trigger_note 0 13 1 64)  # C-2
    assert (== (get_channel_note 0) 13)
}

fn get_channel_volume(channel: int) -> int {
    return (pt2_get_channel_volume channel)
}

shadow get_channel_volume {
    (init_replayer)
    (trigger_note 0 1 1 64)
    assert (== (get_channel_volume 0) 64)
}
