# ProTracker Replayer Engine
# Core playback and effect processing
# Based on pt2_replayer.c from pt2-clone by Olav SÃ¸rensen
#
# NOTE: Uses extern C functions for state storage because nanolang
# doesn't allow mutable variables at top level

import "examples/protracker-clone/types.nano"
import "examples/protracker-clone/pattern.nano"

# === EXTERN STATE MANAGEMENT ===
# All state is stored in C code (pt2_state.c) to work around
# nanolang's limitation on module-level mutable variables

# Initialization
extern fn pt2_init_state() -> int

# Playback control
extern fn pt2_start_playback() -> int
extern fn pt2_stop_playback() -> int
extern fn pt2_is_playing() -> int

# State getters
extern fn pt2_get_current_row() -> int
extern fn pt2_get_current_pattern() -> int
extern fn pt2_get_speed() -> int
extern fn pt2_get_bpm() -> int
extern fn pt2_get_tick() -> int
extern fn pt2_get_song_pos() -> int

# State setters
extern fn pt2_set_current_row(row: int) -> int
extern fn pt2_set_current_pattern(pattern: int) -> int
extern fn pt2_set_speed(speed: int) -> int
extern fn pt2_set_bpm(bpm: int) -> int
extern fn pt2_set_tick(tick: int) -> int
extern fn pt2_set_song_pos(pos: int) -> int

# Channel state
extern fn pt2_set_channel_period(channel: int, period: int) -> int
extern fn pt2_get_channel_period(channel: int) -> int
extern fn pt2_set_channel_volume(channel: int, volume: int) -> int
extern fn pt2_get_channel_volume(channel: int) -> int
extern fn pt2_set_channel_sample(channel: int, sample: int) -> int
extern fn pt2_get_channel_sample(channel: int) -> int
extern fn pt2_set_channel_note(channel: int, note: int) -> int
extern fn pt2_get_channel_note(channel: int) -> int

# Pattern table
extern fn pt2_set_pattern_table_entry(pos: int, pattern: int) -> int
extern fn pt2_get_pattern_table_entry(pos: int) -> int
extern fn pt2_set_song_length(length: int) -> int
extern fn pt2_get_song_length() -> int

# === INITIALIZATION ===

fn init_replayer() -> int {
    return (pt2_init_state)
}

shadow init_replayer {
    let result: int = (init_replayer)
    assert (== result 0)
}

# === PLAYBACK CONTROL ===

fn start_playback() -> int {
    return (pt2_start_playback)
}

fn stop_playback() -> int {
    return (pt2_stop_playback)
}

fn is_playing() -> int {
    return (pt2_is_playing)
}

shadow is_playing {
    (init_replayer)
    (start_playback)
    assert (== (is_playing) 1)
    (stop_playback)
    assert (== (is_playing) 0)
}

# === PATTERN NAVIGATION ===

fn set_pattern(pattern: int) -> int {
    if (< pattern 0) {
        set g_current_pattern 0
    } else {
        if (>= pattern PT_PATTERNS) {
            set g_current_pattern (- PT_PATTERNS 1)
        } else {
            set g_current_pattern pattern
        }
    }
    set g_current_row 0
    return g_current_pattern
}

fn next_row() -> int {
    set g_current_row (+ g_current_row 1)
    
    # Check if we reached end of pattern
    if (>= g_current_row PT_ROWS) {
        set g_current_row 0
        
        # Advance to next pattern in song
        set g_song_pos (+ g_song_pos 1)
        if (>= g_song_pos g_song_length) {
            set g_song_pos 0  # Loop back to start
        }
        
        # Get pattern from order table
        let next_pattern: int = (at g_pattern_table g_song_pos)
        set g_current_pattern next_pattern
    } else {}
    
    return g_current_row
}

shadow next_row {
    (init_replayer)
    (set_pattern 0)
    let row1: int = (next_row)
    assert (== row1 1)
}

# === NOTE TRIGGERING ===

fn trigger_note(channel: int, note: int, sample: int, volume: int) -> int {
    # Set period from note
    let period: int = (note_to_period note)
    
    # Update channel state based on channel number
    if (== channel 0) {
        set g_ch0_note note
        set g_ch0_period period
        set g_ch0_sample sample
        if (> volume 0) {
            set g_ch0_volume volume
        } else {}
    } else {
    if (== channel 1) {
        set g_ch1_note note
        set g_ch1_period period
        set g_ch1_sample sample
        if (> volume 0) {
            set g_ch1_volume volume
        } else {}
    } else {
    if (== channel 2) {
        set g_ch2_note note
        set g_ch2_period period
        set g_ch2_sample sample
        if (> volume 0) {
            set g_ch2_volume volume
        } else {}
    } else {
    if (== channel 3) {
        set g_ch3_note note
        set g_ch3_period period
        set g_ch3_sample sample
        if (> volume 0) {
            set g_ch3_volume volume
        } else {}
    } else {}}}}
    
    return period
}

shadow trigger_note {
    (init_replayer)
    (trigger_note 0 1 1 64)  # Channel 0, C-1, sample 1, volume 64
    assert (== g_ch0_note 1)
    assert (== g_ch0_period 856)  # C-1 period
    assert (== g_ch0_sample 1)
    assert (== g_ch0_volume 64)
}

# === EFFECT PROCESSING ===

fn process_effect_speed(param: int) -> int {
    # Effect 0xF - Set speed/tempo
    if (<= param 32) {
        # 1-32: Set speed (ticks per row)
        if (> param 0) {
            set g_speed param
        } else {}
    } else {
        # 33+: Set BPM
        set g_bpm param
    }
    return g_speed
}

fn process_effect_volume(param: int) -> int {
    # Effect 0xC - Set volume
    # param is 0-64 (0x00-0x40)
    if (> param 64) {
        return 64
    } else {
        return param
    }
}

# === TICK HANDLER ===

fn process_tick(pattern_data: array<int>) -> int {
    # Main replayer tick - called once per tick
    
    if (== g_playing 0) {
        return 0
    } else {}
    
    # On tick 0, process new notes
    if (== g_tick 0) {
        # Process all 4 channels
        let mut ch: int = 0
        while (< ch PT_CHANNELS) {
            # Get note data for this channel
            let note: int = (get_note pattern_data g_current_pattern ch g_current_row)
            let sample: int = (get_sample pattern_data g_current_pattern ch g_current_row)
            let effect: int = (get_effect pattern_data g_current_pattern ch g_current_row)
            let param: int = (get_param pattern_data g_current_pattern ch g_current_row)
            
            # Trigger note if present
            if (> note 0) {
                (trigger_note ch note sample 64)
            } else {}
            
            # Process effects
            if (== effect EffectType.SPEED) {
                (process_effect_speed param)
            } else {
            if (== effect EffectType.VOLUME) {
                let vol: int = (process_effect_volume param)
                # Apply volume to channel (simplified)
            } else {}}
            
            set ch (+ ch 1)
        }
    } else {}
    
    # Advance tick
    set g_tick (+ g_tick 1)
    
    # Check if we should advance to next row
    if (>= g_tick g_speed) {
        set g_tick 0
        (next_row)
    } else {}
    
    return g_tick
}

shadow process_tick {
    (init_replayer)
    (start_playback)
    let data: array<int> = (create_pattern_data)
    
    # Process one full row (6 ticks at speed 6)
    let mut i: int = 0
    while (< i 6) {
        (process_tick data)
        set i (+ i 1)
    }
    
    # Should have advanced to row 1
    assert (== g_current_row 1)
}

# === PLAYBACK INFO GETTERS ===

fn get_current_row() -> int {
    let row: int = g_current_row
    return row
}

shadow get_current_row {
    (init_replayer)
    assert (== (get_current_row) 0)
}

fn get_current_pattern() -> int {
    let pattern: int = g_current_pattern
    return pattern
}

shadow get_current_pattern {
    (init_replayer)
    assert (== (get_current_pattern) 0)
}

fn get_current_speed() -> int {
    let speed: int = g_speed
    return speed
}

shadow get_current_speed {
    (init_replayer)
    assert (== (get_current_speed) 6)
}

fn get_current_bpm() -> int {
    let bpm: int = g_bpm
    return bpm
}

shadow get_current_bpm {
    (init_replayer)
    assert (== (get_current_bpm) 125)
}

fn get_channel_note(channel: int) -> int {
    let note: int = 0
    if (== channel 0) { set note g_ch0_note } else {
    if (== channel 1) { set note g_ch1_note } else {
    if (== channel 2) { set note g_ch2_note } else {
    if (== channel 3) { set note g_ch3_note } else {}}}
    return note
}

shadow get_channel_note {
    (init_replayer)
    (trigger_note 0 13 1 64)  # C-2
    assert (== (get_channel_note 0) 13)
}

fn get_channel_volume(channel: int) -> int {
    let volume: int = 0
    if (== channel 0) { set volume g_ch0_volume } else {
    if (== channel 1) { set volume g_ch1_volume } else {
    if (== channel 2) { set volume g_ch2_volume } else {
    if (== channel 3) { set volume g_ch3_volume } else {}}}
    return volume
}

shadow get_channel_volume {
    (init_replayer)
    (trigger_note 0 1 1 64)
    assert (== (get_channel_volume 0) 64)
}
