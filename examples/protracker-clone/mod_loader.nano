# MOD file loader
# Based on pt2-clone by Olav Sørensen

import "modules/pt2_state/pt2_state.nano"
import "examples/protracker-clone/types.nano"
import "examples/protracker-clone/pattern.nano"

# MOD file format constants
let MOD_NAME_LEN: int = 20
let MOD_SAMPLE_NAME_LEN: int = 22
let MOD_SAMPLE_HEADER_SIZE: int = 30
let MOD_SAMPLES: int = 31
let MOD_PATTERN_TABLE_SIZE: int = 128

# Helper: Read 16-bit big-endian value from string
fn read_be16(data: string, offset: int) -> int {
    let byte1: int = (char_at data offset)
    let byte2: int = (char_at data (+ offset 1))
    return (+ (* byte1 256) byte2)
}

shadow read_be16 {
    # Test: 0x1817 = 6167 decimal
    let test_data: string = "\x18\x17\x00\x00"
    assert (== (read_be16 test_data 0) 6167)
}

# Load MOD file and return pattern data
fn load_mod_file(filename: string) -> array<int> {
    (println "Loading MOD file:")
    (println filename)
    
    # Read file
    let file_data: string = (file_read filename)
    let file_size: int = (str_length file_data)
    
    (print "File size: ")
    (print file_size)
    (println " bytes")
    
    # Check minimum size (header + samples info = 20 + 31*30 + 1 + 1 + 128 + 4 = 1084 bytes)
    if (< file_size 1084) {
        (println "Error: File too small to be a valid MOD")
        return (create_pattern_data)
    } else {}
    
    # Read song name (bytes 0-19)
    let song_name: string = (str_substring file_data 0 20)
    (print "Song: ")
    (println song_name)
    (println "")
    
    # Parse sample headers and extract sample data
    (println "Parsing samples:")
    
    # First pass: parse headers and calculate offsets
    let mut samp: int = 0
    let mut total_sample_bytes: int = 0
    let mut sample_count: int = 0
    
    while (< samp 31) {
        let header_offset: int = (+ 20 (* samp 30))
        
        # Read sample header
        let samp_name: string = (str_substring file_data header_offset 22)
        let samp_len_words: int = (read_be16 file_data (+ header_offset 22))
        let samp_len_bytes: int = (* samp_len_words 2)
        let samp_finetune: int = (char_at file_data (+ header_offset 24))
        let samp_volume: int = (char_at file_data (+ header_offset 25))
        let samp_loop_start: int = (* (read_be16 file_data (+ header_offset 26)) 2)
        let samp_loop_len: int = (* (read_be16 file_data (+ header_offset 28)) 2)
        
        # Print and store sample info
        if (> samp_len_bytes 0) {
            (print "  Sample ")
            (print (+ samp 1))
            (print ": len=")
            (print samp_len_bytes)
            (print " vol=")
            (print samp_volume)
            (print " loop=")
            (print samp_loop_start)
            (print "/")
            (println samp_loop_len)
            
            # Store in pt2_state for later use
            (pt2_set_sample_length samp samp_len_bytes)
            (pt2_set_sample_volume samp samp_volume)
            (pt2_set_sample_loop_start samp samp_loop_start)
            (pt2_set_sample_loop_length samp samp_loop_len)
            
            set total_sample_bytes (+ total_sample_bytes samp_len_bytes)
            set sample_count (+ sample_count 1)
        } else {}
        
        set samp (+ samp 1)
    }
    
    (println "")
    (print "Samples found: ")
    (println sample_count)
    (print "Total sample data: ")
    (print total_sample_bytes)
    (println " bytes")
    (println "")
    
    # TODO: Extract sample waveform data
    # Sample data starts after patterns at: 1084 + (highest_pattern + 1) * 1024
    # For now, we'll skip actual waveform extraction and focus on pattern playback
    # We can use SDL_mixer to generate test tones instead
    
    # Read song length (byte 950)
    let song_length_byte: string = (str_substring file_data 950 1)
    let song_length: int = (char_at song_length_byte 0)
    (print "Song length: ")
    (println song_length)
    
    # Read pattern table (bytes 952-1079 = 128 bytes)
    let pattern_table_start: int = 952
    
    # Find highest pattern number to know how many patterns to read
    let mut highest_pattern: int = 0
    let mut i: int = 0
    while (< i song_length) {
        let table_byte: string = (str_substring file_data (+ pattern_table_start i) 1)
        let pattern_num: int = (char_at table_byte 0)
        if (> pattern_num highest_pattern) {
            set highest_pattern pattern_num
        } else {}
        set i (+ i 1)
    }
    
    (print "Highest pattern: ")
    (println highest_pattern)
    
    # Read module tag (bytes 1080-1083, should be "M.K." or "4CHN")
    let tag: string = (str_substring file_data 1080 4)
    (print "Module tag: ")
    (println tag)
    
    # Pattern data starts at byte 1084
    # Each pattern is 1024 bytes (64 rows * 4 channels * 4 bytes)
    let pattern_data_start: int = 1084
    let pattern_size: int = 1024  # 64 rows * 4 channels * 4 bytes/note
    
    # Create pattern data array
    let mut pattern_data: array<int> = (create_pattern_data)
    
    # Read patterns
    let mut patt: int = 0
    while (<= patt highest_pattern) {
        let patt_offset: int = (+ pattern_data_start (* patt pattern_size))
        
        # Read all rows in this pattern
        let mut row: int = 0
        while (< row PT_ROWS) {
            # Read all channels in this row
            let mut chan: int = 0
            while (< chan PT_CHANNELS) {
                # Each note is 4 bytes in MOD format
                let note_offset: int = (+ patt_offset (+ (* row 16) (* chan 4)))
                
                if (< note_offset file_size) {
                    # Read 4 bytes for this note
                    let byte0_str: string = (str_substring file_data note_offset 1)
                    let byte1_str: string = (str_substring file_data (+ note_offset 1) 1)
                    let byte2_str: string = (str_substring file_data (+ note_offset 2) 1)
                    let byte3_str: string = (str_substring file_data (+ note_offset 3) 1)
                    
                    let byte0: int = (char_at byte0_str 0)
                    let byte1: int = (char_at byte1_str 0)
                    let byte2: int = (char_at byte2_str 0)
                    let byte3: int = (char_at byte3_str 0)
                    
                    # MOD format: period is in bytes 0-1 (12 bits)
                    # Sample number is in bytes 0,2 (upper 4 bits of byte 0, upper 4 bits of byte 2)
                    # Effect is in byte 2 (lower 4 bits) and byte 3
                    
                    # Extract sample number (simplified - just use byte 0 high nibble)
                    let sample: int = (/ byte0 16)  # Upper 4 bits
                    
                    # Extract period (12-bit value from bytes 0-1)
                    let period_high: int = (% byte0 16)  # Lower 4 bits of byte 0
                    let period: int = (+ (* period_high 256) byte1)
                    
                    # Convert period to note number
                    let note: int = (period_to_note period)
                    
                    # Extract effect and parameter
                    let effect: int = (/ byte2 16)  # Upper 4 bits of byte 2
                    let param: int = byte3
                    
                    # Store in our pattern data
                    if (> note 0) {
                        (array_set pattern_data (pattern_index patt chan row NOTE_COMP) note)
                    } else {}
                    if (> sample 0) {
                        (array_set pattern_data (pattern_index patt chan row SAMPLE_COMP) sample)
                    } else {}
                    if (> effect 0) {
                        (array_set pattern_data (pattern_index patt chan row EFFECT_COMP) effect)
                        (array_set pattern_data (pattern_index patt chan row PARAM_COMP) param)
                    } else {}
                } else {}
                
                set chan (+ chan 1)
            }
            set row (+ row 1)
        }
        
        set patt (+ patt 1)
    }
    
    (println "✓ MOD file loaded successfully!")
    return pattern_data
}

shadow load_mod_file {
    # Can't test file loading in shadow tests
    assert true
}
