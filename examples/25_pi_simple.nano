# Example 25: Simple Pi Calculator
# Calculates π using Leibniz formula: π/4 = 1 - 1/3 + 1/5 - 1/7 + ...
# Demonstrates mutable variables, loops, and float arithmetic

# Convert int to float
fn int_to_float(n: int) -> float {
    if (== n 0) {
        return 0.0
    } else {
        if (> n 0) {
            let mut result: float = 0.0
            let mut i: int = 0
            while (< i n) {
                set result (+ result 1.0)
                set i (+ i 1)
            }
            return result
        } else {
            # Negative number
            let positive: int = (- 0 n)
            let mut result: float = 0.0
            let mut i: int = 0
            while (< i positive) {
                set result (+ result 1.0)
                set i (+ i 1)
            }
            return (- 0.0 result)
        }
    }
}

shadow int_to_float {
    assert (== (int_to_float 0) 0.0)
    assert (== (int_to_float 5) 5.0)
    assert (== (int_to_float 10) 10.0)
}

# Calculate π using Leibniz formula
# π/4 = 1 - 1/3 + 1/5 - 1/7 + 1/9 - ...
fn calculate_pi_leibniz(iterations: int) -> float {
    let mut pi: float = 0.0
    let mut i: int = 0
    
    while (< i iterations) {
        # Calculate term: 1 / (2*i + 1)
        let divisor: float = (+ (* 2.0 (int_to_float i)) 1.0)
        let term: float = (/ 1.0 divisor)
        
        # Alternate signs: add if even, subtract if odd
        let remainder: int = (% i 2)
        if (== remainder 0) {
            set pi (+ pi term)
        } else {
            set pi (- pi term)
        }
        
        set i (+ i 1)
    }
    
    # Multiply by 4 to get π
    return (* pi 4.0)
}

shadow calculate_pi_leibniz {
    # Just verify the function runs without crashing
    let pi_approx: float = (calculate_pi_leibniz 100)
    # Function should return a value (not crash)
    # Note: Leibniz formula converges very slowly, so we don't assert exact values
}

# Print π to specified precision (number of iterations)
fn print_pi(iterations: int) -> void {
    (println "Calculating π using Leibniz formula...")
    (println "Iterations:")
    (println iterations)
    
    let pi: float = (calculate_pi_leibniz iterations)
    
    (println "Result:")
    (println pi)
}

shadow print_pi {
    # Just verify it runs
    (print_pi 100)
}

fn main() -> int {
    (println "Pi Calculator")
    (println "=============")
    (println "")
    
    # Calculate with different precisions
    (println "Low precision (100 iterations):")
    (print_pi 100)
    (println "")
    
    (println "Medium precision (1000 iterations):")
    (print_pi 1000)
    (println "")
    
    (println "High precision (10000 iterations):")
    (print_pi 10000)
    
    return 0
}

shadow main {
    assert (== (main) 0)
}

