# Example 25: Simple Pi Calculator
# Calculates π using Leibniz formula: π/4 = 1 - 1/3 + 1/5 - 1/7 + ...
# Demonstrates mutable variables, loops, float arithmetic, and type casting

# Calculate π using Leibniz formula
# π/4 = 1 - 1/3 + 1/5 - 1/7 + 1/9 - ...
fn calculate_pi_leibniz(iterations: int) -> float {
    let mut pi: float = 0.0
    let mut i: int = 0
    
    while (< i iterations) {
        # Calculate term: 1 / (2*i + 1)
        let divisor: float = (+ (* 2.0 (cast_float i)) 1.0)
        let term: float = (/ 1.0 divisor)
        
        # Alternate signs: add if even, subtract if odd
        let remainder: int = (% i 2)
        if (== remainder 0) {
            set pi (+ pi term)
        } else {
            set pi (- pi term)
        }
        
        set i (+ i 1)
    }
    
    # Multiply by 4 to get π
    return (* pi 4.0)
}

shadow calculate_pi_leibniz {
    # Just verify the function runs without crashing
    let pi_approx: float = (calculate_pi_leibniz 100)
    # Function should return a value (not crash)
    # Note: Leibniz formula converges very slowly, so we don't assert exact values
}

# Print π to specified precision (number of iterations)
fn print_pi(iterations: int) -> void {
    (println "Calculating π using Leibniz formula...")
    (println "Iterations:")
    (println iterations)
    
    let pi: float = (calculate_pi_leibniz iterations)
    
    (println "Result:")
    (println pi)
}

shadow print_pi {
    # Just verify it runs
    (print_pi 100)
}

fn main() -> int {
    (println "Pi Calculator")
    (println "=============")
    (println "")
    
    # Calculate with different precisions
    (println "Low precision (100 iterations):")
    (print_pi 100)
    (println "")
    
    (println "Medium precision (1000 iterations):")
    (print_pi 1000)
    (println "")
    
    (println "High precision (10000 iterations):")
    (print_pi 10000)
    
    return 0
}

shadow main {
    assert (== (main) 0)
}

