/*
 * Mega Stack Collapse Demo - Bullet Physics + SDL2
 * Inspired by the "stacking 1000 Boxes using BULLET" forum thread
 * and Moby Motion's "Blender - Bullet Physics (HD)" tower cascade video.
 */

import "modules/sdl/sdl.nano"
import "modules/sdl_helpers/sdl_helpers.nano"
import "modules/bullet/bullet.nano"

/* Window + camera */
let WINDOW_WIDTH: int = 1400
let WINDOW_HEIGHT: int = 900
let TARGET_FPS: int = 60
let FRAME_TIME: float = 0.016666

let CAMERA_SCALE: float = 14.0
let CAMERA_OFFSET_Y: float = 28.0

/* Tower configuration */
let TOWER_COUNT: int = 12
let LAYERS_PER_TOWER: int = 32
let TOWER_SPACING: float = 3.8
let TOWER_BASE_Y: float = (- 0.0 40.0)
let BLOCK_HALF_WIDTH: float = 0.7
let BLOCK_HALF_HEIGHT: float = 0.5
let BLOCK_HALF_DEPTH: float = 0.7
let BLOCK_MASS: float = 2.0
let LAYER_LEAN: float = 0.07

let GROUND_HALF_HEIGHT: float = 2.0
let WALL_HALF_THICKNESS: float = 1.0

/* Colors */
let COLOR_BG_R: int = 6
let COLOR_BG_G: int = 8
let COLOR_BG_B: int = 15

let COLOR_GROUND_R: int = 60
let COLOR_GROUND_G: int = 120
let COLOR_GROUND_B: int = 160

let COLOR_BLOCK_BASE_R: int = 220
let COLOR_BLOCK_BASE_G: int = 140
let COLOR_BLOCK_BASE_B: int = 80

/* Helpers */
fn project_x(x: float) -> int {
    let screen_x: float = (+ (/ (cast_float WINDOW_WIDTH) 2.0) (* x CAMERA_SCALE))
    return (cast_int screen_x)
}

shadow project_x {
    assert (== (project_x 0.0) (/ WINDOW_WIDTH 2))
}

fn project_y(y: float) -> int {
    let adjusted_y: float = (- y CAMERA_OFFSET_Y)
    let screen_y: float = (+ (/ (cast_float WINDOW_HEIGHT) 2.0) (- (* adjusted_y CAMERA_SCALE)))
    return (cast_int screen_y)
}

shadow project_y {
    assert (< (project_y 10.0) (project_y (- 0.0 10.0)))
}

fn clamp_ratio(value: float) -> float {
    if (< value 0.0) {
        return 0.0
    }
    if (> value 1.0) {
        return 1.0
    }
    return value
}

shadow clamp_ratio {
    assert (== (clamp_ratio (- 0.0 1.0)) 0.0)
    assert (== (clamp_ratio 0.5) 0.5)
    assert (== (clamp_ratio 2.0) 1.0)
}

fn clamp_int(value: int, min_value: int, max_value: int) -> int {
    if (< value min_value) {
        return min_value
    }
    if (> value max_value) {
        return max_value
    }
    return value
}

shadow clamp_int {
    assert (== (clamp_int (- 0 5) 0 255) 0)
    assert (== (clamp_int 128 0 255) 128)
    assert (== (clamp_int 400 0 255) 255)
}

fn collapse_progress(initial: array<float>, current: array<float>) -> float {
    let count: int = (array_length initial)
    if (== count 0) {
        return 0.0
    }
    let mut sum: float = 0.0
    let mut i: int = 0
    while (< i count) {
        let initial_height: float = (at initial i)
        let current_height: float = (at current i)
        if (<= initial_height 0.0) {
            set sum (+ sum 1.0)
        } else {
            let ratio: float = (/ current_height initial_height)
            set sum (+ sum (clamp_ratio ratio))
        }
        set i (+ i 1)
    }
    return (/ sum (cast_float count))
}

shadow collapse_progress {
    let init: array<float> = [10.0, 8.0]
    let curr: array<float> = [5.0, 2.0]
    let ratio: float = (collapse_progress init curr)
    assert (== ratio 0.375)
}

fn format_percent(value: float) -> string {
    let clamped: float = (clamp_ratio value)
    let percent: int = (cast_int (* clamped 100.0))
    return (+ (int_to_string percent) "%")
}

shadow format_percent {
    assert (str_equals (format_percent 0.42) "42%")
}

fn main() -> int {
    (println "╔════════════════════════════════════════════════════════════╗")
    (println "║      BULLET MEGA STACK COLLAPSE (TOWER FIELD)             ║")
    (println "╚════════════════════════════════════════════════════════════╝")
    (println "Inspired by large-scale Bullet rigid body showcases (Moby Motion, Bullet forums)")
    (println "ESC to exit")
    (println "")

    unsafe { (SDL_Init SDL_INIT_VIDEO) }
    let window: SDL_Window = (SDL_CreateWindow
        "Bullet Mega Stack Collapse"
        SDL_WINDOWPOS_CENTERED SDL_WINDOWPOS_CENTERED
        WINDOW_WIDTH WINDOW_HEIGHT
        SDL_WINDOW_SHOWN)
    let renderer: SDL_Renderer = (SDL_CreateRenderer window -1 SDL_RENDERER_ACCELERATED)

    let mut bullet_ok: int = 0
    unsafe { set bullet_ok (nl_bullet_init) }
    if (== bullet_ok 0) {
        (println "Failed to initialize Bullet")
        unsafe {
            (SDL_DestroyRenderer renderer)
            (SDL_DestroyWindow window)
            (SDL_Quit)
        }
        return 1
    }

    /* World setup */
    let mut handles: array<int> = []
    let mut tower_ids: array<int> = []
    let mut tower_initial_tops: array<float> = []

    unsafe {
        (nl_bullet_create_rigid_box 0.0 TOWER_BASE_Y 0.0 120.0 GROUND_HALF_HEIGHT 60.0 0.0 0.4)
        (nl_bullet_create_rigid_box (- 0.0 30.0) (- 0.0 40.0) 0.0 WALL_HALF_THICKNESS 25.0 60.0 0.0 0.3)
        (nl_bullet_create_rigid_box 30.0 (- 0.0 40.0) 0.0 WALL_HALF_THICKNESS 25.0 60.0 0.0 0.3)
    }

    let tower_spacing: float = TOWER_SPACING
    let layer_step: float = (* BLOCK_HALF_HEIGHT 2.0)
    let base_y: float = (+ (+ TOWER_BASE_Y GROUND_HALF_HEIGHT) BLOCK_HALF_HEIGHT)

    let mut tower_index: int = 0
    while (< tower_index TOWER_COUNT) {
        let tower_center_x: float = (+ (- 0.0 (* tower_spacing (/ (cast_float (- TOWER_COUNT 1)) 2.0))) (* (cast_float tower_index) tower_spacing))
        let tower_top: float = (+ base_y (* (cast_float (- LAYERS_PER_TOWER 1)) layer_step))
        set tower_initial_tops (array_push tower_initial_tops tower_top)

        let mut layer: int = 0
        while (< layer LAYERS_PER_TOWER) {
            let lean_dir: float = (cond ((== (% tower_index 2) 0) 1.0) (else (- 0.0 1.0)))
            let lean_amount: float = (* (cast_float layer) (* LAYER_LEAN lean_dir))
            let block_x: float = (+ tower_center_x lean_amount)
            let block_y: float = (+ base_y (* (cast_float layer) layer_step))
            let mut handle: int = 0
            unsafe {
                set handle (nl_bullet_create_rigid_box block_x block_y 0.0 BLOCK_HALF_WIDTH BLOCK_HALF_HEIGHT BLOCK_HALF_DEPTH BLOCK_MASS 0.15)
            }
            set handles (array_push handles handle)
            set tower_ids (array_push tower_ids tower_index)
            set layer (+ layer 1)
        }
        set tower_index (+ tower_index 1)
    }

    (println (+ "Spawned rigid bodies: " (int_to_string (array_length handles))))

    /* Rendering helpers */
    let block_width_px: int = (cast_int (* (* BLOCK_HALF_WIDTH 2.0) CAMERA_SCALE))
    let block_height_px: int = (cast_int (* (* BLOCK_HALF_HEIGHT 2.0) CAMERA_SCALE))
    let ground_height_px: int = (cast_int (* (* GROUND_HALF_HEIGHT 2.0) CAMERA_SCALE))

    let mut running: bool = true
    let mut frame_count: int = 0

    while running {
        let mut frame_start: int = 0
        unsafe { set frame_start (SDL_GetTicks) }

        if (== (nl_sdl_poll_event_quit) 1) {
            set running false
        }
        let key: int = (nl_sdl_poll_keypress)
        if (== key 41) {
            set running false
        }

        unsafe { (nl_bullet_step FRAME_TIME) }

        if (== (% frame_count 120) 0) {
            let mut current_tops: array<float> = (array_new TOWER_COUNT (- 0.0 1000.0))
            let mut i: int = 0
            while (< i (array_length handles)) {
                let handle: int = (at handles i)
                let tower_id: int = (at tower_ids i)
                let mut y: float = 0.0
                unsafe { set y (nl_bullet_get_rigid_body_y handle) }
                let existing: float = (at current_tops tower_id)
                if (> y existing) {
                    (array_set current_tops tower_id y)
                }
                set i (+ i 1)
            }
            let progress: float = (collapse_progress tower_initial_tops current_tops)
            (println (+ "Collapse completion: " (format_percent (- 1.0 progress))))
        }

        unsafe {
            (SDL_SetRenderDrawColor renderer COLOR_BG_R COLOR_BG_G COLOR_BG_B 255)
            (SDL_RenderClear renderer)
        }

        /* Ground */
        let ground_screen_x: int = (project_x 0.0)
        let ground_screen_y: int = (project_y TOWER_BASE_Y)
        unsafe {
            (SDL_SetRenderDrawColor renderer COLOR_GROUND_R COLOR_GROUND_G COLOR_GROUND_B 255)
            (nl_sdl_render_fill_rect renderer (- ground_screen_x 2000) (- ground_screen_y ground_height_px) 4000 (+ ground_height_px 40))
        }

        /* Blocks */
        let mut j: int = 0
        while (< j (array_length handles)) {
            let handle: int = (at handles j)
            let tower_id: int = (at tower_ids j)
            let mut x: float = 0.0
            let mut y: float = 0.0
            unsafe {
                set x (nl_bullet_get_rigid_body_x handle)
                set y (nl_bullet_get_rigid_body_y handle)
            }
            let screen_x: int = (project_x x)
            let screen_y: int = (project_y y)
            let brightness: int = (+ 60 (* (% tower_id 3) 30))
            let block_r: int = (clamp_int (+ COLOR_BLOCK_BASE_R (- brightness 10)) 0 255)
            let block_g: int = (clamp_int (+ COLOR_BLOCK_BASE_G brightness) 0 255)
            let block_b: int = (clamp_int (+ COLOR_BLOCK_BASE_B (/ brightness 2)) 0 255)
            unsafe {
                (SDL_SetRenderDrawColor renderer block_r block_g block_b 255)
                (nl_sdl_render_fill_rect renderer (- screen_x (/ block_width_px 2)) (- screen_y (/ block_height_px 2)) block_width_px block_height_px)
            }
            set j (+ j 1)
        }

        unsafe { (SDL_RenderPresent renderer) }

        set frame_count (+ frame_count 1)

        let mut frame_end: int = 0
        unsafe { set frame_end (SDL_GetTicks) }
        let frame_duration: int = (- frame_end frame_start)
        let frame_budget: int = (/ 1000 TARGET_FPS)
        if (< frame_duration frame_budget) {
            unsafe { (SDL_Delay (- frame_budget frame_duration)) }
        }
    }

    unsafe {
        (nl_bullet_cleanup)
        (SDL_DestroyRenderer renderer)
        (SDL_DestroyWindow window)
        (SDL_Quit)
    }

    (println "Demo finished")
    return 0
}

shadow main {
    assert true
}
