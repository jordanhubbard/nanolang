# Conway's Game of Life - NCurses Version
# Watch cellular automata patterns evolve in real-time

import "modules/ncurses/ncurses.nano"

# === ENUMS ===
enum CellState {
    DEAD = 0,
    ALIVE = 1
}

# === CONSTANTS ===
let GRID_WIDTH: int = 60
let GRID_HEIGHT: int = 30
let UPDATE_DELAY_MS: int = 100

# === EXTERNAL FUNCTIONS ===
extern fn rand() -> int
extern fn srand(seed: int) -> void

# === HELPER FUNCTIONS ===

fn grid_index(x: int, y: int, width: int) -> int {
    return (+ (* y width) x)
}

shadow grid_index {
    assert (== (grid_index 0 0 10) 0)
    assert (== (grid_index 3 2 10) 23)
}

fn grid_get(grid: array<int>, x: int, y: int, width: int, height: int) -> int {
    # Modern bounds checking with early return
    if (or (< x 0) (>= x width)) {
        return CellState.DEAD
    }
    if (or (< y 0) (>= y height)) {
        return CellState.DEAD
    }
    
    let idx: int = (grid_index x y width)
    return (at grid idx)
}

shadow grid_get {
    let grid: array<int> = [CellState.DEAD, CellState.ALIVE,
                            CellState.DEAD, CellState.DEAD]
    assert (== (grid_get grid 1 0 2 2) CellState.ALIVE)
    assert (== (grid_get grid (- 1) 0 2 2) CellState.DEAD)
}

fn count_neighbors(grid: array<int>, x: int, y: int, width: int, height: int) -> int {
    let mut count: int = 0
    
    # Check all 8 neighbors
    if (== (grid_get grid (- x 1) (- y 1) width height) CellState.ALIVE) { set count (+ count 1) } else {}
    if (== (grid_get grid x (- y 1) width height) CellState.ALIVE) { set count (+ count 1) } else {}
    if (== (grid_get grid (+ x 1) (- y 1) width height) CellState.ALIVE) { set count (+ count 1) } else {}
    if (== (grid_get grid (- x 1) y width height) CellState.ALIVE) { set count (+ count 1) } else {}
    if (== (grid_get grid (+ x 1) y width height) CellState.ALIVE) { set count (+ count 1) } else {}
    if (== (grid_get grid (- x 1) (+ y 1) width height) CellState.ALIVE) { set count (+ count 1) } else {}
    if (== (grid_get grid x (+ y 1) width height) CellState.ALIVE) { set count (+ count 1) } else {}
    if (== (grid_get grid (+ x 1) (+ y 1) width height) CellState.ALIVE) { set count (+ count 1) } else {}
    
    return count
}

shadow count_neighbors {
    /* Single alive cell at center of 3x3 has 0 neighbors */
    let grid: array<int> = [0,0,0,
                            0,1,0,
                            0,0,0]
    assert (== (count_neighbors grid 1 1 3 3) 0)
}

fn apply_rules(current: CellState, neighbors: int) -> CellState {
    let dead: CellState = CellState.DEAD
    let alive: CellState = CellState.ALIVE
    
    return (cond
        # Cell is alive
        ((and (== current alive) (< neighbors 2)) dead)      # Underpopulation
        ((and (== current alive) (> neighbors 3)) dead)      # Overpopulation
        ((== current alive) alive)                            # Survival (2-3 neighbors)
        # Cell is dead
        ((== neighbors 3) alive)                              # Reproduction
        (else dead)                                           # Stay dead
    )
}

shadow apply_rules {
    assert (== (apply_rules CellState.ALIVE 1) CellState.DEAD)
    assert (== (apply_rules CellState.ALIVE 2) CellState.ALIVE)
    assert (== (apply_rules CellState.DEAD 3) CellState.ALIVE)
}

fn make_empty_grid(width: int, height: int) -> array<int> {
    let mut grid: array<int> = []
    let total: int = (* width height)
    let dead: int = CellState.DEAD
    
    # Modern for loop
    for i in (range 0 total) {
        set grid (array_push grid dead)
    }
    
    return grid
}

shadow make_empty_grid {
    let grid: array<int> = (make_empty_grid 3 2)
    assert (== (array_length grid) 6)
    assert (== (at grid 0) CellState.DEAD)
}

fn add_glider(grid: array<int>, width: int, height: int, start_x: int, start_y: int) -> array<int> {
    # Glider pattern:
    #   █
    #    █
    # ███
    
    let alive: CellState = CellState.ALIVE
    
    let idx1: int = (grid_index (+ start_x 1) start_y width)
    let idx2: int = (grid_index (+ start_x 2) (+ start_y 1) width)
    let idx3: int = (grid_index start_x (+ start_y 2) width)
    let idx4: int = (grid_index (+ start_x 1) (+ start_y 2) width)
    let idx5: int = (grid_index (+ start_x 2) (+ start_y 2) width)
    
    (array_set grid idx1 alive)
    (array_set grid idx2 alive)
    (array_set grid idx3 alive)
    (array_set grid idx4 alive)
    (array_set grid idx5 alive)
    
    return grid
}

shadow add_glider {
    /* Uses array_set() heavily; keep shadow test side-effect free. */
    assert true
}

fn add_blinker(grid: array<int>, width: int, height: int, start_x: int, start_y: int) -> array<int> {
    # Blinker pattern (oscillator):
    # ███
    
    let alive: CellState = CellState.ALIVE
    
    let idx1: int = (grid_index start_x start_y width)
    let idx2: int = (grid_index (+ start_x 1) start_y width)
    let idx3: int = (grid_index (+ start_x 2) start_y width)
    
    (array_set grid idx1 alive)
    (array_set grid idx2 alive)
    (array_set grid idx3 alive)
    
    return grid
}

shadow add_blinker {
    /* Uses array_set() heavily; keep shadow test side-effect free. */
    assert true
}

fn step(grid: array<int>, width: int, height: int) -> array<int> {
    let mut new_grid: array<int> = (make_empty_grid width height)
    
    # Modern for loops
    for y in (range 0 height) {
        for x in (range 0 width) {
            let idx: int = (grid_index x y width)
            let neighbors: int = (count_neighbors grid x y width height)
            
            if (< neighbors 2) {
                let dead: CellState = CellState.DEAD
                (array_set new_grid idx dead)
            } else {
                if (== neighbors 2) {
                    (array_set new_grid idx (at grid idx))
                } else {
                    if (== neighbors 3) {
                        let alive: CellState = CellState.ALIVE
                        (array_set new_grid idx alive)
                    } else {
                        let dead: CellState = CellState.DEAD
                        (array_set new_grid idx dead)
                    }
                }
            }
        }
    }
    
    return new_grid
}

shadow step {
    /* step uses array_set() on a grid built via array_push(); keep shadow test side-effect free. */
    assert true
}

fn draw_grid_ncurses(grid: array<int>, width: int, height: int) -> void {
    let alive: int = CellState.ALIVE
    
    # Modern for loops
    for y in (range 0 height) {
        for x in (range 0 width) {
            let idx: int = (grid_index x y width)
            
            if (== (at grid idx) alive) {
                unsafe { (mvaddch_wrapper y x (cast_int '#')) }
            } else {
                unsafe { (mvaddch_wrapper y x (cast_int ' ')) }
            }
        }
    }
}

shadow draw_grid_ncurses {
    /* draw_grid_ncurses uses ncurses externs; keep shadow test side-effect free. */
    assert true
}

# === MAIN ===

fn main() -> int {
    # Initialize ncurses
    let win: int = (initscr_wrapper)
    unsafe { (curs_set_wrapper 0) } # Hide cursor 
    unsafe { (cbreak_wrapper) }
    unsafe { (noecho_wrapper) }
    unsafe { (nl_keypad win 1) }
    unsafe { (timeout_wrapper UPDATE_DELAY_MS) }
    
    # Initialize grid with random population (~30% alive)
    # Seed random number generator
    unsafe { (srand 42) }   # Use fixed seed for reproducibility, or (time 0) for varying
    
    let mut grid: array<int> = []
    let grid_size: int = (* GRID_WIDTH GRID_HEIGHT)
    let alive: CellState = CellState.ALIVE
    let dead: CellState = CellState.DEAD
    let mut i: int = 0
    
    while (< i grid_size) {
        # Generate random number 0-99
        # If < 30, cell is alive (30% probability)
        let r: int = (% (rand) 100)
        
        if (< r 30) {
            set grid (array_push grid alive)
        } else {
            set grid (array_push grid dead)
        }
        
        set i (+ i 1)
    }
    
    let mut generation: int = 0
    let mut running: bool = true
    let mut paused: bool = false

    # Draw an initial frame before entering the loop so the screen isn't blank
    unsafe {     (clear_wrapper) }
    (draw_grid_ncurses grid GRID_WIDTH GRID_HEIGHT)
    unsafe {     (mvprintw_wrapper (+ GRID_HEIGHT 1) 0 (+ "Generation: " (int_to_string generation))) }
    unsafe {     (mvprintw_wrapper (+ GRID_HEIGHT 2) 0 "SPACE=Pause  Q=Quit") }
    unsafe {     (refresh_wrapper) }
    
    # Game loop
    while running {
        # Get input
        let key: int = (getch_wrapper)
        
        if (or (== key KEY_SPACE) (== key (cast_int ' '))) {
            set paused (not paused)
        } else {
            if (or (== key (cast_int 'q')) (== key (cast_int 'Q'))) {
                set running false
            } else {}
        }
        
        # Update simulation (if not paused)
        if (not paused) {
            set grid (step grid GRID_WIDTH GRID_HEIGHT)
            set generation (+ generation 1)
        } else {}
        
        # Draw
        unsafe {         (clear_wrapper) }
        (draw_grid_ncurses grid GRID_WIDTH GRID_HEIGHT)
        
        # Draw UI
        unsafe {         (mvprintw_wrapper (+ GRID_HEIGHT 1) 0 (+ "Generation: " (int_to_string generation))) }
        
        if paused {
            unsafe {             (mvprintw_wrapper (+ GRID_HEIGHT 2) 0 "PAUSED - SPACE=Resume  Q=Quit") }
        } else {
            unsafe {             (mvprintw_wrapper (+ GRID_HEIGHT 2) 0 "SPACE=Pause  Q=Quit") }
        }
        
        unsafe {         (refresh_wrapper) }
    }
    
    # Cleanup
    unsafe {     (endwin_wrapper) }
    
    (println "")
    (println "Game of Life finished!")
    (print "Final generation: ")
    (println generation)
    
    return 0
}

shadow main {
    # Skip running - it's an interactive simulation
    assert true
}
