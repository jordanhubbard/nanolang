/* =============================================================================
 * Checked Arithmetic Operations Demo
 * =============================================================================
 * Demonstrates safe arithmetic that catches overflow, underflow, and division
 * by zero at runtime, returning Result<int, string> instead of crashing.
 * 
 * MISRA Rule 12.4 compliant: All arithmetic operations check for overflow
 * JSF AV Rule 204 compliant: Division operations check for zero divisor
 */

import "modules/stdlib/checked_math.nano"

fn demo_safe_addition() -> int {
    (println "=== SAFE ADDITION ===")
    
    /* Normal addition */
    let r1: Result<int, string> = (checked_add 1000000 2000000)
    match r1 {
        Ok(v) => {
            (print "1000000 + 2000000 = ")
            (println v.value)
        },
        Err(e) => {
            (print "Error: ")
            (println e.error)
        }
    }
    
    /* Negative addition */
    let r2: Result<int, string> = (checked_add -500 300)
    match r2 {
        Ok(v) => {
            (print "-500 + 300 = ")
            (println v.value)
        },
        Err(e) => {
            (print "Error: ")
            (println e.error)
        }
    }
    
    (println "")
    return 0
}

shadow demo_safe_addition {
    assert (== (demo_safe_addition) 0)
}

fn demo_safe_division() -> int {
    (println "=== SAFE DIVISION ===")
    
    /* Normal division */
    let r1: Result<int, string> = (checked_div 100 2)
    match r1 {
        Ok(v) => {
            (print "100 / 2 = ")
            (println v.value)
        },
        Err(e) => {
            (print "Error: ")
            (println e.error)
        }
    }
    
    /* Division by zero - SAFELY CAUGHT! */
    let r2: Result<int, string> = (checked_div 100 0)
    match r2 {
        Ok(v) => {
            (print "100 / 0 = ")
            (println v.value)
        },
        Err(e) => {
            (print "100 / 0 -> Error: ")
            (println e.error)
        }
    }
    
    /* Negative division */
    let r3: Result<int, string> = (checked_div -100 4)
    match r3 {
        Ok(v) => {
            (print "-100 / 4 = ")
            (println v.value)
        },
        Err(e) => {
            (print "Error: ")
            (println e.error)
        }
    }
    
    (println "")
    return 0
}

shadow demo_safe_division {
    assert (== (demo_safe_division) 0)
}

fn demo_safe_multiplication() -> int {
    (println "=== SAFE MULTIPLICATION ===")
    
    /* Normal multiplication */
    let r1: Result<int, string> = (checked_mul 1000 2000)
    match r1 {
        Ok(v) => {
            (print "1000 * 2000 = ")
            (println v.value)
        },
        Err(e) => {
            (print "Error: ")
            (println e.error)
        }
    }
    
    /* Multiplication by zero */
    let r2: Result<int, string> = (checked_mul 999999 0)
    match r2 {
        Ok(v) => {
            (print "999999 * 0 = ")
            (println v.value)
        },
        Err(e) => {
            (print "Error: ")
            (println e.error)
        }
    }
    
    (println "")
    return 0
}

shadow demo_safe_multiplication {
    assert (== (demo_safe_multiplication) 0)
}

fn demo_safe_subtraction() -> int {
    (println "=== SAFE SUBTRACTION ===")
    
    /* Normal subtraction */
    let r1: Result<int, string> = (checked_sub 5000 3000)
    match r1 {
        Ok(v) => {
            (print "5000 - 3000 = ")
            (println v.value)
        },
        Err(e) => {
            (print "Error: ")
            (println e.error)
        }
    }
    
    /* Negative result */
    let r2: Result<int, string> = (checked_sub 100 200)
    match r2 {
        Ok(v) => {
            (print "100 - 200 = ")
            (println v.value)
        },
        Err(e) => {
            (print "Error: ")
            (println e.error)
        }
    }
    
    (println "")
    return 0
}

shadow demo_safe_subtraction {
    assert (== (demo_safe_subtraction) 0)
}

fn demo_safe_modulo() -> int {
    (println "=== SAFE MODULO ===")
    
    /* Normal modulo */
    let r1: Result<int, string> = (checked_mod 17 5)
    match r1 {
        Ok(v) => {
            (print "17 % 5 = ")
            (println v.value)
        },
        Err(e) => {
            (print "Error: ")
            (println e.error)
        }
    }
    
    /* Modulo by zero - SAFELY CAUGHT! */
    let r2: Result<int, string> = (checked_mod 100 0)
    match r2 {
        Ok(v) => {
            (print "100 % 0 = ")
            (println v.value)
        },
        Err(e) => {
            (print "100 % 0 -> Error: ")
            (println e.error)
        }
    }
    
    (println "")
    return 0
}

shadow demo_safe_modulo {
    assert (== (demo_safe_modulo) 0)
}

fn main() -> int {
    (println "")
    (println "╔══════════════════════════════════════════════════════════╗")
    (println "║   CHECKED ARITHMETIC OPERATIONS DEMO                     ║")
    (println "║   Safe arithmetic with overflow/underflow/div-by-0 check ║")
    (println "║   MISRA Rule 12.4 & JSF AV Rule 204 Compliant           ║")
    (println "╚══════════════════════════════════════════════════════════╝")
    (println "")
    
    let r1: int = (demo_safe_addition)
    let r2: int = (demo_safe_division)
    let r3: int = (demo_safe_multiplication)
    let r4: int = (demo_safe_subtraction)
    let r5: int = (demo_safe_modulo)
    
    (println "╔══════════════════════════════════════════════════════════╗")
    (println "║   ✓ All operations completed safely!                     ║")
    (println "║   ✓ Division by zero caught and handled gracefully       ║")
    (println "║   ✓ No crashes, no undefined behavior                    ║")
    (println "╚══════════════════════════════════════════════════════════╝")
    (println "")
    
    return 0
}

shadow main {
    assert (== (main) 0)
}

