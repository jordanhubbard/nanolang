# event_example.nano - libevent async event notification
#
# This example demonstrates libevent event loop basics.

import "modules/event/event.nano"

fn show_version() -> void {
    (println "=== libevent Version ===")
    (print "Version: ")
    (println (nl_event_get_version))
    
    let ver_num: int = (nl_event_get_version_number)
    (print "Version number: ")
    (println ver_num)
    (println "")
}

shadow show_version {
    # Skip - uses extern functions
}

fn test_event_base() -> void {
    (println "=== Event Base Test ===")
    
    # Create event base
    let base: int = (nl_event_base_new)
    
    if (== base 0) {
        (println "Failed to create event base")
        return
    }
    
    (println "Event base created successfully")
    
    # Get backend method
    let method: string = (nl_event_base_get_method base)
    (print "Backend method: ")
    (println method)
    
    # Get number of events
    let num_events: int = (nl_event_base_get_num_events base)
    (print "Number of active events: ")
    (println num_events)
    
    # Check if loop would run
    if (== num_events 0) {
        (println "No events registered - loop would exit immediately")
    }
    
    # Free event base
    (nl_event_base_free base)
    (println "Event base freed")
    (println "")
}

shadow test_event_base {
    # Skip - uses extern functions
}

fn test_timer_event() -> void {
    (println "=== Timer Event Test ===")
    
    let base: int = (nl_event_base_new)
    
    if (== base 0) {
        (println "Failed to create event base")
        return
    }
    
    # Create timer event
    let timer: int = (nl_evtimer_new base)
    
    if (== timer 0) {
        (println "Failed to create timer")
        (nl_event_base_free base)
        return
    }
    
    (println "Timer event created")
    
    # Note: Full timer functionality requires callback support
    # This is a simplified demonstration
    
    # Clean up
    (nl_event_free timer)
    (nl_event_base_free base)
    (println "Timer and base freed")
    (println "")
}

shadow test_timer_event {
    # Skip - uses extern functions
}

fn test_sleep() -> void {
    (println "=== Event-based Sleep Test ===")
    
    let base: int = (nl_event_base_new)
    
    if (== base 0) {
        (println "Failed to create event base")
        return
    }
    
    (println "Sleeping for 1 second using event loop...")
    
    # Schedule loop exit after 1 second
    (nl_event_sleep base 1)
    
    # Run the loop (will exit after timeout)
    let result: int = (nl_event_base_dispatch base)
    
    if (== result 0) {
        (println "Sleep completed successfully")
    } else {
        (println "Sleep returned with code:")
        (println result)
    }
    
    (nl_event_base_free base)
    (println "")
}

shadow test_sleep {
    # Skip - uses extern functions
}

fn test_loop_modes() -> void {
    (println "=== Loop Mode Test ===")
    
    let base: int = (nl_event_base_new)
    
    if (== base 0) {
        (println "Failed to create event base")
        return
    }
    
    # Test non-blocking loop (should return immediately with no events)
    (println "Running non-blocking loop...")
    let result: int = (nl_event_base_loop base 1)
    (print "Result: ")
    (println result)
    
    # Test run-once mode
    (println "Running once mode...")
    set result (nl_event_base_loop base 2)
    (print "Result: ")
    (println result)
    
    (nl_event_base_free base)
    (println "")
}

shadow test_loop_modes {
    # Skip - uses extern functions
}

fn main() -> int {
    (println "libevent Examples for nanolang")
    (println "==============================")
    (println "")
    
    show_version
    test_event_base
    test_timer_event
    test_sleep
    test_loop_modes
    
    (println "All tests completed!")
    (println "")
    (println "Note: Full event handling with callbacks requires")
    (println "additional nanolang support for function pointers.")
    
    return 0
}

shadow main {
    # Skip - uses extern functions
}
