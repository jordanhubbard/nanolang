/* =============================================================================
 * Map and Reduce - Built-in Higher-Order Functions
 * =============================================================================
 * Demonstrates map() and reduce() as first-class language features!
 */

/* ============================================================================
 * Transform Functions for map()
 * ============================================================================
 */

fn double(x: int) -> int {
    return (* x 2)
}

shadow double {
    assert (== (double 5) 10)
    assert (== (double 0) 0)
}

fn square(x: int) -> int {
    return (* x x)
}

shadow square {
    assert (== (square 5) 25)
    assert (== (square 0) 0)
}

fn increment(x: int) -> int {
    return (+ x 1)
}

shadow increment {
    assert (== (increment 5) 6)
    assert (== (increment -1) 0)
}

fn negate(x: int) -> int {
    return (- 0 x)
}

shadow negate {
    assert (== (negate 5) -5)
    assert (== (negate -3) 3)
}

/* ============================================================================
 * Combine Functions for reduce()
 * ============================================================================
 */

fn add(a: int, b: int) -> int {
    return (+ a b)
}

shadow add {
    assert (== (add 2 3) 5)
}

fn multiply(a: int, b: int) -> int {
    return (* a b)
}

shadow multiply {
    assert (== (multiply 4 5) 20)
}

fn maximum(a: int, b: int) -> int {
    if (> a b) {
        return a
    } else {
        return b
    }
}

shadow maximum {
    assert (== (maximum 5 3) 5)
    assert (== (maximum 3 5) 5)
}

fn minimum(a: int, b: int) -> int {
    if (< a b) {
        return a
    } else {
        return b
    }
}

shadow minimum {
    assert (== (minimum 5 3) 3)
    assert (== (minimum 3 5) 3)
}

/* ============================================================================
 * Demonstrate map()
 * ============================================================================
 */

fn demo_map() -> int {
    (println "MAP EXAMPLES:")
    (println "=============")
    (println "")
    
    let numbers: array<int> = [1, 2, 3, 4, 5]
    
    /* Map: double all elements */
    let doubled: array<int> = (map numbers double)
    (print "map([1,2,3,4,5], double) = ")
    (print "[")
    let mut i: int = 0
    while (< i (array_length doubled)) {
        if (> i 0) {
            (print ", ")
        } else {}
        (print (at doubled i))
        set i (+ i 1)
    }
    (println "]")
    (println "  Expected: [2, 4, 6, 8, 10]")
    (println "")
    
    /* Map: square all elements */
    let squared: array<int> = (map numbers square)
    (print "map([1,2,3,4,5], square) = ")
    (print "[")
    set i 0
    while (< i (array_length squared)) {
        if (> i 0) {
            (print ", ")
        } else {}
        (print (at squared i))
        set i (+ i 1)
    }
    (println "]")
    (println "  Expected: [1, 4, 9, 16, 25]")
    (println "")
    
    /* Map: increment all elements */
    let incremented: array<int> = (map numbers increment)
    (print "map([1,2,3,4,5], increment) = ")
    (print "[")
    set i 0
    while (< i (array_length incremented)) {
        if (> i 0) {
            (print ", ")
        } else {}
        (print (at incremented i))
        set i (+ i 1)
    }
    (println "]")
    (println "  Expected: [2, 3, 4, 5, 6]")
    (println "")
    
    /* Map: negate all elements */
    let negated: array<int> = (map numbers negate)
    (print "map([1,2,3,4,5], negate) = ")
    (print "[")
    set i 0
    while (< i (array_length negated)) {
        if (> i 0) {
            (print ", ")
        } else {}
        (print (at negated i))
        set i (+ i 1)
    }
    (println "]")
    (println "  Expected: [-1, -2, -3, -4, -5]")
    (println "")
    
    return 0
}

shadow demo_map {
    assert (== (demo_map) 0)
}

/* ============================================================================
 * Demonstrate reduce()
 * ============================================================================
 */

fn demo_reduce() -> int {
    (println "REDUCE EXAMPLES:")
    (println "================")
    (println "")
    
    let numbers: array<int> = [1, 2, 3, 4, 5]
    
    /* Reduce: sum all elements */
    let sum: int = (reduce numbers 0 add)
    (print "reduce([1,2,3,4,5], 0, add) = ")
    (println sum)
    (println "  Expected: 15 (1+2+3+4+5)")
    (println "")
    
    /* Reduce: product of all elements */
    let product: int = (reduce numbers 1 multiply)
    (print "reduce([1,2,3,4,5], 1, multiply) = ")
    (println product)
    (println "  Expected: 120 (1*2*3*4*5)")
    (println "")
    
    /* Reduce: find maximum */
    let max: int = (reduce numbers 0 maximum)
    (print "reduce([1,2,3,4,5], 0, maximum) = ")
    (println max)
    (println "  Expected: 5")
    (println "")
    
    /* Reduce: find minimum (with large initial value) */
    let mixed: array<int> = [5, 2, 8, 1, 9, 3]
    let min: int = (reduce mixed 999 minimum)
    (print "reduce([5,2,8,1,9,3], 999, minimum) = ")
    (println min)
    (println "  Expected: 1")
    (println "")
    
    return 0
}

shadow demo_reduce {
    assert (== (demo_reduce) 0)
}

/* ============================================================================
 * Combine map() and reduce()
 * ============================================================================
 */

fn demo_combined() -> int {
    (println "COMBINED MAP/REDUCE:")
    (println "====================")
    (println "")
    
    let numbers: array<int> = [1, 2, 3, 4, 5]
    
    /* Sum of squares: map then reduce */
    (println "Sum of squares: map(square) then reduce(add)")
    let squared: array<int> = (map numbers square)
    let sum_of_squares: int = (reduce squared 0 add)
    (print "  Result: ")
    (println sum_of_squares)
    (println "  Expected: 55 (1+4+9+16+25)")
    (println "")
    
    /* Product of doubled values */
    (println "Product of doubled: map(double) then reduce(multiply)")
    let doubled: array<int> = (map numbers double)
    let product_doubled: int = (reduce doubled 1 multiply)
    (print "  Result: ")
    (println product_doubled)
    (println "  Expected: 3840 (2*4*6*8*10)")
    (println "")
    
    return 0
}

shadow demo_combined {
    assert (== (demo_combined) 0)
}

/* ============================================================================
 * Main Program
 * ============================================================================
 */

fn main() -> int {
    (println "╔══════════════════════════════════════════════════════════════╗")
    (println "║  NanoLang: map() and reduce() - First-Class Features       ║")
    (println "╚══════════════════════════════════════════════════════════════╝")
    (println "")
    
    (demo_map)
    (demo_reduce)
    (demo_combined)
    
    (println "╔══════════════════════════════════════════════════════════════╗")
    (println "║  ✅ All map() and reduce() operations successful!          ║")
    (println "╚══════════════════════════════════════════════════════════════╝")
    (println "")
    (println "What This Demonstrates:")
    (println "  ✓ map() transforms each element of an array")
    (println "  ✓ reduce() combines elements with an accumulator")
    (println "  ✓ First-class functions passed as parameters")
    (println "  ✓ Functional programming patterns built into language")
    (println "  ✓ No manual loops needed for common operations")
    (println "")
    
    return 0
}

shadow main {
    assert (== (main) 0)
}

