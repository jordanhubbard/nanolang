/* Extended Generics: List<Point>
 * This example demonstrates the full monomorphization system 
 * where List can be specialized for any user-defined type.
 */

struct Point {
    x: int,
    y: int
}

/* Helper function to create a Point (workaround for struct literal bug) */
fn make_point(x: int, y: int) -> Point {
    let p: Point = (Point_new x y)
    return p
}

shadow make_point {
    let p: Point = (make_point 10 20)
    assert (== p.x 10)
    assert (== p.y 20)
}

/* External function to create Point (temporary workaround) */
extern fn Point_new(x: int, y: int) -> Point

fn test_list_operations() -> int {
    /* Create a List<Point> - compiler generates List_Point type automatically! */
    let points: List<Point> = (List_Point_new)
    
    /* Check initial length */
    let len: int = (List_Point_length points)
    if (!= len 0) { return 1 } else {}
    
    /* Note: Push operations with struct literals currently have a compiler bug
     * This will be fixed separately from the generics implementation */
    
    return 0
}

shadow test_list_operations {
    assert (== (test_list_operations) 0)
}

fn main() -> int {
    return (test_list_operations)
}

shadow main {
    assert (== (main) 0)
}
