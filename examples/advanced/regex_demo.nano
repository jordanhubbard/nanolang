# Example: Regex Demo (Full)
# Purpose: Showcase both one-shot and compiled regex operations with tiered API
# Features: regex, pattern matching, compiled patterns, string manipulation
# Difficulty: Advanced
# Category: advanced
# Prerequisites: regex_demo_simple
# Expected Output: NanoLang Regex - Pythonic API Demo

module "std/regex/regex.nano" as Re

fn quick_replace_all(pattern: string, text: string, replacement: string) -> string {
    let parts: array<string> = (Re.regex_split pattern text)
    if (== (array_length parts) 0) {
        return text
    }
    let mut out: string = ""
    let mut i: int = 0
    let last_index: int = (- (array_length parts) 1)
    while (< i (array_length parts)) {
        set out (+ out (at parts i))
        if (< i last_index) {
            set out (+ out replacement)
        }
        set i (+ i 1)
    }
    return out
}

shadow quick_replace_all {
    (quick_replace_all "b" "abbb" "X")
    assert true
}

# =============================================================================
# TIER 1 DEMOS: Simple One-Shot API (90% of use cases)
# =============================================================================

fn demo_validation() -> void {
    (println "╔════════════════════════════════════════╗")
    (println "║  TIER 1: Simple Validation (No Handles!)  ║")
    (println "╚════════════════════════════════════════╝")
    (println "")
    
    # Email validation - one line, no memory management!
    if (Re.quick_match "[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.[a-z]+" "user@example.com") {
        (println "✓ Valid email: user@example.com")
    }
    
    # Phone validation
    if (Re.quick_match "^[0-9]{3}-[0-9]{3}-[0-9]{4}$" "555-123-4567") {
        (println "✓ Valid phone: 555-123-4567")
    }
    
    if (not (Re.quick_match "^[0-9]{3}-[0-9]{3}-[0-9]{4}$" "invalid")) {
        (println "✗ Invalid phone: invalid")
    }
}

shadow demo_validation {
    (demo_validation)
    assert true
}

fn demo_replacement() -> void {
    (println "")
    (println "╔════════════════════════════════════════╗")
    (println "║  TIER 1: Text Replacement              ║")
    (println "╚════════════════════════════════════════╝")
    (println "")
    
    let text: string = "I have 3 apples and 5 oranges"
    (println (+ "Original:  " text))
    
    # Replace first number - one line!
    let r1: string = (Re.quick_replace "[0-9]+" text "X")
    (println (+ "First:     " r1))
    
    # Replace all numbers - still one line!
    let r2: string = (quick_replace_all "[0-9]+" text "X")
    (println (+ "All:       " r2))
}

shadow demo_replacement {
    (demo_replacement)
    assert true
}

fn demo_split() -> void {
    (println "")
    (println "╔════════════════════════════════════════╗")
    (println "║  TIER 1: Split by Pattern              ║")
    (println "╚════════════════════════════════════════╝")
    (println "")
    
    let csv: string = "apple,banana;cherry,date;elderberry"
    let parts: array<string> = (Re.regex_split "[,;]" csv)
    
    (println (+ "Input: " csv))
    (println (+ "Split into " (+ (int_to_string (array_length parts)) " parts:")))
    
    let mut i: int = 0
    while (< i (array_length parts)) {
        (println (+ "  [" (+ (int_to_string i) (+ "] " (at parts i)))))
        set i (+ i 1)
    }
}

shadow demo_split {
    (demo_split)
    assert true
}

fn demo_find() -> void {
    (println "")
    (println "╔════════════════════════════════════════╗")
    (println "║  TIER 1: Find Pattern Position         ║")
    (println "╚════════════════════════════════════════╝")
    (println "")
    
    let text: string = "The answer is 42 and the year is 2024"
    let pos: int = (Re.quick_find "[0-9]+" text)
    
    (println (+ "Text: " text))
    if (>= pos 0) {
        (println (+ "First number at position: " (int_to_string pos)))
    }
}

shadow demo_find {
    (demo_find)
    assert true
}

# =============================================================================
# TIER 2 DEMOS: Compiled Patterns (Power Users - for performance)
# =============================================================================

fn demo_compiled_loop() -> void {
    (println "")
    (println "╔════════════════════════════════════════╗")
    (println "║  TIER 2: Compiled Pattern in Loop      ║")
    (println "╚════════════════════════════════════════╝")
    (println "")
    (println "Validating 5 emails with ONE compiled pattern...")
    (println "")
    
    # Compile once - efficient for loops
    let email_pattern: Re.Regex = (Re.compile "[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.[a-z]+")
    
    # Test valid email
    if (Re.matches email_pattern "alice@example.com") {
        (println "  ✓ Valid:   alice@example.com")
    } else {
        (println "  ✗ Invalid: alice@example.com")
    }
    
    # Test another valid
    if (Re.matches email_pattern "bob@test.org") {
        (println "  ✓ Valid:   bob@test.org")
    } else {
        (println "  ✗ Invalid: bob@test.org")
    }
    
    # Test invalid
    if (Re.matches email_pattern "invalid.email") {
        (println "  ✓ Valid:   invalid.email")
    } else {
        (println "  ✗ Invalid: invalid.email")
    }
    
    # Test valid
    if (Re.matches email_pattern "charlie@company.net") {
        (println "  ✓ Valid:   charlie@company.net")
    } else {
        (println "  ✗ Invalid: charlie@company.net")
    }
    
    # Test invalid
    if (Re.matches email_pattern "not-an-email") {
        (println "  ✓ Valid:   not-an-email")
    } else {
        (println "  ✗ Invalid: not-an-email")
    }
    
    # GC automatically cleans up - no manual free needed!
    (println "")
    (println "✓ Pattern automatically cleaned up by GC - no memory leaks")
}

shadow demo_compiled_loop {
    (demo_compiled_loop)
    assert true
}

fn demo_comparison() -> void {
    (println "")
    (println "╔════════════════════════════════════════╗")
    (println "║  API Comparison                         ║")
    (println "╚════════════════════════════════════════╝")
    (println "")
    (println "TIER 1 (Simple): One line, automatic cleanup")
    (println "  if (regex_match pattern text) { ... }")
    (println "")
    (println "TIER 2 (Power): Compile once, use many times")
    (println "  let re: opaque = (compile pattern)")
    (println "  if (matches re text1) { ... }")
    (println "  if (matches re text2) { ... }")
    (println "  # GC automatically cleans up when re goes out of scope")
}

shadow demo_comparison {
    (demo_comparison)
    assert true
}

# =============================================================================
# MAIN
# =============================================================================

fn main() -> int {
    (println "")
    (println "═══════════════════════════════════════════════════")
    (println "    NanoLang Regex - Pythonic API Demo")
    (println "    Tier 1: No Memory Management - Tier 2: Manual Free")
    (println "═══════════════════════════════════════════════════")
    (println "")
    
    # Tier 1: Simple one-shot operations
    (demo_validation)
    (demo_replacement)
    (demo_split)
    (demo_find)
    
    # Tier 2: Power user API
    (demo_compiled_loop)
    
    # Comparison
    (demo_comparison)
    
    (println "")
    (println "═══════════════════════════════════════════════════")
    (println "✓ All demos completed successfully!")
    (println "═══════════════════════════════════════════════════")
    
    return 0
}

shadow main {
    (main)
    assert true
}
