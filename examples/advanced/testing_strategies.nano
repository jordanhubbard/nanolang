# Example: Testing Strategies and Best Practices
# Purpose: Comprehensive guide to writing effective shadow tests
# Features: Shadow tests, edge cases, test organization, TDD
# Difficulty: Advanced
# Usage: ./bin/nanoc examples/advanced/testing_strategies.nano -o /tmp/testing && /tmp/testing
# Expected Output: Demonstrates testing best practices
#
# Learning Objectives:
# 1. Write comprehensive shadow tests that cover all cases
# 2. Test edge cases and boundary conditions
# 3. Use Test-Driven Development (TDD) with shadow tests
# 4. Organize tests for readability and maintainability
# 5. Document expected behavior through tests
#
# Shadow Test Philosophy:
# - Tests run at COMPILE TIME (not runtime!)
# - Every function MUST have shadow tests (except extern)
# - Tests are documentation - they show how to use the function
# - Tests catch bugs before the program ever runs

# ==================================================================
# Strategy 1: Test All Code Paths
# ==================================================================

fn absolute_value(x: int) -> int {
    if (< x 0) {
        return (- 0 x)  # Negative path
    } else {
        return x        # Positive path
    }
}

shadow absolute_value {
    # Test negative path
    assert (== (absolute_value -5) 5)
    assert (== (absolute_value -1) 1)
    assert (== (absolute_value -100) 100)
    
    # Test positive path
    assert (== (absolute_value 5) 5)
    assert (== (absolute_value 1) 1)
    assert (== (absolute_value 100) 100)
    
    # Test zero (boundary)
    assert (== (absolute_value 0) 0)
}

# ==================================================================
# Strategy 2: Test Edge Cases and Boundaries
# ==================================================================

fn clamp(value: int, min_val: int, max_val: int) -> int {
    if (< value min_val) {
        return min_val
    } else {}
    
    if (> value max_val) {
        return max_val
    } else {}
    
    return value
}

shadow clamp {
    # Normal cases (within range)
    assert (== (clamp 5 0 10) 5)
    assert (== (clamp 7 0 10) 7)
    
    # Edge case: below minimum
    assert (== (clamp -5 0 10) 0)
    assert (== (clamp -100 0 10) 0)
    
    # Edge case: above maximum
    assert (== (clamp 15 0 10) 10)
    assert (== (clamp 100 0 10) 10)
    
    # Boundary cases: exactly at limits
    assert (== (clamp 0 0 10) 0)   # At minimum
    assert (== (clamp 10 0 10) 10) # At maximum
    
    # Edge case: min == max
    assert (== (clamp 5 7 7) 7)
    assert (== (clamp 10 7 7) 7)
}

# ==================================================================
# Strategy 3: Test-Driven Development (TDD)
# ==================================================================

# Step 1: Write shadow tests FIRST (define expected behavior)
# Step 2: Implement function to make tests pass
# Step 3: Refactor while keeping tests green

fn factorial(n: int) -> int {
    # Implementation written AFTER shadow tests
    if (<= n 1) {
        return 1
    } else {}
    return (* n (factorial (- n 1)))
}

shadow factorial {
    # Written FIRST to define expected behavior
    
    # Base cases
    assert (== (factorial 0) 1)
    assert (== (factorial 1) 1)
    
    # Small values
    assert (== (factorial 2) 2)
    assert (== (factorial 3) 6)
    assert (== (factorial 4) 24)
    assert (== (factorial 5) 120)
    
    # Larger value
    assert (== (factorial 10) 3628800)
}

# ==================================================================
# Strategy 4: Test Error Conditions
# ==================================================================

fn safe_divide(a: int, b: int) -> int {
    if (== b 0) {
        return -1  # Error code
    } else {}
    return (/ a b)
}

shadow safe_divide {
    # Success cases
    assert (== (safe_divide 10 2) 5)
    assert (== (safe_divide 15 3) 5)
    assert (== (safe_divide 7 2) 3)  # Integer division
    
    # Error case: division by zero
    assert (== (safe_divide 10 0) -1)
    assert (== (safe_divide 0 0) -1)
    assert (== (safe_divide -5 0) -1)
}

# ==================================================================
# Strategy 5: Test with Different Input Types
# ==================================================================

fn is_even(n: int) -> bool {
    return (== (% n 2) 0)
}

shadow is_even {
    # Positive even numbers
    assert (== (is_even 0) true)
    assert (== (is_even 2) true)
    assert (== (is_even 100) true)
    
    # Positive odd numbers
    assert (== (is_even 1) false)
    assert (== (is_even 3) false)
    assert (== (is_even 99) false)
    
    # Negative even numbers
    assert (== (is_even -2) true)
    assert (== (is_even -100) true)
    
    # Negative odd numbers
    assert (== (is_even -1) false)
    assert (== (is_even -99) false)
}

# ==================================================================
# Strategy 6: Test Complex Data Structures
# ==================================================================

fn array_sum(arr: array<int>) -> int {
    let len: int = (array_length arr)
    let mut sum: int = 0
    let mut i: int = 0
    
    while (< i len) {
        set sum (+ sum (at arr i))
        set i (+ i 1)
    }
    
    return sum
}

shadow array_sum {
    # Empty array
    let empty: array<int> = []
    assert (== (array_sum empty) 0)
    
    # Single element
    let single: array<int> = [42]
    assert (== (array_sum single) 42)
    
    # Multiple elements
    let multi: array<int> = [1, 2, 3, 4, 5]
    assert (== (array_sum multi) 15)
    
    # Negative numbers
    let negative: array<int> = [-1, -2, -3]
    assert (== (array_sum negative) -6)
    
    # Mixed positive and negative
    let mixed: array<int> = [10, -5, 3, -2]
    assert (== (array_sum mixed) 6)
}

# ==================================================================
# Strategy 7: Test Recursive Functions
# ==================================================================

fn fibonacci(n: int) -> int {
    if (<= n 1) {
        return n
    } else {}
    return (+ (fibonacci (- n 1)) (fibonacci (- n 2)))
}

shadow fibonacci {
    # Base cases (critical for recursion!)
    assert (== (fibonacci 0) 0)
    assert (== (fibonacci 1) 1)
    
    # Recursive cases
    assert (== (fibonacci 2) 1)
    assert (== (fibonacci 3) 2)
    assert (== (fibonacci 4) 3)
    assert (== (fibonacci 5) 5)
    assert (== (fibonacci 6) 8)
    assert (== (fibonacci 7) 13)
    
    # Larger value to ensure recursion works
    assert (== (fibonacci 10) 55)
}

# ==================================================================
# Strategy 8: Organize Tests by Category
# ==================================================================

fn demo_string_length(s: string) -> int {
    return (str_length s)
}

shadow demo_string_length {
    # Category: Empty strings
    assert (== (demo_string_length "") 0)
    
    # Category: Single character
    assert (== (demo_string_length "a") 1)
    assert (== (demo_string_length "X") 1)
    
    # Category: Short strings
    assert (== (demo_string_length "hi") 2)
    assert (== (demo_string_length "cat") 3)
    
    # Category: Longer strings
    assert (== (demo_string_length "hello") 5)
    assert (== (demo_string_length "NanoLang") 8)
    
    # Category: Special characters
    assert (== (demo_string_length "hello world!") 12)
}

# ==================================================================
# Best Practices Summary
# ==================================================================

# 1. ✅ Test all code paths (if/else branches)
# 2. ✅ Test edge cases (0, negative, max, min)
# 3. ✅ Test boundary conditions (exactly at limits)
# 4. ✅ Test error conditions (invalid input)
# 5. ✅ Test with different input types (positive, negative, zero)
# 6. ✅ Test complex data (arrays, structs, nested data)
# 7. ✅ Test recursive base cases (critical!)
# 8. ✅ Organize tests by category (readability)
# 9. ✅ Use descriptive test cases (show expected behavior)
# 10. ✅ Write tests FIRST (TDD approach)

fn main() -> int {
    (println "Testing Strategies Demo")
    (println "All shadow tests passed at compile time!")
    (println "")
    
    (println "Strategy 1: All Code Paths")
    (println (absolute_value -5))  # 5
    (println (absolute_value 5))   # 5
    (println "")
    
    (println "Strategy 2: Edge Cases")
    (println (clamp -5 0 10))  # 0 (clamped to min)
    (println (clamp 15 0 10))  # 10 (clamped to max)
    (println (clamp 5 0 10))   # 5 (within range)
    (println "")
    
    (println "Strategy 3: TDD")
    (println (factorial 5))  # 120
    (println "")
    
    (println "Strategy 4: Error Conditions")
    (println (safe_divide 10 2))  # 5
    (println (safe_divide 10 0))  # -1 (error)
    (println "")
    
    (println "Strategy 7: Recursion")
    (println (fibonacci 10))  # 55
    
    return 0
}

shadow main {
    assert (== (main) 0)
}

