# Example: Assert With Bead
# Purpose: Demonstrate automatic issue creation from failed assertions using beads
# Features: beads, assertions, issue tracking, validation
# Difficulty: Advanced
# Category: advanced
# Prerequisites: beads_basic_usage
# Expected Output: === assert_with_bead Example ===

from "stdlib/beads.nano" import assert_with_bead, assert_with_bead_context

# Example function with validation
fn divide(a: int, b: int) -> int {
    # Use assert_with_bead instead of regular assert
    # If this fails, it will create a P0 bug automatically
    (assert_with_bead
        (!= b 0)
        "Division by zero detected"
        0
        "Attempted to divide by zero in divide() function"
    )
    
    return (/ a b)
}

shadow divide {
    assert (== (divide 10 2) 5)
    assert (== (divide 20 4) 5)
    # Note: Can't test divide by zero in shadow test as it would create a bead
}

# Example: Data validation with automatic issue creation
fn validate_user_input(age: int, name: string) -> bool {
    let mut all_valid: bool = true
    
    # Age validation - creates P1 bug if fails
    if (not (assert_with_bead
        (and (>= age 0) (< age 150))
        "Invalid age value detected"
        1
        (+ "Age validation failed: " (int_to_string age))
    )) {
        set all_valid false
    }
    
    # Name validation - creates P2 bug if fails
    if (not (assert_with_bead
        (> (str_length name) 0)
        "Empty name detected"
        2
        "Name field cannot be empty"
    )) {
        set all_valid false
    }
    
    return all_valid
}

shadow validate_user_input {
    assert (== (validate_user_input 25 "Alice") true)
    assert (== (validate_user_input 30 "Bob") true)
}

# Example: Using context-aware assertions
fn process_array(arr: array<int>) -> int {
    # Enhanced assertion with file/line context
    (assert_with_bead_context
        (> (array_length arr) 0)
        "Empty array passed to process_array"
        1
        "beads_assert_with_bead.nano"
        45
        "process_array() requires non-empty array"
    )
    
    let mut sum: int = 0
    for i in (range 0 (array_length arr)) {
        set sum (+ sum (at arr i))
    }
    
    return sum
}

shadow process_array {
    let test_arr: array<int> = (array_new 3 0)
    (array_set test_arr 0 1)
    (array_set test_arr 1 2)
    (array_set test_arr 2 3)
    assert (== (process_array test_arr) 6)
}

# Example: Batch validation with prioritized issues
fn validate_config(max_connections: int, timeout_ms: int, retry_count: int) -> bool {
    let mut valid: bool = true
    
    # Critical validation - P0
    if (not (assert_with_bead
        (> max_connections 0)
        "Invalid max_connections: must be positive"
        0
        (+ "max_connections=" (int_to_string max_connections))
    )) {
        set valid false
    }
    
    # Important validation - P1
    if (not (assert_with_bead
        (>= timeout_ms 100)
        "Timeout too low: may cause premature failures"
        1
        (+ "timeout_ms=" (int_to_string timeout_ms))
    )) {
        set valid false
    }
    
    # Nice-to-have validation - P3
    if (not (assert_with_bead
        (<= retry_count 10)
        "Retry count excessive: may cause performance issues"
        3
        (+ "retry_count=" (int_to_string retry_count))
    )) {
        set valid false
    }
    
    return valid
}

shadow validate_config {
    assert (== (validate_config 100 1000 3) true)
    assert (== (validate_config 50 500 5) true)
}

fn main() -> int {
    (println "=== assert_with_bead Example ===")
    (println "")
    (println "This example demonstrates automatic issue creation from assertions.")
    (println "When an assertion fails, a bead is created automatically.")
    (println "")
    
    # Example 1: Basic assertion
    (println "1. Testing divide function...")
    let result1: int = (divide 10 2)
    (println (+ "   10 / 2 = " (int_to_string result1)))
    (println "")
    
    # Example 2: Validation with multiple assertions
    (println "2. Testing user input validation...")
    let valid1: bool = (validate_user_input 25 "Alice")
    (println (+ "   validate_user_input(25, 'Alice') = " (cond ((== valid1 true) "valid") (else "invalid"))))
    
    let valid2: bool = (validate_user_input -5 "")
    (println (+ "   validate_user_input(-5, '') = " (cond ((== valid2 true) "valid") (else "invalid"))))
    (println "   (If invalid, beads were created for the failures)")
    (println "")
    
    # Example 3: Array processing
    (println "3. Testing array processing...")
    let test_arr: array<int> = (array_new 3 0)
    (array_set test_arr 0 5)
    (array_set test_arr 1 10)
    (array_set test_arr 2 15)
    let sum: int = (process_array test_arr)
    (println (+ "   Sum of [5, 10, 15] = " (int_to_string sum)))
    (println "")
    
    # Example 4: Config validation
    (println "4. Testing config validation...")
    let config_valid: bool = (validate_config 100 1000 3)
    (println (+ "   validate_config(100, 1000, 3) = " (cond ((== config_valid true) "valid") (else "invalid"))))
    (println "")
    
    (println "âœ“ Example complete!")
    (println "")
    (println "Check 'bd list' to see any beads created by failed assertions.")
    
    return 0
}

shadow main {
    assert (== (main) 0)
}
