# Example: Error Handling Patterns
# Purpose: Demonstrate comprehensive error handling strategies in NanoLang
# Features: return codes, sentinel values, early returns, validation
# Difficulty: Advanced
# Category: advanced
# Prerequisites: none
# Expected Output: Error Handling Patterns Demo
#
# Learning Objectives:
# 1. Use return codes for error signaling (0 = success, non-zero = error)
# 2. Implement validation functions that return bool
# 3. Use early returns to handle error cases first
# 4. Design APIs that make errors explicit
# 5. Document error conditions in shadow tests
#
# NanoLang Philosophy:
# - Explicit over implicit: errors are return values, not exceptions
# - Fail fast: validate inputs early and return immediately on error
# - Document behavior: shadow tests show both success and failure cases

# Pattern 1: Return Code (0 = success, negative = error code)
fn divide_safe(a: int, b: int) -> int {
    # Error case: division by zero
    if (== b 0) {
        return -1  # Error code: division by zero
    } else {}
    
    # Success case
    return (/ a b)
}

shadow divide_safe {
    # Success cases
    assert (== (divide_safe 10 2) 5)
    assert (== (divide_safe 7 3) 2)
    
    # Error case: division by zero returns -1
    assert (== (divide_safe 10 0) -1)
}

# Pattern 2: Validation Function (returns bool)
fn is_valid_age(age: int) -> bool {
    return (and (>= age 0) (<= age 150))
}

shadow is_valid_age {
    # Valid ages
    assert (== (is_valid_age 0) true)
    assert (== (is_valid_age 25) true)
    assert (== (is_valid_age 150) true)
    
    # Invalid ages
    assert (== (is_valid_age -1) false)
    assert (== (is_valid_age 151) false)
}

# Pattern 3: Early Return for Error Cases
fn process_value(x: int) -> int {
    # Validate input first (early return pattern)
    if (< x 0) {
        return -1  # Error: negative input
    } else {}
    
    if (> x 1000) {
        return -2  # Error: value too large
    } else {}
    
    # Main logic only runs for valid input
    return (* x 2)
}

shadow process_value {
    # Success cases
    assert (== (process_value 0) 0)
    assert (== (process_value 10) 20)
    assert (== (process_value 500) 1000)
    
    # Error cases
    assert (== (process_value -1) -1)   # Negative input
    assert (== (process_value 1001) -2) # Too large
}

# Pattern 4: Sentinel Value (-1 for "not found")
fn find_in_array(arr: array<int>, target: int) -> int {
    let len: int = (array_length arr)
    
    let mut i: int = 0
    while (< i len) {
        if (== (at arr i) target) {
            return i  # Found: return index
        } else {}
        set i (+ i 1)
    }
    
    return -1  # Not found: sentinel value
}

shadow find_in_array {
    let test_arr: array<int> = [10, 20, 30, 40, 50]
    
    # Success cases: element found
    assert (== (find_in_array test_arr 10) 0)
    assert (== (find_in_array test_arr 30) 2)
    assert (== (find_in_array test_arr 50) 4)
    
    # Error case: element not found
    assert (== (find_in_array test_arr 99) -1)
}

# Pattern 5: Validate-Then-Process
fn safe_sqrt(x: int) -> int {
    # Validation
    if (< x 0) {
        return -1  # Error: cannot take sqrt of negative
    } else {}
    
    # Processing (simplified integer sqrt)
    let mut guess: int = x
    let mut i: int = 0
    
    while (< i 10) {
        if (== guess 0) {
            return 0
        } else {}
        
        let new_guess: int = (/ (+ guess (/ x guess)) 2)
        set guess new_guess
        set i (+ i 1)
    }
    
    return guess
}

shadow safe_sqrt {
    # Success cases
    assert (== (safe_sqrt 0) 0)
    assert (== (safe_sqrt 1) 1)
    assert (== (safe_sqrt 4) 2)
    assert (== (safe_sqrt 9) 3)
    assert (== (safe_sqrt 16) 4)
    
    # Error case: negative input
    assert (== (safe_sqrt -1) -1)
}

# Pattern 6: Chaining Validations
fn validate_and_compute(a: int, b: int, c: int) -> int {
    # Chain of validations
    if (< a 0) {
        return -1  # Error: a is negative
    } else {}
    
    if (< b 0) {
        return -2  # Error: b is negative
    } else {}
    
    if (< c 0) {
        return -3  # Error: c is negative
    } else {}
    
    if (== b 0) {
        return -4  # Error: b is zero (division)
    } else {}
    
    # All validations passed, compute result
    return (/ (+ a c) b)
}

shadow validate_and_compute {
    # Success case
    assert (== (validate_and_compute 10 2 6) 8)  # (10+6)/2 = 8
    
    # Error cases with specific codes
    assert (== (validate_and_compute -1 2 6) -1)  # a negative
    assert (== (validate_and_compute 10 -1 6) -2) # b negative
    assert (== (validate_and_compute 10 2 -1) -3) # c negative
    assert (== (validate_and_compute 10 0 6) -4)  # b is zero
}

fn main() -> int {
    (println "Error Handling Patterns Demo")
    (println "")
    
    # Pattern 1: Return codes
    (println "Pattern 1: Return Codes")
    (println (divide_safe 10 2))  # 5
    (println (divide_safe 10 0))  # -1 (error)
    (println "")
    
    # Pattern 2: Validation
    (println "Pattern 2: Validation Functions")
    (println (is_valid_age 25))   # true
    (println (is_valid_age -5))   # false
    (println "")
    
    # Pattern 3: Early returns
    (println "Pattern 3: Early Returns")
    (println (process_value 10))   # 20
    (println (process_value -1))   # -1 (error)
    (println (process_value 2000)) # -2 (error)
    (println "")
    
    # Pattern 4: Sentinel values
    (println "Pattern 4: Sentinel Values")
    let arr: array<int> = [10, 20, 30]
    (println (find_in_array arr 20))  # 1 (found at index 1)
    (println (find_in_array arr 99))  # -1 (not found)
    (println "")
    
    # Pattern 5: Validate-then-process
    (println "Pattern 5: Validate-Then-Process")
    (println (safe_sqrt 16))  # 4
    (println (safe_sqrt -1))  # -1 (error)
    (println "")
    
    # Pattern 6: Chained validations
    (println "Pattern 6: Chained Validations")
    (println (validate_and_compute 10 2 6))  # 8
    (println (validate_and_compute -1 2 6))  # -1 (error code)
    
    return 0
}

shadow main {
    assert (== (main) 0)
}

