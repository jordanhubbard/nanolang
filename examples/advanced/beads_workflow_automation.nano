# Example: Beads Workflow Automation
# Purpose: Demonstrate programmatic issue management and automated triage with beads
# Features: beads, workflow automation, issue triage, priority management
# Difficulty: Advanced
# Category: advanced
# Prerequisites: beads_basic_usage
# Expected Output: === Automatic Issue Triage ===

from "stdlib/beads.nano" import 
    Bead, BeadStats, BeadCreateOptions,
    bd_open, bd_ready, bd_by_priority, bd_stats,
    bd_create, bd_create_with_options, bd_close

# Automatically triage issues based on project state
fn auto_triage() -> int {
    (println "=== Automatic Issue Triage ===")
    (println "")
    
    let stats: BeadStats = (bd_stats)
    
    (println "Current project status:")
    (println (+ "  Open: " (int_to_string stats.open)))
    (println (+ "  In Progress: " (int_to_string stats.in_progress)))
    (println (+ "  Ready to work: " (int_to_string stats.ready_to_work)))
    (println "")
    
    # Check for urgent work
    let p0_beads: array<Bead> = (bd_by_priority 0)
    let p0_count: int = (array_length p0_beads)
    
    if (> p0_count 0) {
        (println "⚠️  URGENT: Found P0 issues!")
        (println (+ "   " (+ (int_to_string p0_count) " critical issues need immediate attention")))
        return 1
    }
    
    # Check work capacity
    if (> stats.ready_to_work 0) {
        (println "✓ Work available:")
        (println (+ "  " (+ (int_to_string stats.ready_to_work) " issues ready to start")))
    } else {
        (println "ℹ️  No issues ready to work")
        if (> stats.blocked 0) {
            (println (+ "   " (+ (int_to_string stats.blocked) " issues are blocked")))
        }
    }
    
    return 0
}

shadow auto_triage {
    # Should run without crashing
    let result: int = (auto_triage)
    assert (or (== result 0) (== result 1))
}

# Create standardized bug report
fn create_bug_report(
    title: string,
    error_message: string,
    file: string,
    line: int,
    is_critical: bool
) -> string {
    let priority: int = (cond ((== is_critical true) 0) (else 1))
    
    let mut description: string = "Bug Report\n\n"
    set description (+ description (+ "Error: " error_message))
    set description (+ description (+ "\nLocation: " file))
    set description (+ description (+ ":" (int_to_string line)))
    set description (+ description "\n\nAutomatic bug report generated by workflow automation.")
    
    let labels: array<string> = (array_new 2 "")
    (array_set labels 0 "bug")
    let severity_label: string = (cond ((== is_critical true) "critical") (else "normal"))
    (array_set labels 1 severity_label)
    
    let opts: BeadCreateOptions = BeadCreateOptions {
        title: title,
        description: description,
        priority: priority,
        issue_type: "bug",
        labels: labels
    }
    
    return (bd_create_with_options opts)
}

shadow create_bug_report {
    # Test with non-critical bug (won't actually create if bd unavailable)
    let id: string = (create_bug_report
        "Test bug"
        "Null pointer exception"
        "test.nano"
        42
        false
    )
    # Should return empty string or valid ID
    assert true
}

# Create feature request with proper categorization
fn create_feature_request(
    feature_name: string,
    use_case: string,
    priority: int
) -> string {
    let mut description: string = "Feature Request\n\n"
    set description (+ description (+ "Feature: " feature_name))
    set description (+ description (+ "\n\nUse Case:\n" use_case))
    set description (+ description "\n\nAutomatically created feature request.")
    
    let labels: array<string> = (array_new 2 "")
    (array_set labels 0 "feature")
    (array_set labels 1 "enhancement")
    
    let opts: BeadCreateOptions = BeadCreateOptions {
        title: feature_name,
        description: description,
        priority: priority,
        issue_type: "feature",
        labels: labels
    }
    
    return (bd_create_with_options opts)
}

shadow create_feature_request {
    let id: string = (create_feature_request
        "Test feature"
        "Testing feature creation"
        3
    )
    assert true
}

# Batch close completed tasks
fn close_completed_tasks(task_ids: array<string>, reason: string) -> int {
    let mut closed_count: int = 0
    
    for i in (range 0 (array_length task_ids)) {
        let id: string = (at task_ids i)
        let success: bool = (bd_close id reason)
        
        if success {
            set closed_count (+ closed_count 1)
            (println (+ "✓ Closed: " id))
        } else {
            (println (+ "✗ Failed: " id))
        }
    }
    
    return closed_count
}

shadow close_completed_tasks {
    let empty: array<string> = (array_new 0 "")
    let count: int = (close_completed_tasks empty "test")
    assert (== count 0)
}

# Generate daily summary report
fn daily_summary() -> int {
    (println "=== Daily Issue Summary ===")
    (println "")
    
    let stats: BeadStats = (bd_stats)
    
    # Overall health
    let total_active: int = (+ stats.open (+ stats.in_progress stats.blocked))
    let mut completion_rate: int = 0
    if (> stats.total 0) {
        set completion_rate (/ (* stats.closed 100) stats.total)
    } else {}
    
    (println "Project Health:")
    (println (+ "  Total issues: " (int_to_string stats.total)))
    (println (+ "  Active: " (int_to_string total_active)))
    (println (+ "  Closed: " (int_to_string stats.closed)))
    (println (+ "  Completion rate: " (+ (int_to_string completion_rate) "%")))
    (println "")
    
    # Priority breakdown
    (println "By Priority:")
    for p in (range 0 5) {
        let priority_beads: array<Bead> = (bd_by_priority p)
        let count: int = (array_length priority_beads)
        (println (+ "  P" (+ (int_to_string p) (+ ": " (+ (int_to_string count) " issues")))))
    }
    (println "")
    
    # Action items
    (println "Action Items:")
    let ready: array<Bead> = (bd_ready)
    if (> (array_length ready) 0) {
        (println (+ "  ✓ " (+ (int_to_string (array_length ready)) " issues ready to work")))
    }
    if (> stats.blocked 0) {
        (println (+ "  ⚠️  " (+ (int_to_string stats.blocked) " issues are blocked")))
    }
    
    return 0
}

shadow daily_summary {
    let result: int = (daily_summary)
    assert (== result 0)
}

fn main() -> int {
    (println "=== Beads Workflow Automation ===")
    (println "")
    
    # Run triage
    (println "1. Running automatic triage...")
    (println "")
    let triage_result: int = (auto_triage)
    (println "")
    
    # Example: Create a bug report
    (println "2. Creating example bug report...")
    let bug_id: string = (create_bug_report
        "Example bug from automation"
        "Division by zero in calculate()"
        "calculator.nano"
        142
        false
    )
    if (!= bug_id "") {
        (println (+ "   ✓ Created bug: " bug_id))
    } else {
        (println "   ℹ️  Bug creation skipped (bd not available)")
    }
    (println "")
    
    # Example: Create a feature request
    (println "3. Creating example feature request...")
    let feature_id: string = (create_feature_request
        "Add caching layer"
        "Improve performance by caching frequently accessed data"
        2
    )
    if (!= feature_id "") {
        (println (+ "   ✓ Created feature: " feature_id))
    } else {
        (println "   ℹ️  Feature creation skipped (bd not available)")
    }
    (println "")
    
    # Generate daily summary
    (println "4. Generating daily summary...")
    (println "")
    let summary_result: int = (daily_summary)
    (println "")
    
    (println "✓ Workflow automation complete!")
    
    return 0
}

shadow main {
    assert (== (main) 0)
}
