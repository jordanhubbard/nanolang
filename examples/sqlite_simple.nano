# Simple SQLite Database Example  
# Demonstrates SECURE database operations with SQLite3
#
# Concept: Safe database CRUD with prepared statements
# Topics: SQL, database security, parameter binding
# Difficulty: Intermediate
#
# Description:
# Shows secure database operations using prepared statements
# to prevent SQL injection attacks. Demonstrates proper use
# of nl_sqlite3_prepare with result iteration.
#
# Key Features Demonstrated:
# - Prepared statements (nl_sqlite3_prepare) for queries
# - Result iteration with nl_sqlite3_step
# - Column access (nl_sqlite3_column_*)
# - Proper resource cleanup (nl_sqlite3_finalize)
#
# SECURITY NOTE:
# This example is SAFE because it uses:
# ‚úÖ Hardcoded SQL strings (no user input concatenation)
# ‚úÖ Prepared statements for queries
#
# For dynamic queries with user input, ALWAYS use parameter binding:
# ‚úÖ SAFE:   let stmt = (nl_sqlite3_prepare db "SELECT * FROM users WHERE id = ?")
#            (nl_sqlite3_bind_int stmt 1 user_id)
#
# ‚ùå UNSAFE: Concatenating user input into SQL string
#            This would allow SQL injection attacks!

module "modules/sqlite/sqlite.nano"

fn main() -> int {
    (println "")
    (println "üìá SQLite Database Example")
    (println "==========================")
    (println "")
    
    # Open database
    let db_path: string = "test.db"
    let db: int = (nl_sqlite3_open db_path)
    
    if (== db 0) {
        (println "‚ùå Failed to open database")
        return 1
    } else {
        (print "‚úì Database opened: ")
        (println db_path)
    }
    
    # Create table
    (println "")
    (println "Creating table...")
    let create_sql: string = "CREATE TABLE IF NOT EXISTS contacts (id INTEGER PRIMARY KEY, name TEXT, email TEXT)"
    let create_result: int = (nl_sqlite3_exec db create_sql)
    
    if (== create_result 0) {
        (println "‚úì Table created")
    } else {
        (print "‚ùå Create failed: ")
        (println (nl_sqlite3_errmsg db))
    }
    
    # Insert data
    (println "")
    (println "Inserting contacts...")
    let insert1: string = "INSERT INTO contacts (name, email) VALUES ('Alice', 'alice@example.com')"
    (nl_sqlite3_exec db insert1)
    (println "‚úì Inserted Alice")
    
    let insert2: string = "INSERT INTO contacts (name, email) VALUES ('Bob', 'bob@example.com')"
    (nl_sqlite3_exec db insert2)
    (println "‚úì Inserted Bob")
    
    # Query data
    (println "")
    (println "Querying all contacts...")
    (println "")
    
    let select_sql: string = "SELECT id, name, email FROM contacts"
    let stmt: int = (nl_sqlite3_prepare db select_sql)
    
    if (== stmt 0) {
        (println "‚ùå Failed to prepare query")
    } else {
        let mut running: bool = true
        let mut count: int = 0
        
        while running {
            let result: int = (nl_sqlite3_step stmt)
            
            if (== result 100) {  # SQLITE_ROW
                set count (+ count 1)
                
                let id: int = (nl_sqlite3_column_int stmt 0)
                let name: string = (nl_sqlite3_column_text stmt 1)
                let email: string = (nl_sqlite3_column_text stmt 2)
                
                (print "ID: ")
                (print id)
                (print " | Name: ")
                (print name)
                (print " | Email: ")
                (println email)
            } else {
                set running false
            }
        }
        
        (nl_sqlite3_finalize stmt)
        
        (println "")
        (print "Total: ")
        (print count)
        (println " contacts")
    }
    
    # Close database
    (nl_sqlite3_close db)
    
    (println "")
    (println "‚úÖ Database operations completed!")
    (println "")
    (print "View with: sqlite3 ")
    (println db_path)
    (println "")
    
    return 0
}

shadow main {
    # Uses extern functions
    assert true
}
