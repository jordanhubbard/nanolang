# Snake Game - NCurses Version
# Interactive terminal snake game with proper UI

import "modules/ncurses/ncurses.nano"

# === ENUMS ===
enum Direction {
    UP = 0,
    RIGHT = 1,
    DOWN = 2,
    LEFT = 3
}

# === CONSTANTS ===
let GRID_WIDTH: int = 40
let GRID_HEIGHT: int = 20
let INITIAL_LENGTH: int = 3
let GAME_SPEED_MS: int = 100

# === HELPER FUNCTIONS ===

fn grid_index(x: int, y: int, width: int) -> int {
    return (+ (* y width) x)
}

shadow grid_index {
    assert (== (grid_index 0 0 10) 0)
    assert (== (grid_index 3 2 10) 23)
}

fn is_valid_pos(x: int, y: int, width: int, height: int) -> bool {
    # Modern boolean expression
    return (and (and (>= x 0) (< x width))
                (and (>= y 0) (< y height)))
}

shadow is_valid_pos {
    assert (is_valid_pos 0 0 10 10)
    assert (not (is_valid_pos (- 1) 0 10 10))
    assert (not (is_valid_pos 0 10 10 10))
}

fn check_self_collision(snake_x: array<int>, snake_y: array<int>, length: int) -> bool {
    if (< length 2) {
        return false
    } else {}
    
    let head_x: int = (at snake_x 0)
    let head_y: int = (at snake_y 0)
    
    # Modern for loop with boolean expression
    for i in (range 1 length) {
        if (and (== head_x (at snake_x i)) (== head_y (at snake_y i))) {
            return true
        } else {}
    }
    
    return false
}

shadow check_self_collision {
    let snake_x: array<int> = [5, 4, 5]
    let snake_y: array<int> = [5, 5, 5]
    assert (check_self_collision snake_x snake_y 3)
}

fn draw_border(width: int, height: int) -> void {
    # Draw top border (modern for loop)
    unsafe { (mvaddch_wrapper 0 0 (cast_int '+')) }
    for x in (range 1 (+ width 1)) {
        unsafe { (mvaddch_wrapper 0 x (cast_int '-')) }
    }
    unsafe { (mvaddch_wrapper 0 (+ width 1) (cast_int '+')) }
    
    # Draw sides (modern for loop)
    for y in (range 1 (+ height 1)) {
        unsafe { (mvaddch_wrapper y 0 (cast_int '|')) }
        unsafe { (mvaddch_wrapper y (+ width 1) (cast_int '|')) }
    }
    
    # Draw bottom border (modern for loop)
    unsafe { (mvaddch_wrapper (+ height 1) 0 (cast_int '+')) }
    for x in (range 1 (+ width 1)) {
        unsafe { (mvaddch_wrapper (+ height 1) x (cast_int '-')) }
    }
    unsafe { (mvaddch_wrapper (+ height 1) (+ width 1) (cast_int '+')) }
}

shadow draw_border {
    assert true
}

fn draw_game(snake_x: array<int>, snake_y: array<int>, food_x: int, food_y: int, length: int, score: int) -> void {
    unsafe {     (clear_wrapper) }
    
    # Draw border
    (draw_border GRID_WIDTH GRID_HEIGHT)
    
    # Draw snake (modern for loop)
    for i in (range 0 length) {
        let sx: int = (at snake_x i)
        let sy: int = (at snake_y i)
        
        let screen_x: int = (+ sx 1)
        let screen_y: int = (+ sy 1)
        
        if (== i 0) {
            # Head
            unsafe { (mvaddch_wrapper screen_y screen_x (cast_int 'O')) }
        } else {
            # Body
            unsafe { (mvaddch_wrapper screen_y screen_x (cast_int 'o')) }
        }
    }
    
    # Draw food
    let food_screen_x: int = (+ food_x 1)
    let food_screen_y: int = (+ food_y 1)
    unsafe { (mvaddch_wrapper food_screen_y food_screen_x (cast_int '*')) }
    
    # Draw score
    unsafe {     (mvprintw_wrapper (+ GRID_HEIGHT 3) 0 (+ "Score: " (int_to_string score))) }
    unsafe {     (mvprintw_wrapper (+ GRID_HEIGHT 4) 0 "Arrow Keys = Move  |  Q = Quit") }
    
    unsafe {     (refresh_wrapper) }
}

shadow draw_game {
    assert true
}

fn place_food(old_food_x: int, old_food_y: int, _length: int) -> int {
    # Simple deterministic food placement
    let mut food_x: int = (+ old_food_x 7)
    let mut food_y: int = (+ old_food_y 5)
    
    # Wrap around grid
    if (>= food_x GRID_WIDTH) {
        set food_x (- food_x GRID_WIDTH)
    } else {}
    
    if (>= food_y GRID_HEIGHT) {
        set food_y (- food_y GRID_HEIGHT)
    } else {}
    
    # Return food position encoded as (y * width + x)
    return (grid_index food_x food_y GRID_WIDTH)
}

shadow place_food {
    /* Deterministic placement based on old coords */
    assert (== (place_food 0 0 0) (grid_index 7 5 GRID_WIDTH))
}

# === MAIN GAME ===

fn main() -> int {
    (println "Starting Snake (NCurses)...")
    (println "")
    
    # Initialize ncurses
    let win: int = (initscr_wrapper)
    unsafe { (curs_set_wrapper 0) } # Hide cursor 
    unsafe { (nl_nodelay win 1) }   # Non-blocking input
    unsafe { (nl_keypad win 1) }    # Enable arrow keys
    unsafe { (timeout_wrapper 100) } # 100ms timeout for getch
    
    # Initialize game state
    let mut snake_x: array<int> = []
    let mut snake_y: array<int> = []
    
    # Start snake in middle
    let start_x: int = (/ GRID_WIDTH 2)
    let start_y: int = (/ GRID_HEIGHT 2)
    
    set snake_x (array_push snake_x start_x)
    set snake_y (array_push snake_y start_y)
    
    set snake_x (array_push snake_x (- start_x 1))
    set snake_y (array_push snake_y start_y)
    
    set snake_x (array_push snake_x (- start_x 2))
    set snake_y (array_push snake_y start_y)
    
    let mut snake_length: int = INITIAL_LENGTH
    let mut direction: int = Direction.RIGHT
    let mut next_direction: int = Direction.RIGHT
    
    # Place initial food
    let mut food_x: int = 25
    let mut food_y: int = 10
    
    let mut score: int = 0
    let mut running: bool = true
    let mut game_over: bool = false
    
    # Game loop
    while running {
        # Get input
        let key: int = (getch_wrapper)
        
        # Handle input
        if (== key KEY_UP) {
            if (!= direction Direction.DOWN) {
                set next_direction Direction.UP
            } else {}
        } else {
            if (== key KEY_DOWN) {
                if (!= direction Direction.UP) {
                    set next_direction Direction.DOWN
                } else {}
            } else {
                if (== key KEY_LEFT) {
                    if (!= direction Direction.RIGHT) {
                        set next_direction Direction.LEFT
                    } else {}
                } else {
                    if (== key KEY_RIGHT) {
                        if (!= direction Direction.LEFT) {
                            set next_direction Direction.RIGHT
                        } else {}
                    } else {
                        if (or (== key (cast_int 'q')) (== key (cast_int 'Q'))) {
                            set running false
                        } else {}
                    }
                }
            }
        }
        
        if (not game_over) {
            set direction next_direction
            
            # Calculate new head position
            let head_x: int = (at snake_x 0)
            let head_y: int = (at snake_y 0)
            
            # Calculate new head position based on direction
            let new_head_x: int = (cond
                ((== direction Direction.LEFT) (- head_x 1))
                ((== direction Direction.RIGHT) (+ head_x 1))
                (else head_x)
            )
            let new_head_y: int = (cond
                ((== direction Direction.UP) (- head_y 1))
                ((== direction Direction.DOWN) (+ head_y 1))
                (else head_y)
            )
            
            # Check wall collision
            if (not (is_valid_pos new_head_x new_head_y GRID_WIDTH GRID_HEIGHT)) {
                set game_over true
            } else {
                # Check if food eaten
                if (== new_head_x food_x) {
                    if (== new_head_y food_y) {
                        set score (+ score 10)
                        set snake_length (+ snake_length 1)
                        
                        # Place new food
                        let new_food_pos: int = (place_food food_x food_y snake_length)
                        set food_x (% new_food_pos GRID_WIDTH)
                        set food_y (/ new_food_pos GRID_WIDTH)
                    } else {}
                } else {}
                
                # Build new snake with head at front
                let mut new_snake_x: array<int> = []
                let mut new_snake_y: array<int> = []
                
                # Add new head
                set new_snake_x (array_push new_snake_x new_head_x)
                set new_snake_y (array_push new_snake_y new_head_y)
                
                # Copy old body (excluding tail if didn't eat food)
                # When food eaten: old arrays have (snake_length-1) elements
                # When not eaten: we want to drop the tail, copying (snake_length-1) elements
                let copy_length: int = (- snake_length 1)
                let mut i: int = 0
                while (< i copy_length) {
                    set new_snake_x (array_push new_snake_x (at snake_x i))
                    set new_snake_y (array_push new_snake_y (at snake_y i))
                    set i (+ i 1)
                }
                
                set snake_x new_snake_x
                set snake_y new_snake_y
                
                # Check self collision
                if (check_self_collision snake_x snake_y snake_length) {
                    set game_over true
                } else {}
            }
        } else {}
        
        # Draw
        (draw_game snake_x snake_y food_x food_y snake_length score)
        
        if game_over {
            unsafe {             (mvprintw_wrapper (/ GRID_HEIGHT 2) (/ GRID_WIDTH 2) "GAME OVER!") }
            unsafe {             (mvprintw_wrapper (+ GRID_HEIGHT 5) 0 (+ "Final Score: " (int_to_string score))) }
            unsafe {             (mvprintw_wrapper (+ GRID_HEIGHT 6) 0 "Press Q to quit") }
            unsafe {             (refresh_wrapper) }
        } else {}
    }
    
    # Cleanup
    unsafe {     (endwin_wrapper) }
    
    (println "")
    (println "Game Over!")
    (print "Final Score: ")
    (println score)
    
    return 0
}

shadow main {
    # Skip running - it's an interactive game
    assert true
}
