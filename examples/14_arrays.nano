# Arrays in nanolang
# Demonstrates safe, bounds-checked arrays

# Array creation and access
fn test_array_basics() -> int {
    # Access elements directly (bounds-checked!)
    let first: int = (at [1, 2, 3, 4, 5] 0)
    let last: int = (at [1, 2, 3, 4, 5] 4)
    
    return (+ first last)
}

shadow test_array_basics {
    assert (== (test_array_basics) 6)
}

# Array operations - sum specific arrays
fn sum_five() -> int {
    return (+ (+ (+ (+ (at [1, 2, 3, 4, 5] 0) (at [1, 2, 3, 4, 5] 1)) (at [1, 2, 3, 4, 5] 2)) (at [1, 2, 3, 4, 5] 3)) (at [1, 2, 3, 4, 5] 4))
}

shadow sum_five {
    assert (== (sum_five) 15)
}

# Array with array_new
fn test_array_new() -> int {
    # Test that array_new creates correct length
    let len: int = (array_length (array_new 5 0))
    
    return len
}

shadow test_array_new {
    assert (== (test_array_new) 5)
}

# String arrays
fn test_string_arrays() -> int {
    let len: int = (array_length ["Alice", "Bob", "Carol"])
    
    return len
}

shadow test_string_arrays {
    assert (== (test_string_arrays) 3)
}

# Main function
fn main() -> int {
    (println "Array Tests")
    (println "===========")
    
    # Test 1
    let result1: int = (test_array_basics)
    (println "test_array_basics:")
    (println result1)
    
    # Test 2  
    let sum: int = (sum_five)
    (println "sum_five:")
    (println sum)
    
    # Test 3
    let result3: int = (test_array_new)
    (println "test_array_new:")
    (println result3)
    
    # Test 4
    let result5: int = (test_string_arrays)
    (println "test_string_arrays:")
    (println result5)
    
    (println "All tests passed!")
    return 0
}

shadow main {
    assert (== (main) 0)
}
