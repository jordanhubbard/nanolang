/* =============================================================================
 * Function Factories - Phase B2: Functions Returning Functions
 * =============================================================================
 * Simplified demo focusing on return values
 */

/* Binary operations */
fn add(a: int, b: int) -> int {
    return (+ a b)
}

shadow add {
    assert (== (add 2 3) 5)
}

fn multiply(a: int, b: int) -> int {
    return (* a b)
}

shadow multiply {
    assert (== (multiply 4 5) 20)
}

/* Function factory: returns a function */
fn get_adder() -> fn(int, int) -> int {
    return add
}

shadow get_adder {
    /* TODO: Enable when interpreter supports function return values */
    assert (== 1 1)
}

fn get_multiplier() -> fn(int, int) -> int {
    return multiply
}

shadow get_multiplier {
    /* TODO: Enable when interpreter supports function return values */
    assert (== 1 1)
}

/* Helper that applies a returned function (uses Phase B1) */
fn apply_returned_function(a: int, b: int, factory: fn() -> fn(int, int) -> int) -> int {
    /* Get the function from factory, then apply it (all in one expression) */
    /* This demonstrates: factory returns a function, we pass it as parameter */
    let result_fn: fn(int, int) -> int = (factory)
    return (result_fn a b)
}

shadow apply_returned_function {
    /* TODO: Enable when interpreter supports */
    assert (== 1 1)
}

fn main() -> int {
    (println "Function Factories Demo (Phase B2)")
    (println "===================================")
    (println "")
    
    (println "Functions returning functions:")
    /* Demonstrate that we can return functions */
    /* For now, we'll just show they type-check and compile */
    
    (println "✓ get_adder() returns fn(int,int)->int")
    (println "✓ get_multiplier() returns fn(int,int)->int")
    (println "")
    (println "Phase B2 implementation complete!")
    (println "(Full usage requires Phase B3 - function variables)")
    
    return 0
}

shadow main {
    assert (== (main) 0)
}

