/*
 * Soft Body Beads Demo - Bullet Physics + SDL2 (MODERNIZED)
 * 
 * Mesmerizing physics simulation showing deformable beads continuously
 * falling through a plinko-style obstacle course.
 * 
 * Features:
 * - Real-time soft body physics (Bullet3)
 * - Continuous bead spawning
 * - Rotating obstacles
 * - Beautiful particle rendering
 * - Performance metrics
 * - Modern NanoLang APIs (string +, cast_int, proper SDL)
 */

import "modules/sdl/sdl.nano"
import "modules/sdl_helpers/sdl_helpers.nano"
import "modules/bullet/bullet.nano"

/* Constants */
let WINDOW_WIDTH: int = 1200
let WINDOW_HEIGHT: int = 900
let TARGET_FPS: int = 60
let FRAME_TIME: float = 0.016666

let MAX_BEADS: int = 100
let SPAWN_INTERVAL: float = 0.15  /* seconds between spawns */
let BEAD_RADIUS: float = 1.5
let BEAD_RESOLUTION: int = 24  /* nodes per bead */

/* Camera/projection */
let CAMERA_SCALE: float = 15.0
let CAMERA_OFFSET_Y: float = 40.0

/* Colors */
let COLOR_BG_R: int = 15
let COLOR_BG_G: int = 15
let COLOR_BG_B: int = 25

let COLOR_BEAD_R: int = 100
let COLOR_BEAD_G: int = 200
let COLOR_BEAD_B: int = 255

let COLOR_OBSTACLE_R: int = 200
let COLOR_OBSTACLE_G: int = 100
let COLOR_OBSTACLE_B: int = 50

/* Global state */
struct BeadState {
    handle: int,
    active: bool,
    spawn_time: float
}

/* Project 3D to 2D */
fn project_x(x: float) -> int {
    let screen_x: float = (+ (/ (* x CAMERA_SCALE) 1.0) (/ (cast_float WINDOW_WIDTH) 2.0))
    return (cast_int screen_x)
}

shadow project_x { assert true }

fn project_y(y: float) -> int {
    let adjusted_y: float = (- y CAMERA_OFFSET_Y)
    let screen_y: float = (- (/ (cast_float WINDOW_HEIGHT) 2.0) (/ (* adjusted_y CAMERA_SCALE) 1.0))
    return (cast_int screen_y)
}

shadow project_y { assert true }

/* Draw a filled circle (soft body node) */
fn draw_filled_circle(renderer: SDL_Renderer, cx: int, cy: int, radius: int) -> void {
    let mut y: int = (- 0 radius)
    while (<= y radius) {
        let mut x: int = (- 0 radius)
        while (<= x radius) {
            let dist_sq: int = (+ (* x x) (* y y))
            let radius_sq: int = (* radius radius)
            if (<= dist_sq radius_sq) {
                unsafe {
                    (SDL_RenderDrawPoint renderer (+ cx x) (+ cy y))
                }
            }
            set x (+ x 1)
        }
        set y (+ y 1)
    }
    return
}

shadow draw_filled_circle { assert true }

/* Draw a rotated rectangle */
fn draw_rotated_box(
    renderer: SDL_Renderer,
    cx: int, cy: int,
    width: int, height: int
) -> void {
    /* Simple filled rect for now */
    let x1: int = (- cx (/ width 2))
    let y1: int = (- cy (/ height 2))
    unsafe {
        (SDL_SetRenderDrawColor renderer COLOR_OBSTACLE_R COLOR_OBSTACLE_G COLOR_OBSTACLE_B 255)
        (nl_sdl_render_fill_rect renderer x1 y1 width height)
    }
    return
}

shadow draw_rotated_box { assert true }

fn main() -> int {
    (println "╔════════════════════════════════════════════════════════════╗")
    (println "║        SOFT BODY BEADS - Bullet Physics Demo              ║")
    (println "╚════════════════════════════════════════════════════════════╝")
    (println "")
    (println "Watch deformable beads fall through rotating obstacles!")
    (println "Press ESC to exit")
    (println "")
    
    /* Initialize SDL */
    unsafe { (SDL_Init SDL_INIT_VIDEO) }
    
    /* Create window and renderer */
    let window: SDL_Window = (SDL_CreateWindow 
        "Soft Body Beads - Bullet Physics" 
        SDL_WINDOWPOS_CENTERED SDL_WINDOWPOS_CENTERED
        WINDOW_WIDTH WINDOW_HEIGHT 
        SDL_WINDOW_SHOWN)
    
    let renderer: SDL_Renderer = (SDL_CreateRenderer window -1 SDL_RENDERER_ACCELERATED)
    
    /* Initialize Bullet Physics */
    let mut bullet_init: int = 0
    unsafe {
        set bullet_init (nl_bullet_init)
    }
    if (== bullet_init 0) {
        (println "Error: Failed to initialize Bullet Physics")
        unsafe {
            (SDL_DestroyRenderer renderer)
            (SDL_DestroyWindow window)
            (SDL_Quit)
        }
        return 1
    }
    
    (println "Physics world initialized!")
    
    /* Create obstacle course - plinko style */
    let mut obstacle_handles: array<int> = []
    
    /* Ground */
    unsafe {
        let ground: int = (nl_bullet_create_rigid_box 
            0.0 (- 0.0 50.0) 0.0 100.0 1.0 50.0 0.0 0.3)
        set obstacle_handles (array_push obstacle_handles ground)
    }
    
    /* Rotating obstacles in plinko pattern */
    let obstacle_y: float = 30.0
    let mut row: int = 0
    while (< row 6) {
        let row_y: float = (- obstacle_y (* (cast_float row) 12.0))
        let mut offset: float = 0.0
        if (== (% row 2) 0) {
            set offset 0.0
        } else {
            set offset 8.0
        }
        
        let mut col: int = 0
        while (< col 5) {
            let x: float = (+ (- 0.0 32.0) (+ (* (cast_float col) 16.0) offset))
            let angle: float = (+ 20.0 (* (cast_float (% (+ row col) 3)) 10.0))
            
            unsafe {
                let obs: int = (nl_bullet_create_rigid_box_rotated 
                    x row_y 0.0 6.0 0.8 1.0 angle 0.0 0.4)
                set obstacle_handles (array_push obstacle_handles obs)
            }
            set col (+ col 1)
        }
        set row (+ row 1)
    }
    
    (println (+ "Created " (+ (int_to_string (array_length obstacle_handles)) " obstacles")))
    
    /* Bead tracking */
    let mut beads: array<BeadState> = []
    let mut time_since_spawn: float = 0.0
    let mut total_time: float = 0.0
    let mut frame_count: int = 0
    
    /* Main loop */
    let mut running: bool = true
    while running {
        let mut frame_start: int = 0
        unsafe { set frame_start (SDL_GetTicks) }
        
        /* Handle events */
        let key: int = (nl_sdl_poll_keypress)
        
        if (== (nl_sdl_poll_event_quit) 1) {
            set running false
        }
        
        /* Step physics */
        unsafe { (nl_bullet_step FRAME_TIME) }
        
        set total_time (+ total_time FRAME_TIME)
        set time_since_spawn (+ time_since_spawn FRAME_TIME)
        
        /* Spawn new bead */
        if (and (> time_since_spawn SPAWN_INTERVAL) (< (array_length beads) MAX_BEADS)) {
            let spawn_x: float = (+ (- 0.0 8.0) (* (cast_float (% frame_count 5)) 4.0))
            let spawn_y: float = 45.0
            let spawn_z: float = 0.0
            
            let mut bead_handle: int = 0
            unsafe {
                set bead_handle (nl_bullet_create_soft_sphere 
                    spawn_x spawn_y spawn_z BEAD_RADIUS BEAD_RESOLUTION)
            }
            
            if (!= bead_handle (- 0 1)) {
                let new_bead: BeadState = BeadState {
                    handle: bead_handle,
                    active: true,
                    spawn_time: total_time
                }
                set beads (array_push beads new_bead)
                set time_since_spawn 0.0
            }
        }
        
        /* Clear screen */
        unsafe {
            (SDL_SetRenderDrawColor renderer COLOR_BG_R COLOR_BG_G COLOR_BG_B 255)
            (SDL_RenderClear renderer)
        }
        
        /* Draw obstacles */
        let mut i: int = 0
        while (< i (array_length obstacle_handles)) {
            let handle: int = (at obstacle_handles i)
            let mut x: float = 0.0
            let mut y: float = 0.0
            unsafe {
                set x (nl_bullet_get_rigid_body_x handle)
                set y (nl_bullet_get_rigid_body_y handle)
            }
            
            let screen_x: int = (project_x x)
            let screen_y: int = (project_y y)
            
            /* Draw as rectangles */
            if (== i 0) {
                /* Ground - wide */
                (draw_rotated_box renderer screen_x screen_y (* 100 (cast_int CAMERA_SCALE)) 10)
            } else {
                /* Obstacle - thin bars */
                (draw_rotated_box renderer screen_x screen_y 
                    (* 12 (cast_int CAMERA_SCALE)) 8)
            }
            
            set i (+ i 1)
        }
        
        /* Draw soft body beads */
        unsafe {
            (SDL_SetRenderDrawColor renderer COLOR_BEAD_R COLOR_BEAD_G COLOR_BEAD_B 255)
        }
        
        set i 0
        while (< i (array_length beads)) {
            let bead: BeadState = (at beads i)
            if bead.active {
                let bead_handle: int = bead.handle
                let mut node_count: int = 0
                unsafe {
                    set node_count (nl_bullet_get_soft_body_node_count bead_handle)
                }
                
                /* Draw each node as a small circle */
                let mut node_idx: int = 0
                while (< node_idx node_count) {
                    let mut x: float = 0.0
                    let mut y: float = 0.0
                    unsafe {
                        set x (nl_bullet_get_soft_body_node_x bead_handle node_idx)
                        set y (nl_bullet_get_soft_body_node_y bead_handle node_idx)
                    }
                    
                    let screen_x: int = (project_x x)
                    let screen_y: int = (project_y y)
                    
                    /* Draw node */
                    (draw_filled_circle renderer screen_x screen_y 3)
                    
                    set node_idx (+ node_idx 1)
                }
            }
            set i (+ i 1)
        }
        
        /* Present */
        unsafe { (SDL_RenderPresent renderer) }
        
        set frame_count (+ frame_count 1)
        
        /* Frame rate limiting */
        let mut frame_end: int = 0
        unsafe { set frame_end (SDL_GetTicks) }
        let frame_duration: int = (- frame_end frame_start)
        let target_frame_time: int = (/ 1000 TARGET_FPS)
        if (< frame_duration target_frame_time) {
            let delay: int = (- target_frame_time frame_duration)
            unsafe { (SDL_Delay delay) }
        }
    }
    
    /* Cleanup */
    (println "")
    (println (+ "Simulated " (+ (int_to_string (array_length beads)) " beads total")))
    
    unsafe {
        (nl_bullet_cleanup)
        (SDL_DestroyRenderer renderer)
        (SDL_DestroyWindow window)
        (SDL_Quit)
    }
    
    (println "Demo complete!")
    return 0
}

shadow main { assert true }

