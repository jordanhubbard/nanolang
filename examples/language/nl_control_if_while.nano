# Example: If/Else and While Loops
# Purpose: Comprehensive tests of if/else branching, while loops, nested loops, and combined control flow
# Features: if/else, while, nested conditionals, nested loops, early return, and/or conditions, shadow tests
# Difficulty: Beginner
# Category: language
# Prerequisites: nl_hello, nl_comparisons, nl_mutable
# Expected Output: nl_control_if_while: All if/while tests passed!

/* ==== PART 1: Simple If Statements ==== */

fn test_if_true() -> int {
    if true {
        return 1
    } else {
        return 0
    }
}

shadow test_if_true {
    assert (== (test_if_true) 1)
}

fn test_if_false() -> int {
    if false {
        return 1
    } else {
        return 0
    }
}

shadow test_if_false {
    assert (== (test_if_false) 0)
}

fn test_if_comparison() -> int {
    let x: int = 10
    if (> x 5) {
        return 1
    } else {
        return 0
    }
}

shadow test_if_comparison {
    assert (== (test_if_comparison) 1)
}

/* ==== PART 2: Nested If Statements ==== */

fn test_nested_if() -> int {
    let x: int = 10
    let y: int = 20
    
    if (> x 5) {
        if (> y 15) {
            return 3
        } else {
            return 2
        }
    } else {
        return 1
    }
}

shadow test_nested_if {
    assert (== (test_nested_if) 3)
}

fn classify_number(n: int) -> int {
    if (< n 0) {
        return -1
    } else {
        if (== n 0) {
            return 0
        } else {
            return 1
        }
    }
}

shadow classify_number {
    assert (== (classify_number -5) -1)
    assert (== (classify_number 0) 0)
    assert (== (classify_number 5) 1)
}

/* ==== PART 3: If with Complex Conditions ==== */

fn test_and_condition() -> int {
    let x: int = 5
    if (and (> x 0) (< x 10)) {
        return 1
    } else {
        return 0
    }
}

shadow test_and_condition {
    assert (== (test_and_condition) 1)
}

fn test_or_condition() -> int {
    let x: int = 15
    if (or (< x 0) (> x 10)) {
        return 1
    } else {
        return 0
    }
}

shadow test_or_condition {
    assert (== (test_or_condition) 1)
}

fn in_range(x: int, low: int, high: int) -> int {
    if (and (>= x low) (<= x high)) {
        return 1
    } else {
        return 0
    }
}

shadow in_range {
    assert (== (in_range 5 0 10) 1)
    assert (== (in_range -1 0 10) 0)
    assert (== (in_range 15 0 10) 0)
}

/* ==== PART 4: Simple While Loops ==== */

fn sum_to_n(n: int) -> int {
    let mut sum: int = 0
    let mut i: int = 1
    
    while (<= i n) {
        set sum (+ sum i)
        set i (+ i 1)
    }
    
    return sum
}

shadow sum_to_n {
    assert (== (sum_to_n 5) 15)
    assert (== (sum_to_n 10) 55)
    assert (== (sum_to_n 0) 0)
}

fn factorial(n: int) -> int {
    let mut result: int = 1
    let mut i: int = 1
    
    while (<= i n) {
        set result (* result i)
        set i (+ i 1)
    }
    
    return result
}

shadow factorial {
    assert (== (factorial 0) 1)
    assert (== (factorial 1) 1)
    assert (== (factorial 5) 120)
}

/* ==== PART 5: While with Early Return ==== */

fn find_first_divisible(limit: int, divisor: int) -> int {
    let mut i: int = 1
    
    while (<= i limit) {
        if (== (% i divisor) 0) {
            return i
        } else {
            set i (+ i 1)
        }
    }
    
    return -1
}

shadow find_first_divisible {
    assert (== (find_first_divisible 20 7) 7)
}

/* ==== PART 6: Nested Loops ==== */

fn nested_loop_sum() -> int {
    let mut sum: int = 0
    let mut i: int = 0
    
    while (< i 3) {
        let mut j: int = 0
        while (< j 3) {
            set sum (+ sum 1)
            set j (+ j 1)
        }
        set i (+ i 1)
    }
    
    return sum
}

shadow nested_loop_sum {
    assert (== (nested_loop_sum) 9)
}

fn multiplication_table_sum(n: int) -> int {
    let mut sum: int = 0
    let mut i: int = 1
    
    while (<= i n) {
        let mut j: int = 1
        while (<= j n) {
            set sum (+ sum (* i j))
            set j (+ j 1)
        }
        set i (+ i 1)
    }
    
    return sum
}

shadow multiplication_table_sum {
    assert (== (multiplication_table_sum 3) 36)
}

/* ==== PART 7: Combined If and While ==== */

fn count_even(n: int) -> int {
    let mut count: int = 0
    let mut i: int = 0
    
    while (< i n) {
        if (== (% i 2) 0) {
            set count (+ count 1)
        } else {
            set count count
        }
        set i (+ i 1)
    }
    
    return count
}

shadow count_even {
    assert (== (count_even 10) 5)
}

fn sum_odd(n: int) -> int {
    let mut sum: int = 0
    let mut i: int = 1
    
    while (<= i n) {
        if (== (% i 2) 1) {
            set sum (+ sum i)
        } else {
            set sum sum
        }
        set i (+ i 1)
    }
    
    return sum
}

shadow sum_odd {
    assert (== (sum_odd 10) 25)
}

/* ==== PART 8: Fibonacci with Loop ==== */

fn fibonacci(n: int) -> int {
    if (<= n 1) {
        return n
    } else {
        let mut a: int = 0
        let mut b: int = 1
        let mut i: int = 2
        
        while (<= i n) {
            let temp: int = b
            set b (+ a b)
            set a temp
            set i (+ i 1)
        }
        
        return b
    }
}

shadow fibonacci {
    assert (== (fibonacci 0) 0)
    assert (== (fibonacci 1) 1)
    assert (== (fibonacci 6) 8)
    assert (== (fibonacci 10) 55)
}

/* ==== Main ==== */

fn main() -> int {
    (println "nl_control_if_while: All if/while tests passed!")
    return 0
}

shadow main {
    assert (== (main) 0)
}
