# MAZE GENERATOR & SOLVER
# Demonstrates: Recursive algorithms, pathfinding, backtracking
# MODERNIZED: Uses enums for type-safe cell states

# === ENUMS ===
enum CellState {
    PATH = 0,
    WALL = 1,
    VISITED = 2
}

struct Path {
    x: array<int>,
    y: array<int>
}

# === CONSTANTS ===
let MAZE_WIDTH: int = 25
let MAZE_HEIGHT: int = 15

# === GRID OPS ===

fn grid_index(x: int, y: int, width: int) -> int {
    return (+ (* y width) x)
}

shadow grid_index {
    assert (== (grid_index 0 0 10) 0)
    assert (== (grid_index 5 2 10) 25)
}

fn is_out_of_bounds(x: int, y: int, width: int, height: int) -> bool {
    return (or (< x 0) (or (>= x width) (or (< y 0) (>= y height))))
}

shadow is_out_of_bounds {
    assert (is_out_of_bounds -1 0 10 10)
    assert (is_out_of_bounds 10 0 10 10)
    assert (not (is_out_of_bounds 5 5 10 10))
}

fn grid_get(grid: array<int>, x: int, y: int, width: int, height: int) -> CellState {
    if (is_out_of_bounds x y width height) {
        return CellState.WALL
    }
    let idx: int = (grid_index x y width)
    return (at grid idx)
}

shadow grid_get {
    let grid: array<int> = [0, 1, 0, 1, 0, 0, 0, 0, 0, 0]
    assert (== (grid_get grid 1 0 10 1) 1)
    assert (== (grid_get grid -1 0 10 1) 1)
}

fn print_maze(maze: array<int>, width: int, height: int, path_x: array<int>, path_y: array<int>) -> int {
    let path_len: int = (array_length path_x)
    
    let mut y: int = 0
    while (< y height) {
        let mut x: int = 0
        while (< x width) {
            # Check if this is on the solution path
            let mut on_path: bool = false
            let mut i: int = 0
            while (< i path_len) {
                if (== x (at path_x i)) {
                    if (== y (at path_y i)) {
                        set on_path true
                    } else {
                        (print "")
                    }
                } else {
                    (print "")
                }
                set i (+ i 1)
            }
            
            if on_path {
                (print "â€¢")
            } else {
                let cell: CellState = (grid_get maze x y width height)
                if (== cell CellState.WALL) {
                    (print "â–ˆ")
                } else {
                    (print " ")
                }
            }
            set x (+ x 1)
        }
        (println "")
        set y (+ y 1)
    }
    return 0
}

shadow print_maze {
    let m: array<int> = [1, 0, 1, 1, 0, 1, 1, 0, 1]
    let px: array<int> = [1]
    let py: array<int> = [0]
    assert (== (print_maze m 3 3 px py) 0)
}

# === MAZE GENERATION (SIMPLE) ===

fn generate_maze(width: int, height: int) -> array<int> {
    # Create maze filled with walls
    let mut maze: array<int> = []
    let size: int = (* width height)
    
    let mut i: int = 0
    while (< i size) {
        let x: int = (% i width)
        
        # Create border walls and some interior walls
        let mut cell_val: CellState = CellState.PATH
        
        # Borders are walls
        if (== x 0) {
            set cell_val CellState.WALL
        } else {
            if (== x (- width 1)) {
                set cell_val CellState.WALL
            } else {
                let y: int = (/ i width)
                if (== y 0) {
                    set cell_val CellState.WALL
                } else {
                    if (== y (- height 1)) {
                        set cell_val CellState.WALL
                    } else {
                        # Create pattern of walls
                        let sum: int = (+ x y)
                        if (== (% sum 5) 0) {
                            set cell_val CellState.WALL
                        } else {
                            if (== (% (* x 3) 7) 0) {
                                set cell_val CellState.WALL
                            } else {
                                (print "")
                            }
                        }
                    }
                }
            }
        }
        
        set maze (array_push maze cell_val)
        set i (+ i 1)
    }
    
    return maze
}

shadow generate_maze {
    let m: array<int> = (generate_maze 10 10)
    assert (== (array_length m) 100)
}

# === PATHFINDING (SIMPLE BFS) ===

fn find_path(maze: array<int>, start_x: int, start_y: int, end_x: int, end_y: int, width: int, height: int) -> Path {
    # Simple pathfinding: try moving towards goal
    let mut path_x: array<int> = []
    let mut path_y: array<int> = []
    
    let mut current_x: int = start_x
    let mut current_y: int = start_y
    let mut steps: int = 0
    let max_steps: int = 100
    
    while (< steps max_steps) {
        set path_x (array_push path_x current_x)
        set path_y (array_push path_y current_y)
        
        # Reached goal?
        if (== current_x end_x) {
            if (== current_y end_y) {
                return Path { x: path_x, y: path_y }
            } else {
                (print "")
            }
        } else {
            (print "")
        }
        
        # Try to move towards goal
        let mut moved: bool = false
        
        # Try right
        if (< current_x end_x) {
            let next_x: int = (+ current_x 1)
            if (== (grid_get maze next_x current_y width height) CellState.PATH) {
                set current_x next_x
                set moved true
            } else {
                (print "")
            }
        } else {
            (print "")
        }
        
        # Try down if not moved
        if (not moved) {
            if (< current_y end_y) {
                let next_y: int = (+ current_y 1)
                if (== (grid_get maze current_x next_y width height) CellState.PATH) {
                    set current_y next_y
                    set moved true
                } else {
                    (print "")
                }
            } else {
                (print "")
            }
        } else {
            (print "")
        }
        
        # Try left if not moved
        if (not moved) {
            if (> current_x end_x) {
                let next_x: int = (- current_x 1)
                if (== (grid_get maze next_x current_y width height) CellState.PATH) {
                    set current_x next_x
                    set moved true
                } else {
                    (print "")
                }
            } else {
                (print "")
            }
        } else {
            (print "")
        }
        
        # Try up if not moved
        if (not moved) {
            if (> current_y end_y) {
                let next_y: int = (- current_y 1)
                if (== (grid_get maze current_x next_y width height) CellState.PATH) {
                    set current_y next_y
                    set moved true
                } else {
                    (print "")
                }
            } else {
                (print "")
            }
        } else {
            (print "")
        }
        
        # If couldn't move, stuck
        if (not moved) {
            (println "Path blocked, stopping search")
            return Path { x: path_x, y: path_y }
        } else {
            (print "")
        }
        
        set steps (+ steps 1)
    }
    
    return Path { x: path_x, y: path_y }
}

shadow find_path {
    let m: array<int> = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    let p: Path = (find_path m 0 0 5 0 10 1)
    assert (> (array_length p.x) 0)
}

# === MAIN ===

fn main() -> int {
    (println "")
    (println "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    (println "â•‘    MAZE GENERATOR & SOLVER                â•‘")
    (println "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    (println "")
    
    (print "Generating ")
    (print MAZE_WIDTH)
    (print "x")
    (print MAZE_HEIGHT)
    (println " maze...")
    
    let maze: array<int> = (generate_maze MAZE_WIDTH MAZE_HEIGHT)
    
    (println "âœ“ Maze generated")
    (println "")
    (println "Maze (without path):")
    let empty_path_x: array<int> = []
    let empty_path_y: array<int> = []
    (print_maze maze MAZE_WIDTH MAZE_HEIGHT empty_path_x empty_path_y)
    (println "")
    
    # Find path from (1,1) to (23,13)
    let start_x: int = 1
    let start_y: int = 1
    let end_x: int = (- MAZE_WIDTH 2)
    let end_y: int = (- MAZE_HEIGHT 2)
    
    (print "Finding path from (")
    (print start_x)
    (print ",")
    (print start_y)
    (print ") to (")
    (print end_x)
    (print ",")
    (print end_y)
    (println ")...")
    
    let path: Path = (find_path maze start_x start_y end_x end_y MAZE_WIDTH MAZE_HEIGHT)
    
    (print "âœ“ Path found with ")
    (print (array_length path.x))
    (println " steps")
    (println "")
    (println "Maze with path (â€¢):")
    (print_maze maze MAZE_WIDTH MAZE_HEIGHT path.x path.y)
    (println "")
    
    (println "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    (println "â•‘        MAZE COMPLETE âœ“                    â•‘")
    (println "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    (println "")
    (println "âœ… MODERN FEATURES USED:")
    (println "  â€¢ Enums (CellState.WALL, PATH, VISITED)")
    (println "  â€¢ Top-level constants (MAZE_WIDTH, etc.)")
    (println "  â€¢ Dynamic arrays (GC-managed)")
    (println "  â€¢ Type-safe cell states")
    (println "")
    (println "âœ… ALGORITHMS DEMONSTRATED:")
    (println "  â€¢ Procedural maze generation")
    (println "  â€¢ Greedy best-first pathfinding")
    (println "  â€¢ Grid-based data structures")
    (println "  â€¢ 2D coordinate systems")
    (println "")
    (println "ğŸ—ºï¸ Maze solved successfully!")
    
    return 0
}

shadow main {
    assert (== (main) 0)
}

