# Example: Prime Sieve (Eratosthenes)
# Purpose: Counts primes up to one million using the Sieve of Eratosthenes algorithm for optimized performance
# Features: arrays, bool arrays, nested loops, algorithm optimization
# Difficulty: Intermediate
# Category: language
# Prerequisites: nl_hello, nl_loops, nl_primes
# Expected Output: Calculating primes up to 1,000,000 (OPTIMIZED - Sieve of Eratosthenes)...

fn count_primes_sieve(limit: int) -> int {
    if (< limit 2) {
        return 0
    }
    
    # Allocate boolean array for the sieve
    let mut sieve: array<bool> = (array_new limit true)
    
    # 0 and 1 are not prime
    (array_set sieve 0 false)
    (array_set sieve 1 false)
    
    # Sieve of Eratosthenes algorithm
    let mut p: int = 2
    while (< (* p p) limit) {
        if (at sieve p) {
            # Mark all multiples of p as not prime
            let mut i: int = (* p p)
            while (< i limit) {
                (array_set sieve i false)
                set i (+ i p)
            }
        }
        set p (+ p 1)
    }
    
    # Count primes
    let mut count: int = 0
    let mut idx: int = 0
    while (< idx limit) {
        if (at sieve idx) {
            set count (+ count 1)
        }
        set idx (+ idx 1)
    }
    return count
}

fn main() -> int {
    print("Calculating primes up to 1,000,000 (OPTIMIZED - Sieve of Eratosthenes)...")
    let total: int = (count_primes_sieve 1000000)
    print("Total primes found: ")
    print((int_to_string total))
    return 0
}
