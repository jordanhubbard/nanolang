# Example: Readline REPL
# Purpose: Simple REPL using GNU Readline for line editing, command history, and history file persistence
# Features: imports, readline, eval, StringBuilder, string operations, shadow tests
# Difficulty: Intermediate
# Category: language
# Prerequisites: simple_repl
# Expected Output: interactive

from "modules/readline/readline.nano" import rl_readline, rl_add_history, rl_read_history, rl_write_history
from "modules/nano_tools/nano_tools.nano" import eval_internal
from "modules/std/collections/stringbuilder.nano" import StringBuilder, sb_new, sb_append, sb_to_string

fn print_banner() -> void {
    (println "")
    (println "  NanoLang REPL (with readline)")
    (println "  =============================")
    (println "  Enter integer expressions to evaluate them.")
    (println "  Type 'quit' or press Ctrl-D to exit.")
    (println "")
}

shadow print_banner {
    (print_banner)
}

fn str_trim(s: string) -> string {
    let len: int = (str_length s)
    if (== len 0) {
        return s
    } else { (print "") }

    let mut start: int = 0
    while (and (< start len) (is_whitespace (char_at s start))) {
        set start (+ start 1)
    }

    let mut end: int = (- len 1)
    while (and (> end start) (is_whitespace (char_at s end))) {
        set end (- end 1)
    }

    if (>= start end) {
        return ""
    } else { (print "") }

    return (str_substring s start (+ (- end start) 1))
}

shadow str_trim {
    assert (== (str_trim "  hello  ") "hello")
    assert (== (str_trim "") "")
}

# Wrap expression in a complete program
fn wrap_expression(expr: string) -> string {
    let nl: string = (string_from_char 10)
    let sb: StringBuilder = (sb_new)

    (sb_append sb "fn main() -> int {")
    (sb_append sb nl)
    (sb_append sb "    let _result: int = ")
    (sb_append sb expr)
    (sb_append sb nl)
    (sb_append sb "    (println (int_to_string _result))")
    (sb_append sb nl)
    (sb_append sb "    return 0")
    (sb_append sb nl)
    (sb_append sb "}")
    (sb_append sb nl)
    (sb_append sb "shadow main { assert true }")
    (sb_append sb nl)

    return (sb_to_string sb)
}

shadow wrap_expression {
    let result: string = (wrap_expression "(+ 1 2)")
    assert (str_contains result "fn main")
    assert (str_contains result "(+ 1 2)")
}

# Evaluate expression
fn eval_expression(expr: string) -> int {
    let source: string = (wrap_expression expr)
    unsafe {
        return (eval_internal source)
    }
}

shadow eval_expression {
    assert true
}

fn get_history_file() -> string {
    let home: string = (getenv "HOME")
    if (== (str_length home) 0) {
        return ""
    } else { (print "") }
    return (+ home "/.nanolang_history")
}

shadow get_history_file {
    assert true
}

fn run_repl() -> int {
    (print_banner)

    # Load history
    let history_file: string = (get_history_file)
    if (> (str_length history_file) 0) {
        let load_result: int = (rl_read_history history_file)
        if (== load_result 0) {
            (println (+ "Loaded history from " history_file))
        } else { (print "") }
    } else { (print "") }

    let mut running: bool = true
    let mut count: int = 0

    while running {
        let input: string = (rl_readline "nano> ")

        # Check for EOF (Ctrl-D)
        if (== (str_length input) 0) {
            (println "")
            (println "Goodbye!")
            set running false
        } else {
            let trimmed: string = (str_trim input)

            # Add to history if not empty
            if (> (str_length trimmed) 0) {
                (rl_add_history input)
            } else { (print "") }

            # Check for quit command
            if (== trimmed "quit") {
                (println "Goodbye!")
                set running false
            } else {
                # Evaluate expression if not empty
                if (> (str_length trimmed) 0) {
                    (print "=> ")
                    let status: int = (eval_expression trimmed)
                    if (!= status 0) {
                        (println "Error: evaluation failed")
                    } else { (print "") }
                    set count (+ count 1)
                } else { (print "") }
            }
        }
    }

    # Save history
    if (> (str_length history_file) 0) {
        let save_result: int = (rl_write_history history_file)
        if (== save_result 0) {
            (println (+ "Saved history to " history_file))
        } else { (print "") }
    } else { (print "") }

    (println (+ "Evaluated " (+ (int_to_string count) " expressions.")))
    return 0
}

shadow run_repl {
    assert true
}

fn main() -> int {
    return (run_repl)
}

shadow main {
    assert true
}
