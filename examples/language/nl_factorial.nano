# Factorial calculator with comprehensive shadow-tests

# Example: Factorial (Recursion)
# Purpose: Demonstrate recursive function calls and shadow testing
# Features: Recursion, conditional logic, base case, shadow tests
# Difficulty: Beginner
# Usage: ./bin/nanoc examples/nl_factorial.nano -o /tmp/factorial && /tmp/factorial
# Expected Output: Prints factorials from 0! to 10!
#
# Learning Objectives:
# 1. Understand recursive function calls
# 2. Implement base case to prevent infinite recursion
# 3. See how shadow tests verify correctness at compile time
# 4. Learn the mathematical definition of factorial

fn factorial(n: int) -> int {
    if (<= n 1) {
        return 1
    }
    return (* n (factorial (- n 1)))
}

shadow factorial {
    # Test base cases
    assert (== (factorial 0) 1)
    assert (== (factorial 1) 1)
    
    # Test small values
    assert (== (factorial 2) 2)
    assert (== (factorial 3) 6)
    assert (== (factorial 4) 24)
    assert (== (factorial 5) 120)
    
    # Test larger value
    assert (== (factorial 10) 3628800)
}

fn main() -> int {
    (println "Factorials from 0 to 10:")
    (println "")
    
    let mut i: int = 0
    while (<= i 10) {
        # Modern string concatenation using +
        let result: int = (factorial i)
        let msg: string = (+ (+ (int_to_string i) "! = ") (int_to_string result))
        (println msg)
        set i (+ i 1)
    }
    
    return 0
}

shadow main {
    assert (== (main) 0)
}
