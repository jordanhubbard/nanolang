# Example 25: Pi Calculator to 500 Decimal Places
# Uses the Spigot algorithm for computing pi digit by digit

from "stdlib/timing.nano" import get_nanoseconds, format_nanoseconds

# External C functions
extern fn strlen(s: string) -> int
extern fn atan(x: float) -> float
extern fn get_argc() -> int
extern fn get_argv(index: int) -> string

# Helper to convert int to float
fn int_to_float(n: int) -> float {
    # Use division by 1.0 to convert
    let f: float = 1.0
    if (== n 0) {
        return 0.0
    } else {
        if (> n 0) {
            let mut result: float = 0.0
            let mut i: int = 0
            while (< i n) {
                set result (+ result 1.0)
                set i (+ i 1)
            }
            return result
        } else {
            # Negative number
            let positive: int = (- 0 n)
            let mut result: float = 0.0
            let mut i: int = 0
            while (< i positive) {
                set result (+ result 1.0)
                set i (+ i 1)
            }
            return (- 0.0 result)
        }
    }
}

shadow int_to_float {
    assert (== (int_to_float 0) 0.0)
    assert (== (int_to_float 5) 5.0)
    assert (== (int_to_float 100) 100.0)
}

# Initialize array for spigot algorithm
# We need more digits internally for accuracy
fn init_spigot_array(size: int) -> array<int> {
    let arr: array<int> = (array_new size 2)
    return arr
}

shadow init_spigot_array {
    let arr: array<int> = (init_spigot_array 10)
    assert (== (array_length arr) 10)
    assert (== (at arr 0) 2)
    assert (== (at arr 5) 2)
}

# Compute one digit of pi using spigot algorithm
# This is a simplified version that works for moderate precision
fn compute_pi_digit(arr: array<int>, len: int, digit_num: int) -> int {
    let mut carry: int = 0
    let mut i: int = (- len 1)
    
    # Work backwards through array
    while (>= i 0) {
        let mut temp: int = (* (at arr i) 10)
        set temp (+ temp carry)
        
        let divisor: int = (+ (* i 2) 1)
        let quotient: int = (/ temp divisor)
        let remainder: int = (- temp (* quotient divisor))
        
        (array_set arr i remainder)
        set carry quotient
        
        set i (- i 1)
    }
    
    # Extract digit from carry
    let digit: int = (/ carry 10)
    set carry (- carry (* digit 10))
    
    return digit
}

shadow compute_pi_digit {
    # Basic test - just verify it returns a digit 0-9
    let arr: array<int> = (init_spigot_array 20)
    let digit: int = (compute_pi_digit arr 20 0)
    assert (>= digit 0)
    assert (<= digit 9)
}

# Calculate pi digits using the spigot algorithm
fn calculate_pi_spigot(decimal_places: int) -> string {
    if (<= decimal_places 0) {
        return "3"
    } else {
        let arr_len: int = (+ (/ (* decimal_places 10) 3) 1)
        let arr: array<int> = (init_spigot_array arr_len)
        let mut result: string = "3."
        let mut i: int = 0
        while (< i decimal_places) {
            let digit: int = (compute_pi_digit arr arr_len i)
            set result (+ result (int_to_string digit))
            set i (+ i 1)
        }
        return result
    }
}

shadow calculate_pi_spigot {
    let pi0: string = (calculate_pi_spigot 0)
    assert (str_equals pi0 "3")

    let pi5: string = (calculate_pi_spigot 5)
    assert (== (str_length pi5) 7)
}

# Simple pi calculation using Leibniz formula (slower but simpler)
# π/4 = 1 - 1/3 + 1/5 - 1/7 + 1/9 - ...
fn calculate_pi_leibniz(iterations: int) -> float {
    let mut pi: float = 0.0
    let mut i: int = 0
    
    while (< i iterations) {
        let term: float = (/ 1.0 (+ (* 2.0 (int_to_float i)) 1.0))
        
        # Alternate signs
        let remainder: int = (% i 2)
        if (== remainder 0) {
            set pi (+ pi term)
        } else {
            set pi (- pi term)
        }
        
        set i (+ i 1)
    }
    
    return (* pi 4.0)
}

shadow calculate_pi_leibniz {
    let pi_approx: float = (calculate_pi_leibniz 1000)
    # Should be close to 3.14159
    assert (> pi_approx 3.14)
    assert (< pi_approx 3.15)
}

# Better formula: Machin's formula
# π/4 = 4*arctan(1/5) - arctan(1/239)
# We'll compute arctan using Taylor series
fn arctan_series(x: float, terms: int) -> float {
    let mut result: float = 0.0
    let mut i: int = 0
    let x_squared: float = (* x x)
    let mut x_power: float = x
    
    while (< i terms) {
        let n: float = (+ (* 2.0 (int_to_float i)) 1.0)
        let term: float = (/ x_power n)
        
        let remainder: int = (% i 2)
        if (== remainder 0) {
            set result (+ result term)
        } else {
            set result (- result term)
        }
        
        set x_power (* x_power x_squared)
        set i (+ i 1)
    }
    
    return result
}

shadow arctan_series {
    # arctan(1) should be π/4 ≈ 0.7854
    let result: float = (arctan_series 1.0 100)
    assert (> result 0.78)
    assert (< result 0.79)
}

fn calculate_pi_machin(terms: int) -> float {
    let term1: float = (arctan_series 0.2 terms)      # arctan(1/5)
    let term2: float = (arctan_series 0.0041841 terms) # arctan(1/239) ≈ 0.0041841
    
    let pi_over_4: float = (- (* 4.0 term1) term2)
    return (* pi_over_4 4.0)
}

shadow calculate_pi_machin {
    let pi_approx: float = (calculate_pi_machin 50)
    # Should be close to 3.14159265
    assert (> pi_approx 3.141)
    assert (< pi_approx 3.142)
}

# Print pi with high precision (using multiple methods for verification)
fn print_pi_digits() -> int {
    (println "Method 1: Leibniz Formula (1000 terms)")
    let pi1: float = (calculate_pi_leibniz 1000)
    (println pi1)
    (println "")
    
    (println "Method 2: Leibniz Formula (10000 terms)")  
    let pi2: float = (calculate_pi_leibniz 10000)
    (println pi2)
    (println "")
    
    (println "Method 3: Machin's Formula (50 terms)")
    let pi3: float = (calculate_pi_machin 50)
    (println pi3)
    (println "")
    
    (println "Method 4: Machin's Formula (100 terms)")
    let pi4: float = (calculate_pi_machin 100)
    (println pi4)
    (println "")
    
    (println "Method 5: Using C math library")
    let pi5: float = (* 4.0 (atan 1.0))
    (println pi5)
    (println "")
    
    return 0
}

shadow print_pi_digits {
    assert (== (print_pi_digits) 0)
}

fn run_single_calculation(decimal_places: int) -> int {
    (println "========================================")
    (print "Calculating pi to ")
    (print (int_to_string decimal_places))
    (println " decimal places")
    (println "========================================")
    (println "")

    let start_time: int = (get_nanoseconds)
    let pi_value: string = (calculate_pi_spigot decimal_places)
    let end_time: int = (get_nanoseconds)

    let mut elapsed_ns: int = (- end_time start_time)
    if (<= elapsed_ns 0) {
        set elapsed_ns 1
    }
    let time_str: string = (format_nanoseconds elapsed_ns)

    (print "Result: ")
    (println pi_value)
    (println "")
    (print "Time spent: ")
    (print time_str)
    (println " seconds")
    (println "")

    return 0
}

shadow run_single_calculation {
    assert (== (run_single_calculation 5) 0)
}

# Main function
fn main() -> int {
    let argc: int = (get_argc)
    if (>= argc 2) {
        let arg_value: string = (get_argv 1)
        let mut decimal_places: int = (string_to_int arg_value)
        if (< decimal_places 0) { set decimal_places (- 0 decimal_places) } else {}
        return (run_single_calculation decimal_places)
    }

    (println "========================================")
    (println "Pi Calculator")
    (println "========================================")
    (println "")
    (println "Computing pi using multiple methods...")
    (println "")
    (println "Note: Standard floating point provides")
    (println "~15-17 decimal digits of precision.")
    (println "For 500 digits, arbitrary precision")
    (println "arithmetic would be needed (e.g., GMP).")
    (println "")
    (println "Here are high-precision estimates using")
    (println "different mathematical formulas:")
    (println "")
    (println "========================================")
    (println "")
    
    let result: int = (print_pi_digits)
    
    (println "========================================")
    (println "")
    (println "Actual pi (first 50 digits):")
    (println "3.14159265358979323846264338327950288419716939937510")
    (println "")
    (println "For 500 decimal places, nanolang would need:")
    (println "1. Arbitrary precision arithmetic library")
    (println "2. Extern binding to GMP (GNU Multiple Precision)")
    (println "3. Or implement bignum arithmetic in nanolang")
    (println "")
    (println "This example demonstrates the mathematical")
    (println "algorithms that could be used with arbitrary")
    (println "precision once that capability is added.")
    (println "========================================")
    
    return result
}

shadow main {
    assert (== (main) 0)
}

