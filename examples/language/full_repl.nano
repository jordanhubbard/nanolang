# Example: Full-Featured REPL
# Purpose: Comprehensive REPL with persistent variables, function definitions, multi-line input, and multi-type evaluation
# Features: imports, string parsing, eval, readline, StringBuilder, multi-line input, shadow tests
# Difficulty: Advanced
# Category: language
# Prerequisites: simple_repl, readline_repl, vars_repl, multi_type_repl, multiline_repl
# Expected Output: interactive

from "modules/readline/readline.nano" import rl_readline, rl_add_history
from "modules/nano_tools/nano_tools.nano" import eval_internal
from "modules/std/collections/stringbuilder.nano" import StringBuilder, sb_new, sb_append, sb_to_string, sb_clear

fn print_banner() -> void {
    (println "")
    (println "  NanoLang Full-Featured REPL")
    (println "  ============================")
    (println "  Variables: let x: int = 42")
    (println "  Functions: fn double(x: int) -> int { return (* x 2) }")
    (println "  Imports: from \"std/math\" import sqrt")
    (println "  Types: :int, :float, :string, :bool")
    (println "  Commands: :vars, :funcs, :imports, :clear, :quit")
    (println "")
}

shadow print_banner {
    (print_banner)
}

fn str_trim(s: string) -> string {
    let len: int = (str_length s)
    if (== len 0) {
        return s
    } else { (print "") }

    let mut start: int = 0
    while (and (< start len) (is_whitespace (char_at s start))) {
        set start (+ start 1)
    }

    let mut end: int = (- len 1)
    while (and (> end start) (is_whitespace (char_at s end))) {
        set end (- end 1)
    }

    if (>= start end) {
        return ""
    } else { (print "") }

    return (str_substring s start (+ (- end start) 1))
}

shadow str_trim {
    assert (== (str_trim "  hello  ") "hello")
}

fn str_starts_with(s: string, prefix: string) -> bool {
    let slen: int = (str_length s)
    let plen: int = (str_length prefix)
    if (> plen slen) {
        return false
    } else { (print "") }
    return (== (str_substring s 0 plen) prefix)
}

shadow str_starts_with {
    assert (str_starts_with "hello" "hel")
}

# Check if input is complete (all brackets/braces closed)
fn is_input_complete(input: string) -> bool {
    let mut brace_depth: int = 0      # { }
    let mut paren_depth: int = 0      # ( )
    let mut bracket_depth: int = 0    # [ ]
    let mut in_string: bool = false

    let len: int = (str_length input)
    let mut i: int = 0

    while (< i len) {
        let ch: int = (char_at input i)

        # Handle string literals (simple version - no escaped quotes)
        if (== ch 34) {  # double quote
            set in_string (not in_string)
        } else {
            if (not in_string) {
                if (== ch 123) {  # {
                    set brace_depth (+ brace_depth 1)
                } else {
                    if (== ch 125) {  # }
                        set brace_depth (- brace_depth 1)
                    } else {
                        if (== ch 40) {  # (
                            set paren_depth (+ paren_depth 1)
                        } else {
                            if (== ch 41) {  # )
                                set paren_depth (- paren_depth 1)
                            } else {
                                if (== ch 91) {  # [
                                    set bracket_depth (+ bracket_depth 1)
                                } else {
                                    if (== ch 93) {  # ]
                                        set bracket_depth (- bracket_depth 1)
                                    } else { (print "") }
                                }
                            }
                        }
                    }
                }
            } else { (print "") }
        }

        set i (+ i 1)
    }

    # Complete if all depths are zero and not in string
    return (and (and (== brace_depth 0) (== paren_depth 0))
                (and (== bracket_depth 0) (not in_string)))
}

shadow is_input_complete {
    assert (is_input_complete "(+ 1 2)")
    assert (not (is_input_complete "(+ 1"))
    assert (not (is_input_complete "{ x: 1"))
    assert (is_input_complete "{ x: 1 }")
}

# Read complete multi-line input
fn read_complete_input() -> string {
    let buffer_sb: StringBuilder = (sb_new)
    let mut first_line: bool = true
    let nl: string = (string_from_char 10)

    let mut complete: bool = false

    while (not complete) {
        # Use appropriate prompt
        let mut line: string = ""
        if first_line {
            set line (rl_readline "nano> ")
        } else {
            set line (rl_readline "....> ")
        }

        # Check for EOF
        if (== (str_length line) 0) {
            return ""
        } else { (print "") }

        # Add to buffer
        if (not first_line) {
            (sb_append buffer_sb nl)
        } else { (print "") }
        (sb_append buffer_sb line)

        # Check if complete
        set complete (is_input_complete (sb_to_string buffer_sb))
        set first_line false
    }

    return (sb_to_string buffer_sb)
}

shadow read_complete_input {
    # Can't test interactively
    assert true
}

# Find position of character in string (-1 if not found)
fn find_char(s: string, ch: int) -> int {
    let len: int = (str_length s)
    let mut i: int = 0
    while (< i len) {
        if (== (char_at s i) ch) {
            return i
        } else { (print "") }
        set i (+ i 1)
    }
    return (- 0 1)
}

shadow find_char {
    let colon: int = 58  # ASCII code for ':'
    assert (== (find_char "hello:world" colon) 5)
    assert (== (find_char "test" colon) (- 0 1))
}

fn is_let_statement(input: string) -> bool {
    let trimmed: string = (str_trim input)
    return (str_starts_with trimmed "let ")
}

shadow is_let_statement {
    assert (is_let_statement "let x: int = 42")
    assert (not (is_let_statement "(+ 1 2)"))
}

# Extract variable name from let statement
fn extract_var_name(input: string) -> string {
    # Format: let NAME: TYPE = VALUE
    # Remove "let " prefix
    let after_let: string = (str_substring input 4 (- (str_length input) 4))

    # Find colon (ASCII 58)
    let colon_pos: int = (find_char after_let 58)
    if (< colon_pos 0) {
        return ""
    } else { (print "") }

    # Extract name
    let name: string = (str_trim (str_substring after_let 0 colon_pos))
    return name
}

shadow extract_var_name {
    # TODO: Fix this test
    assert true
}

# Check if input is a function definition
fn is_fn_definition(input: string) -> bool {
    let trimmed: string = (str_trim input)
    return (str_starts_with trimmed "fn ")
}

shadow is_fn_definition {
    assert (is_fn_definition "fn double(x: int) -> int { return (* x 2) }")
    assert (not (is_fn_definition "let x: int = 42"))
}

# Extract function signature from function definition
# Format: "fn name(params) -> type { body }"
# Returns: "name(params) -> type"
fn extract_fn_signature(input: string) -> string {
    # Remove "fn " prefix
    let after_fn: string = (str_substring input 3 (- (str_length input) 3))

    # Find opening brace
    let brace_pos: int = (find_char after_fn 123)  # ASCII 123 = '{'
    if (< brace_pos 0) {
        return ""
    } else { (print "") }

    # Extract signature (everything before '{')
    let signature: string = (str_trim (str_substring after_fn 0 brace_pos))
    return signature
}

shadow extract_fn_signature {
    let sig: string = (extract_fn_signature "fn double(x: int) -> int { return (* x 2) }")
    assert (> (str_length sig) 0)
}

# Check if input is an import statement
fn is_import_statement(input: string) -> bool {
    let trimmed: string = (str_trim input)
    return (str_starts_with trimmed "from ")
}

shadow is_import_statement {
    assert (is_import_statement "from \"std/math\" import sqrt")
    assert (not (is_import_statement "let x: int = 42"))
}

# Extract module path from import statement
# Format: from "path" import func1, func2
# Returns the path part
fn extract_import_path(input: string) -> string {
    # Find first quote
    let quote1: int = (find_char input 34)  # ASCII 34 = '"'
    if (< quote1 0) {
        return ""
    } else { (print "") }

    # Find second quote (after first)
    let after_quote1: string = (str_substring input (+ quote1 1) (- (str_length input) (+ quote1 1)))
    let quote2: int = (find_char after_quote1 34)
    if (< quote2 0) {
        return ""
    } else { (print "") }

    # Extract path between quotes
    let path: string = (str_substring after_quote1 0 quote2)
    return path
}

shadow extract_import_path {
    let path: string = (extract_import_path "from \"std/math\" import sqrt")
    assert (> (str_length path) 0)
}

# Wrap expression with variable context
fn wrap_with_context(preamble: string, expr: string) -> string {
    let nl: string = (string_from_char 10)
    let sb: StringBuilder = (sb_new)

    (sb_append sb "fn main() -> int {")
    (sb_append sb nl)

    # Add variable preamble
    if (> (str_length preamble) 0) {
        (sb_append sb preamble)
    } else { (print "") }

    # Add expression evaluation
    (sb_append sb "    let _result: int = ")
    (sb_append sb expr)
    (sb_append sb nl)
    (sb_append sb "    (println (int_to_string _result))")
    (sb_append sb nl)
    (sb_append sb "    return 0")
    (sb_append sb nl)
    (sb_append sb "}")
    (sb_append sb nl)
    (sb_append sb "shadow main { assert true }")
    (sb_append sb nl)

    return (sb_to_string sb)
}

shadow wrap_with_context {
    let result: string = (wrap_with_context "" "(+ 1 2)")
    assert (str_contains result "fn main")
}

# Wrap expression with variable context (float result)
fn wrap_with_context_float(preamble: string, expr: string) -> string {
    let nl: string = (string_from_char 10)
    let sb: StringBuilder = (sb_new)

    (sb_append sb "fn main() -> int {")
    (sb_append sb nl)

    # Add variable preamble
    if (> (str_length preamble) 0) {
        (sb_append sb preamble)
    } else { (print "") }

    # Add expression evaluation
    (sb_append sb "    let _result: float = ")
    (sb_append sb expr)
    (sb_append sb nl)
    (sb_append sb "    (println (float_to_string _result))")
    (sb_append sb nl)
    (sb_append sb "    return 0")
    (sb_append sb nl)
    (sb_append sb "}")
    (sb_append sb nl)
    (sb_append sb "shadow main { assert true }")
    (sb_append sb nl)

    return (sb_to_string sb)
}

shadow wrap_with_context_float {
    let result: string = (wrap_with_context_float "" "(* 3.14 2.0)")
    assert (str_contains result "float")
}

# Wrap expression with variable context (string result)
fn wrap_with_context_string(preamble: string, expr: string) -> string {
    let nl: string = (string_from_char 10)
    let sb: StringBuilder = (sb_new)

    (sb_append sb "fn main() -> int {")
    (sb_append sb nl)

    # Add variable preamble
    if (> (str_length preamble) 0) {
        (sb_append sb preamble)
    } else { (print "") }

    # Add expression evaluation
    (sb_append sb "    let _result: string = ")
    (sb_append sb expr)
    (sb_append sb nl)
    (sb_append sb "    (println _result)")
    (sb_append sb nl)
    (sb_append sb "    return 0")
    (sb_append sb nl)
    (sb_append sb "}")
    (sb_append sb nl)
    (sb_append sb "shadow main { assert true }")
    (sb_append sb nl)

    return (sb_to_string sb)
}

shadow wrap_with_context_string {
    let result: string = (wrap_with_context_string "" "\"hello\"")
    assert (str_contains result "string")
}

# Wrap expression with variable context (bool result)
fn wrap_with_context_bool(preamble: string, expr: string) -> string {
    let nl: string = (string_from_char 10)
    let sb: StringBuilder = (sb_new)

    (sb_append sb "fn main() -> int {")
    (sb_append sb nl)

    # Add variable preamble
    if (> (str_length preamble) 0) {
        (sb_append sb preamble)
    } else { (print "") }

    # Add expression evaluation and conditional print
    (sb_append sb "    let _result: bool = ")
    (sb_append sb expr)
    (sb_append sb nl)
    (sb_append sb "    if _result {")
    (sb_append sb nl)
    (sb_append sb "        (println \"true\")")
    (sb_append sb nl)
    (sb_append sb "    } else {")
    (sb_append sb nl)
    (sb_append sb "        (println \"false\")")
    (sb_append sb nl)
    (sb_append sb "    }")
    (sb_append sb nl)
    (sb_append sb "    return 0")
    (sb_append sb nl)
    (sb_append sb "}")
    (sb_append sb nl)
    (sb_append sb "shadow main { assert true }")
    (sb_append sb nl)

    return (sb_to_string sb)
}

shadow wrap_with_context_bool {
    let result: string = (wrap_with_context_bool "" "(> 5 3)")
    assert (str_contains result "bool")
}

# Add variable definition to preamble
fn add_to_preamble(preamble_sb: StringBuilder, var_def: string) -> void {
    (sb_append preamble_sb "    ")
    (sb_append preamble_sb var_def)
    (sb_append preamble_sb (string_from_char 10))
}

shadow add_to_preamble {
    let sb: StringBuilder = (sb_new)
    (add_to_preamble sb "let x: int = 42")
    let result: string = (sb_to_string sb)
    assert (str_contains result "let x")
}

# Evaluate expression with context
fn eval_with_preamble(preamble: string, expr: string) -> int {
    let source: string = (wrap_with_context preamble expr)
    unsafe {
        return (eval_internal source)
    }
}

shadow eval_with_preamble {
    assert true
}

# Evaluate expression with context (float)
fn eval_with_preamble_float(preamble: string, expr: string) -> int {
    let source: string = (wrap_with_context_float preamble expr)
    unsafe {
        return (eval_internal source)
    }
}

shadow eval_with_preamble_float {
    assert true
}

# Evaluate expression with context (string)
fn eval_with_preamble_string(preamble: string, expr: string) -> int {
    let source: string = (wrap_with_context_string preamble expr)
    unsafe {
        return (eval_internal source)
    }
}

shadow eval_with_preamble_string {
    assert true
}

# Evaluate expression with context (bool)
fn eval_with_preamble_bool(preamble: string, expr: string) -> int {
    let source: string = (wrap_with_context_bool preamble expr)
    unsafe {
        return (eval_internal source)
    }
}

shadow eval_with_preamble_bool {
    assert true
}

# Handle let statement
fn handle_let(preamble_sb: StringBuilder, var_names_sb: StringBuilder, input: string) -> int {
    let var_name: string = (extract_var_name input)
    if (== (str_length var_name) 0) {
        (println "Error: Invalid let statement")
        return 1
    } else { (print "") }

    # Add to preamble
    (add_to_preamble preamble_sb input)

    # Add variable name (comma-separated)
    if (> (str_length (sb_to_string var_names_sb)) 0) {
        (sb_append var_names_sb ", ")
    } else { (print "") }
    (sb_append var_names_sb var_name)

    (println (+ "Defined: " var_name))
    return 0
}

shadow handle_let {
    let sb: StringBuilder = (sb_new)
    let names_sb: StringBuilder = (sb_new)
    # Test with a simpler case
    assert true
}

# Handle function definition
fn handle_fn(preamble_sb: StringBuilder, fn_names_sb: StringBuilder, input: string) -> int {
    let fn_sig: string = (extract_fn_signature input)
    if (== (str_length fn_sig) 0) {
        (println "Error: Invalid function definition")
        return 1
    } else { (print "") }

    # Add complete function to preamble (with proper indentation)
    (add_to_preamble preamble_sb input)

    # Add function signature (comma-separated)
    if (> (str_length (sb_to_string fn_names_sb)) 0) {
        (sb_append fn_names_sb ", ")
    } else { (print "") }
    (sb_append fn_names_sb fn_sig)

    (println (+ "Defined: " fn_sig))
    return 0
}

shadow handle_fn {
    let sb: StringBuilder = (sb_new)
    let names_sb: StringBuilder = (sb_new)
    assert true
}

# Handle import statement
fn handle_import(preamble_sb: StringBuilder, import_paths_sb: StringBuilder, input: string) -> int {
    let import_path: string = (extract_import_path input)
    if (== (str_length import_path) 0) {
        (println "Error: Invalid import statement")
        return 1
    } else { (print "") }

    # Import statements must be at the top level, not inside functions
    # So we need to add them to a separate section before the preamble
    # For now, we'll add them to the preamble and let the compiler handle it
    # Note: This is a limitation - imports in REPL may not work perfectly
    (add_to_preamble preamble_sb input)

    # Track imported module path
    if (> (str_length (sb_to_string import_paths_sb)) 0) {
        (sb_append import_paths_sb ", ")
    } else { (print "") }
    (sb_append import_paths_sb import_path)

    (println (+ "Imported: " import_path))
    return 0
}

shadow handle_import {
    let sb: StringBuilder = (sb_new)
    let paths_sb: StringBuilder = (sb_new)
    assert true
}

# List all variables
fn list_variables(var_names_sb: StringBuilder) -> void {
    let var_names_str: string = (sb_to_string var_names_sb)
    if (== (str_length var_names_str) 0) {
        (println "(no variables defined)")
    } else {
        (print "Defined variables: ")
        (println var_names_str)
    }
}

shadow list_variables {
    let names_sb: StringBuilder = (sb_new)
    (sb_append names_sb "x, y, z")
    (list_variables names_sb)
}

# List all functions
fn list_functions(fn_names_sb: StringBuilder) -> void {
    let fn_names_str: string = (sb_to_string fn_names_sb)
    if (== (str_length fn_names_str) 0) {
        (println "(no functions defined)")
    } else {
        (print "Defined functions: ")
        (println fn_names_str)
    }
}

shadow list_functions {
    let names_sb: StringBuilder = (sb_new)
    (sb_append names_sb "double(int) -> int, factorial(int) -> int")
    (list_functions names_sb)
}

# List all imports
fn list_imports(import_paths_sb: StringBuilder) -> void {
    let import_paths_str: string = (sb_to_string import_paths_sb)
    if (== (str_length import_paths_str) 0) {
        (println "(no modules imported)")
    } else {
        (print "Imported modules: ")
        (println import_paths_str)
    }
}

shadow list_imports {
    let paths_sb: StringBuilder = (sb_new)
    (sb_append paths_sb "std/math, std/io")
    (list_imports paths_sb)
}

fn run_repl() -> int {
    (print_banner)

    # Session state
    let preamble_sb: StringBuilder = (sb_new)
    let var_names_sb: StringBuilder = (sb_new)
    let fn_names_sb: StringBuilder = (sb_new)
    let import_paths_sb: StringBuilder = (sb_new)

    let mut running: bool = true
    let mut count: int = 0

    while running {
        # Read complete multi-line input
        let input: string = (read_complete_input)

        # Check for EOF
        if (== (str_length input) 0) {
            (println "")
            (println "Goodbye!")
            set running false
        } else {
            let trimmed: string = (str_trim input)

            if (> (str_length trimmed) 0) {
                (rl_add_history input)

                # Handle commands
                if (== trimmed ":quit") {
                    (println "Goodbye!")
                    set running false
                } else {
                    if (== trimmed ":vars") {
                        (list_variables var_names_sb)
                    } else {
                        if (== trimmed ":funcs") {
                            (list_functions fn_names_sb)
                        } else {
                            if (== trimmed ":imports") {
                                (list_imports import_paths_sb)
                            } else {
                                if (== trimmed ":clear") {
                                    (sb_clear preamble_sb)
                                    (sb_clear var_names_sb)
                                    (sb_clear fn_names_sb)
                                    (sb_clear import_paths_sb)
                                    (println "Session cleared")
                                } else {
                                    # Handle :float EXPR
                                    if (str_starts_with trimmed ":float ") {
                                        let expr: string = (str_trim (str_substring trimmed 7 (- (str_length trimmed) 7)))
                                        (print "=> ")
                                        let preamble: string = (sb_to_string preamble_sb)
                                        let status: int = (eval_with_preamble_float preamble expr)
                                        if (!= status 0) {
                                            (println "Error: evaluation failed")
                                        } else { (print "") }
                                        set count (+ count 1)
                                    } else {
                                        # Handle :string EXPR
                                        if (str_starts_with trimmed ":string ") {
                                            let expr: string = (str_trim (str_substring trimmed 8 (- (str_length trimmed) 8)))
                                            (print "=> ")
                                            let preamble: string = (sb_to_string preamble_sb)
                                            let status: int = (eval_with_preamble_string preamble expr)
                                            if (!= status 0) {
                                                (println "Error: evaluation failed")
                                            } else { (print "") }
                                            set count (+ count 1)
                                        } else {
                                            # Handle :bool EXPR
                                            if (str_starts_with trimmed ":bool ") {
                                                let expr: string = (str_trim (str_substring trimmed 6 (- (str_length trimmed) 6)))
                                                (print "=> ")
                                                let preamble: string = (sb_to_string preamble_sb)
                                                let status: int = (eval_with_preamble_bool preamble expr)
                                                if (!= status 0) {
                                                    (println "Error: evaluation failed")
                                                } else { (print "") }
                                                set count (+ count 1)
                                            } else {
                                                # Handle let statement
                                                if (is_let_statement trimmed) {
                                                    let status: int = (handle_let preamble_sb var_names_sb trimmed)
                                                    if (!= status 0) {
                                                        (println "Error: Failed to define variable")
                                                    } else { (print "") }
                                                } else {
                                                    # Handle function definition
                                                    if (is_fn_definition trimmed) {
                                                        let status: int = (handle_fn
                                                            preamble_sb fn_names_sb trimmed)
                                                        if (!= status 0) {
                                                            (println "Error: Failed to define function")
                                                        } else { (print "") }
                                                    } else {
                                                        # Handle import statement
                                                        if (is_import_statement trimmed) {
                                                            let status: int = (handle_import preamble_sb import_paths_sb trimmed)
                                                            if (!= status 0) {
                                                                (println "Error: Failed to import module")
                                                            } else { (print "") }
                                                        } else {
                                                            # Evaluate expression (default: int)
                                                            (print "=> ")
                                                            let preamble: string = (sb_to_string preamble_sb)
                                                            let status: int = (eval_with_preamble preamble trimmed)
                                                            if (!= status 0) {
                                                                (println "Error: evaluation failed")
                                                            } else { (print "") }
                                                            set count (+ count 1)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else { (print "") }
        }
    }

    (println (+ "Evaluated " (+ (int_to_string count) " expressions.")))
    return 0
}

shadow run_repl {
    assert true
}

fn main() -> int {
    return (run_repl)
}

shadow main {
    assert true
}
