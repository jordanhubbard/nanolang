# Example: Fibonacci Sequence
# Purpose: Classic recursive algorithm with multiple base cases
# Features: recursion, if/else, shadow tests, while loop, string concatenation
# Difficulty: Beginner
# Category: language
# Prerequisites: nl_hello, nl_factorial
# Expected Output: Fibonacci sequence (first 15 numbers):

fn fib(n: int) -> int {
    if (<= n 1) {
        return n
    }
    return (+ (fib (- n 1)) (fib (- n 2)))
}

shadow fib {
    # Test base cases
    assert (== (fib 0) 0)
    assert (== (fib 1) 1)
    
    # Test sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55
    assert (== (fib 2) 1)
    assert (== (fib 3) 2)
    assert (== (fib 4) 3)
    assert (== (fib 5) 5)
    assert (== (fib 6) 8)
    assert (== (fib 7) 13)
    assert (== (fib 8) 21)
    assert (== (fib 9) 34)
    assert (== (fib 10) 55)
}

fn main() -> int {
    (println "Fibonacci sequence (first 15 numbers):")
    (println "")

    let mut i: int = 0
    while (< i 15) {
        # Modern string concatenation using +
        let result: int = (fib i)
        let msg: string = (+ (+ "fib(" (int_to_string i)) (+ ") = " (int_to_string result)))
        (println msg)
        set i (+ i 1)
    }

    return 0
}

shadow main {
    assert (== (main) 0)
}
