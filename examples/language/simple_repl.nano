# NanoLang REPL - Interactive Read-Eval-Print Loop
#
# A full-featured REPL that demonstrates:
# - GNU Readline for line editing and history
# - Dynamic code evaluation using the eval function
# - Command history with persistence to ~/.nanolang_history
#
# Usage:
#   Enter NanoLang expressions to evaluate them.
#   Results are printed automatically.
#   Use arrow keys for history, Ctrl-A/E for line navigation.
#   Type 'quit' or press Ctrl-D to exit.
#
# Examples:
#   nano> (+ 2 3)
#   => 5
#   nano> (* 7 6)
#   => 42
#   nano> (cond ((> 5 3) 100) (else 0))
#   => 100

from "modules/readline/readline.nano" import rl_readline, rl_add_history, rl_read_history, rl_write_history
from "modules/nano_tools/nano_tools.nano" import eval_internal
from "modules/std/collections/stringbuilder.nano" import StringBuilder, sb_new, sb_append, sb_to_string

fn print_banner() -> void {
    (println "")
    (println "  NanoLang REPL")
    (println "  =============")
    (println "  Enter expressions to evaluate them.")
    (println "  Use arrow keys for history navigation.")
    (println "  Type 'help' for commands, 'quit' to exit.")
    (println "")
}

shadow print_banner {
    (print_banner)
}

fn print_help() -> void {
    (println "")
    (println "Commands:")
    (println "  help   - Show this help message")
    (println "  quit   - Exit the REPL (or press Ctrl-D)")
    (println "  clear  - Clear the screen")
    (println "")
    (println "Key bindings (Emacs-style):")
    (println "  Up/Down  - Navigate command history")
    (println "  Ctrl-A   - Beginning of line")
    (println "  Ctrl-E   - End of line")
    (println "  Ctrl-R   - Reverse search history")
    (println "  Ctrl-D   - Exit (on empty line)")
    (println "")
    (println "Examples:")
    (println "  (+ 2 3)                    # => 5")
    (println "  (* 7 6)                    # => 42")
    (println "  (cond ((> 5 3) 100) (else 0))  # => 100")
    (println "")
}

shadow print_help {
    (print_help)
}

fn wrap_expression(expr: string) -> string {
    # Wrap an expression in a main function that prints and returns its value
    let nl: string = (string_from_char 10)
    let sb: StringBuilder = (sb_new)
    (sb_append sb "fn main() -> int {")
    (sb_append sb nl)
    (sb_append sb "    let _result: int = ")
    (sb_append sb expr)
    (sb_append sb nl)
    (sb_append sb "    (println (int_to_string _result))")
    (sb_append sb nl)
    (sb_append sb "    return 0")
    (sb_append sb nl)
    (sb_append sb "}")
    (sb_append sb nl)
    (sb_append sb "shadow main { assert true }")
    (sb_append sb nl)
    return (sb_to_string sb)
}

shadow wrap_expression {
    let result: string = (wrap_expression "(+ 2 3)")
    assert (str_contains result "fn main")
    assert (str_contains result "let _result")
}

fn str_trim(s: string) -> string {
    let len: int = (str_length s)
    if (== len 0) {
        return s
    } else { (print "") }
    
    let mut start: int = 0
    while (and (< start len) (is_whitespace (char_at s start))) {
        set start (+ start 1)
    }
    
    let mut end: int = (- len 1)
    while (and (> end start) (is_whitespace (char_at s end))) {
        set end (- end 1)
    }
    
    if (>= start end) {
        return ""
    } else { (print "") }
    
    return (str_substring s start (+ (- end start) 1))
}

shadow str_trim {
    assert (== (str_trim "  hello  ") "hello")
    assert (== (str_trim "test") "test")
    assert (== (str_trim "   ") "")
}

fn is_command(input: string, cmd: string) -> bool {
    return (== (str_trim input) cmd)
}

shadow is_command {
    assert (is_command "quit" "quit")
    assert (is_command "  help  " "help")
    assert (not (is_command "(+ 1 2)" "quit"))
}

fn is_empty(input: string) -> bool {
    return (== (str_length (str_trim input)) 0)
}

shadow is_empty {
    assert (is_empty "")
    assert (is_empty "   ")
    assert (not (is_empty "hello"))
}

fn eval_expression(expr: string) -> int {
    # Returns 0 on success, 1 on failure
    let source: string = (wrap_expression expr)
    unsafe {
        return (eval_internal source)
    }
}

shadow eval_expression {
    assert (== (eval_expression "(+ 2 3)") 0)
    assert (== (eval_expression "(* 6 7)") 0)
}

fn get_history_file() -> string {
    let home: string = (getenv "HOME")
    if (== (str_length home) 0) {
        return ""
    } else { (print "") }
    return (+ home "/.nanolang_history")
}

shadow get_history_file {
    let path: string = (get_history_file)
    assert true
}

fn clear_screen() -> void {
    # ANSI escape sequence to clear screen and move cursor home
    (print (string_from_char 27))
    (print "[2J")
    (print (string_from_char 27))
    (println "[H")
}

shadow clear_screen {
    # Just verify it doesn't crash
    assert true
}

fn run_repl() -> int {
    (print_banner)
    
    # Load history from file
    let history_file: string = (get_history_file)
    if (> (str_length history_file) 0) {
        let load_result: int = (rl_read_history history_file)
        if (== load_result 0) {
            (println (+ "Loaded history from " history_file))
        } else { (print "") }
    } else { (print "") }
    
    let mut running: bool = true
    let mut count: int = 0
    
    while running {
        let input: string = (rl_readline "nano> ")
        
        # Check for EOF (Ctrl-D)
        if (== (str_length input) 0) {
            (println "")
            (println "Goodbye!")
            set running false
        } else {
            let trimmed: string = (str_trim input)
            
            # Add non-empty, non-command lines to history
            if (and (not (is_empty trimmed)) (not (is_command trimmed "help"))) {
                (rl_add_history input)
            } else { (print "") }
            
            if (is_command trimmed "quit") {
                (println "Goodbye!")
                set running false
            } else {
                if (is_command trimmed "help") {
                    (print_help)
                } else {
                    if (is_command trimmed "clear") {
                        (clear_screen)
                    } else {
                        if (not (is_empty trimmed)) {
                            (print "=> ")
                            let status: int = (eval_expression trimmed)
                            if (!= status 0) {
                                (println "Error: evaluation failed")
                            } else { (print "") }
                            set count (+ count 1)
                        } else { (print "") }
                    }
                }
            }
        }
    }
    
    # Save history to file
    if (> (str_length history_file) 0) {
        let save_result: int = (rl_write_history history_file)
        if (== save_result 0) {
            (println (+ "Saved history to " history_file))
        } else { (print "") }
    } else { (print "") }
    
    (println (+ "Evaluated " (+ (int_to_string count) " expressions.")))
    return 0
}

shadow run_repl {
    assert true
}

fn main() -> int {
    return (run_repl)
}

shadow main {
    assert true
}
