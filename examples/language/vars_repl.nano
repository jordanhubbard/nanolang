# Example: Variables REPL
# Purpose: REPL with persistent variable state across evaluations using a source code preamble approach
# Features: imports, readline, eval, StringBuilder, string parsing, variable tracking, shadow tests
# Difficulty: Intermediate
# Category: language
# Prerequisites: simple_repl, readline_repl
# Expected Output: interactive

from "modules/readline/readline.nano" import rl_readline, rl_add_history
from "modules/nano_tools/nano_tools.nano" import eval_internal
from "modules/std/collections/stringbuilder.nano" import StringBuilder, sb_new, sb_append, sb_to_string, sb_clear

fn print_banner() -> void {
    (println "")
    (println "  NanoLang REPL with Variables")
    (println "  ============================")
    (println "  Try: let x: int = 42")
    (println "  Then: (+ x 10)")
    (println "  Commands: :vars, :clear, :quit")
    (println "")
}

shadow print_banner {
    (print_banner)
}

fn str_trim(s: string) -> string {
    let len: int = (str_length s)
    if (== len 0) {
        return s
    } else { (print "") }

    let mut start: int = 0
    while (and (< start len) (is_whitespace (char_at s start))) {
        set start (+ start 1)
    }

    let mut end: int = (- len 1)
    while (and (> end start) (is_whitespace (char_at s end))) {
        set end (- end 1)
    }

    if (>= start end) {
        return ""
    } else { (print "") }

    return (str_substring s start (+ (- end start) 1))
}

shadow str_trim {
    assert (== (str_trim "  hello  ") "hello")
}

fn str_starts_with(s: string, prefix: string) -> bool {
    let slen: int = (str_length s)
    let plen: int = (str_length prefix)
    if (> plen slen) {
        return false
    } else { (print "") }
    return (== (str_substring s 0 plen) prefix)
}

shadow str_starts_with {
    assert (str_starts_with "hello" "hel")
}

# Find position of character in string (-1 if not found)
fn find_char(s: string, ch: int) -> int {
    let len: int = (str_length s)
    let mut i: int = 0
    while (< i len) {
        if (== (char_at s i) ch) {
            return i
        } else { (print "") }
        set i (+ i 1)
    }
    return (- 0 1)
}

shadow find_char {
    let colon: int = 58  # ASCII code for ':'
    assert (== (find_char "hello:world" colon) 5)
    assert (== (find_char "test" colon) (- 0 1))
}

fn is_let_statement(input: string) -> bool {
    let trimmed: string = (str_trim input)
    return (str_starts_with trimmed "let ")
}

shadow is_let_statement {
    assert (is_let_statement "let x: int = 42")
    assert (not (is_let_statement "(+ 1 2)"))
}

# Extract variable name from let statement
fn extract_var_name(input: string) -> string {
    # Format: let NAME: TYPE = VALUE
    # Remove "let " prefix
    let after_let: string = (str_substring input 4 (- (str_length input) 4))

    # Find colon (ASCII 58)
    let colon_pos: int = (find_char after_let 58)
    if (< colon_pos 0) {
        return ""
    } else { (print "") }

    # Extract name
    let name: string = (str_trim (str_substring after_let 0 colon_pos))
    return name
}

shadow extract_var_name {
    assert (== (extract_var_name "let x: int = 42") "x")
    assert (== (extract_var_name "let count: string = hello") "count")
    assert (== (extract_var_name "no colon here") "")
}

# Wrap expression with variable context
fn wrap_with_context(preamble: string, expr: string) -> string {
    let nl: string = (string_from_char 10)
    let sb: StringBuilder = (sb_new)

    (sb_append sb "fn main() -> int {")
    (sb_append sb nl)

    # Add variable preamble
    if (> (str_length preamble) 0) {
        (sb_append sb preamble)
    } else { (print "") }

    # Add expression evaluation
    (sb_append sb "    let _result: int = ")
    (sb_append sb expr)
    (sb_append sb nl)
    (sb_append sb "    (println (int_to_string _result))")
    (sb_append sb nl)
    (sb_append sb "    return 0")
    (sb_append sb nl)
    (sb_append sb "}")
    (sb_append sb nl)
    (sb_append sb "shadow main { assert true }")
    (sb_append sb nl)

    return (sb_to_string sb)
}

shadow wrap_with_context {
    let result: string = (wrap_with_context "" "(+ 1 2)")
    assert (str_contains result "fn main")
}

# Add variable definition to preamble
fn add_to_preamble(preamble_sb: StringBuilder, var_def: string) -> void {
    (sb_append preamble_sb "    ")
    (sb_append preamble_sb var_def)
    (sb_append preamble_sb (string_from_char 10))
}

shadow add_to_preamble {
    let sb: StringBuilder = (sb_new)
    (add_to_preamble sb "let x: int = 42")
    let result: string = (sb_to_string sb)
    assert (str_contains result "let x")
}

# Evaluate expression with context
fn eval_with_preamble(preamble: string, expr: string) -> int {
    let source: string = (wrap_with_context preamble expr)
    unsafe {
        return (eval_internal source)
    }
}

shadow eval_with_preamble {
    assert true
}

# Handle let statement
fn handle_let(preamble_sb: StringBuilder, var_names_sb: StringBuilder, input: string) -> int {
    let var_name: string = (extract_var_name input)
    if (== (str_length var_name) 0) {
        (println "Error: Invalid let statement")
        return 1
    } else { (print "") }

    # Add to preamble
    (add_to_preamble preamble_sb input)

    # Add variable name (comma-separated)
    if (> (str_length (sb_to_string var_names_sb)) 0) {
        (sb_append var_names_sb ", ")
    } else { (print "") }
    (sb_append var_names_sb var_name)

    (println (+ "Defined: " var_name))
    return 0
}

shadow handle_let {
    let sb: StringBuilder = (sb_new)
    let names_sb: StringBuilder = (sb_new)
    # Test with a simpler case
    assert true
}

# List all variables
fn list_variables(var_names_sb: StringBuilder) -> void {
    let var_names_str: string = (sb_to_string var_names_sb)
    if (== (str_length var_names_str) 0) {
        (println "(no variables defined)")
    } else {
        (print "Defined variables: ")
        (println var_names_str)
    }
}

shadow list_variables {
    let names_sb: StringBuilder = (sb_new)
    (sb_append names_sb "x, y, z")
    (list_variables names_sb)
}

fn run_repl() -> int {
    (print_banner)

    # Session state
    let preamble_sb: StringBuilder = (sb_new)
    let var_names_sb: StringBuilder = (sb_new)

    let mut running: bool = true
    let mut count: int = 0

    while running {
        let input: string = (rl_readline "nano> ")

        # Check for EOF
        if (== (str_length input) 0) {
            (println "")
            (println "Goodbye!")
            set running false
        } else {
            let trimmed: string = (str_trim input)

            if (> (str_length trimmed) 0) {
                (rl_add_history input)

                # Handle commands
                if (== trimmed ":quit") {
                    (println "Goodbye!")
                    set running false
                } else {
                    if (== trimmed ":vars") {
                        (list_variables var_names_sb)
                    } else {
                        if (== trimmed ":clear") {
                            (sb_clear preamble_sb)
                            (sb_clear var_names_sb)
                            (println "Session cleared")
                        } else {
                            # Handle let statement
                            if (is_let_statement trimmed) {
                                let status: int = (handle_let preamble_sb var_names_sb trimmed)
                                if (!= status 0) {
                                    (println "Error: Failed to define variable")
                                } else { (print "") }
                            } else {
                                # Evaluate expression
                                (print "=> ")
                                let preamble: string = (sb_to_string preamble_sb)
                                let status: int = (eval_with_preamble preamble trimmed)
                                if (!= status 0) {
                                    (println "Error: evaluation failed")
                                } else { (print "") }
                                set count (+ count 1)
                            }
                        }
                    }
                }
            } else { (print "") }
        }
    }

    (println (+ "Evaluated " (+ (int_to_string count) " expressions.")))
    return 0
}

shadow run_repl {
    assert true
}

fn main() -> int {
    return (run_repl)
}

shadow main {
    assert true
}
