# Example: Filter, Map, and Fold
# Purpose: Demonstrates classic functional programming patterns using first-class functions
# Features: higher-order functions, predicates, fold, arrays, first-class functions
# Difficulty: Advanced
# Category: language
# Prerequisites: nl_first_class_functions, nl_array_complete
# Expected Output: Filter, Map, and Fold Demo

/* ============================================================================
 * Predicates (fn(T) -> bool)
 * ============================================================================
 */

fn is_positive(x: int) -> bool {
    return (> x 0)
}

shadow is_positive {
    assert (== (is_positive 5) true)
    assert (== (is_positive -3) false)
    assert (== (is_positive 0) false)
}

fn is_even(x: int) -> bool {
    return (== (% x 2) 0)
}

shadow is_even {
    assert (== (is_even 4) true)
    assert (== (is_even 5) false)
    assert (== (is_even 0) true)
}

fn is_greater_than_5(x: int) -> bool {
    return (> x 5)
}

shadow is_greater_than_5 {
    assert (== (is_greater_than_5 10) true)
    assert (== (is_greater_than_5 3) false)
}

/* ============================================================================
 * Transforms (fn(T) -> U)
 * ============================================================================
 */

fn double(x: int) -> int {
    return (* x 2)
}

shadow double {
    assert (== (double 5) 10)
    assert (== (double 0) 0)
}

fn square(x: int) -> int {
    return (* x x)
}

shadow square {
    assert (== (square 5) 25)
    assert (== (square 0) 0)
}

fn negate(x: int) -> int {
    return (- 0 x)
}

shadow negate {
    assert (== (negate 5) -5)
    assert (== (negate -3) 3)
}

/* ============================================================================
 * Binary Operations (fn(T, T) -> T)
 * ============================================================================
 */

fn add(a: int, b: int) -> int {
    return (+ a b)
}

shadow add {
    assert (== (add 2 3) 5)
}

fn multiply(a: int, b: int) -> int {
    return (* a b)
}

shadow multiply {
    assert (== (multiply 4 5) 20)
}

fn maximum(a: int, b: int) -> int {
    if (> a b) {
        return a
    } else {
        return b
    }
}

shadow maximum {
    assert (== (maximum 5 3) 5)
    assert (== (maximum 3 5) 5)
}

/* ============================================================================
 * Higher-Order Functions
 * ============================================================================
 */

/* Count elements that pass test */
fn count_matching(numbers: array<int>, test: fn(int) -> bool) -> int {
    let mut count: int = 0
    let mut i: int = 0
    while (< i (array_length numbers)) {
        let value: int = (at numbers i)
        if (test value) {
            set count (+ count 1)
        } else {}
        set i (+ i 1)
    }
    return count
}

shadow count_matching {
    /* Test counting elements that match a predicate */
    let numbers: array<int> = [1, 2, 3, 4, 5, 6]
    let even_count: int = (count_matching numbers is_even)
    assert (== even_count 3)  /* 2, 4, 6 */
}

/* Apply transform to first element (simplified map) */
fn apply_first(numbers: array<int>, transform: fn(int) -> int) -> int {
    if (> (array_length numbers) 0) {
        return (transform (at numbers 0))
    } else {
        return 0
    }
}

shadow apply_first {
    /* Test applying a transform to the first element */
    let numbers: array<int> = [5, 10, 15]
    let result: int = (apply_first numbers double)
    assert (== result 10)  /* 5 * 2 = 10 */
}

/* Fold: combine elements */
fn fold(numbers: array<int>, initial: int, combine: fn(int, int) -> int) -> int {
    let mut acc: int = initial
    let mut i: int = 0
    while (< i (array_length numbers)) {
        set acc (combine acc (at numbers i))
        set i (+ i 1)
    }
    return acc
}

shadow fold {
    /* Test folding (reducing) an array */
    let numbers: array<int> = [1, 2, 3, 4]
    let sum: int = (fold numbers 0 add)
    assert (== sum 10)  /* 1+2+3+4 = 10 */
}

/* ============================================================================
 * Main Program
 * ============================================================================
 */

fn main() -> int {
    (println "Filter, Map, and Fold Demo")
    (println "===========================")
    (println "")
    
    let numbers: array<int> = [1, -2, 3, -4, 5, 6, -7, 8, 9, -10]
    
    /* Count matching examples */
    (println "COUNT MATCHING:")
    let positive_count: int = (count_matching numbers is_positive)
    (println (+ "Positive numbers: " (int_to_string positive_count)))  /* Should be 6: [1, 3, 5, 6, 8, 9] */
    
    let even_count: int = (count_matching numbers is_even)
    (println (+ "Even numbers: " (int_to_string even_count)))  /* Should be 5: [-2, -4, 6, 8, -10] */
    
    let big_count: int = (count_matching numbers is_greater_than_5)
    (println (+ "Numbers > 5: " (int_to_string big_count)))  /* Should be 3: [6, 8, 9] */
    (println "")
    
    /* Apply transform examples */
    (println "APPLY TRANSFORM:")
    let first_doubled: int = (apply_first numbers double)
    (println (+ "First element doubled: " (int_to_string first_doubled)))  /* 1 * 2 = 2 */
    
    let first_squared: int = (apply_first numbers square)
    (println (+ "First element squared: " (int_to_string first_squared)))  /* 1 * 1 = 1 */
    (println "")
    
    /* Fold examples */
    (println "FOLD:")
    let positives: array<int> = [1, 3, 5, 6, 8, 9]
    let sum: int = (fold positives 0 add)
    (println (+ "Sum of positives: " (int_to_string sum)))  /* Should be 1+3+5+6+8+9 = 32 */
    
    let first_three: array<int> = [1, 3, 5]
    let product: int = (fold first_three 1 multiply)
    (println (+ "Product of [1,3,5]: " (int_to_string product)))  /* Should be 1*3*5 = 15 */
    
    let max_value: int = (fold positives 0 maximum)
    (println (+ "Maximum: " (int_to_string max_value)))  /* Should be 9 */
    (println "")
    
    (println "âœ“ All higher-order functions working!")
    return 0
}

shadow main {
    assert (== (main) 0)
}

