# Example: Multi-Line REPL
# Purpose: REPL with multi-line input support that tracks bracket depth for incomplete expressions and function definitions
# Features: imports, string parsing, eval, readline, StringBuilder, bracket depth tracking, shadow tests
# Difficulty: Advanced
# Category: language
# Prerequisites: simple_repl, readline_repl, vars_repl, multi_type_repl
# Expected Output: interactive

from "modules/readline/readline.nano" import rl_readline, rl_add_history
from "modules/nano_tools/nano_tools.nano" import eval_internal
from "modules/std/collections/stringbuilder.nano" import StringBuilder, sb_new, sb_append, sb_to_string, sb_clear

fn print_banner() -> void {
    (println "")
    (println "  NanoLang REPL (Multi-Line + Multi-Type)")
    (println "  =======================================")
    (println "  Try: let x: int = 42")
    (println "  Then: (+ x 10)        # Defaults to :int")
    (println "  Multi-line: fn double(x: int) -> int {")
    (println "                  return (* x 2)")
    (println "              }")
    (println "  Commands: :vars, :clear, :quit")
    (println "")
}

shadow print_banner {
    (print_banner)
}

fn str_trim(s: string) -> string {
    let len: int = (str_length s)
    if (== len 0) {
        return s
    } else { (print "") }

    let mut start: int = 0
    while (and (< start len) (is_whitespace (char_at s start))) {
        set start (+ start 1)
    }

    let mut end: int = (- len 1)
    while (and (> end start) (is_whitespace (char_at s end))) {
        set end (- end 1)
    }

    if (>= start end) {
        return ""
    } else { (print "") }

    return (str_substring s start (+ (- end start) 1))
}

shadow str_trim {
    assert (== (str_trim "  hello  ") "hello")
}

fn str_starts_with(s: string, prefix: string) -> bool {
    let slen: int = (str_length s)
    let plen: int = (str_length prefix)
    if (> plen slen) {
        return false
    } else { (print "") }
    return (== (str_substring s 0 plen) prefix)
}

shadow str_starts_with {
    assert (str_starts_with "hello" "hel")
}

# Check if input is complete (all brackets/braces closed)
fn is_input_complete(input: string) -> bool {
    let mut brace_depth: int = 0      # { }
    let mut paren_depth: int = 0      # ( )
    let mut bracket_depth: int = 0    # [ ]
    let mut in_string: bool = false

    let len: int = (str_length input)
    let mut i: int = 0

    while (< i len) {
        let ch: int = (char_at input i)

        # Handle string literals (simple version - no escaped quotes)
        if (== ch 34) {  # double quote
            set in_string (not in_string)
        } else {
            if (not in_string) {
                if (== ch 123) {  # {
                    set brace_depth (+ brace_depth 1)
                } else {
                    if (== ch 125) {  # }
                        set brace_depth (- brace_depth 1)
                    } else {
                        if (== ch 40) {  # (
                            set paren_depth (+ paren_depth 1)
                        } else {
                            if (== ch 41) {  # )
                                set paren_depth (- paren_depth 1)
                            } else {
                                if (== ch 91) {  # [
                                    set bracket_depth (+ bracket_depth 1)
                                } else {
                                    if (== ch 93) {  # ]
                                        set bracket_depth (- bracket_depth 1)
                                    } else { (print "") }
                                }
                            }
                        }
                    }
                }
            } else { (print "") }
        }

        set i (+ i 1)
    }

    # Complete if all depths are zero and not in string
    return (and (and (== brace_depth 0) (== paren_depth 0))
                (and (== bracket_depth 0) (not in_string)))
}

shadow is_input_complete {
    assert (is_input_complete "(+ 1 2)")
    assert (not (is_input_complete "(+ 1"))
    assert (not (is_input_complete "{ x: 1"))
    assert (is_input_complete "{ x: 1 }")
}

# Read complete multi-line input
fn read_complete_input() -> string {
    let buffer_sb: StringBuilder = (sb_new)
    let mut first_line: bool = true
    let nl: string = (string_from_char 10)

    let mut complete: bool = false

    while (not complete) {
        # Use appropriate prompt
        let mut line: string = ""
        if first_line {
            set line (rl_readline "nano> ")
        } else {
            set line (rl_readline "....> ")
        }

        # Check for EOF
        if (== (str_length line) 0) {
            return ""
        } else { (print "") }

        # Add to buffer
        if (not first_line) {
            (sb_append buffer_sb nl)
        } else { (print "") }
        (sb_append buffer_sb line)

        # Check if complete
        set complete (is_input_complete (sb_to_string buffer_sb))
        set first_line false
    }

    return (sb_to_string buffer_sb)
}

shadow read_complete_input {
    # Can't test interactively
    assert true
}

# Find position of character in string (-1 if not found)
fn find_char(s: string, ch: int) -> int {
    let len: int = (str_length s)
    let mut i: int = 0
    while (< i len) {
        if (== (char_at s i) ch) {
            return i
        } else { (print "") }
        set i (+ i 1)
    }
    return (- 0 1)
}

shadow find_char {
    let colon: int = 58  # ASCII code for ':'
    assert (== (find_char "hello:world" colon) 5)
    assert (== (find_char "test" colon) (- 0 1))
}

fn is_let_statement(input: string) -> bool {
    let trimmed: string = (str_trim input)
    return (str_starts_with trimmed "let ")
}

shadow is_let_statement {
    assert (is_let_statement "let x: int = 42")
    assert (not (is_let_statement "(+ 1 2)"))
}

# Extract variable name from let statement
fn extract_var_name(input: string) -> string {
    # Format: let NAME: TYPE = VALUE
    # Remove "let " prefix
    let after_let: string = (str_substring input 4 (- (str_length input) 4))

    # Find colon (ASCII 58)
    let colon_pos: int = (find_char after_let 58)
    if (< colon_pos 0) {
        return ""
    } else { (print "") }

    # Extract name
    let name: string = (str_trim (str_substring after_let 0 colon_pos))
    return name
}

shadow extract_var_name {
    # TODO: Fix this test
    assert true
}

# Wrap expression with variable context
fn wrap_with_context(preamble: string, expr: string) -> string {
    let nl: string = (string_from_char 10)
    let sb: StringBuilder = (sb_new)

    (sb_append sb "fn main() -> int {")
    (sb_append sb nl)

    # Add variable preamble
    if (> (str_length preamble) 0) {
        (sb_append sb preamble)
    } else { (print "") }

    # Add expression evaluation
    (sb_append sb "    let _result: int = ")
    (sb_append sb expr)
    (sb_append sb nl)
    (sb_append sb "    (println (int_to_string _result))")
    (sb_append sb nl)
    (sb_append sb "    return 0")
    (sb_append sb nl)
    (sb_append sb "}")
    (sb_append sb nl)
    (sb_append sb "shadow main { assert true }")
    (sb_append sb nl)

    return (sb_to_string sb)
}

shadow wrap_with_context {
    let result: string = (wrap_with_context "" "(+ 1 2)")
    assert (str_contains result "fn main")
}

# Wrap expression with variable context (float result)
fn wrap_with_context_float(preamble: string, expr: string) -> string {
    let nl: string = (string_from_char 10)
    let sb: StringBuilder = (sb_new)

    (sb_append sb "fn main() -> int {")
    (sb_append sb nl)

    # Add variable preamble
    if (> (str_length preamble) 0) {
        (sb_append sb preamble)
    } else { (print "") }

    # Add expression evaluation
    (sb_append sb "    let _result: float = ")
    (sb_append sb expr)
    (sb_append sb nl)
    (sb_append sb "    (println (float_to_string _result))")
    (sb_append sb nl)
    (sb_append sb "    return 0")
    (sb_append sb nl)
    (sb_append sb "}")
    (sb_append sb nl)
    (sb_append sb "shadow main { assert true }")
    (sb_append sb nl)

    return (sb_to_string sb)
}

shadow wrap_with_context_float {
    let result: string = (wrap_with_context_float "" "(* 3.14 2.0)")
    assert (str_contains result "float")
}

# Wrap expression with variable context (string result)
fn wrap_with_context_string(preamble: string, expr: string) -> string {
    let nl: string = (string_from_char 10)
    let sb: StringBuilder = (sb_new)

    (sb_append sb "fn main() -> int {")
    (sb_append sb nl)

    # Add variable preamble
    if (> (str_length preamble) 0) {
        (sb_append sb preamble)
    } else { (print "") }

    # Add expression evaluation
    (sb_append sb "    let _result: string = ")
    (sb_append sb expr)
    (sb_append sb nl)
    (sb_append sb "    (println _result)")
    (sb_append sb nl)
    (sb_append sb "    return 0")
    (sb_append sb nl)
    (sb_append sb "}")
    (sb_append sb nl)
    (sb_append sb "shadow main { assert true }")
    (sb_append sb nl)

    return (sb_to_string sb)
}

shadow wrap_with_context_string {
    let result: string = (wrap_with_context_string "" "\"hello\"")
    assert (str_contains result "string")
}

# Wrap expression with variable context (bool result)
fn wrap_with_context_bool(preamble: string, expr: string) -> string {
    let nl: string = (string_from_char 10)
    let sb: StringBuilder = (sb_new)

    (sb_append sb "fn main() -> int {")
    (sb_append sb nl)

    # Add variable preamble
    if (> (str_length preamble) 0) {
        (sb_append sb preamble)
    } else { (print "") }

    # Add expression evaluation and conditional print
    (sb_append sb "    let _result: bool = ")
    (sb_append sb expr)
    (sb_append sb nl)
    (sb_append sb "    if _result {")
    (sb_append sb nl)
    (sb_append sb "        (println \"true\")")
    (sb_append sb nl)
    (sb_append sb "    } else {")
    (sb_append sb nl)
    (sb_append sb "        (println \"false\")")
    (sb_append sb nl)
    (sb_append sb "    }")
    (sb_append sb nl)
    (sb_append sb "    return 0")
    (sb_append sb nl)
    (sb_append sb "}")
    (sb_append sb nl)
    (sb_append sb "shadow main { assert true }")
    (sb_append sb nl)

    return (sb_to_string sb)
}

shadow wrap_with_context_bool {
    let result: string = (wrap_with_context_bool "" "(> 5 3)")
    assert (str_contains result "bool")
}

# Add variable definition to preamble
fn add_to_preamble(preamble_sb: StringBuilder, var_def: string) -> void {
    (sb_append preamble_sb "    ")
    (sb_append preamble_sb var_def)
    (sb_append preamble_sb (string_from_char 10))
}

shadow add_to_preamble {
    let sb: StringBuilder = (sb_new)
    (add_to_preamble sb "let x: int = 42")
    let result: string = (sb_to_string sb)
    assert (str_contains result "let x")
}

# Evaluate expression with context
fn eval_with_preamble(preamble: string, expr: string) -> int {
    let source: string = (wrap_with_context preamble expr)
    unsafe {
        return (eval_internal source)
    }
}

shadow eval_with_preamble {
    assert true
}

# Evaluate expression with context (float)
fn eval_with_preamble_float(preamble: string, expr: string) -> int {
    let source: string = (wrap_with_context_float preamble expr)
    unsafe {
        return (eval_internal source)
    }
}

shadow eval_with_preamble_float {
    assert true
}

# Evaluate expression with context (string)
fn eval_with_preamble_string(preamble: string, expr: string) -> int {
    let source: string = (wrap_with_context_string preamble expr)
    unsafe {
        return (eval_internal source)
    }
}

shadow eval_with_preamble_string {
    assert true
}

# Evaluate expression with context (bool)
fn eval_with_preamble_bool(preamble: string, expr: string) -> int {
    let source: string = (wrap_with_context_bool preamble expr)
    unsafe {
        return (eval_internal source)
    }
}

shadow eval_with_preamble_bool {
    assert true
}

# Handle let statement
fn handle_let(preamble_sb: StringBuilder, var_names_sb: StringBuilder, input: string) -> int {
    let var_name: string = (extract_var_name input)
    if (== (str_length var_name) 0) {
        (println "Error: Invalid let statement")
        return 1
    } else { (print "") }

    # Add to preamble
    (add_to_preamble preamble_sb input)

    # Add variable name (comma-separated)
    if (> (str_length (sb_to_string var_names_sb)) 0) {
        (sb_append var_names_sb ", ")
    } else { (print "") }
    (sb_append var_names_sb var_name)

    (println (+ "Defined: " var_name))
    return 0
}

shadow handle_let {
    let sb: StringBuilder = (sb_new)
    let names_sb: StringBuilder = (sb_new)
    # Test with a simpler case
    assert true
}

# List all variables
fn list_variables(var_names_sb: StringBuilder) -> void {
    let var_names_str: string = (sb_to_string var_names_sb)
    if (== (str_length var_names_str) 0) {
        (println "(no variables defined)")
    } else {
        (print "Defined variables: ")
        (println var_names_str)
    }
}

shadow list_variables {
    let names_sb: StringBuilder = (sb_new)
    (sb_append names_sb "x, y, z")
    (list_variables names_sb)
}

fn run_repl() -> int {
    (print_banner)

    # Session state
    let preamble_sb: StringBuilder = (sb_new)
    let var_names_sb: StringBuilder = (sb_new)

    let mut running: bool = true
    let mut count: int = 0

    while running {
        # Read complete multi-line input
        let input: string = (read_complete_input)

        # Check for EOF
        if (== (str_length input) 0) {
            (println "")
            (println "Goodbye!")
            set running false
        } else {
            let trimmed: string = (str_trim input)

            if (> (str_length trimmed) 0) {
                (rl_add_history input)

                # Handle commands
                if (== trimmed ":quit") {
                    (println "Goodbye!")
                    set running false
                } else {
                    if (== trimmed ":vars") {
                        (list_variables var_names_sb)
                    } else {
                        if (== trimmed ":clear") {
                            (sb_clear preamble_sb)
                            (sb_clear var_names_sb)
                            (println "Session cleared")
                        } else {
                            # Handle :float EXPR
                            if (str_starts_with trimmed ":float ") {
                                let expr: string = (str_trim (str_substring trimmed 7 (- (str_length trimmed) 7)))
                                (print "=> ")
                                let preamble: string = (sb_to_string preamble_sb)
                                let status: int = (eval_with_preamble_float preamble expr)
                                if (!= status 0) {
                                    (println "Error: evaluation failed")
                                } else { (print "") }
                                set count (+ count 1)
                            } else {
                                # Handle :string EXPR
                                if (str_starts_with trimmed ":string ") {
                                    let expr: string = (str_trim (str_substring trimmed 8 (- (str_length trimmed) 8)))
                                    (print "=> ")
                                    let preamble: string = (sb_to_string preamble_sb)
                                    let status: int = (eval_with_preamble_string preamble expr)
                                    if (!= status 0) {
                                        (println "Error: evaluation failed")
                                    } else { (print "") }
                                    set count (+ count 1)
                                } else {
                                    # Handle :bool EXPR
                                    if (str_starts_with trimmed ":bool ") {
                                        let expr: string = (str_trim (str_substring trimmed 6 (- (str_length trimmed) 6)))
                                        (print "=> ")
                                        let preamble: string = (sb_to_string preamble_sb)
                                        let status: int = (eval_with_preamble_bool preamble expr)
                                        if (!= status 0) {
                                            (println "Error: evaluation failed")
                                        } else { (print "") }
                                        set count (+ count 1)
                                    } else {
                                        # Handle let statement
                                        if (is_let_statement trimmed) {
                                            let status: int = (handle_let preamble_sb var_names_sb trimmed)
                                            if (!= status 0) {
                                                (println "Error: Failed to define variable")
                                            } else { (print "") }
                                        } else {
                                            # Evaluate expression (default: int)
                                            (print "=> ")
                                            let preamble: string = (sb_to_string preamble_sb)
                                            let status: int = (eval_with_preamble preamble trimmed)
                                            if (!= status 0) {
                                                (println "Error: evaluation failed")
                                            } else { (print "") }
                                            set count (+ count 1)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else { (print "") }
        }
    }

    (println (+ "Evaluated " (+ (int_to_string count) " expressions.")))
    return 0
}

shadow run_repl {
    assert true
}

fn main() -> int {
    return (run_repl)
}

shadow main {
    assert true
}
