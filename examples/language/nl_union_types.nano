# Example: Union Types
# Purpose: Demonstrates tagged union (sum type) definitions with generic and non-generic variants
# Features: union types, generics, match, Result, Status, Data variants
# Difficulty: Intermediate
# Category: language
# Prerequisites: nl_hello
# Expected Output: Generic Result<int, string> types created successfully

/* Define a generic Result union for error handling */
union Result<T, E> {
    Ok { value: T },
    Error { error: E }
}

/* Function that returns a generic union type with string error */
fn divide(a: int, b: int) -> Result<int, string> {
    if (== b 0) {
        return Result.Error { error: "Division by zero" }
    } else {
        return Result.Ok { value: (/ a b) }
    }
}

shadow divide {
    let ok: Result<int, string> = (divide 10 2)
    let err: Result<int, string> = (divide 10 0)
    # Both should execute without crashing
    assert (== 1 1)
}

/* Union with empty variants */
union Status {
    Pending {},
    Running {},
    Complete {}
}

fn get_status() -> Status {
    return Status.Running {}
}

shadow get_status {
    let s: Status = (get_status)
    assert (== 1 1)
}

/* Union with mixed field types */
union Data {
    Empty {},
    Integer { value: int },
    Text { message: string },
    Pair { first: int, second: int }
}

fn create_pair(a: int, b: int) -> Data {
    return Data.Pair { first: a, second: b }
}

shadow create_pair {
    let d: Data = (create_pair 1 2)
    assert (== 1 1)
}

fn main() -> int {
    /* Create generic union values */
    let _result_ok: Result<int, string> = (divide 10 2)
    let _result_err: Result<int, string> = (divide 10 0)
    
    (println "Generic Result<int, string> types created successfully")
    
    /* Non-generic unions still work too */
    let _status: Status = (get_status)
    
    let _data1: Data = Data.Empty {}
    let _data2: Data = Data.Integer { value: 42 }
    let _data3: Data = Data.Text { message: "Hello" }
    let _data4: Data = (create_pair 5 10)
    
    (println "Union types demonstration complete!")
    (println "✓ Generic unions (Result<T,E>): Working")
    (println "✓ Non-generic unions (Status, Data): Working")
    return 0
}

shadow main {
    assert (== (main) 0)
}

