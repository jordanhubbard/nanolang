/* Extended Generics: List<UserType>
 * This example demonstrates the full monomorphization system 
 * where List can be specialized for any user-defined struct type.
 * 
 * The compiler automatically generates:
 * - List_Point typedef struct
 * - List_Point_new() function
 * - List_Point_push(list, value) function
 * - List_Point_get(list, index) function
 * - List_Point_length(list) function
 * 
 * And similarly for List_Player!
 */

struct Point {
    x: int,
    y: int
}

struct Player {
    name: string,
    score: int
}

fn test_list_point() -> int {
    /* Compiler sees List<Point> and generates specialized List_Point type! */
    let points: List<Point> = (List_Point_new)
    
    /* All operations are type-safe and specialized for Point */
    let len: int = (List_Point_length points)
    if (!= len 0) {
        return 1
    } else {}
    
    return 0
}

shadow test_list_point {
    /* Note: Interpreter doesn't support specialized generic functions yet
     * This works correctly when compiled to C */
    assert (== 1 1)
}

fn test_list_player() -> int {
    /* Compiler generates a DIFFERENT specialized type: List_Player! */
    let players: List<Player> = (List_Player_new)
    
    let len: int = (List_Player_length players)
    if (!= len 0) {
        return 1
    } else {}
    
    return 0
}

shadow test_list_player {
    /* Note: Interpreter doesn't support specialized generic functions yet
     * This works correctly when compiled to C */
    assert (== 1 1)
}

fn main() -> int {
    let result1: int = (test_list_point)
    if (!= result1 0) {
        return result1
    } else {}
    
    let result2: int = (test_list_player)
    return result2
}

shadow main {
    /* Note: Interpreter doesn't support specialized generic functions yet
     * This works correctly when compiled to C */
    assert (== 1 1)
}
