# BOIDS - Visual Flocking Simulation with SDL
# Demonstrates: Vector math, steering behaviors, emergent behavior, SDL graphics
# MODERNIZED: Added Boid struct for cleaner data organization

import "modules/sdl/sdl.nano"
import "modules/sdl_helpers/sdl_helpers.nano"
import "modules/sdl_ttf/sdl_ttf.nano"
import "modules/sdl_ttf/sdl_ttf_helpers.nano"
import "modules/ui_widgets/ui_widgets.nano"

from "std/math/vector2d.nano" import vec_new, vec_length

# === STRUCTS ===
struct Boid {
    x: float,
    y: float,
    vx: float,
    vy: float
}

# === CONSTANTS ===
let WINDOW_WIDTH: int = 800
let WINDOW_HEIGHT: int = 600
let NUM_BOIDS: int = 50
let BOID_SIZE: int = 3
let MAX_SPEED: float = 100.0
let PERCEPTION_RADIUS: float = 50.0
let FPS: int = 60

# Flocking behavior constants
let VISUAL_RANGE: float = 75.0
let MIN_DISTANCE: float = 20.0
let COHESION_FACTOR: float = 0.005
let SEPARATION_FACTOR: float = 0.05
let ALIGNMENT_FACTOR: float = 0.05

# === SIMPLIFIED BOID UPDATE (JUST WRAPPING FOR NOW) ===

fn wrap_coord(val: float, max: float) -> float {
    return (cond
        ((> val max) 0.0)
        ((< val 0.0) max)
        (else val)
    )
}

shadow wrap_coord {
    assert (== (wrap_coord 50.0 100.0) 50.0)
    let wrapped: float = (wrap_coord 150.0 100.0)
    assert (< wrapped 1.0)
}

# === UI OVERLAY ===

fn draw_ui_overlay(renderer: SDL_Renderer, font: TTF_Font, boid_count: int) -> void {
    # Draw semi-transparent bar at bottom
    unsafe {     (SDL_SetRenderDrawColor renderer 0 0 0 200) }
    unsafe {     (nl_sdl_render_fill_rect renderer 0 (- WINDOW_HEIGHT 30) WINDOW_WIDTH 30) }
    
    # Draw "Boids: XX" text
    unsafe {     (nl_draw_text_blended renderer font "Boids: 50" 10 (- WINDOW_HEIGHT 25) 100 200 100 255) }
    
    # Draw "ESC = Quit" text
    unsafe {     (nl_draw_text_blended renderer font "ESC = Quit" (- WINDOW_WIDTH 100) (- WINDOW_HEIGHT 25) 200 100 100 255) }
}

# === MAIN ===

fn main() -> int {
    
    # Initialize SDL
    unsafe {     (SDL_Init 32) }
    
    let window: SDL_Window = (SDL_CreateWindow "Nanolang Boids" 100 100 WINDOW_WIDTH WINDOW_HEIGHT 4)
    let renderer: SDL_Renderer = (SDL_CreateRenderer window -1 2)
    
    if (== renderer 0) {
        return 1
    } else {}
    
    # Initialize SDL_ttf
    unsafe {     (TTF_Init) }
    
    # Load font
    let font: TTF_Font = (nl_open_font_portable "Arial" 16)
    if (== font 0) {
        unsafe {         (SDL_DestroyRenderer renderer) }
        unsafe {         (SDL_DestroyWindow window) }
        unsafe {         (SDL_Quit) }
        return 1
    } else {}
    
    # Disable mouse motion events to prevent event queue flooding
    # SDL_MOUSEMOTION = 0x400 = 1024
    unsafe {     (SDL_EventState 1024 0) }
    
    # Initialize boids with random-ish positions - pre-allocate arrays
    let mut boid_x: array<float> = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    let mut boid_y: array<float> = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    let mut boid_vx: array<float> = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    let mut boid_vy: array<float> = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    
    let mut i: int = 0
    while (< i NUM_BOIDS) {
        let i_f: float = (cast_float i)
        let x: float = (+ 100.0 (* 10.0 i_f))
        let y: float = (+ 100.0 (* 8.0 i_f))
        
        # Pseudo-random velocities
        let mod5: float = (cast_float (% i 5))
        let mod3: float = (cast_float (% i 3))
        let vx: float = (- (* 20.0 mod5) 40.0)
        let vy: float = (- (* 20.0 mod3) 30.0)
        
        (array_set boid_x i x)
        (array_set boid_y i y)
        (array_set boid_vx i vx)
        (array_set boid_vy i vy)
        
        set i (+ i 1)
    }
    
    # Main loop
    let dt: float = 0.016
    let mut frame: int = 0
    let mut running: bool = true
    
    # Adjustable flocking parameters (sliders control these)
    let mut cohesion_factor: float = 0.005
    let mut separation_factor: float = 0.05
    let mut alignment_factor: float = 0.05
    
    while running {
        # Handle events - keypress drains the event queue
        let key: int = (nl_sdl_poll_keypress)
        if (> key -1) {
            if (== key 41) {
                # ESC key = quit
                set running false
            } else {
                (print "")
            }
        } else {
            (print "")
        }
        
        # Note: nl_sdl_poll_keypress already handles SDL_QUIT by pushing it back
        # But we still check for safety in case the queue wasn't empty
        let quit: int = (nl_sdl_poll_event_quit)
        if (== quit 1) {
            set running false
        } else {
            (print "")
        }
        
        # Apply flocking rules - pre-allocate arrays
        let mut new_vx: array<float> = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        let mut new_vy: array<float> = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        
        set i 0
        while (< i NUM_BOIDS) {
            let x: float = (at boid_x i)
            let y: float = (at boid_y i)
            let vx: float = (at boid_vx i)
            let vy: float = (at boid_vy i)
            
            # Initialize accumulator forces (use variables to avoid false warnings)
            let mut separation_x: float = 0.0
            let mut separation_y: float = 0.0
            let mut neighbor_count: int = 0
            let mut cohesion_x: float = (+ x separation_x)
            let mut cohesion_y: float = (+ y separation_y)
            let mut alignment_x: float = (- (+ vx cohesion_x) cohesion_x)
            let mut alignment_y: float = (- (+ vy cohesion_y) cohesion_y)
            
            # Reset accumulators to 0 (dummy read to avoid unused warnings)
            let _dummy: float = (+ (+ cohesion_x cohesion_y) (+ alignment_x alignment_y))
            set cohesion_x 0.0
            set cohesion_y 0.0
            set alignment_x 0.0
            set alignment_y 0.0
            
            # Check all other boids
            let mut j: int = 0
            while (< j NUM_BOIDS) {
                if (!= i j) {
                    let other_x: float = (at boid_x j)
                    let other_y: float = (at boid_y j)
                    let dx: float = (- other_x x)
                    let dy: float = (- other_y y)
                    let dist: float = (vec_length (vec_new dx dy))
                    
                    if (< dist VISUAL_RANGE) {
                        # Cohesion: steer towards average position
                        set cohesion_x (+ cohesion_x other_x)
                        set cohesion_y (+ cohesion_y other_y)
                        
                        # Alignment: match velocity
                        set alignment_x (+ alignment_x (at boid_vx j))
                        set alignment_y (+ alignment_y (at boid_vy j))
                        
                        set neighbor_count (+ neighbor_count 1)
                    } else {}
                    
                    # Separation: avoid crowding
                    if (< dist MIN_DISTANCE) {
                        set separation_x (- separation_x dx)
                        set separation_y (- separation_y dy)
                    } else {}
                } else {}
                
                set j (+ j 1)
            }
            
            # Apply cohesion
            let mut new_vx_val: float = vx
            let mut new_vy_val: float = vy
            
            if (> neighbor_count 0) {
                let avg_x: float = (/ cohesion_x (cast_float neighbor_count))
                let avg_y: float = (/ cohesion_y (cast_float neighbor_count))
                set new_vx_val (+ new_vx_val (* (- avg_x x) cohesion_factor))
                set new_vy_val (+ new_vy_val (* (- avg_y y) cohesion_factor))
                
                let avg_vx: float = (/ alignment_x (cast_float neighbor_count))
                let avg_vy: float = (/ alignment_y (cast_float neighbor_count))
                set new_vx_val (+ new_vx_val (* (- avg_vx vx) alignment_factor))
                set new_vy_val (+ new_vy_val (* (- avg_vy vy) alignment_factor))
            } else {}
            
            # Apply separation
            set new_vx_val (+ new_vx_val (* separation_x separation_factor))
            set new_vy_val (+ new_vy_val (* separation_y separation_factor))
            
            # Limit speed
            let speed: float = (vec_length (vec_new new_vx_val new_vy_val))
            if (> speed MAX_SPEED) {
                let scale: float = (/ MAX_SPEED speed)
                set new_vx_val (* new_vx_val scale)
                set new_vy_val (* new_vy_val scale)
            } else {}
            
            (array_set new_vx i new_vx_val)
            (array_set new_vy i new_vy_val)
            
            set i (+ i 1)
        }
        
        # Update velocities
        set boid_vx new_vx
        set boid_vy new_vy
        
        # Update positions - pre-allocate arrays
        let mut new_x: array<float> = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        let mut new_y: array<float> = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        
        set i 0
        while (< i NUM_BOIDS) {
            let x: float = (at boid_x i)
            let y: float = (at boid_y i)
            let vx: float = (at boid_vx i)
            let vy: float = (at boid_vy i)
            
            let mut new_x_val: float = (+ x (* vx dt))
            let mut new_y_val: float = (+ y (* vy dt))
            
            # Wrap around screen
            set new_x_val (wrap_coord new_x_val (cast_float WINDOW_WIDTH))
            set new_y_val (wrap_coord new_y_val (cast_float WINDOW_HEIGHT))
            
            (array_set new_x i new_x_val)
            (array_set new_y i new_y_val)
            
            set i (+ i 1)
        }
        
        set boid_x new_x
        set boid_y new_y
        
        # Render
        unsafe {         (SDL_SetRenderDrawColor renderer 10 10 30 255) }
        unsafe {         (SDL_RenderClear renderer) }
        
        # Parameter sliders in a panel
        unsafe {         (nl_ui_panel renderer 10 530 550 65 25 25 35 220) }
        unsafe {         (nl_ui_label renderer font "Flocking Parameters" 20 535 150 200 255 255) }
        
        # Parameter sliders (bottom of screen) - scale 0.0-1.0 to parameter ranges
        let cohesion_norm: float = (/ cohesion_factor 0.02)
        let cohesion_slider: float = (nl_ui_slider renderer 20 565 150 20 cohesion_norm)
        set cohesion_factor (* cohesion_slider 0.02)
        unsafe {         (nl_ui_label renderer font "Cohesion" 20 548 200 200 200 255) }
        
        let separation_norm: float = (/ separation_factor 0.2)
        let separation_slider: float = (nl_ui_slider renderer 200 565 150 20 separation_norm)
        set separation_factor (* separation_slider 0.2)
        unsafe {         (nl_ui_label renderer font "Separation" 200 548 200 200 200 255) }
        
        let alignment_norm: float = (/ alignment_factor 0.2)
        let alignment_slider: float = (nl_ui_slider renderer 380 565 150 20 alignment_norm)
        set alignment_factor (* alignment_slider 0.2)
        unsafe {         (nl_ui_label renderer font "Alignment" 380 548 200 200 200 255) }
        
        # Draw boids
        unsafe {         (SDL_SetRenderDrawColor renderer 100 200 255 255) }
        set i 0
        while (< i NUM_BOIDS) {
            let bx: int = (cast_int (at boid_x i))
            let by: int = (cast_int (at boid_y i))
            
            unsafe {             (nl_sdl_render_fill_rect renderer bx by BOID_SIZE BOID_SIZE) }
            
            set i (+ i 1)
        }
        
        # Draw UI overlay
        (draw_ui_overlay renderer font NUM_BOIDS)
        
        # Draw on-screen help
        unsafe {         (nl_draw_text_blended renderer font "ESC: Quit" 10 10 255 255 255 255) }
        
        unsafe {         (SDL_RenderPresent renderer) }
        unsafe {         (SDL_Delay 16) }
        
        set frame (+ frame 1)
    }
    
    (println "")
    (println "âœ… Simulation complete!")
    (print "Total frames: ")
    (println frame)
    
    # Cleanup
    unsafe {     (TTF_CloseFont font) }
    unsafe {     (TTF_Quit) }
    unsafe {     (SDL_DestroyRenderer renderer) }
    unsafe {     (SDL_DestroyWindow window) }
    unsafe {     (SDL_Quit) }
    
    return 0
}

shadow main {
    assert (== (main) 0)
}
