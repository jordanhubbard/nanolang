# SNAKE - Classic Snake Game (Text-based)
# Tests: Dynamic arrays, collision detection, game logic
# MODERNIZED: Uses enums for directions, struct for positions

# === ENUMS ===
enum Direction {
    UP = 0,
    RIGHT = 1,
    DOWN = 2,
    LEFT = 3
}

# === STRUCTS ===
struct Position {
    x: int,
    y: int
}

# === CONSTANTS ===
let GRID_WIDTH: int = 30
let GRID_HEIGHT: int = 15
let INITIAL_LENGTH: int = 3
let MAX_MOVES: int = 50

# === GRID OPERATIONS ===

fn grid_index(x: int, y: int, width: int) -> int {
    return (+ (* y width) x)
}

shadow grid_index {
    assert (== (grid_index 0 0 10) 0)
    assert (== (grid_index 5 2 10) 25)
}

fn is_valid_pos(x: int, y: int, width: int, height: int) -> bool {
    return (and (and (>= x 0) (< x width))
                (and (>= y 0) (< y height)))
}

shadow is_valid_pos {
    assert (== (is_valid_pos 5 5 10 10) true)
    assert (== (is_valid_pos -1 5 10 10) false)
    assert (== (is_valid_pos 10 5 10 10) false)
}

fn move_in_direction(x: int, y: int, dir: int) -> (int, int) {
    if (== dir Direction.UP) {
        return (x, (- y 1))
    } else {
        if (== dir Direction.DOWN) {
            return (x, (+ y 1))
        } else {
            if (== dir Direction.LEFT) {
                return ((- x 1), y)
            } else {
                # Direction.RIGHT
                return ((+ x 1), y)
            }
        }
    }
}

shadow move_in_direction {
    let result: (int, int) = (move_in_direction 5 5 Direction.UP)
    assert (== result.0 5)
    assert (== result.1 4)
    let result2: (int, int) = (move_in_direction 5 5 Direction.LEFT)
    assert (== result2.0 4)
    assert (== result2.1 5)
}

fn print_grid(snake_x: array<int>, snake_y: array<int>, food_x: int, food_y: int, width: int, height: int) -> int {
    # Modern for loop iteration
    for y in (range 0 height) {
        for x in (range 0 width) {
            # Check if this is food (modern boolean expression)
            let is_food: bool = (and (== x food_x) (== y food_y))
            
            if is_food {
                (print "â—‰")
            } else {
                # Check if this is snake (modernized loop)
                let mut is_snake: bool = false
                let snake_len: int = (array_length snake_x)
                for i in (range 0 snake_len) {
                    if (and (== x (at snake_x i)) (== y (at snake_y i))) {
                        set is_snake true
                    } else {
                        (print "")
                    }
                }
                
                if is_snake {
                    (print "â–ˆ")
                } else {
                    (print "Â·")
                }
            }
        }
        (println "")
    }
    return 0
}

shadow print_grid {
    let sx: array<int> = [5, 4, 3]
    let sy: array<int> = [5, 5, 5]
    assert (== (print_grid sx sy 10 5 15 10) 0)
}

# === COLLISION DETECTION ===

fn check_self_collision(snake_x: array<int>, snake_y: array<int>) -> bool {
    let len: int = (array_length snake_x)
    if (< len 2) {
        return false
    } else {
        let head_x: int = (at snake_x 0)
        let head_y: int = (at snake_y 0)
        
        # Check collision with body (modern for loop)
        for i in (range 1 len) {
            if (and (== head_x (at snake_x i)) (== head_y (at snake_y i))) {
                return true
            } else {
                (print "")
            }
        }
        return false
    }
}

shadow check_self_collision {
    let sx1: array<int> = [5, 4, 3]
    let sy1: array<int> = [5, 5, 5]
    assert (== (check_self_collision sx1 sy1) false)
    
    let sx2: array<int> = [5, 4, 3, 5]
    let sy2: array<int> = [5, 5, 5, 5]
    assert (== (check_self_collision sx2 sy2) true)
}

# === MAIN ===

fn main() -> int {
    (println "")
    (println "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    (println "â•‘         SNAKE GAME                    â•‘")
    (println "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    (println "")
    
    # Initialize snake in center, moving right
    let start_x: int = (/ GRID_WIDTH 2)
    let start_y: int = (/ GRID_HEIGHT 2)
    
    let mut snake_x: array<int> = []
    let mut snake_y: array<int> = []
    
    let mut i: int = 0
    while (< i INITIAL_LENGTH) {
        set snake_x (array_push snake_x (- start_x i))
        set snake_y (array_push snake_y start_y)
        set i (+ i 1)
    }
    
    (print "âœ“ Snake initialized at (")
    (print start_x)
    (print ", ")
    (print start_y)
    (println ")")
    
    # Place food
    let mut food_x: int = 20
    let mut food_y: int = 7
    
    (print "âœ“ Food placed at (")
    (print food_x)
    (print ", ")
    (print food_y)
    (println ")")
    (println "")
    
    # Initial direction
    let mut direction: int = Direction.RIGHT
    let mut score: int = 0
    let mut moves: int = 0
    let mut game_over: bool = false
    
    (println "Starting game...")
    (println "")
    (print_grid snake_x snake_y food_x food_y GRID_WIDTH GRID_HEIGHT)
    (println "")
    
    # Game loop - auto-play with simple AI
    while (and (not game_over) (< moves MAX_MOVES)) {
        # Simple AI: move towards food
        let head_x: int = (at snake_x 0)
        let head_y: int = (at snake_y 0)
        
        # Decide direction based on food position
        if (< head_x food_x) {
            set direction Direction.RIGHT
        } else {
            if (> head_x food_x) {
                set direction Direction.LEFT
            } else {
                if (< head_y food_y) {
                    set direction Direction.DOWN
                } else {
                    if (> head_y food_y) {
                        set direction Direction.UP
                    } else {
                        (print "")
                    }
                }
            }
        }
        
        # Calculate new head position using modern tuple return
        let new_pos: (int, int) = (move_in_direction head_x head_y direction)
        let new_head_x: int = new_pos.0
        let new_head_y: int = new_pos.1
        
        # Check wall collision
        if (not (is_valid_pos new_head_x new_head_y GRID_WIDTH GRID_HEIGHT)) {
            (println "ğŸ’¥ Hit wall! Game Over!")
            set game_over true
        } else {
            # Move snake (add new head)
            let mut new_snake_x: array<int> = []
            let mut new_snake_y: array<int> = []
            
            set new_snake_x (array_push new_snake_x new_head_x)
            set new_snake_y (array_push new_snake_y new_head_y)
            
            # Check if food eaten (modern boolean expression)
            let ate_food: bool = (and (== new_head_x food_x) (== new_head_y food_y))
            if ate_food {
                set score (+ score 1)
                # Move food (simple: add offset)
                set food_x (+ food_x 5)
                set food_y (+ food_y 3)
                # Wrap food position
                if (>= food_x GRID_WIDTH) {
                    set food_x (- food_x GRID_WIDTH)
                } else {
                    (print "")
                }
                if (>= food_y GRID_HEIGHT) {
                    set food_y (- food_y GRID_HEIGHT)
                } else {
                    (print "")
                }
            } else {
                (print "")
            }
            
            # Copy rest of body (modern for loop)
            let body_len: int = (array_length snake_x)
            let mut copy_len: int = body_len
            if (not ate_food) {
                set copy_len (- body_len 1)  # Remove tail
            } else {
                (print "")
            }
            
            for i in (range 0 copy_len) {
                set new_snake_x (array_push new_snake_x (at snake_x i))
                set new_snake_y (array_push new_snake_y (at snake_y i))
            }
            
            set snake_x new_snake_x
            set snake_y new_snake_y
            
            # Check self collision
            if (check_self_collision snake_x snake_y) {
                (println "ğŸ Ate self! Game Over!")
                set game_over true
            } else {
                # Print every 10 moves
                if (== (% moves 10) 0) {
                    (print "Move ")
                    (print moves)
                    (print " - Score: ")
                    (println score)
                    (print_grid snake_x snake_y food_x food_y GRID_WIDTH GRID_HEIGHT)
                    (println "")
                } else {
                    (print "")
                }
            }
        }
        
        set moves (+ moves 1)
    }
    
    (println "")
    (println "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    (println "â•‘        GAME COMPLETE âœ“                â•‘")
    (println "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    (println "")
    (print "Final Score: ")
    (println score)
    (print "Total Moves: ")
    (println moves)
    (print "Snake Length: ")
    (println (array_length snake_x))
    (println "")
    (println "âœ… FEATURES DEMONSTRATED:")
    (println "  â€¢ Dynamic snake growth")
    (println "  â€¢ Collision detection (walls & self)")
    (println "  â€¢ Simple AI pathfinding")
    (println "  â€¢ Dynamic array manipulation")
    (println "  â€¢ Score tracking")
    (println "  â€¢ Game state management")
    (println "")
    (println "ğŸ Snake slithered successfully!")
    
    return 0
}

shadow main {
    # Skip running main - it's an interactive game
    assert true
}

