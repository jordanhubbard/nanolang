{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "version": "0.3.0",
  "language": "nanolang",
  "description": "nanolang language specification - A minimal, statically-typed, LLM-friendly, self-hosted language with mandatory shadow-tests",
  
  "types": {
    "primitives": [
      {
        "name": "int",
        "c_type": "int64_t",
        "size": 8,
        "signed": true,
        "description": "64-bit signed integer"
      },
      {
        "name": "float",
        "c_type": "double",
        "size": 8,
        "signed": true,
        "description": "64-bit floating point (IEEE 754)"
      },
      {
        "name": "bool",
        "c_type": "bool",
        "size": 1,
        "signed": false,
        "description": "Boolean value (true or false)"
      },
      {
        "name": "string",
        "c_type": "char*",
        "size": 8,
        "description": "UTF-8 text (heap-allocated, null-terminated)"
      },
      {
        "name": "bstring",
        "c_type": "nl_string_t*",
        "size": 8,
        "description": "Binary string (length-explicit, UTF-8 aware, supports embedded nulls)"
      },
      {
        "name": "void",
        "c_type": "void",
        "size": 0,
        "description": "No value (return type only)"
      }
    ],
    
    "composite": {
      "array": {
        "kind": "array",
        "syntax": "array<element_type>",
        "element_type": "any",
        "dynamic": true,
        "description": "Static array type with fixed element type"
      },
      "struct": {
        "kind": "struct",
        "syntax": "struct Name { field1: type1, field2: type2 }",
        "description": "Product type with named fields",
        "c_transpilation": "typedef struct nl_Name { type1 field1; type2 field2; } nl_Name;"
      },
      "enum": {
        "kind": "enum",
        "syntax": "enum Name { Variant1 = value1, Variant2 = value2 }",
        "description": "Enumeration with integer values",
        "c_transpilation": "typedef enum { nl_Name_Variant1 = value1, nl_Name_Variant2 = value2 } nl_Name;"
      },
      "union": {
        "kind": "union",
        "syntax": "union Name { Variant1 { fields }, Variant2 { fields } }",
        "description": "Tagged union (sum type) with variants",
        "pattern_matching": "match expression { Variant(binding) => body }",
        "c_transpilation": "typedef struct with tag and union of variant structs"
      },
      "generic": {
        "kind": "generic",
        "syntax": "List<T>",
        "description": "Generic types with type parameters (monomorphized at compile time)",
        "examples": ["List<int>", "List<string>", "List<Point>"],
        "built_in_generics": ["List<T>"]
      },
      "function": {
        "kind": "function",
        "syntax": "fn(param_type1, param_type2) -> return_type",
        "description": "First-class function type",
        "examples": [
          "fn(int, int) -> int",
          "fn(string) -> bool",
          "fn() -> void"
        ]
      },
      "tuple": {
        "kind": "tuple",
        "syntax": "(type1, type2, type3)",
        "description": "Tuple type with multiple values - COMPLETE",
        "status": "complete",
        "examples": ["(int, int)", "(string, int, bool)"],
        "usage": [
          "Type annotation: let t: (int, string) = (10, \"hello\")",
          "Tuple literal: (value1, value2, value3)",
          "Index access: tuple.0, tuple.1, tuple.2",
          "Function returns: fn divide(a: int, b: int) -> (int, int)"
        ]
      }
    }
  },
  
  "syntax": {
    "notation": "prefix",
    "description": "S-expression style prefix notation for all operations",
    "examples": {
      "arithmetic": "(+ a b) instead of a + b",
      "comparison": "(== x 5) instead of x == 5",
      "logical": "(and p q) instead of p && q",
      "function_call": "(function_name arg1 arg2) instead of function_name(arg1, arg2)"
    }
  },
  
  "operations": {
    "arithmetic": {
      "add": { "operator": "+", "types": ["int", "float"], "arity": 2, "pure": true },
      "sub": { "operator": "-", "types": ["int", "float"], "arity": 2, "pure": true },
      "mul": { "operator": "*", "types": ["int", "float"], "arity": 2, "pure": true },
      "div": { "operator": "/", "types": ["int", "float"], "arity": 2, "pure": true, "preconditions": ["divisor != 0"] },
      "mod": { "operator": "%", "types": ["int"], "arity": 2, "pure": true, "preconditions": ["divisor != 0"] }
    },
    "comparison": {
      "eq": { "operator": "==", "types": ["int", "float", "bool", "string"], "arity": 2, "pure": true },
      "ne": { "operator": "!=", "types": ["int", "float", "bool", "string"], "arity": 2, "pure": true },
      "lt": { "operator": "<", "types": ["int", "float"], "arity": 2, "pure": true },
      "le": { "operator": "<=", "types": ["int", "float"], "arity": 2, "pure": true },
      "gt": { "operator": ">", "types": ["int", "float"], "arity": 2, "pure": true },
      "ge": { "operator": ">=", "types": ["int", "float"], "arity": 2, "pure": true }
    },
    "logical": {
      "and": { "operator": "and", "types": ["bool"], "arity": 2, "pure": true, "short_circuit": true },
      "or": { "operator": "or", "types": ["bool"], "arity": 2, "pure": true, "short_circuit": true },
      "not": { "operator": "not", "types": ["bool"], "arity": 1, "pure": true }
    }
  },
  
  "statements": {
    "let": {
      "syntax": "let [mut] name: type = expression",
      "description": "Variable declaration (immutable by default)",
      "mutability": "Optional 'mut' keyword for mutable variables"
    },
    "set": {
      "syntax": "set variable_name expression",
      "description": "Variable assignment (variable must be declared as mutable)"
    },
    "if": {
      "syntax": "if condition { then_branch } [else { else_branch }]",
      "description": "Conditional expression (else branch optional)"
    },
    "while": {
      "syntax": "while condition { body }",
      "description": "While loop"
    },
    "for": {
      "syntax": "for var in (range start end) { body }",
      "description": "For loop with range iterator"
    },
    "return": {
      "syntax": "return expression",
      "description": "Return statement"
    },
    "match": {
      "syntax": "match expression { Variant(binding) => body, ... }",
      "description": "Pattern matching on union types"
    }
  },
  
  "features": {
    "shadow_tests": {
      "mandatory": true,
      "description": "Every function must have a shadow-test block with assertions",
      "syntax": "shadow function_name { assert ... }",
      "execution": "Compile-time (during transpilation and type checking)"
    },
    "static_typing": {
      "mandatory": true,
      "description": "All variables and parameters must have explicit type annotations",
      "no_inference": true,
      "no_implicit_conversions": true
    },
    "generics": {
      "strategy": "monomorphization",
      "description": "Generic types are specialized at compile time for each concrete type used",
      "supported": ["List<T>", "user-defined generics"],
      "examples": [
        "List<int>",
        "List<string>",
        "List<Point>"
      ]
    },
    "first_class_functions": {
      "description": "Functions can be passed as parameters, returned, and assigned to variables",
      "syntax": "fn(param_type) -> return_type",
      "no_pointers": "Function types don't expose underlying C function pointers",
      "examples": [
        "let f: fn(int) -> int = double",
        "fn apply(op: fn(int) -> int, x: int) -> int",
        "fn get_function() -> fn(int) -> int"
      ]
    },
    "unions": {
      "description": "Tagged unions (sum types) with pattern matching",
      "variants": "Each variant can have named fields",
      "pattern_matching": "match expression destructures unions safely"
    },
    "namespacing": {
      "description": "All user-defined types are prefixed with nl_ in generated C code",
      "prefix": "nl_",
      "examples": {
        "struct": "Point -> nl_Point",
        "enum": "Status -> nl_Status, Status.Active -> nl_Status_Active",
        "union": "Result -> nl_Result"
      },
      "purpose": "Prevent name collisions with C runtime and enable clean C interop"
    }
  },
  
  "stdlib": {
    "io": {
      "print": { "signature": "print(any) -> void", "description": "Print value to stdout" },
      "println": { "signature": "println(any) -> void", "description": "Print value with newline" },
      "assert": { "signature": "assert(bool) -> void", "description": "Runtime assertion" }
    },
    "math": {
      "abs": { "signature": "abs(int|float) -> int|float", "description": "Absolute value" },
      "min": { "signature": "min(int|float, int|float) -> int|float", "description": "Minimum of two values" },
      "max": { "signature": "max(int|float, int|float) -> int|float", "description": "Maximum of two values" },
      "sqrt": { "signature": "sqrt(float) -> float", "description": "Square root" },
      "pow": { "signature": "pow(float, float) -> float", "description": "Power" },
      "floor": { "signature": "floor(float) -> float", "description": "Round down" },
      "ceil": { "signature": "ceil(float) -> float", "description": "Round up" },
      "round": { "signature": "round(float) -> float", "description": "Round to nearest" },
      "sin": { "signature": "sin(float) -> float", "description": "Sine (radians)" },
      "cos": { "signature": "cos(float) -> float", "description": "Cosine (radians)" },
      "tan": { "signature": "tan(float) -> float", "description": "Tangent (radians)" }
    },
    "string": {
      "str_length": { "signature": "str_length(string) -> int", "description": "String length" },
      "str_concat": { "signature": "str_concat(string, string) -> string", "description": "Concatenate strings" },
      "str_substring": { "signature": "str_substring(string, int, int) -> string", "description": "Extract substring" },
      "str_contains": { "signature": "str_contains(string, string) -> bool", "description": "Check substring" },
      "str_equals": { "signature": "str_equals(string, string) -> bool", "description": "String equality" },
      "char_at": { "signature": "char_at(string, int) -> int", "description": "Get ASCII value at index" },
      "string_from_char": { "signature": "string_from_char(int) -> string", "description": "Create string from ASCII" },
      "is_digit": { "signature": "is_digit(int) -> bool", "description": "Check if character is digit" },
      "is_alpha": { "signature": "is_alpha(int) -> bool", "description": "Check if character is letter" },
      "is_alnum": { "signature": "is_alnum(int) -> bool", "description": "Check if alphanumeric" },
      "is_whitespace": { "signature": "is_whitespace(int) -> bool", "description": "Check if whitespace" },
      "is_upper": { "signature": "is_upper(int) -> bool", "description": "Check if uppercase" },
      "is_lower": { "signature": "is_lower(int) -> bool", "description": "Check if lowercase" },
      "int_to_string": { "signature": "int_to_string(int) -> string", "description": "Convert int to string" },
      "string_to_int": { "signature": "string_to_int(string) -> int", "description": "Parse string to int" },
      "digit_value": { "signature": "digit_value(int) -> int", "description": "Convert '5' -> 5" },
      "char_to_lower": { "signature": "char_to_lower(int) -> int", "description": "Convert to lowercase" },
      "char_to_upper": { "signature": "char_to_upper(int) -> int", "description": "Convert to uppercase" }
    },
    "bstring": {
      "bstr_new": { "signature": "bstr_new(string) -> bstring", "description": "Create binary string from C string" },
      "bstr_new_binary": { "signature": "bstr_new_binary(string, int) -> bstring", "description": "Create binary string with explicit length" },
      "bstr_length": { "signature": "bstr_length(bstring) -> int", "description": "Get binary string length in bytes" },
      "bstr_concat": { "signature": "bstr_concat(bstring, bstring) -> bstring", "description": "Concatenate binary strings" },
      "bstr_substring": { "signature": "bstr_substring(bstring, int, int) -> bstring", "description": "Extract substring from binary string" },
      "bstr_equals": { "signature": "bstr_equals(bstring, bstring) -> bool", "description": "Binary string equality" },
      "bstr_byte_at": { "signature": "bstr_byte_at(bstring, int) -> int", "description": "Get byte value at index" },
      "bstr_to_cstr": { "signature": "bstr_to_cstr(bstring) -> string", "description": "Convert binary string to C string" },
      "bstr_validate_utf8": { "signature": "bstr_validate_utf8(bstring) -> bool", "description": "Check if valid UTF-8" },
      "bstr_utf8_length": { "signature": "bstr_utf8_length(bstring) -> int", "description": "Get UTF-8 character count" },
      "bstr_utf8_char_at": { "signature": "bstr_utf8_char_at(bstring, int) -> int", "description": "Get UTF-8 character code point" },
      "bstr_free": { "signature": "bstr_free(bstring) -> void", "description": "Free binary string memory" }
    },
    "array": {
      "at": { "signature": "at(array<T>, int) -> T", "description": "Get element (bounds-checked)" },
      "array_length": { "signature": "array_length(array<T>) -> int", "description": "Get array length" },
      "array_new": { "signature": "array_new(int, T) -> array<T>", "description": "Create new array" },
      "array_set": { "signature": "array_set(array<T>, int, T) -> void", "description": "Set element (bounds-checked)" },
      "filter": {
        "signature": "filter(array<T>, fn(T) -> bool) -> array<T>",
        "description": "Keep elements that satisfy a predicate and return a new array (compiled + interpreted)"
      },
      "map": {
        "signature": "map(array<T>, fn(T) -> T) -> array<T>",
        "description": "Apply a transform function to each element and return a new array (compiled + interpreted)"
      },
      "reduce": {
        "signature": "reduce(array<T>, A, fn(A, T) -> A) -> A",
        "description": "Fold an array into a single value, starting from an initial accumulator (compiled + interpreted)"
      }
    },
    "os": {
      "getcwd": { "signature": "getcwd() -> string", "description": "Get current directory" },
      "getenv": { "signature": "getenv(string) -> string", "description": "Get environment variable" },
      "range": { "signature": "range(int, int) -> iterator", "description": "Range iterator (for loops only)" }
    },
    "generics": {
      "List_new": { "signature": "List_<T>_new() -> List<T>", "description": "Create empty list (monomorphized for each type)" },
      "List_push": { "signature": "List_<T>_push(List<T>, T) -> void", "description": "Push element to end of list" },
      "List_get": { "signature": "List_<T>_get(List<T>, int) -> T", "description": "Get list element at index (bounds-checked)" },
      "List_length": { "signature": "List_<T>_length(List<T>) -> int", "description": "Get number of elements in list" }
    }
  },
  
  "compilation": {
    "target": "C",
    "c_standard": "C99",
    "strategy": "transpilation",
    "phases": [
      "Lexical analysis (tokenization)",
      "Parsing (AST generation)",
      "Type checking (static analysis)",
      "Shadow-test execution (compile-time testing)",
      "C code generation (transpilation)",
      "C compilation (gcc/clang)"
    ],
    "output": {
      "executable": "Compiled binary from generated C code",
      "intermediate": "Optional .c file output with --keep-c flag"
    },
    "optimization": "Relies on C compiler optimizations"
  },
  
  "tooling": {
    "compiler": {
      "name": "nanoc",
      "version": "0.3.0",
      "usage": "nanoc <input.nano> -o <output>",
      "flags": [
        "--keep-c: Keep generated C file",
        "--verbose: Verbose output",
        "-o: Output binary name"
      ],
      "self_hosted": true,
      "self_hosted_compiler": "nanoc_selfhost.nano (152 lines)"
    },
    "interpreter": {
      "name": "nano",
      "version": "0.3.0",
      "usage": "nano <input.nano> [OPTIONS]",
      "flags": [
        "--trace-all: Trace all execution",
        "--trace-function=<name>: Trace specific function",
        "--trace-var=<name>: Trace variable operations",
        "--trace-scope=<name>: Trace function scope",
        "--call <function>: Call specific function"
      ]
    }
  },

  "common_errors": {
    "missing_shadow_test": {
      "severity": "warning",
      "phase": "typecheck",
      "message_template": "Warning: Function '{name}' is missing a shadow test",
      "cause": "The function has no shadow block (and does not call extern functions).",
      "fix": "Add a shadow block after the function with at least one assert.",
      "example": "fn double(x: int) -> int {\n    return (* x 2)\n}\n\nshadow double {\n    assert (== (double 5) 10)\n}"
    },
    "undefined_variable": {
      "severity": "error",
      "phase": "typecheck",
      "message_template": "Error at line {line}, column {column}: Undefined variable '{name}'",
      "cause": "A variable is referenced before it is declared in the current scope.",
      "fix": "Declare the variable with let before use, or fix the identifier spelling.",
      "example": "fn main() -> int {\n    let y: int = (+ x 1)\n    return 0\n}\n\nshadow main {\n    assert (== (main) 0)\n}"
    },
    "type_mismatch_let": {
      "severity": "error",
      "phase": "typecheck",
      "message_template": "Error at line {line}, column {column}: Type mismatch in let statement",
      "cause": "The declared type of a let binding does not match the type of the initializer expression.",
      "fix": "Change the annotation or change the expression so the types match.",
      "example": "fn main() -> int {\n    let x: int = 3.14\n    return 0\n}\n\nshadow main {\n    assert (== (main) 0)\n}"
    },
    "immutable_assignment": {
      "severity": "error",
      "phase": "typecheck",
      "message_template": "Error at line {line}, column {column}: Cannot assign to immutable variable '{name}'",
      "cause": "set was used on a variable declared without mut.",
      "fix": "Declare the variable with let mut, then use set.",
      "example": "fn main() -> int {\n    let counter: int = 0\n    set counter (+ counter 1)\n    return 0\n}\n\nshadow main {\n    assert (== (main) 0)\n}"
    },
    "undefined_var_or_function_runtime": {
      "severity": "error",
      "phase": "runtime",
      "message_template": "Error: Undefined variable or function '{name}'",
      "cause": "An identifier could not be resolved at runtime (neither variable nor function).",
      "fix": "Ensure the identifier is declared/defined and in scope, or fix the spelling.",
      "example": "fn main() -> int {\n    (foo 1 2)\n    return 0\n}\n\nshadow main {\n    assert (== (main) 0)\n}"
    },
    "missing_main": {
      "severity": "error",
      "phase": "typecheck",
      "message_template": "Error: Program must define a 'main' function",
      "cause": "The entrypoint function main was not found.",
      "fix": "Define fn main() -> int { ... } in the program."
    },
    "main_wrong_return_type": {
      "severity": "error",
      "phase": "typecheck",
      "message_template": "Error: 'main' function must return int",
      "cause": "The main function exists but does not return int.",
      "fix": "Change main signature to fn main() -> int and return an int."
    }
  },

  "debugging": {
    "workflow": [
      "Start with the first reported error and use line/column to locate the source.",
      "Use the interpreter (nano) for fast feedback; enable tracing to understand execution.",
      "If compiling, use nanoc --keep-c to inspect generated C output."
    ],
    "interpreter_flags": {
      "--trace-all": "Trace all execution",
      "--trace-function=<name>": "Trace a specific function",
      "--trace-var=<name>": "Trace variable reads/writes",
      "--trace-scope=<name>": "Trace a function scope",
      "--call <function>": "Call a specific function"
    },
    "compiler_flags": {
      "--keep-c": "Keep the generated C file for inspection",
      "--verbose": "Verbose output",
      "-o": "Output binary name"
    }
  },

  "idioms": {
    "shadow_test_first": {
      "description": "Write the shadow block first to lock behavior, then implement.",
      "example": "fn add(a: int, b: int) -> int {\n    return (+ a b)\n}\n\nshadow add {\n    assert (== (add 2 3) 5)\n}"
    },
    "struct_constructor": {
      "description": "Use a helper function to build structs consistently.",
      "example": "struct Point { x: int, y: int }\n\nfn make_point(x: int, y: int) -> Point {\n    return Point { x: x, y: y }\n}\n\nshadow make_point {\n    let p: Point = (make_point 1 2)\n    assert (== p.x 1)\n    assert (== p.y 2)\n}"
    },
    "import_alias": {
      "description": "Import a module with an alias and call functions via qualified name.",
      "example": "import \"test_modules/math_helper.nano\" as Math\n\nfn main() -> int {\n    let sum: int = (Math.add 2 3)\n    return sum\n}\n\nshadow main {\n    assert (== (main) 5)\n}"
    }
  },
  
  "examples": {
    "hello_world": "fn main() -> int {\n    (println \"Hello, World!\")\n    return 0\n}\n\nshadow main {\n    assert (== (main) 0)\n}",
    "shadow_test_driven": "fn double(x: int) -> int {\n    return (* x 2)\n}\n\nshadow double {\n    assert (== (double 0) 0)\n    assert (== (double 5) 10)\n}",
    "import_alias": "import \"test_modules/math_helper.nano\" as Math\n\nfn main() -> int {\n    return (Math.add 2 3)\n}\n\nshadow main {\n    assert (== (main) 5)\n}",
    "fibonacci": "See examples/nl_fibonacci.nano",
    "prime_checker": "See examples/nl_primes.nano",
    "unions": "See examples/nl_union_types.nano",
    "generics": "See examples/nl_generics_demo.nano",
    "first_class_functions": "See examples/nl_first_class_functions.nano",
    "map_reduce": "See examples/nl_filter_map_fold.nano",
    "data_analytics": "See examples/nl_data_analytics.nano"
  },
  
  "compiler_internals": {
    "location": "stdlib/",
    "description": "Self-hosted compiler components written in NanoLang",
    "modules": [
      {
        "name": "StringBuilder",
        "file": "stdlib/StringBuilder.nano",
        "description": "String building utility for efficient concatenation",
        "functions": 14
      },
      {
        "name": "ast",
        "file": "stdlib/ast.nano",
        "description": "Abstract Syntax Tree data structures and operations",
        "functions": 13
      },
      {
        "name": "lalr",
        "file": "stdlib/lalr.nano",
        "description": "LALR parser tables and algorithms",
        "functions": 20
      }
    ]
  },
  
  "status": {
    "version": "0.3.0",
    "stability": "production-ready",
    "production_ready": true,
    "self_hosted": true,
    "features_complete": [
      "Basic types (int, float, bool, string, bstring, void)",
      "Prefix notation (S-expressions)",
      "Static typing with explicit annotations",
      "Shadow-tests (mandatory, compile-time execution)",
      "Structs (product types)",
      "Enums (named constants)",
      "Unions with pattern matching (sum types)",
      "Tuples (complete)",
      "Generics (List<T>) with monomorphization for all types",
      "First-class functions",
      "Mutability tracking (mut keyword)",
      "Standard library (49+ functions: 3 I/O, 11 math, 18 string, 12 bstring, 4 array, 4 generics)",
      "C transpilation with nl_ namespacing",
      "Module system with FFI support",
      "Import system for code organization",
      "Binary strings (bstring) with UTF-8 support",
      "Self-hosted compiler (nanoc written in NanoLang)",
      "Dual execution (interpreter + compiler)",
      "Comprehensive error messages with line/column tracking"
    ],
    "features_in_development": [
    ],
    "future_features": [
      "More standard library modules",
      "Package manager",
      "Incremental compilation",
      "Optimization passes in NanoLang"
    ],
    "self_hosting_achievement": {
      "date": "2025-11-30",
      "status": "100% complete - true self-hosting achieved",
      "compiler_source": "src_nano/nanoc_selfhost.nano (152 lines)",
      "total_lines": "4,789 lines of self-hosted compiler code",
      "components": {
        "parser": "2,772 lines",
        "typechecker": "795 lines", 
        "transpiler": "1,070 lines",
        "compiler_driver": "152 lines"
      },
      "bootstrap_chain": "C compiler → NanoLang compiler → NanoLang programs",
      "verification": "All 156 shadow tests passing in self-hosted mode",
      "bootstrap_stages": "Stage 0 (C) → Stage 1 (mixed) → Stage 2 (full self-host)",
      "current_status": "Production-ready, self-compiling language (December 2025)"
    }
  }
}
