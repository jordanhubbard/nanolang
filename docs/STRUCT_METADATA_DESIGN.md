# Struct Metadata Design

## Problem Statement

NanoLang currently has no compile-time struct introspection. Complex programs (compilers, serializers, ORMs) need to programmatically query struct field types at runtime.

## Proposed Solution

**Auto-generate metadata functions** for each struct at compile-time.

---

## Design

### User Code (Input)

```nano
struct Point {
    x: int,
    y: int,
    label: string
}
```

### Compiler-Generated Code (Output)

```nano
/* Auto-generated by compiler */
fn __reflect_Point_field_count() -> int {
    return 3
}

fn __reflect_Point_field_name(index: int) -> string {
    if (== index 0) { return "x" }
    else { if (== index 1) { return "y" }
    else { if (== index 2) { return "label" }
    else { return "" }}}
}

fn __reflect_Point_field_type(index: int) -> string {
    if (== index 0) { return "int" }
    else { if (== index 1) { return "int" }
    else { if (== index 2) { return "string" }
    else { return "" }}}
}

fn __reflect_Point_has_field(name: string) -> bool {
    if (== name "x") { return true }
    else { if (== name "y") { return true }
    else { if (== name "label") { return true }
    else { return false }}}
}

fn __reflect_Point_field_type_by_name(name: string) -> string {
    if (== name "x") { return "int" }
    else { if (== name "y") { return "int" }
    else { if (== name "label") { return "string" }
    else { return "" }}}
}
```

### User API (Helper Library)

```nano
/* User-facing reflection API */
fn reflect_field_type(struct_name: string, field_name: string) -> string {
    /* Dynamically dispatch to correct __reflect_* function */
    if (== struct_name "Point") {
        return (__reflect_Point_field_type_by_name field_name)
    } else {
        /* Add more structs as needed */
        return ""
    }
}
```

---

## Implementation Strategy

### Phase 1: Reference Compiler (C)
**File:** `src/transpiler_iterative_v3_twopass.c`

1. During **Phase 1** (struct discovery), collect all struct definitions
2. During **Phase 2** (code emission), generate reflection functions
3. Emit them BEFORE `main()` function

**Key Functions to Modify:**
- `emit_struct_metadata()` - new function
- `emit_c_code()` - call metadata generator

### Phase 2: Self-Hosted Compiler (NanoLang)
**File:** `src_nano/transpiler.nano`

1. Add `emit_struct_metadata()` function
2. Call during transpilation phase
3. Test with `nanoc_v06` self-compilation

### Phase 3: Typechecker Integration
**File:** `src_nano/typecheck.nano`

1. Replace `init_struct_metadata()` hardcoded table
2. Call reflection functions instead
3. Remove 280+ lines of manual metadata

---

## Benefits

✅ **Zero manual maintenance** - metadata stays in sync  
✅ **Works for ANY struct** - not just compiler internals  
✅ **Enables new use cases** - JSON, ORMs, debuggers  
✅ **Backward compatible** - existing code unaffected  

---

## Risks

⚠️ **Code size increase** - each struct generates ~50 LOC  
⚠️ **Dual implementation required** - must implement in C + NanoLang  
⚠️ **No dynamic dispatch** - still need switch/if chains  

---

## Testing Strategy

### Test 1: Simple Struct
```nano
struct Person {
    name: string,
    age: int
}

fn test_metadata() -> bool {
    let count: int = (__reflect_Person_field_count)
    let name0: string = (__reflect_Person_field_name 0)
    let type0: string = (__reflect_Person_field_type 0)
    
    return (and (== count 2) (and (== name0 "name") (== type0 "string")))
}
```

### Test 2: Complex Nested Struct
```nano
struct Config {
    port: int,
    host: string,
    options: array<string>
}
```

### Test 3: Self-Hosted Compiler
- Compile `nanoc_v06.nano` with metadata enabled
- Verify all 149 type errors resolve
- Check binary size increase (<10%)

---

## Timeline

- **Day 1-2**: Implement in reference compiler (C)
- **Day 3**: Test with simple examples
- **Day 4**: Implement in self-hosted compiler
- **Day 5**: Integration testing, docs, examples

---

## Future Enhancements

1. **Generic metadata structs** instead of functions:
   ```nano
   struct FieldInfo {
       name: string,
       type_name: string,
       offset: int
   }
   
   fn __reflect_Point() -> array<FieldInfo> { ... }
   ```

2. **Runtime field access** (advanced):
   ```nano
   fn get_field(obj: any, field_name: string) -> any { ... }
   ```

3. **Macro-based derive** (very advanced):
   ```nano
   @derive(Debug, Serialize)
   struct Point { x: int, y: int }
   ```

---

## Status

**Approved**: 2025-01-07  
**Implementer**: AI Assistant  
**Priority**: P0 (blocks self-hosting)  
**Complexity**: High (3-5 days)  
