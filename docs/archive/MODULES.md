# nanolang Modules

**Version:** 1.0  
**Date:** November 15, 2025  
**Status:** ✅ Implemented

---

## Overview

nanolang supports a module system that allows you to:
- Import other nanolang files as modules
- Import C libraries via FFI modules
- Share code across multiple programs
- Build libraries of reusable functions

Modules work seamlessly in both interpreter and compiler modes.

---

## Syntax

### Importing nanolang Modules

```nano
import "module.nano"
import "utils/math.nano"
import module_name  # Equivalent to "module_name.nano"
import "module.nano" as alias_name
```

**Examples:**

```nano
# Import a math utilities module
import "math_utils.nano"

# Use functions from the module
fn main() -> int {
    let result: int = (add 5 3)  # add is from math_utils.nano
    return result
}
```

### Module Resolution

Modules are resolved relative to the current file:
- `import "math.nano"` looks for `math.nano` in the same directory
- `import "utils/math.nano"` looks for `utils/math.nano` relative to current file
- Absolute paths are also supported: `import "/path/to/module.nano"`

---

## Creating Modules

A module is simply a nanolang file that exports functions, structs, enums, and unions. Modules do **not** require a `main` function.

**Example: `math_utils.nano`**

```nano
# Math utilities module

fn add(a: int, b: int) -> int {
    return (+ a b)
}

shadow add {
    assert (== (add 2 3) 5)
    assert (== (add 0 0) 0)
}

fn multiply(a: int, b: int) -> int {
    return (* a b)
}

shadow multiply {
    assert (== (multiply 3 4) 12)
}
```

**Example: `main.nano`**

```nano
import "math_utils.nano"

fn main() -> int {
    let sum: int = (add 10 20)
    let product: int = (multiply 5 6)
    (println sum)
    (println product)
    return 0
}
```

---

## FFI Modules (C Library Bindings)

Modules can also wrap C libraries using `extern` declarations. This allows nanolang to use any C library.

### Creating FFI Modules

**Example: `sdl.nano` (SDL2 bindings)**

```nano
# SDL2 FFI module
# Generated by nanoc-ffi or manually created

# Include paths: -I/opt/homebrew/include/SDL2
# Library paths: -L/opt/homebrew/lib
# Libraries: -lSDL2

# SDL initialization
extern fn SDL_Init(flags: int) -> int
extern fn SDL_Quit() -> void

# Window management
extern fn SDL_CreateWindow(title: string, x: int, y: int, w: int, h: int, flags: int) -> int
extern fn SDL_DestroyWindow(window: int) -> void

# Event handling
extern fn SDL_PollEvent(event: int) -> int
```

### Using FFI Modules

```nano
import "sdl.nano"

fn main() -> int {
    let result: int = (SDL_Init 0)
    if (!= result 0) {
        return 1
    }
    
    # ... use SDL functions ...
    
    (SDL_Quit)
    return 0
}
```

When compiling, use the compiler flags to link against the library:

```bash
nanoc program.nano -o program -I/opt/homebrew/include/SDL2 -L/opt/homebrew/lib -lSDL2
```

---

## FFI Binding Generator Tool

The `nanoc-ffi` tool helps generate nanolang modules from C header files:

```bash
nanoc-ffi SDL.h -o sdl.nano -I/opt/homebrew/include/SDL2 -L/opt/homebrew/lib -lSDL2
```

**Options:**
- `-o <file>` - Output nanolang module file
- `-I <path>` - Add include path
- `-L <path>` - Add library path  
- `-l <lib>` - Link against library
- `--name <name>` - Module name

The tool generates a template module with metadata comments. You then add `extern` declarations based on the C header file.

**Future Enhancement:** The tool will automatically parse C headers and generate `extern` declarations.

---

## Module Features

### What Modules Export

Modules can export:
- **Functions** - All functions are available to importing modules
- **Structs** - Struct definitions are available
- **Enums** - Enum definitions are available
- **Unions** - Union definitions are available
- **Extern declarations** - C function bindings

### What Modules Don't Export

- **Variables** - Top-level variables are not exported (modules are stateless)
- **Shadow tests** - Shadow tests are not exported (they're for module validation)

---

## Module Loading

### Interpreter Mode

In interpreter mode (`./bin/nano`), modules are:
1. Parsed and type-checked
2. Loaded into the environment
3. Made available to the main program

Modules are loaded **before** the main program is type-checked, so all module symbols are available.

### Compiler Mode

In compiler mode (`./bin/nanoc`), modules are:
1. Parsed and type-checked
2. Their symbols are made available to the main program
3. **Future:** Modules will be compiled to object files and statically linked

**Current Status:** Modules work in compiler mode, but static linking of module object files is not yet implemented. All module code is included in the generated C output.

---

## Best Practices

### 1. Organize Related Functions

Group related functions in modules:

```nano
# math_utils.nano - Math utilities
fn add(...) -> int { ... }
fn multiply(...) -> int { ... }

# string_utils.nano - String utilities  
fn reverse(...) -> string { ... }
fn capitalize(...) -> string { ... }
```

### 2. Use Descriptive Module Names

Use clear, descriptive names:
- ✅ `math_utils.nano`
- ✅ `sdl_bindings.nano`
- ❌ `m.nano`
- ❌ `utils.nano` (too generic)

### 3. Document Module Purpose

Add comments explaining what the module provides:

```nano
# Math utilities module
# Provides basic arithmetic operations: add, subtract, multiply, divide
```

### 4. Keep Modules Focused

Each module should have a single, clear purpose:
- ✅ One module for math utilities
- ✅ One module for SDL bindings
- ❌ One module with everything

### 5. Use Shadow Tests

All module functions should have shadow tests:

```nano
fn add(a: int, b: int) -> int {
    return (+ a b)
}

shadow add {
    assert (== (add 2 3) 5)
    assert (== (add -1 1) 0)
}
```

---

## Limitations

### Current Limitations

1. **No Namespacing** - Module symbols are added to the global namespace
   - If two modules export `add`, there will be a conflict
   - Solution: Use descriptive function names or module aliases

2. **No Static Linking** - Modules are not yet compiled to separate object files
   - All module code is included in the main program's C output
   - Future: Modules will be compiled separately and linked

3. **No Circular Dependencies** - Modules cannot import each other
   - Module A cannot import Module B if Module B imports Module A

4. **No Module Aliases** - The `as` keyword in imports is parsed but not yet used
   - Future: `import "math.nano" as math` will namespace symbols

---

## Examples

See `examples/` directory for module examples:
- `examples/math_utils.nano` - Math utilities module
- `examples/test_import.nano` - Example using imported modules
- `examples/test_modules.nano` - More complex module usage

---

## Future Enhancements

1. **Automatic C Header Parsing** - `nanoc-ffi` will parse C headers and generate extern declarations
2. **Static Module Linking** - Modules will be compiled to `.o` files and linked
3. **Module Namespacing** - Module aliases will namespace symbols
4. **Module Metadata** - Modules can declare dependencies, version, etc.
5. **Module Search Paths** - Configure search paths for modules

---

## Summary

Modules enable code reuse and C library integration in nanolang. They work seamlessly in both interpreter and compiler modes, making it easy to:
- Share code across programs
- Use C libraries via FFI
- Build libraries of reusable functions
- Organize large codebases

Modules are a first-class feature that makes nanolang more powerful and practical for real-world applications.

