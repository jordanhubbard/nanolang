This is nanolang, an LLM-oriented language which is fully described by schema and has both a C version (for bootstrap) and a version fully written in itself, nanolang

It is time to write our own compiler back-end in nanolang, but rather than invent an entire C compiler toolchain that is ANSI C compatible and compile all existing C code from the transpiler with it, we want to do something different - we want to work backwards from an ideal, hypotheical CPU instruction set for which all behavior is extremely well defined and not optimized for performance but rather for complete lack of side-effects. It will be a very simple stack machine with a bare minimum number of registers; we can refer to every idealized instruction set architecture ever created in designing this and should lean heavily on the RISC architecture, for example RISC-V, but also keeping in mind that we do NOT need to be binary or ABI compatible with any ISA ever created.

Once we have our ISA, we need to prove that we can express every operation required by nanolang code as is specified by the nanolang schema.  We should not try to make the ISA unnecessarily complex by having nanolang-specific instructions for every nanolang operation, but we can certainly make our ISA simpler in some cases by knowing in advance that nanolang will be the only language to ever target this ISA, so we can borrow liberally from both RISC and CISC designs as this helps us to achieve the right balance between compiler code generation complexity and ISA complexity.

Next we will write a version of nanolang which compiles directly into this ISA as well as an ISA virtual machine which runs this ISA - we will actually write the ISA and the multi-threaded virtual machine interpreter process first, to prove that we can run code written to this ISA. The nano_virt compiler will generate entirely self-contained virtual ISA executables which are in turn loaded into their own threads in the nano_vm process.

This leaves us with external function calls made by nano_vm threads:  These will be turned into RPC calls which allow any VM instance to call into another co-process, which we will also design and implement.  This process will be called the nanovm Unix module runtime.  Since all modules today are written in C and nanolang and link directly with Unix libraries, we will not break this contract, instead we will entirely externalize them into this co-process which is conditionally executed (upon first external function call time) at the same time as the virtual machine interpreter process.  Each thread in nanovm which requires a call into an external function will get its own co-process, that speaking RPC 1:1 to the VM thread which runs the ISA.  This will allow multiple "virtual processes" to execute in parallel and still have their own windows, bullet physics libray instances, and so on. If there are no module or external function calls in a nanolang program, the "virtual machine binary" (which will be in our own format) will not cause the co-process to be executed but can, instead, be a light weight process running as a thread in an existing virtual machine process.

This will require multiple plans - one for the ISA, one for the ISA VM, one for the co-process for executing module or external "unsafe" function call code, and so on.  We will also have to have a plan for another nanolang compiler which, this time, does not transpile to C but instead compiles directly into the native ISA as a binary blob that can be loaded directly in to the nanolang virtual machine.  When this version of nano_virt is used, it will still compile machine-native binaries, but those will be simple wrappers which ensure that the nanovm process is running on first virtual instance launch and then tell it to load the ISA code and execute its main function.  The VM process will be persistent until its last thread exits, so subsequent native binaries compiled by nano_virt will either lazy-launch it or discover the existing VM and talk to it to launch themselves.

Fundamental architecture is to have as much be virtual as possible with system native processes launched on demand and complete address space seperation between virtual code and actual Unix-native code.
