/* =============================================================================
 * nanolang Transpiler (Self-Hosted) - Minimal Version
 * =============================================================================
 * C code generation from nanolang AST
 * 
 * Phase 1 Scope (Minimal):
 * - Generate C code for basic expressions
 * - Generate C code for statements (let, if, while, return)
 * - Generate C code for function definitions
 * - Generate main() wrapper
 * - Generate necessary C includes and runtime
 * 
 * Strategy:
 * - Simple recursive code generation
 * - Generate readable C code (not optimized)
 * - Use string concatenation (no string builder yet)
 * - Generate flat C (minimal helper functions)
 */

import "src_nano/compiler/ir.nano"
import "src_nano/ast_shared.nano"
import "src_nano/parser.nano"
import "src_nano/compiler/diagnostics.nano" as Diagnostics

/* =============================================================================
 * CODE GENERATION STATE
 * ============================================================================= */

struct CodeGenState {
    indent_level: int,
    temp_var_counter: int,
    has_error: bool
}

let mut module_aliases: array<string> = []
let mut module_alias_targets: array<string> = []
let mut func_aliases: array<string> = []
let mut func_alias_targets: array<string> = []

let mut extern_func_names: array<string> = []

fn register_extern_names(parser: Parser) -> int {
    set extern_func_names []
    let n: int = (parser_get_function_count parser)
    let mut i: int = 0
    while (< i n) {
        let f: ASTFunction = (parser_get_function parser i)
        if (< f.body 0) {
            set extern_func_names (array_push extern_func_names f.name)
        } else { (print "") }
        set i (+ i 1)
    }
    return (array_length extern_func_names)
}

shadow register_extern_names {
    let toks: List<LexerToken> = (tokenize_string "extern fn foo() -> int")
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let n: int = (register_extern_names p)
    assert (>= n 0)
}

fn would_collide_with_extern(user_func_name: string) -> bool {
    let c_name: string = (+ "nl_" (mangle_name user_func_name))
    let n: int = (array_length extern_func_names)
    let mut i: int = 0
    while (< i n) {
        if (== (array_get extern_func_names i) c_name) {
            return true
        } else { (print "") }
        set i (+ i 1)
    }
    return false
}

shadow would_collide_with_extern {
    set extern_func_names ["nl_sb_new", "nl_cg_append"]
    assert (would_collide_with_extern "sb_new")
    assert (would_collide_with_extern "cg_append")
    assert (not (would_collide_with_extern "my_func"))
    set extern_func_names []
}

/* Opaque types should not get nl_ prefix - they map to external C types */
fn is_opaque_type(name: string) -> bool {
    if (== name "NLStringBuilder") { return true } else { (print "") }
    if (== name "NLStringSet") { return true } else { (print "") }
    if (== name "NLHashMap") { return true } else { (print "") }
    if (== name "NlPeg") { return true } else { (print "") }
    if (== name "Json") { return true } else { (print "") }
    if (== name "Regex") { return true } else { (print "") }
    if (== name "DateTime") { return true } else { (print "") }
    if (== name "HttpResponse") { return true } else { (print "") }
    if (== name "HttpServer") { return true } else { (print "") }
    if (== name "HttpRequest") { return true } else { (print "") }
    if (== name "SDL_Window") { return true } else { (print "") }
    if (== name "SDL_Renderer") { return true } else { (print "") }
    if (== name "SDL_Texture") { return true } else { (print "") }
    if (== name "SDL_Surface") { return true } else { (print "") }
    if (== name "SDL_GLContext") { return true } else { (print "") }
    if (== name "Mix_Chunk") { return true } else { (print "") }
    if (== name "Mix_Music") { return true } else { (print "") }
    if (== name "TTF_Font") { return true } else { (print "") }
    if (== name "GLFWwindow") { return true } else { (print "") }
    if (== name "GLFWmonitor") { return true } else { (print "") }
    return false
}

shadow is_opaque_type {
    assert (is_opaque_type "NLStringBuilder")
    assert (is_opaque_type "SDL_Window")
    assert (not (is_opaque_type "int"))
    assert (not (is_opaque_type "Point"))
}

/* Function pointer typedef tracking */
let mut fn_type_originals: array<string> = []
let mut fn_type_names: array<string> = []

fn reset_module_aliases() -> int {
    set module_aliases []
    set module_alias_targets []
    return 0
}

shadow reset_module_aliases {
    (reset_module_aliases)
    assert (== (array_length module_aliases) 0)
}

fn reset_func_aliases() -> int {
    set func_aliases []
    set func_alias_targets []
    return 0
}

shadow reset_func_aliases {
    (reset_func_aliases)
    assert (== (array_length func_aliases) 0)
}

fn add_module_alias(alias: string, module_name: string) -> int {
    set module_aliases (array_push module_aliases alias)
    set module_alias_targets (array_push module_alias_targets module_name)
    return 0
}

shadow add_module_alias {
    (reset_module_aliases)
    let r: int = (add_module_alias "io" "std_io")
    assert (== r 0)
    assert (== (array_length module_aliases) 1)
    (reset_module_aliases)
}

fn add_func_alias(alias: string, target: string) -> int {
    set func_aliases (array_push func_aliases alias)
    set func_alias_targets (array_push func_alias_targets target)
    return 0
}

shadow add_func_alias {
    (reset_func_aliases)
    let r: int = (add_func_alias "greet" "hello_mod.greet")
    assert (== r 0)
    assert (== (array_length func_aliases) 1)
    (reset_func_aliases)
}

fn resolve_module_alias(name: string) -> string {
    let mut i: int = 0
    let n: int = (array_length module_aliases)
    while (< i n) {
        if (== (at module_aliases i) name) {
            return (at module_alias_targets i)
        } else { (print "") }
        set i (+ i 1)
    }
    return name
}

shadow resolve_module_alias {
    (reset_module_aliases)
    (add_module_alias "io" "std/io")
    assert (== (resolve_module_alias "io") "std/io")
    assert (== (resolve_module_alias "unknown") "unknown")
}

fn resolve_func_alias(name: string) -> string {
    let mut i: int = 0
    let n: int = (array_length func_aliases)
    while (< i n) {
        if (== (at func_aliases i) name) {
            return (at func_alias_targets i)
        } else { (print "") }
        set i (+ i 1)
    }
    return ""
}

shadow resolve_func_alias {
    (reset_func_aliases)
    (add_func_alias "f" "module::func")
    assert (== (resolve_func_alias "f") "module::func")
    assert (== (resolve_func_alias "unknown") "")
}

fn reset_fn_types() -> int {
    set fn_type_originals []
    set fn_type_names []
    return 0
}

shadow reset_fn_types {
    (reset_fn_types)
    assert (== (array_length fn_type_originals) 0)
    assert (== (array_length fn_type_names) 0)
}

fn is_fn_type(t: string) -> bool {
    return (transp_str_starts_with t "fn(")
}

fn register_fn_type(t: string) -> string {
    /* Check if already registered */
    let mut i: int = 0
    let n: int = (array_length fn_type_originals)
    while (< i n) {
        if (== (at fn_type_originals i) t) {
            return (at fn_type_names i)
        } else { (print "") }
        set i (+ i 1)
    }
    /* Register new function type */
    let idx: int = (array_length fn_type_originals)
    let mut name_parts: array<string> = []
    set name_parts (cg_append name_parts "nl_FnPtr_")
    set name_parts (cg_append name_parts (int_to_string idx))
    let name: string = (cg_build name_parts)
    set fn_type_originals (array_push fn_type_originals t)
    set fn_type_names (array_push fn_type_names name)
    return name
}

shadow register_fn_type {
    (reset_fn_types)
    let name1: string = (register_fn_type "fn(int)->int")
    assert (== name1 "nl_FnPtr_0")
    let name2: string = (register_fn_type "fn(int)->int")
    assert (== name2 "nl_FnPtr_0")
    let name3: string = (register_fn_type "fn(string)->bool")
    assert (== name3 "nl_FnPtr_1")
    (reset_fn_types)
}

fn parse_fn_type_params(t: string) -> array<string> {
    /* Parse fn(int,int)->int to get parameter types */
    /* Opening paren is at index 2, scan from index 3 for closing paren */
    let len: int = (str_length t)
    let mut depth: int = 0
    let mut close: int = -1
    let mut i: int = 3
    while (< i len) {
        let ch: string = (str_substring t i 1)
        if (== ch "(") {
            set depth (+ depth 1)
        } else {
        if (== ch ")") {
            if (== depth 0) {
                set close i
                set i len
            } else {
                set depth (- depth 1)
            }
        } else { (print "") }
        }
        set i (+ i 1)
    }
    if (< close 0) {
        let empty: array<string> = []
        return empty
    } else { (print "") }
    let params_str: string = (str_substring t 3 (- close 3))
    if (== (str_length params_str) 0) {
        let empty: array<string> = []
        return empty
    } else { (print "") }
    /* Split by comma (simple - no nested generics for now) */
    let mut result: array<string> = []
    let mut start: int = 0
    let plen: int = (str_length params_str)
    set i 0
    set depth 0
    while (< i plen) {
        let ch: string = (str_substring params_str i 1)
        if (or (== ch "(") (== ch "<")) {
            set depth (+ depth 1)
        } else {
        if (or (== ch ")") (== ch ">")) {
            set depth (- depth 1)
        } else {
        if (and (== ch ",") (== depth 0)) {
            let param: string = (str_substring params_str start (- i start))
            set result (array_push result param)
            set start (+ i 1)
        } else { (print "") }
        } }
        set i (+ i 1)
    }
    if (< start plen) {
        let param: string = (str_substring params_str start (- plen start))
        set result (array_push result param)
    } else { (print "") }
    return result
}

shadow parse_fn_type_params {
    let params1: array<string> = (parse_fn_type_params "fn(int,string)->bool")
    assert (== (array_length params1) 2)
    assert (== (at params1 0) "int")
    assert (== (at params1 1) "string")
    let params2: array<string> = (parse_fn_type_params "fn()->void")
    assert (== (array_length params2) 0)
}

fn parse_fn_type_return(t: string) -> string {
    /* Parse fn(...)->RetType to get return type */
    let len: int = (str_length t)
    let mut i: int = 3
    let mut depth: int = 0
    let mut close: int = -1
    while (< i len) {
        let ch: string = (str_substring t i 1)
        if (== ch "(") {
            set depth (+ depth 1)
        } else {
        if (== ch ")") {
            if (== depth 0) {
                set close i
                set i len
            } else {
                set depth (- depth 1)
            }
        } else { (print "") }
        }
        set i (+ i 1)
    }
    if (< close 0) {
        return "void"
    } else { (print "") }
    /* After close paren, expect "->RetType" or " -> RetType" */
    let after: string = (str_substring t (+ close 1) (- len (+ close 1)))
    /* Find "->" */
    let alen: int = (str_length after)
    set i 0
    while (< i (- alen 1)) {
        let ch: string = (str_substring after i 1)
        let ch2: string = (str_substring after (+ i 1) 1)
        if (and (== ch "-") (== ch2 ">")) {
            /* Return type starts after "->" possibly with spaces */
            let mut rstart: int = (+ i 2)
            while (< rstart alen) {
                let rch: string = (str_substring after rstart 1)
                if (== rch " ") {
                    set rstart (+ rstart 1)
                } else {
                    set i alen
                    let ret: string = (str_substring after rstart (- alen rstart))
                    return ret
                }
            }
        } else { (print "") }
        set i (+ i 1)
    }
    return "void"
}

shadow parse_fn_type_return {
    assert (== (parse_fn_type_return "fn(int,int)->int") "int")
    assert (== (parse_fn_type_return "fn()->string") "string")
    assert (== (parse_fn_type_return "fn()->void") "void")
}

fn generate_fn_type_typedefs() -> string {
    let n: int = (array_length fn_type_originals)
    if (== n 0) {
        return ""
    } else { (print "") }
    let mut sb: array<string> = []
    set sb (cg_append sb "/* Function pointer typedefs */\n")
    let mut i: int = 0
    while (< i n) {
        let t: string = (at fn_type_originals i)
        let name: string = (at fn_type_names i)
        let ret_type: string = (parse_fn_type_return t)
        let params: array<string> = (parse_fn_type_params t)
        let c_ret: string = (type_to_c ret_type)
        set sb (cg_append sb "typedef ")
        set sb (cg_append sb c_ret)
        set sb (cg_append sb " (*")
        set sb (cg_append sb name)
        set sb (cg_append sb ")(")
        let pcount: int = (array_length params)
        let mut pi: int = 0
        while (< pi pcount) {
            if (> pi 0) {
                set sb (cg_append sb ", ")
            } else { (print "") }
            set sb (cg_append sb (type_to_c (at params pi)))
            set pi (+ pi 1)
        }
        if (== pcount 0) {
            set sb (cg_append sb "void")
        } else { (print "") }
        set sb (cg_append sb ");\n")
        set i (+ i 1)
    }
    set sb (cg_append sb "\n")
    return (cg_build sb)
}

shadow generate_fn_type_typedefs {
    (reset_fn_types)
    let empty: string = (generate_fn_type_typedefs)
    assert (== empty "")
    (register_fn_type "fn(int)->int")
    let result: string = (generate_fn_type_typedefs)
    assert (> (str_length result) 0)
    (reset_fn_types)
}

shadow is_fn_type {
    assert (is_fn_type "fn(int,int)->int")
    assert (is_fn_type "fn()->void")
    assert (not (is_fn_type "int"))
    assert (not (is_fn_type "string"))
}

fn codegen_new() -> CodeGenState {
    return CodeGenState {
        indent_level: 0,
        temp_var_counter: 0,
        has_error: false
    }
}

shadow codegen_new {
    let state: CodeGenState = (codegen_new)
    assert (== state.indent_level 0)
}

/* =============================================================================
 * CODE GENERATION HELPERS
 * ============================================================================= */

/* Generate indentation */
fn gen_indent(level: int) -> string {
    if (<= level 0) {
        return ""
    } else {
        return (+ "    " (gen_indent (- level 1)))
    }
}

shadow gen_indent {
    assert (== (gen_indent 0) "")
    assert (== (gen_indent 1) "    ")
}

/* =============================================================================
 * STRINGBUILDER - O(n) string accumulation instead of O(n²) concatenation
 * ============================================================================= */

/* StringBuilder: Array-based string accumulator for O(n) performance
 * Instead of: set result (+ result "text")  // O(n²) - copies entire string each time
 * Use: (cg_append parts "text")              // O(n) - just appends to array
 */
fn cg_append(parts: array<string>, text: string) -> array<string> {
    (array_push parts text)
    return parts
}

fn cg_build(parts: array<string>) -> string {
    let count: int = (array_length parts)
    if (== count 0) {
        return ""
    } else {
        if (== count 1) {
            return (at parts 0)
        } else {
            let mut current: array<string> = parts
            while (> (array_length current) 1) {
                let mut next: array<string> = []
                let mut i: int = 0
                let n: int = (array_length current)
                while (< i n) {
                    if (< (+ i 1) n) {
                        let left: string = (at current i)
                        let right: string = (at current (+ i 1))
                        set next (array_push next (+ left right))
                    } else {
                        set next (array_push next (at current i))
                    }
                    set i (+ i 2)
                }
                set current next
            }
            return (at current 0)
        }
    }
}

shadow cg_append {
    let mut parts: array<string> = []
    set parts (cg_append parts "hello")
    set parts (cg_append parts " ")
    set parts (cg_append parts "world")
    assert (== (array_length parts) 3)
    assert (== (at parts 0) "hello")
    assert (== (at parts 1) " ")
    assert (== (at parts 2) "world")
}

shadow cg_build {
    let mut parts: array<string> = []
    set parts (cg_append parts "hello")
    set parts (cg_append parts " ")
    set parts (cg_append parts "world")
    let result: string = (cg_build parts)
    assert (== result "hello world")
}

/* Generate a fresh temporary variable name */
fn gen_temp_var(state: CodeGenState) -> string {
    let counter_str: string = (int_to_string state.temp_var_counter)
    return (+ "_t" counter_str)
}

shadow gen_temp_var {
    let state: CodeGenState = (codegen_new)
    let name: string = (gen_temp_var state)
    assert (== name "_t0")
}

/* Increment temp counter */
fn codegen_next_temp(state: CodeGenState) -> CodeGenState {
    return CodeGenState {
        indent_level: state.indent_level,
        temp_var_counter: (+ state.temp_var_counter 1),
        has_error: state.has_error
    }
}

shadow codegen_next_temp {
    let state: CodeGenState = (codegen_new)
    let state2: CodeGenState = (codegen_next_temp state)
    assert (== state2.temp_var_counter 1)
}

/* Mangle qualified names (e.g. "std::math::sin") into valid C identifiers.
 * Replaces separators like "::" and "." with "_".
 */
fn mangle_name(name: string) -> string {
    let mut out: string = ""
    let len: int = (str_length name)
    let mut i: int = 0

    while (< i len) {
        let ch: string = (str_substring name i 1)

        if (and (== ch ":") (< (+ i 1) len)) {
            let ch2: string = (str_substring name (+ i 1) 1)
            if (== ch2 ":") {
                set out (+ out "_")
                set i (+ i 2)
            } else {
                set out (+ out "_")
                set i (+ i 1)
            }
        } else {
            if (or (or (== ch ".") (== ch "<"))
                    (or (== ch ">") (== ch ","))) {
                set out (+ out "_")
            } else {
                set out (+ out ch)
            }
            set i (+ i 1)
        }
    }

    return out
}

shadow mangle_name {
    assert (== (mangle_name "std::math::sin") "std_math_sin")
}

/* String utility functions for transpiler */
fn transp_str_starts_with(s: string, prefix: string) -> bool {
    let ls: int = (str_length s)
    let lp: int = (str_length prefix)
    if (< ls lp) {
        return false
    } else {
        let mut i: int = 0
        while (< i lp) {
            if (!= (char_at s i) (char_at prefix i)) {
                return false
            } else { (print "") }
            set i (+ i 1)
        }
        return true
    }
}

shadow transp_str_starts_with {
    assert (transp_str_starts_with "array<int>" "array")
    assert (not (transp_str_starts_with "int" "array"))
}

fn transp_str_index_of(s: string, ch: string) -> int {
    let len: int = (str_length s)
    let mut i: int = 0
    
    while (< i len) {
        let char_at: string = (str_substring s i 1)
        if (== char_at ch) {
            return i
        } else {
            (print "")
        }
        set i (+ i 1)
    }
    
    return -1
}

shadow transp_str_index_of {
    assert (== (transp_str_index_of "array<int>" "<") 5)
    assert (== (transp_str_index_of "test" "e") 1)
    assert (== (transp_str_index_of "test" "z") -1)
}

fn transp_extract_list_element_type(s: string) -> string {
    /* "List<Point>" -> "Point" */
    let start: int = (+ (transp_str_index_of s "<") 1)
    let end: int = (transp_str_index_of s ">")
    if (and (> start 0) (> end start)) {
        return (str_substring s start (- end start))
    } else {
        return ""
    }
}

shadow transp_extract_list_element_type {
    assert (== (transp_extract_list_element_type "List<Point>") "Point")
    assert (== (transp_extract_list_element_type "List<int>") "int")
    assert (== (transp_extract_list_element_type "invalid") "")
}

/* Check if a type string is a generic type (contains '<') */
fn is_generic_type(type_str: string) -> bool {
    return (str_contains type_str "<")
}

shadow is_generic_type {
    assert (is_generic_type "Result<int,string>")
    assert (not (is_generic_type "int"))
    assert (is_generic_type "List<Point>")
}

/* Extract base type name from a generic type string */
fn extract_base_type_name(type_str: string) -> string {
    let idx: int = (transp_str_index_of type_str "<")
    if (< idx 0) {
        return type_str
    } else {
        return (str_substring type_str 0 idx)
    }
}

shadow extract_base_type_name {
    assert (== (extract_base_type_name "Result<int,string>") "Result")
    assert (== (extract_base_type_name "List<Point>") "List")
    assert (== (extract_base_type_name "int") "int")
}

/* Extract type arguments from a generic type string */
fn extract_type_args(type_str: string) -> array<string> {
    let lt: int = (transp_str_index_of type_str "<")
    if (< lt 0) {
        return []
    } else {
        let len: int = (str_length type_str)
        /* inner = everything between < and > */
        let inner: string = (str_substring type_str (+ lt 1) (- (- len lt) 2))
        let inner_len: int = (str_length inner)
        let mut args: array<string> = []
        let mut cur: string = ""
        let mut i: int = 0
        let mut depth: int = 0
        while (< i inner_len) {
            let ch: string = (str_substring inner i 1)
            if (== ch "<") {
                set depth (+ depth 1)
                set cur (+ cur ch)
            } else {
                if (== ch ">") {
                    set depth (- depth 1)
                    set cur (+ cur ch)
                } else {
                    if (and (== ch ",") (== depth 0)) {
                        /* Trim leading spaces from cur */
                        let mut trimmed: string = cur
                        while (and (> (str_length trimmed) 0) (== (str_substring trimmed 0 1) " ")) {
                            set trimmed (str_substring trimmed 1 (- (str_length trimmed) 1))
                        }
                        set args (array_push args trimmed)
                        set cur ""
                    } else {
                        set cur (+ cur ch)
                    }
                }
            }
            set i (+ i 1)
        }
        /* Push last arg */
        let mut trimmed_last: string = cur
        while (and (> (str_length trimmed_last) 0) (== (str_substring trimmed_last 0 1) " ")) {
            set trimmed_last (str_substring trimmed_last 1 (- (str_length trimmed_last) 1))
        }
        if (> (str_length trimmed_last) 0) {
            set args (array_push args trimmed_last)
        } else { (print "") }
        return args
    }
}

shadow extract_type_args {
    let args1: array<string> = (extract_type_args "Result<int,string>")
    assert (== (array_length args1) 2)
    assert (== (at args1 0) "int")
    assert (== (at args1 1) "string")
    let args2: array<string> = (extract_type_args "List<Point>")
    assert (== (array_length args2) 1)
    assert (== (at args2 0) "Point")
}

/* Convert a generic type string to a monomorphized name.
 * "Result<int,string>" -> "Result_int_string"
 */
fn monomorphize_type_name(type_str: string) -> string {
    let base: string = (extract_base_type_name type_str)
    let args: array<string> = (extract_type_args type_str)
    let mut result: string = base
    let mut i: int = 0
    let n: int = (array_length args)
    while (< i n) {
        set result (+ result "_")
        let arg: string = (at args i)
        /* Recursively monomorphize nested generic args */
        if (str_contains arg "<") {
            set result (+ result (monomorphize_type_name arg))
        } else {
            set result (+ result arg)
        }
        set i (+ i 1)
    }
    return result
}

shadow monomorphize_type_name {
    assert (== (monomorphize_type_name "Result<int,string>") "Result_int_string")
    assert (== (monomorphize_type_name "List<Point>") "List_Point")
    assert (== (monomorphize_type_name "Option<int>") "Option_int")
}

fn hashset_new_string() -> HashMap<string, int> {
    let s: HashMap<string, int> = (map_new)
    return s
}

shadow hashset_new_string {
    let s: HashMap<string, int> = (hashset_new_string)
    assert (!= s 0)
    assert (not (hashset_has_string s "test"))
}

fn hashset_has_string(map: HashMap<string, int>, key: string) -> bool {
    return (map_has map key)
}

shadow hashset_has_string {
    let m: HashMap<string, int> = (hashset_new_string)
    assert (not (hashset_has_string m "a"))
    (map_put m "a" 1)
    assert (hashset_has_string m "a")
}

fn hashset_add_string(map: HashMap<string, int>, key: string) -> HashMap<string, int> {
    if (not (map_has map key)) {
        (map_put map key 1)
    } else { (print "") }
    return map
}

shadow hashset_add_string {
    let m: HashMap<string, int> = (hashset_new_string)
    let m2: HashMap<string, int> = (hashset_add_string m "a")
    assert (hashset_has_string m2 "a")
    let m3: HashMap<string, int> = (hashset_add_string m2 "a")
    assert (hashset_has_string m3 "a")
}

pub fn str_ends_with(s: string, suffix: string) -> bool {
    let ls: int = (str_length s)
    let lf: int = (str_length suffix)
    if (< ls lf) {
        return false
    } else {
        return (== (str_substring s (- ls lf) lf) suffix)
    }
}

shadow str_ends_with {
    assert (str_ends_with "hello.nano" ".nano")
    assert (not (str_ends_with "test.c" ".nano"))
}

fn last_double_colon_index(s: string) -> int {
    let len: int = (str_length s)
    let mut i: int = 0
    let mut last: int = -1
    while (< (+ i 1) len) {
        let c1: string = (str_substring s i 1)
        let c2: string = (str_substring s (+ i 1) 1)
        if (and (== c1 ":") (== c2 ":")) {
            set last i
            set i (+ i 2)
        } else {
            set i (+ i 1)
        }
    }
    return last
}

shadow last_double_colon_index {
    assert (== (last_double_colon_index "module::function") 6)
    assert (== (last_double_colon_index "a::b::c") 4)
    assert (== (last_double_colon_index "test") -1)
}

fn last_dot_index(s: string) -> int {
    let len: int = (str_length s)
    let mut i: int = 0
    let mut last: int = -1
    while (< i len) {
        if (== (str_substring s i 1) ".") {
            set last i
        } else { (print "") }
        set i (+ i 1)
    }
    return last
}

shadow last_dot_index {
    assert (== (last_dot_index "file.nano") 4)
    assert (== (last_dot_index "a.b.c") 3)
    assert (== (last_dot_index "test") -1)
}

fn last_slash_index(s: string) -> int {
    let len: int = (str_length s)
    let mut i: int = 0
    let mut last: int = -1
    while (< i len) {
        if (== (str_substring s i 1) "/") {
            set last i
        } else { (print "") }
        set i (+ i 1)
    }
    return last
}

shadow last_slash_index {
    assert (== (last_slash_index "/path/to/file.nano") 8)
    assert (== (last_slash_index "dir/file") 3)
    assert (== (last_slash_index "test") -1)
}

fn module_name_from_path(path: string) -> string {
    let last_slash: int = (last_slash_index path)
    let last_dot: int = (last_dot_index path)
    let mut start: int = 0
    if (>= last_slash 0) {
        set start (+ last_slash 1)
    } else {
        (print "")
    }
    let mut end: int = (str_length path)
    if (>= last_dot 0) {
        set end last_dot
    } else {
        (print "")
    }
    let len: int = (- end start)
    if (<= len 0) {
        return path
    } else {
        return (str_substring path start len)
    }
}

shadow module_name_from_path {
    assert (== (module_name_from_path "src/lexer.nano") "lexer")
    assert (== (module_name_from_path "file.nano") "file")
    assert (== (module_name_from_path "test") "test")
}

fn build_module_alias_map(parser: Parser) -> int {
    (reset_module_aliases)
    (reset_func_aliases)
    let import_count: int = (parser_get_import_count parser)
    let mut i: int = 0
    while (< i import_count) {
        let imp: ASTImport = (parser_get_import parser i)
        if (> (str_length imp.module_name) 0) {
            let module_name: string = (module_name_from_path imp.module_path)
            (add_module_alias imp.module_name module_name)
        } else { (print "") }
        if (and imp.is_selective (not imp.is_wildcard)) {
            if (> imp.import_symbol_count 0) {
                let module_name: string = (module_name_from_path imp.module_path)
                let mut si: int = 0
                while (< si imp.import_symbol_count) {
                    let sym: string = (at imp.import_symbols si)
                    let mut alias_name: string = ""
                    if (< si (array_length imp.import_aliases)) {
                        set alias_name (at imp.import_aliases si)
                    } else { (print "") }
                    if (== (str_length alias_name) 0) {
                        set alias_name sym
                    } else { (print "") }
                    if (> (str_length alias_name) 0) {
                        let mut target_parts: array<string> = []
                        set target_parts (cg_append target_parts module_name)
                        set target_parts (cg_append target_parts ".")
                        set target_parts (cg_append target_parts sym)
                        let target: string = (cg_build target_parts)
                        (add_func_alias alias_name target)
                    } else { (print "") }
                    set si (+ si 1)
                }
            } else { (print "") }
        } else { (print "") }
        set i (+ i 1)
    }
    return 0
}

shadow build_module_alias_map {
    let toks: List<LexerToken> = (tokenize_string "fn main() -> int { return 0 }")
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let r: int = (build_module_alias_map p)
    assert (== r 0)
}

fn mangle_module_ident(name: string) -> string {
    let mut out: string = ""
    let len: int = (str_length name)
    let mut i: int = 0

    while (< i len) {
        let ch: string = (str_substring name i 1)

        if (and (== ch ":") (< (+ i 1) len)) {
            let ch2: string = (str_substring name (+ i 1) 1)
            if (== ch2 ":") {
                set out (+ out "__")
                set i (+ i 2)
            } else {
                set out (+ out "_")
                set i (+ i 1)
            }
        } else {
            if (== ch ".") {
                set out (+ out "__")
            } else {
                if (or (or (== ch "<") (== ch ">"))
                        (or (== ch ",") (== ch "("))) {
                    set out (+ out "_")
                } else {
                    if (== ch ")") {
                        set out (+ out "_")
                    } else {
                        set out (+ out ch)
                    }
                }
            }
            set i (+ i 1)
        }
    }

    return out
}

shadow mangle_module_ident {
    assert (== (mangle_module_ident "module::function") "module__function")
    assert (== (mangle_module_ident "std.io") "std__io")
    assert (== (mangle_module_ident "List<int>") "List_int_")
}

fn is_unprefixed_list_runtime_fn(name: string) -> bool {
    if (transp_str_starts_with name "list_int_") { return true } else { (print "") }
    if (transp_str_starts_with name "list_string_") { return true } else { (print "") }
    if (transp_str_starts_with name "list_token_") { return true } else { (print "") }
    return false
}

shadow is_unprefixed_list_runtime_fn {
    assert (is_unprefixed_list_runtime_fn "list_int_new")
    assert (is_unprefixed_list_runtime_fn "list_string_push")
    assert (not (is_unprefixed_list_runtime_fn "list_Point_new"))
    assert (not (is_unprefixed_list_runtime_fn "list_LexerToken_get"))
}

fn is_generic_list_runtime_fn(name: string) -> bool {
    return (and (transp_str_starts_with name "list_") (not (is_unprefixed_list_runtime_fn name)))
}

shadow is_generic_list_runtime_fn {
    assert (is_generic_list_runtime_fn "list_Point_new")
    assert (not (is_generic_list_runtime_fn "list_int_new"))
    assert (not (is_generic_list_runtime_fn "some_other_fn"))
}

fn c_name_for_qualified_function(func_name: string) -> string {
    let len: int = (str_length func_name)
    let dc: int = (last_double_colon_index func_name)
    if (>= dc 0) {
        let mod_part: string = (str_substring func_name 0 dc)
        let base: string = (str_substring func_name (+ dc 2) (- len (+ dc 2)))
        let resolved: string = (resolve_module_alias mod_part)
        let mm: string = (mangle_module_ident resolved)
        let mut parts: array<string> = []
        set parts (cg_append parts mm)
        set parts (cg_append parts "__")
        set parts (cg_append parts (mangle_name base))
        return (cg_build parts)
    } else {
        let dot: int = (last_dot_index func_name)
        if (>= dot 0) {
            let mod_part: string = (str_substring func_name 0 dot)
            let base: string = (str_substring func_name (+ dot 1) (- len (+ dot 1)))
            let resolved: string = (resolve_module_alias mod_part)
            if (== resolved mod_part) {
                /* Module alias not found - module was merged, treat as local call */
                return (+ "nl_" (mangle_name base))
            } else { (print "") }
            let mm: string = (mangle_module_ident resolved)
            let mut parts: array<string> = []
            set parts (cg_append parts mm)
            set parts (cg_append parts "__")
            set parts (cg_append parts (mangle_name base))
            return (cg_build parts)
        } else {
            return func_name
        }
    }
}

shadow c_name_for_qualified_function {
    (reset_module_aliases)
    assert (== (c_name_for_qualified_function "std::io::print") "std__io__nl_print")
    assert (== (c_name_for_qualified_function "file.read") "file__nl_read")
}

/* Map builtin function names to their C implementation names */
fn map_builtin_func_name(func_name: string) -> string {
    /* Math builtins that need nl_ prefix */
    if (== func_name "abs") { return "nl_abs" } else { (print "") }
    if (== func_name "min") { return "nl_min" } else { (print "") }
    if (== func_name "max") { return "nl_max" } else { (print "") }
    
    /* C math library functions (no prefix) */
    if (== func_name "sqrt") { return "nl_sqrt" } else { (print "") }
    if (== func_name "pow") { return "nl_pow" } else { (print "") }
    if (== func_name "floor") { return "nl_floor" } else { (print "") }
    if (== func_name "ceil") { return "nl_ceil" } else { (print "") }
    if (== func_name "round") { return "nl_round" } else { (print "") }
    if (== func_name "sin") { return "nl_sin" } else { (print "") }
    if (== func_name "cos") { return "nl_cos" } else { (print "") }
    if (== func_name "tan") { return "nl_tan" } else { (print "") }
    if (== func_name "atan2") { return "nl_atan2" } else { (print "") }
    
    /* String builtins */
    if (== func_name "str_length") { return "strlen" } else { (print "") }
    if (== func_name "str_concat") { return "nl_str_concat" } else { (print "") }
    if (== func_name "str_substring") { return "nl_str_substring" } else { (print "") }
    if (== func_name "str_contains") { return "nl_str_contains" } else { (print "") }
    if (== func_name "str_equals") { return "nl_str_equals" } else { (print "") }
    
    /* Character/string conversion builtins (runtime functions with nl_ prefix) */
    if (== func_name "char_at") { return "nl_char_at" } else { (print "") }
    if (== func_name "string_from_char") { return "nl_string_from_char" } else { (print "") }
    if (== func_name "int_to_string") { return "nl_int_to_string" } else { (print "") }
    if (== func_name "string_to_int") { return "nl_string_to_int" } else { (print "") }
    if (== func_name "float_to_string") { return "nl_float_to_string" } else { (print "") }
    if (== func_name "string_to_float") { return "nl_string_to_float" } else { (print "") }
    if (== func_name "bool_to_string") { return "nl_bool_to_string" } else { (print "") }
    
    /* Character classification builtins (runtime functions with nl_ prefix) */
    if (== func_name "is_digit") { return "nl_is_digit" } else { (print "") }
    if (== func_name "is_alpha") { return "nl_is_alpha" } else { (print "") }
    if (== func_name "is_alnum") { return "nl_is_alnum" } else { (print "") }
    if (== func_name "is_whitespace") { return "nl_is_whitespace" } else { (print "") }
    if (== func_name "is_upper") { return "nl_is_upper" } else { (print "") }
    if (== func_name "is_lower") { return "nl_is_lower" } else { (print "") }
    if (== func_name "digit_value") { return "nl_digit_value" } else { (print "") }
    if (== func_name "char_to_lower") { return "nl_char_to_lower" } else { (print "") }
    if (== func_name "char_to_upper") { return "nl_char_to_upper" } else { (print "") }
    
    /* OS/system builtins from runtime/cli.c (nl_os_* prefix) */
    if (== func_name "getenv") { return "nl_getenv" } else { (print "") }
    if (== func_name "setenv") { return "nl_os_setenv" } else { (print "") }
    if (== func_name "system") { return "nl_os_system" } else { (print "") }
    if (== func_name "exit") { return "nl_os_exit" } else { (print "") }
    if (== func_name "getcwd") { return "nl_os_getcwd" } else { (print "") }
    if (== func_name "chdir") { return "nl_os_chdir" } else { (print "") }
    
    /* File/path builtins from modules/std/fs.c (unprefixed).
     * file_read, path_* functions return const char* in C but string in NanoLang;
     * route them through nl_ wrappers (defined in gen_c_runtime) that cast to char*. */
    if (== func_name "file_read") { return "nl_file_read" } else { (print "") }
    if (== func_name "file_write") { return "file_write" } else { (print "") }
    if (== func_name "file_append") { return "file_append" } else { (print "") }
    if (== func_name "file_exists") { return "file_exists" } else { (print "") }
    if (== func_name "file_remove") { return "file_delete" } else { (print "") }
    if (== func_name "file_size") { return "nl_os_file_size" } else { (print "") }
    if (== func_name "path_join") { return "nl_path_join" } else { (print "") }
    if (== func_name "path_basename") { return "nl_path_basename" } else { (print "") }
    if (== func_name "path_dirname") { return "nl_path_dirname" } else { (print "") }
    if (== func_name "path_normalize") { return "nl_path_normalize" } else { (print "") }
    if (== func_name "path_isfile") { return "nl_os_path_isfile" } else { (print "") }
    if (== func_name "path_isdir") { return "nl_os_path_isdir" } else { (print "") }
    if (== func_name "fs_walkdir") { return "fs_walkdir" } else { (print "") }
    if (== func_name "dir_create") { return "nl_os_dir_create" } else { (print "") }
    if (== func_name "dir_remove") { return "nl_os_dir_remove" } else { (print "") }
    if (== func_name "dir_list") { return "nl_os_dir_list" } else { (print "") }
    if (== func_name "dir_exists") { return "nl_os_dir_exists" } else { (print "") }
    if (== func_name "tmp_dir") { return "nl_os_tmp_dir" } else { (print "") }
    if (== func_name "mktemp") { return "nl_os_mktemp" } else { (print "") }
    if (== func_name "mktemp_dir") { return "nl_os_mktemp_dir" } else { (print "") }
    if (== func_name "path_relpath") { return "nl_path_relpath" } else { (print "") }
    if (== func_name "process_run") { return "nl_os_process_run" } else { (print "") }
    
    /* HashMap/map builtins (self-hosted runtime provides nl_map_*) */
    if (== func_name "map_set") { return "nl_map_put" } else { (print "") }
    if (== func_name "map_length") { return "nl_map_size" } else { (print "") }
    
    /* CLI argument access (from runtime/cli.c) */
    if (== func_name "get_argc") { return "get_argc" } else { (print "") }
    if (== func_name "get_argv") { return "nl_get_argv" } else { (print "") }
    
    /* cast_string/to_string have no nl_ prefix in runtime */
    if (== func_name "cast_string") { return "cast_string" } else { (print "") }
    if (== func_name "to_string") { return "to_string" } else { (print "") }
    if (== func_name "null_opaque") { return "nl_null_opaque" } else { (print "") }
    
    /* Additional math builtins not yet covered */
    if (== func_name "asin") { return "asin" } else { (print "") }
    if (== func_name "acos") { return "acos" } else { (print "") }
    if (== func_name "atan") { return "atan" } else { (print "") }
    if (== func_name "log") { return "log" } else { (print "") }
    if (== func_name "log2") { return "log2" } else { (print "") }
    if (== func_name "log10") { return "log10" } else { (print "") }
    if (== func_name "exp") { return "exp" } else { (print "") }
    if (== func_name "fmod") { return "fmod" } else { (print "") }
    
    /* No mapping found - return empty string */
    return ""
}

shadow map_builtin_func_name {
    assert (== (map_builtin_func_name "abs") "nl_abs")
    assert (== (map_builtin_func_name "sqrt") "nl_sqrt")
    assert (== (map_builtin_func_name "str_length") "strlen")
    assert (== (map_builtin_func_name "int_to_string") "nl_int_to_string")
    assert (== (map_builtin_func_name "is_digit") "nl_is_digit")
    assert (== (map_builtin_func_name "getenv") "nl_getenv")
    assert (== (map_builtin_func_name "file_read") "file_read")
    assert (== (map_builtin_func_name "path_join") "path_join")
    assert (== (map_builtin_func_name "map_set") "nl_map_put")
    assert (== (map_builtin_func_name "unknown_func") "")
}

fn c_func_name_for_call(func_name: string) -> string {
    /* Check for builtin function mapping first */
    let builtin_mapped: string = (map_builtin_func_name func_name)
    if (!= builtin_mapped "") {
        return builtin_mapped
    } else { (print "") }
    
    let alias_target: string = (resolve_func_alias func_name)
    if (> (str_length alias_target) 0) {
        return (c_name_for_qualified_function alias_target)
    } else { (print "") }
    if (is_unprefixed_list_runtime_fn func_name) {
        return func_name
    } else {
        if (is_generic_list_runtime_fn func_name) {
            return (+ "nl_" func_name)
        } else {
            if (or (str_contains func_name "::") (str_contains func_name ".")) {
                return (c_name_for_qualified_function func_name)
            } else {
                if (would_collide_with_extern func_name) {
                    return (+ "nl_wrap_" (mangle_name func_name))
                } else {
                    return (+ "nl_" (mangle_name func_name))
                }
            }
        }
    }
}

shadow c_func_name_for_call {
    set extern_func_names []
    let r: string = (c_func_name_for_call "my_func")
    assert (== r "nl_my_func")
}

fn c_func_name_for_definition(func_name: string) -> string {
    if (or (str_contains func_name "::") (str_contains func_name ".")) {
        return (c_name_for_qualified_function func_name)
    } else {
        if (would_collide_with_extern func_name) {
            return (+ "nl_wrap_" (mangle_name func_name))
        } else {
            return (+ "nl_" (mangle_name func_name))
        }
    }
}

shadow c_func_name_for_definition {
    set extern_func_names []
    assert (== (c_func_name_for_definition "my_func") "nl_my_func")
    assert (== (c_func_name_for_definition "add") "nl_add")
}

/* =============================================================================
 * TYPE ENV (minimal) - track variable types for array lowering
 * ============================================================================= */

struct GenEnv {
    names: array<string>,
    types: array<string>
}

fn type_is_float(t: string) -> bool {
    return (== t "float")
}

shadow type_is_float {
    assert (type_is_float "float")
    assert (not (type_is_float "int"))
}

fn func_returns_float(name: string) -> bool {
    if (== name "sqrt") { return true } else { (print "") }
    if (== name "pow") { return true } else { (print "") }
    if (== name "floor") { return true } else { (print "") }
    if (== name "ceil") { return true } else { (print "") }
    if (== name "round") { return true } else { (print "") }
    if (== name "sin") { return true } else { (print "") }
    if (== name "cos") { return true } else { (print "") }
    if (== name "tan") { return true } else { (print "") }
    if (== name "atan2") { return true } else { (print "") }
    if (== name "cast_float") { return true } else { (print "") }
    if (== name "float_to_string") { return false } else { (print "") }
    if (== name "int_to_float") { return true } else { (print "") }
    return false
}

fn func_returns_string(name: string) -> bool {
    if (== name "int_to_string") { return true } else { (print "") }
    if (== name "float_to_string") { return true } else { (print "") }
    if (== name "bool_to_string") { return true } else { (print "") }
    if (== name "str_substring") { return true } else { (print "") }
    if (== name "str_concat") { return true } else { (print "") }
    if (== name "string_from_char") { return true } else { (print "") }
    return false
}

shadow func_returns_string {
    assert (func_returns_string "int_to_string")
    assert (func_returns_string "str_substring")
    assert (not (func_returns_string "print"))
    assert (not (func_returns_string "sqrt"))
}

shadow func_returns_float {
    assert (func_returns_float "sqrt")
    assert (func_returns_float "sin")
    assert (not (func_returns_float "print"))
}

struct TypeCParseResult {
    ok: bool,
    c_type: string,
    next_pos: int
}

fn is_schema_struct_name(name: string) -> bool {
    if (== name "Parser") { return true } else { (print "") }
    if (== name "NSType") { return true } else { (print "") }
    if (== name "OptionType") { return true } else { (print "") }
    if (== name "CompilerSourceLocation") { return true } else { (print "") }
    if (== name "CompilerDiagnostic") { return true } else { (print "") }
    if (== name "LexPhaseOutput") { return true } else { (print "") }
    if (== name "TypeEnvironment") { return true } else { (print "") }
    if (== name "TypecheckPhaseOutput") { return true } else { (print "") }
    if (== name "TranspilePhaseOutput") { return true } else { (print "") }
    return false
}

shadow is_schema_struct_name {
    assert (is_schema_struct_name "Parser")
    assert (not (is_schema_struct_name "NameParseResult"))
}

fn parse_type_c_from_tokens(parser: Parser, start_pos: int) -> TypeCParseResult {
    let n: int = parser.token_count
    if (or (< start_pos 0) (>= start_pos n)) {
        return TypeCParseResult { ok: false, c_type: "", next_pos: start_pos }
    } else { (print "") }

    let t0: LexerToken = (list_LexerToken_get parser.tokens start_pos)

    if (== t0.token_type LexerTokenType.TOKEN_TYPE_INT) { return TypeCParseResult { ok: true, c_type: "int64_t", next_pos: (+ start_pos 1) } } else { (print "") }
    if (== t0.token_type LexerTokenType.TOKEN_TYPE_FLOAT) { return TypeCParseResult { ok: true, c_type: "double", next_pos: (+ start_pos 1) } } else { (print "") }
    if (== t0.token_type LexerTokenType.TOKEN_TYPE_BOOL) { return TypeCParseResult { ok: true, c_type: "bool", next_pos: (+ start_pos 1) } } else { (print "") }
    if (== t0.token_type LexerTokenType.TOKEN_TYPE_STRING) { return TypeCParseResult { ok: true, c_type: "const char*", next_pos: (+ start_pos 1) } } else { (print "") }

    /* array<T> */
    if (== t0.token_type LexerTokenType.TOKEN_ARRAY) {
        return TypeCParseResult { ok: true, c_type: "DynArray*", next_pos: (+ start_pos 1) }
    } else { (print "") }

    if (== t0.token_type LexerTokenType.TOKEN_IDENTIFIER) {
        let name: string = t0.value

        /* List<T> */
        if (== name "List") {
            if (< (+ start_pos 3) n) {
                let t1: LexerToken = (list_LexerToken_get parser.tokens (+ start_pos 1))
                let t2: LexerToken = (list_LexerToken_get parser.tokens (+ start_pos 2))
                let t3: LexerToken = (list_LexerToken_get parser.tokens (+ start_pos 3))
                if (and (== t1.token_type LexerTokenType.TOKEN_LT) (and (== t2.token_type LexerTokenType.TOKEN_IDENTIFIER) (== t3.token_type LexerTokenType.TOKEN_GT))) {
                    let elem: string = t2.value
                    if (== elem "LexerToken") { return TypeCParseResult { ok: true, c_type: "List_LexerToken*", next_pos: (+ start_pos 4) } } else { (print "") }
                    if (== elem "CompilerDiagnostic") { return TypeCParseResult { ok: true, c_type: "List_CompilerDiagnostic*", next_pos: (+ start_pos 4) } } else { (print "") }
                    let mut list_parts: array<string> = []
                    set list_parts (cg_append list_parts "List_")
                    set list_parts (cg_append list_parts (mangle_type_name elem))
                    set list_parts (cg_append list_parts "*")
                    return TypeCParseResult { ok: true, c_type: (cg_build list_parts), next_pos: (+ start_pos 4) }
                } else { (print "") }
            } else { (print "") }
        } else { (print "") }

        /* Direct schema / built-in types */
        if (is_schema_struct_name name) {
            return TypeCParseResult { ok: true, c_type: name, next_pos: (+ start_pos 1) }
        } else { (print "") }

        /* Opaque types map directly to C types without nl_ prefix */
        if (is_opaque_type name) {
            return TypeCParseResult { ok: true, c_type: name, next_pos: (+ start_pos 1) }
        } else { (print "") }

        /* Fallback: treat as user-defined struct */
        let mut struct_parts: array<string> = []
        set struct_parts (cg_append struct_parts "nl_")
        set struct_parts (cg_append struct_parts (mangle_name name))
        return TypeCParseResult { ok: true, c_type: (cg_build struct_parts), next_pos: (+ start_pos 1) }
    } else { (print "") }

    return TypeCParseResult { ok: false, c_type: "", next_pos: start_pos }
}

shadow parse_type_c_from_tokens {
    /* Minimal sanity: require a token stream with `int` at position 0. */
    let toks: List<LexerToken> = (tokenize_string "int")
    let p: Parser = (parser_new toks (list_LexerToken_length toks))
    let r: TypeCParseResult = (parse_type_c_from_tokens p 0)
    assert r.ok
}

/* Generate C enum typedefs and variant #defines by scanning tokens */
fn generate_enum_definitions_from_tokens(parser: Parser) -> string {
    let mut out: string = ""
    let n: int = parser.token_count
    let mut i: int = 0
    let mut emitted_enums: array<string> = []

    while (< i n) {
        let tok: LexerToken = (list_LexerToken_get parser.tokens i)

        if (== tok.token_type LexerTokenType.TOKEN_ENUM) {
            if (>= (+ i 2) n) { return out } else { (print "") }

            let name_tok: LexerToken = (list_LexerToken_get parser.tokens (+ i 1))
            let brace_tok: LexerToken = (list_LexerToken_get parser.tokens (+ i 2))
            if (and (== name_tok.token_type LexerTokenType.TOKEN_IDENTIFIER) (== brace_tok.token_type LexerTokenType.TOKEN_LBRACE)) {
                let ename: string = name_tok.value
                let mut enum_already: bool = false
                let mut eai: int = 0
                while (< eai (array_length emitted_enums)) {
                    if (== (at emitted_enums eai) ename) { set enum_already true } else { (print "") }
                    set eai (+ eai 1)
                }
                if (not enum_already) {
                set emitted_enums (array_push emitted_enums ename)
                let c_name: string = (+ "nl_" (mangle_name ename))

                /* Emit typedef */
                set out (+ out "typedef int64_t ")
                set out (+ out c_name)
                set out (+ out ";\n")

                /* Parse variants and emit #defines */
                let mut j: int = (+ i 3)
                let mut ordinal: int = 0
                let mut enum_done: bool = false
                while (and (< j n) (not enum_done)) {
                    let tcur: LexerToken = (list_LexerToken_get parser.tokens j)
                    if (== tcur.token_type LexerTokenType.TOKEN_RBRACE) {
                        set enum_done true
                    } else { (print "") }
                    if (not enum_done) {

                    if (== tcur.token_type LexerTokenType.TOKEN_IDENTIFIER) {
                        let vname: string = tcur.value
                        /* Check for = value */
                        let mut explicit_val: int = ordinal
                        if (< (+ j 1) n) {
                            let tnext: LexerToken = (list_LexerToken_get parser.tokens (+ j 1))
                            if (== tnext.token_type LexerTokenType.TOKEN_ASSIGN) {
                                if (< (+ j 2) n) {
                                    let tval: LexerToken = (list_LexerToken_get parser.tokens (+ j 2))
                                    if (== tval.token_type LexerTokenType.TOKEN_NUMBER) {
                                        set explicit_val (string_to_int tval.value)
                                        set j (+ j 2)  /* skip = and number */
                                    } else { (print "") }
                                } else { (print "") }
                            } else { (print "") }
                        } else { (print "") }

                        set out (+ out "#define ")
                        set out (+ out c_name)
                        set out (+ out "_")
                        set out (+ out vname)
                        set out (+ out " ")
                        set out (+ out (int_to_string explicit_val))
                        set out (+ out "\n")
                        set ordinal (+ explicit_val 1)
                    } else { (print "") }

                    set j (+ j 1)
                    } else { (print "") }
                }

                set i j
                } else { (print "") }
            } else { (print "") }
        } else { (print "") }

        set i (+ i 1)
    }

    return out
}

shadow generate_enum_definitions_from_tokens {
    assert (== 1 1)
}

fn generate_struct_definitions_from_tokens(parser: Parser) -> string {
    let mut out: string = ""
    let n: int = parser.token_count
    let mut i: int = 0
    let mut emitted_structs: array<string> = []

    while (< i n) {
        let tok: LexerToken = (list_LexerToken_get parser.tokens i)
        let mut skip_struct: bool = false

        if (== tok.token_type LexerTokenType.TOKEN_STRUCT) {
            /* Skip extern struct declarations */
            if (> i 0) {
                let prev: LexerToken = (list_LexerToken_get parser.tokens (- i 1))
                if (== prev.token_type LexerTokenType.TOKEN_EXTERN) {
                    set skip_struct true
                } else { (print "") }
            } else { (print "") }

            if (not skip_struct) {
            if (>= (+ i 2) n) { return out } else { (print "") }

            let name_tok: LexerToken = (list_LexerToken_get parser.tokens (+ i 1))
            let brace_tok: LexerToken = (list_LexerToken_get parser.tokens (+ i 2))
            if (and (== name_tok.token_type LexerTokenType.TOKEN_IDENTIFIER) (== brace_tok.token_type LexerTokenType.TOKEN_LBRACE)) {
                let sname: string = name_tok.value
                if (not (is_schema_struct_name sname)) {

                /* Deduplicate: skip if already emitted (merged source may contain duplicates) */
                let mut already_emitted: bool = false
                let mut eidx: int = 0
                while (< eidx (array_length emitted_structs)) {
                    if (== (at emitted_structs eidx) sname) {
                        set already_emitted true
                    } else { (print "") }
                    set eidx (+ eidx 1)
                }
                if (not already_emitted) {
                set emitted_structs (array_push emitted_structs sname)

                let c_name: string = (+ "nl_" (mangle_name sname))
                let mut fields: string = ""

                let mut j: int = (+ i 3)
                let mut struct_done: bool = false
                while (and (< j n) (not struct_done)) {
                    let tcur: LexerToken = (list_LexerToken_get parser.tokens j)
                    if (== tcur.token_type LexerTokenType.TOKEN_RBRACE) {
                        set struct_done true
                    } else {
                        if (== tcur.token_type LexerTokenType.TOKEN_IDENTIFIER) {
                            if (>= (+ j 2) n) {
                                set struct_done true
                            } else {
                                let tcolon: LexerToken = (list_LexerToken_get parser.tokens (+ j 1))
                                if (!= tcolon.token_type LexerTokenType.TOKEN_COLON) {
                                    set j (+ j 1)
                                } else {
                                    let fname: string = tcur.value
                                    let tr: TypeCParseResult = (parse_type_c_from_tokens parser (+ j 2))
                                    if tr.ok {
                                        set fields (+ fields "    ")
                                        set fields (+ fields tr.c_type)
                                        set fields (+ fields " ")
                                        set fields (+ fields (mangle_name fname))
                                        set fields (+ fields ";\n")
                                        set j tr.next_pos

                                        if (< j n) {
                                            let tnext: LexerToken = (list_LexerToken_get parser.tokens j)
                                            if (== tnext.token_type LexerTokenType.TOKEN_COMMA) {
                                                set j (+ j 1)
                                            } else { (print "") }
                                        } else { (print "") }
                                    } else {
                                        set j (+ j 1)
                                    }
                                }
                            }
                        } else {
                            set j (+ j 1)
                        }
                    }
                }

                set out (+ out "\n/* Struct definition: ")
                set out (+ out sname)
                set out (+ out " */\n")
                set out (+ out "typedef struct ")
                set out (+ out c_name)
                set out (+ out " {\n")
                set out (+ out fields)
                set out (+ out "} ")
                set out (+ out c_name)
                set out (+ out ";\n")

                set i j
                } else { (print "") }
                } else { (print "") }
            } else { (print "") }
            } else { (print "") }
        } else { (print "") }

        set i (+ i 1)
    }

    return out
}

shadow generate_struct_definitions_from_tokens {
    let src: string = "struct Foo { x: int, y: bool }"
    let toks: List<LexerToken> = (tokenize_string src)
    let p: Parser = (parser_new toks (list_LexerToken_length toks))
    let c: string = (generate_struct_definitions_from_tokens p)
    assert (> (str_length c) 0)
}

fn has_function_named(parser: Parser, name: string) -> bool {
    let n: int = (parser_get_function_count parser)
    let mut i: int = 0
    while (< i n) {
        let f: ASTFunction = (parser_get_function parser i)
        if (== f.name name) { return true } else { (print "") }
        set i (+ i 1)
    }
    return false
}

shadow has_function_named {
    let toks: List<LexerToken> = (tokenize_string "fn main() -> int { return 0 }")
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "test.nano")
    assert (has_function_named p "main")
}

fn is_runtime_declared_extern(name: string) -> bool {
    /* Prefix-based: module introspection functions */
    if (str_contains name "___module_") { return true } else { (print "") }
    /* Prefix-based: json module functions */
    if (str_contains name "nl_json_") { return true } else { (print "") }
    /* Prefix-based: runtime list functions (included via headers) */
    if (str_contains name "list_int_") { return true } else { (print "") }
    if (str_contains name "list_string_") { return true } else { (print "") }
    if (str_contains name "list_token_") { return true } else { (print "") }
    if (str_contains name "list_LexerToken_") { return true } else { (print "") }
    if (str_contains name "list_AST") { return true } else { (print "") }
    if (str_contains name "list_Compiler") { return true } else { (print "") }
    /* Prefix-based: collections.h (nl_sb_, nl_hm_, nl_set_) */
    if (str_contains name "nl_sb_") { return true } else { (print "") }
    if (str_contains name "nl_hm_") { return true } else { (print "") }
    if (str_contains name "nl_set_") { return true } else { (print "") }
    /* Prefix-based: nl_os_ functions from cli.c */
    if (str_contains name "nl_os_") { return true } else { (print "") }
    /* Prefix-based: fs/path/file functions from fs.c */
    if (str_contains name "fs_") { return true } else { (print "") }
    if (str_contains name "path_") { return true } else { (print "") }
    if (str_contains name "file_") { return true } else { (print "") }
    if (str_contains name "dir_") { return true } else { (print "") }
    /* gen_c_runtime declared: CLI functions */
    if (== name "get_argc") { return true } else { (print "") }
    if (== name "get_argv") { return true } else { (print "") }
    if (== name "eval") { return true } else { (print "") }
    if (== name "nl_exec_shell") { return true } else { (print "") }
    if (== name "nl_exec_capture") { return true } else { (print "") }
    if (== name "nl_get_time_ms") { return true } else { (print "") }
    /* C standard library: <ctype.h> */
    if (== name "isalpha") { return true } else { (print "") }
    if (== name "isdigit") { return true } else { (print "") }
    if (== name "isalnum") { return true } else { (print "") }
    if (== name "isspace") { return true } else { (print "") }
    if (== name "isupper") { return true } else { (print "") }
    if (== name "islower") { return true } else { (print "") }
    if (== name "isprint") { return true } else { (print "") }
    if (== name "ispunct") { return true } else { (print "") }
    if (== name "toupper") { return true } else { (print "") }
    if (== name "tolower") { return true } else { (print "") }
    /* C standard library: <string.h> */
    if (== name "strlen") { return true } else { (print "") }
    if (== name "strcmp") { return true } else { (print "") }
    if (== name "strncmp") { return true } else { (print "") }
    if (== name "strcpy") { return true } else { (print "") }
    if (== name "strcat") { return true } else { (print "") }
    if (== name "memcpy") { return true } else { (print "") }
    if (== name "memset") { return true } else { (print "") }
    if (== name "strdup") { return true } else { (print "") }
    if (== name "strndup") { return true } else { (print "") }
    if (== name "strchr") { return true } else { (print "") }
    if (== name "strrchr") { return true } else { (print "") }
    if (== name "strstr") { return true } else { (print "") }
    if (== name "strtol") { return true } else { (print "") }
    if (== name "strtod") { return true } else { (print "") }
    if (== name "strtok") { return true } else { (print "") }
    /* C standard library: <math.h> + <stdlib.h> */
    if (== name "abs") { return true } else { (print "") }
    if (== name "sqrt") { return true } else { (print "") }
    if (== name "sin") { return true } else { (print "") }
    if (== name "cos") { return true } else { (print "") }
    if (== name "tan") { return true } else { (print "") }
    if (== name "floor") { return true } else { (print "") }
    if (== name "ceil") { return true } else { (print "") }
    if (== name "round") { return true } else { (print "") }
    if (== name "pow") { return true } else { (print "") }
    if (== name "fmod") { return true } else { (print "") }
    if (== name "atan") { return true } else { (print "") }
    if (== name "log") { return true } else { (print "") }
    if (== name "log2") { return true } else { (print "") }
    if (== name "log10") { return true } else { (print "") }
    if (== name "exp") { return true } else { (print "") }
    if (== name "exp2") { return true } else { (print "") }
    if (== name "asin") { return true } else { (print "") }
    if (== name "acos") { return true } else { (print "") }
    if (== name "atan2") { return true } else { (print "") }
    if (== name "cbrt") { return true } else { (print "") }
    if (== name "hypot") { return true } else { (print "") }
    if (== name "trunc") { return true } else { (print "") }
    if (== name "rint") { return true } else { (print "") }
    if (== name "nearbyint") { return true } else { (print "") }
    if (== name "remainder") { return true } else { (print "") }
    if (== name "rand") { return true } else { (print "") }
    if (== name "srand") { return true } else { (print "") }
    if (== name "exit") { return true } else { (print "") }
    if (== name "atoi") { return true } else { (print "") }
    if (== name "atof") { return true } else { (print "") }
    if (== name "malloc") { return true } else { (print "") }
    if (== name "calloc") { return true } else { (print "") }
    if (== name "realloc") { return true } else { (print "") }
    if (== name "free") { return true } else { (print "") }
    /* C standard library: <stdio.h> */
    if (== name "printf") { return true } else { (print "") }
    if (== name "fprintf") { return true } else { (print "") }
    if (== name "sprintf") { return true } else { (print "") }
    if (== name "snprintf") { return true } else { (print "") }
    if (== name "sscanf") { return true } else { (print "") }
    if (== name "getchar") { return true } else { (print "") }
    if (== name "putchar") { return true } else { (print "") }
    if (== name "puts") { return true } else { (print "") }
    if (== name "fopen") { return true } else { (print "") }
    if (== name "fclose") { return true } else { (print "") }
    if (== name "fread") { return true } else { (print "") }
    if (== name "fwrite") { return true } else { (print "") }
    /* C standard library: <time.h> */
    if (== name "time") { return true } else { (print "") }
    if (== name "clock") { return true } else { (print "") }
    /* C standard library: <unistd.h> */
    if (== name "sleep") { return true } else { (print "") }
    if (== name "usleep") { return true } else { (print "") }
    return false
}

shadow is_runtime_declared_extern {
    assert (is_runtime_declared_extern "printf")
    assert (is_runtime_declared_extern "malloc")
    assert (is_runtime_declared_extern "nl_sb_new")
    assert (is_runtime_declared_extern "list_int_new")
    assert (not (is_runtime_declared_extern "my_custom_func"))
}

fn generate_function_prototypes(parser: Parser) -> string {
    let mut sb: array<string> = []
    set sb (cg_append sb "\n/* Extern function declarations (not covered by headers) */\n")
    let n: int = (parser_get_function_count parser)
    let mut i: int = 0
    let mut emitted_fns: array<string> = []

    while (< i n) {
        let f: ASTFunction = (parser_get_function parser i)
        if (< f.body 0) {
            if (not (is_runtime_declared_extern f.name)) {
                let mut fn_dup: bool = false
                let mut fdi: int = 0
                while (< fdi (array_length emitted_fns)) {
                    if (== (at emitted_fns fdi) f.name) { set fn_dup true } else { (print "") }
                    set fdi (+ fdi 1)
                }
                if (not fn_dup) {
                set emitted_fns (array_push emitted_fns f.name)
                let mut names: array<string> = []
                let mut ctypes: array<string> = []
                let mut j: int = 0
                while (< j f.param_count) {
                    let let_node: ASTLet = (parser_get_let parser (+ f.param_start j))
                    set names (array_push names let_node.name)
                    set ctypes (array_push ctypes (type_to_c let_node.var_type))
                    set j (+ j 1)
                }
                let c_ret: string = (type_to_c f.return_type)
                set sb (cg_append sb "extern ")
                set sb (cg_append sb c_ret)
                set sb (cg_append sb " ")
                set sb (cg_append sb f.name)
                set sb (cg_append sb "(")
                let mut k: int = 0
                while (< k (array_length names)) {
                    if (> k 0) {
                        set sb (cg_append sb ", ")
                    } else { (print "") }
                    set sb (cg_append sb (at ctypes k))
                    set sb (cg_append sb " ")
                    set sb (cg_append sb (at names k))
                    set k (+ k 1)
                }
                if (== (array_length names) 0) {
                    set sb (cg_append sb "void")
                } else { (print "") }
                set sb (cg_append sb ");\n")
                } else { (print "") }
            } else { (print "") }
        } else { (print "") }
        set i (+ i 1)
    }

    set sb (cg_append sb "\n/* Function prototypes */\n")
    set i 0

    while (< i n) {
        let f: ASTFunction = (parser_get_function parser i)

        if (< f.body 0) {
            set i (+ i 1)
        } else {
        let mut fn_dup2: bool = false
        let mut fdi2: int = 0
        while (< fdi2 (array_length emitted_fns)) {
            if (== (at emitted_fns fdi2) f.name) { set fn_dup2 true } else { (print "") }
            set fdi2 (+ fdi2 1)
        }
        if (not fn_dup2) {
        set emitted_fns (array_push emitted_fns f.name)
        let mut names: array<string> = []
        let mut ctypes: array<string> = []

        let mut j: int = 0
        while (< j f.param_count) {
            let let_node: ASTLet = (parser_get_let parser (+ f.param_start j))
            set names (array_push names let_node.name)
            set ctypes (array_push ctypes (type_to_c let_node.var_type))
            set j (+ j 1)
        }

        let sig: string = (gen_function_signature f.name names ctypes f.return_type)
        set sb (cg_append sb sig)
        set sb (cg_append sb ";\n")
        } else { (print "") }

        set i (+ i 1)
        }
    }

    set sb (cg_append sb "\n")
    return (cg_build sb)
}

shadow generate_function_prototypes {
    let toks: List<LexerToken> = (tokenize_string "fn f(x: int) -> int { return x }")
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let c: string = (generate_function_prototypes p)
    assert (> (str_length c) 0)
}

fn lookup_struct_field_type(parser: Parser, struct_name: string, field_name: string) -> string {
    let sc: int = (parser_get_struct_def_count parser)
    let mut si: int = 0
    while (< si sc) {
        let s: ASTStruct = (parser_get_struct_def parser si)
        if (== s.name struct_name) {
            let fc: int = (array_length s.field_names)
            let mut fi: int = 0
            while (< fi fc) {
                if (== (at s.field_names fi) field_name) {
                    return (at s.field_types fi)
                } else { (print "") }
                set fi (+ fi 1)
            }
        } else { (print "") }
        set si (+ si 1)
    }
    return ""
}

shadow lookup_struct_field_type {
    let src: string = "struct Point { x: int, y: bool } fn main() -> int { return 0 }"
    let toks: List<LexerToken> = (tokenize_string src)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let t: string = (lookup_struct_field_type p "Point" "x")
    assert (== t "int")
    let t2: string = (lookup_struct_field_type p "Point" "z")
    assert (== t2 "")
}

fn is_extern_function(parser: Parser, name: string) -> bool {
    let n: int = (parser_get_function_count parser)
    let mut i: int = 0
    while (< i n) {
        let f: ASTFunction = (parser_get_function parser i)
        if (and (== f.name name) (< f.body 0)) { return true } else { (print "") }
        set i (+ i 1)
    }
    return false
}

shadow is_extern_function {
    let toks: List<LexerToken> = (tokenize_string "extern fn foo() -> int")
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    assert (is_extern_function p "foo")
}

fn genenv_new() -> GenEnv {
    return GenEnv { names: [], types: [] }
}

shadow genenv_new {
    let env: GenEnv = (genenv_new)
    assert (== (array_length env.names) 0)
    assert (== (array_length env.types) 0)
}

fn genenv_put(env: GenEnv, name: string, t: string) -> GenEnv {
    let new_names: array<string> = (array_push env.names name)
    let new_types: array<string> = (array_push env.types t)
    return GenEnv { names: new_names, types: new_types }
}

shadow genenv_put {
    let env: GenEnv = (genenv_new)
    let env2: GenEnv = (genenv_put env "x" "int")
    assert (== (array_length env2.names) 1)
    assert (== (at env2.names 0) "x")
    assert (== (at env2.types 0) "int")
}

fn genenv_get(env: GenEnv, name: string) -> string {
    let mut i: int = (- (array_length env.names) 1)
    while (>= i 0) {
        if (== (at env.names i) name) {
            return (at env.types i)
        } else {
            set i (- i 1)
        }
    }
    return ""
}

shadow genenv_get {
    let env: GenEnv = (genenv_new)
    let env2: GenEnv = (genenv_put env "x" "int")
    let env3: GenEnv = (genenv_put env2 "y" "bool")
    assert (== (genenv_get env3 "x") "int")
    assert (== (genenv_get env3 "y") "bool")
    assert (== (genenv_get env3 "unknown") "")
}

fn is_array_type(t: string) -> bool {
    return (str_contains t "array<")
}

shadow is_array_type {
    assert (is_array_type "array<int>")
    assert (is_array_type "array<Point>")
    assert (not (is_array_type "int"))
    assert (not (is_array_type "List<int>"))
}

fn array_elem_type_from_array_type(t: string) -> string {
    /* Check nested arrays FIRST since "array<array<int>>" also contains "array<int>" */
    if (str_contains t "array<array<") {
        return "array"
    } else {
    if (str_contains t "array<int>") {
        return "int"
    } else {
        if (str_contains t "array<float>") {
            return "float"
        } else {
            if (str_contains t "array<string>") {
                return "string"
            } else {
                if (str_contains t "array<bool>") {
                    return "bool"
                } else {
                        if (str_contains t "array<") {
                            /* Extract struct element types from array<Struct>. */
                            let start: int = (+ (transp_str_index_of t "array<") 6)
                            let end: int = (transp_str_index_of t ">")
                            if (and (>= start 6) (> end start)) {
                                return (str_substring t start (- end start))
                            } else {
                                return ""
                            }
                        } else {
                            return ""
                        }
                    }
                }
            }
        }
    }
    }

shadow array_elem_type_from_array_type {
    assert (== (array_elem_type_from_array_type "array<int>") "int")
    assert (== (array_elem_type_from_array_type "array<float>") "float")
    assert (== (array_elem_type_from_array_type "array<string>") "string")
    assert (== (array_elem_type_from_array_type "array<bool>") "bool")
    assert (== (array_elem_type_from_array_type "array<array<int>>") "array")
    assert (== (array_elem_type_from_array_type "array<Point>") "Point")
}

fn elem_enum_from_elem_type(elem_type: string) -> string {
    if (== elem_type "float") { return "ELEM_FLOAT" }
    else { if (== elem_type "string") { return "ELEM_STRING" }
    else { if (== elem_type "bool") { return "ELEM_BOOL" }
    else { if (== elem_type "array") { return "ELEM_ARRAY" }
    else { if (type_is_struct elem_type) { return "ELEM_INT" }
    else { return "ELEM_INT" } } } } }
}

shadow elem_enum_from_elem_type {
    assert (== (elem_enum_from_elem_type "float") "ELEM_FLOAT")
    assert (== (elem_enum_from_elem_type "string") "ELEM_STRING")
    assert (== (elem_enum_from_elem_type "bool") "ELEM_BOOL")
    assert (== (elem_enum_from_elem_type "array") "ELEM_ARRAY")
    assert (== (elem_enum_from_elem_type "int") "ELEM_INT")
    assert (== (elem_enum_from_elem_type "Point") "ELEM_POINTER")
}

fn get_fn_from_elem_type(elem_type: string) -> string {
    if (== elem_type "float") { return "dyn_array_get_float" }
    else { if (== elem_type "string") { return "dyn_array_get_string" }
    else { if (== elem_type "bool") { return "dyn_array_get_bool" }
    else { if (== elem_type "array") { return "dyn_array_get_array" }
    else { if (type_is_struct elem_type) { return "dyn_array_get_int" }
    else { return "dyn_array_get_int" } } } } }
}

shadow get_fn_from_elem_type {
    assert (== (get_fn_from_elem_type "float") "dyn_array_get_float")
    assert (== (get_fn_from_elem_type "string") "dyn_array_get_string")
    assert (== (get_fn_from_elem_type "int") "dyn_array_get_int")
    assert (== (get_fn_from_elem_type "Point") "dyn_array_get_int")
}

fn push_fn_from_elem_type(elem_type: string) -> string {
    if (== elem_type "float") { return "dyn_array_push_float" }
    else { if (== elem_type "string") { return "dyn_array_push_string" }
    else { if (== elem_type "bool") { return "dyn_array_push_bool" }
    else { if (== elem_type "array") { return "dyn_array_push_array" }
    else { if (type_is_struct elem_type) { return "dyn_array_push_int" }
    else { return "dyn_array_push_int" } } } } }
}

fn is_array_of_struct(t: string) -> bool {
    if (and (str_contains t "array<") (str_contains t ">")) {
        let elem_t: string = (array_elem_type_from_array_type t)
        if (!= elem_t "") {
            return (type_is_struct elem_t)
        } else {
            return false
        }
    } else {
        return false
    }
}

shadow is_array_of_struct {
    assert (is_array_of_struct "array<Point>")
    assert (not (is_array_of_struct "array<int>"))
    assert (not (is_array_of_struct "int"))
    assert (not (is_array_of_struct "string"))
}

shadow push_fn_from_elem_type {
    assert (== (push_fn_from_elem_type "float") "dyn_array_push_float")
    assert (== (push_fn_from_elem_type "bool") "dyn_array_push_bool")
    assert (== (push_fn_from_elem_type "int") "dyn_array_push_int")
    assert (== (push_fn_from_elem_type "Point") "dyn_array_push_int")
}

fn set_fn_from_elem_type(elem_type: string) -> string {
    if (== elem_type "float") { return "dyn_array_set_float" }
    else { if (== elem_type "string") { return "dyn_array_set_string" }
    else { if (== elem_type "bool") { return "dyn_array_set_bool" }
    else { if (== elem_type "array") { return "dyn_array_set_array" }
    else { if (type_is_struct elem_type) { return "dyn_array_set_int" }
    else { return "dyn_array_set_int" } } } } }
}

shadow set_fn_from_elem_type {
    assert (== (set_fn_from_elem_type "string") "dyn_array_set_string")
    assert (== (set_fn_from_elem_type "array") "dyn_array_set_array")
    assert (== (set_fn_from_elem_type "int") "dyn_array_set_int")
    assert (== (set_fn_from_elem_type "Point") "dyn_array_set_int")
}

fn type_is_struct(t: string) -> bool {
    if (or (is_array_type t) (str_contains t "List<")) {
        return false
    } else {
        (print "")
    }
    if (or (transp_str_starts_with t "fn(") (is_tuple_type t)) {
        return false
    } else {
        (print "")
    }
    if (or (== t "")
           (or (== t "int")
               (or (== t "float")
                   (or (== t "string")
                       (or (== t "bool")
                           (or (== t "array")
                               (or (== t "unknown") (== t "void")))))))) {
        return false
    } else {
        return true
    }
}

fn box_struct_expr(elem_type: string, value_expr: string) -> string {
    let c_struct: string = (+ "nl_" (mangle_type_name elem_type))
    let mut parts: array<string> = []
    set parts (cg_append parts "({ ")
    set parts (cg_append parts c_struct)
    set parts (cg_append parts "* _box = malloc(sizeof(")
    set parts (cg_append parts c_struct)
    set parts (cg_append parts ")); *_box = ")
    set parts (cg_append parts value_expr)
    set parts (cg_append parts "; (int64_t)_box; })")
    return (cg_build parts)
}

shadow box_struct_expr {
    let result: string = (box_struct_expr "Point" "my_val")
    assert (str_contains result "nl_Point")
    assert (str_contains result "my_val")
    assert (str_contains result "malloc")
}

shadow type_is_struct {
    assert (type_is_struct "Point")
    assert (not (type_is_struct "int"))
}

fn c_type_from_elem_type(elem_type: string) -> string {
    if (== elem_type "float") { return "double" }
    else { if (== elem_type "string") { return "const char*" }
    else { if (== elem_type "bool") { return "bool" }
    else { if (== elem_type "array") { return "DynArray*" }
    else { if (== elem_type "int") { return "int64_t" }
    else { if (type_is_struct elem_type) { return (+ "nl_" (mangle_type_name elem_type)) }
    else { return "int64_t" } } } } } }
}

shadow c_type_from_elem_type {
    assert (== (c_type_from_elem_type "float") "double")
    assert (== (c_type_from_elem_type "string") "const char*")
    assert (== (c_type_from_elem_type "bool") "bool")
    assert (== (c_type_from_elem_type "int") "int64_t")
    assert (== (c_type_from_elem_type "Point") "nl_Point")
}

/* Helper: convert nanolang type to C type */
fn is_tuple_type(nano_type: string) -> bool {
    let len: int = (str_length nano_type)
    if (< len 2) {
        return false
    } else {
        let first: string = (str_substring nano_type 0 1)
        let last: string = (str_substring nano_type (- len 1) 1)
        return (and (== first "(") (== last ")"))
    }
}

shadow is_tuple_type {
    assert (is_tuple_type "(int, string)")
    assert (is_tuple_type "()")
    assert (not (is_tuple_type "int"))
    assert (not (is_tuple_type "("))
}

fn mangle_type_name(name: string) -> string {
    let mut out: string = ""
    let len: int = (str_length name)
    let mut i: int = 0

    while (< i len) {
        let ch: string = (str_substring name i 1)

        if (and (== ch ":") (< (+ i 1) len)) {
            let ch2: string = (str_substring name (+ i 1) 1)
            if (== ch2 ":") {
                set out (+ out "_")
                set i (+ i 2)
            } else {
                set out (+ out "_")
                set i (+ i 1)
            }
        } else {
            if (or (== ch ".")
                    (or (== ch "<")
                        (or (== ch ">")
                            (or (== ch ",")
                                (or (== ch "(")
                                    (or (== ch ")")
                                        (== ch " "))))))) {
                set out (+ out "_")
            } else {
                set out (+ out ch)
            }
            set i (+ i 1)
        }
    }

    return out
}

shadow mangle_type_name {
    assert (== (mangle_type_name "List<Point>") "List_Point_")
    assert (== (mangle_type_name "Option::Some") "Option_Some")
    assert (== (mangle_type_name "(int, string)") "_int__string_")
}

fn tuple_typedef_name(tuple_type: string) -> string {
    let len: int = (str_length tuple_type)
    if (< len 2) {
        return "Tuple"
    } else {
        let inner: string = (str_substring tuple_type 1 (- len 2))
        /* Strip spaces to normalize "(int, int)" and "(int,int)" to same name */
        let mut stripped: string = ""
        let slen: int = (str_length inner)
        let mut si: int = 0
        while (< si slen) {
            let ch: string = (str_substring inner si 1)
            if (!= ch " ") {
                set stripped (+ stripped ch)
            } else { (print "") }
            set si (+ si 1)
        }
        return (+ "Tuple_" (mangle_type_name stripped))
    }
}

shadow tuple_typedef_name {
    assert (== (tuple_typedef_name "(int,string)") "Tuple_int_string")
    assert (== (tuple_typedef_name "(int, string)") "Tuple_int_string")
}

fn type_to_c(nano_type: string) -> string {
    /* Function pointer types: fn(int,int)->int */
    if (is_fn_type nano_type) {
        return (register_fn_type nano_type)
    } else { (print "") }
    /* HashMap opaque types */
    if (== nano_type "HashMap<string,int>") { return "HashMap_string_int*" } else { (print "") }
    if (== nano_type "HashMap<string, int>") { return "HashMap_string_int*" } else { (print "") }
    if (== nano_type "HashMap<string,string>") { return "HashMap_string_string*" } else { (print "") }
    if (== nano_type "HashMap<string, string>") { return "HashMap_string_string*" } else { (print "") }
    if (== nano_type "int") {
        return "int64_t"
    } else {
    if (== nano_type "int64_t") {
        return "int64_t"
    } else {
        if (== nano_type "float") {
            return "double"
        } else {
            if (== nano_type "bool") {
                return "int"
            } else {
                if (== nano_type "string") {
                    return "const char*"
                } else {
                    if (== nano_type "void") {
                        return "void"
                    } else {
                        /* Schema enums are not nl_-prefixed in generated/compiler_schema.h */
                        if (== nano_type "DiagnosticSeverity") { return "DiagnosticSeverity" } else { (print "") }
                        if (== nano_type "CompilerPhase") { return "CompilerPhase" } else { (print "") }
                        if (== nano_type "ParseNodeType") { return "ParseNodeType" } else { (print "") }
                        /* Token enum is named TokenType in C schema; Nano uses LexerTokenType in places */
                        if (or (== nano_type "LexerTokenType") (== nano_type "TokenType")) { return "TokenType" } else { (print "") }

                        if (transp_str_starts_with nano_type "List<") {
                            let elem: string = (str_substring nano_type 5 (- (str_length nano_type) 6))
                            if (== elem "int") {
                                return "List_int*"
                            } else {
                                if (== elem "string") {
                                    return "List_string*"
                                } else {
                                    if (== elem "LexerToken") {
                                        return "List_LexerToken*"
                                    } else {
                                        if (or (== elem "token") (== elem "Token")) {
                                            return "List_Token*"
                                        } else {
                                            let mut list_parts: array<string> = []
                                            set list_parts (cg_append list_parts "List_")
                                            set list_parts (cg_append list_parts (mangle_type_name elem))
                                            set list_parts (cg_append list_parts "*")
                                            return (cg_build list_parts)
                                        }
                                    }
                                }
                            }
                        } else {
                        if (str_contains nano_type "array<") {
                            return "DynArray*"
                        } else {
                            if (is_tuple_type nano_type) {
                                return (tuple_typedef_name nano_type)
                            } else {
                                if (is_opaque_type nano_type) {
                                    return nano_type
                                } else {
                                if (is_generic_type nano_type) {
                                    return (+ "nl_" (monomorphize_type_name nano_type))
                                } else {
                                    return (+ "nl_" (mangle_name nano_type))
                                }
                                }
                            }
                        }
                        }
                    }
                }
            }
        }
    }
    }
}

shadow type_to_c {
    assert (== (type_to_c "int") "int64_t")
    assert (== (type_to_c "bool") "int")
    assert (== (type_to_c "MyStruct") "nl_MyStruct")
    assert (== (type_to_c "Result<int,string>") "nl_Result_int_string")
}

fn tuple_split_types(tuple_type: string) -> array<string> {
    let len: int = (str_length tuple_type)
    if (< len 2) {
        return []
    } else {
        let inner: string = (str_substring tuple_type 1 (- len 2))
        let mut parts: array<string> = []
        let mut cur: string = ""

        let mut i: int = 0
        let inner_len: int = (str_length inner)
        let mut depth_angle: int = 0
        let mut depth_paren: int = 0

        while (< i inner_len) {
            let ch: string = (str_substring inner i 1)
            let mut is_sep: bool = false
            if (== ch "<") {
                set depth_angle (+ depth_angle 1)
            } else {
                if (== ch ">") {
                    set depth_angle (- depth_angle 1)
                } else {
                    if (== ch "(") {
                        set depth_paren (+ depth_paren 1)
                    } else {
                        if (== ch ")") {
                            set depth_paren (- depth_paren 1)
                        } else {
                            if (and (== ch ",") (and (== depth_angle 0) (== depth_paren 0))) {
                                set parts (array_push parts cur)
                                set cur ""
                                set is_sep true
                            } else {
                                (print "")
                            }
                        }
                    }
                }
            }

            if (not is_sep) {
                set cur (+ cur ch)
            } else { (print "") }
            set i (+ i 1)
        }

        set parts (array_push parts cur)
        return parts
    }
}

shadow tuple_split_types {
    let parts: array<string> = (tuple_split_types "(int,string)")
    assert (== (array_length parts) 2)
    assert (== (at parts 0) "int")
    assert (== (at parts 1) "string")
}

fn collect_tuple_types_from_type(t: string, acc: array<string>, seen: HashMap<string, int>) -> array<string> {
    if (not (is_tuple_type t)) {
        return acc
    } else {
        let elems: array<string> = (tuple_split_types t)
        let mut acc2: array<string> = acc

        let mut i: int = 0
        while (< i (array_length elems)) {
            set acc2 (collect_tuple_types_from_type (at elems i) acc2 seen)
            set i (+ i 1)
        }

        if (map_has seen t) {
            return acc2
        } else {
            (map_put seen t 1)
            return (array_push acc2 t)
        }
    }
}

shadow collect_tuple_types_from_type {
    let acc: array<string> = []
    let seen: HashMap<string, int> = (hashset_new_string)
    let out: array<string> = (collect_tuple_types_from_type "(int,string)" acc seen)
    assert (== (array_length out) 1)
    assert (== (at out 0) "(int,string)")
}

fn gen_tuple_typedef(tuple_type: string) -> string {
    let name: string = (tuple_typedef_name tuple_type)
    let elems: array<string> = (tuple_split_types tuple_type)
    let mut out: string = "typedef struct { "

    let mut i: int = 0
    while (< i (array_length elems)) {
        if (> i 0) {
            set out (+ out "; ")
        } else { (print "") }

        let ct: string = (type_to_c (at elems i))
        set out (+ out ct)
        set out (+ out " _")
        set out (+ out (int_to_string i))
        set i (+ i 1)
    }

    set out (+ out "; } ")
    set out (+ out name)
    set out (+ out ";\n")
    return out
}

shadow gen_tuple_typedef {
    let code: string = (gen_tuple_typedef "(int,string)")
    assert (str_contains code "Tuple_int_string")
    assert (str_contains code "int64_t _0")
}

fn gen_tuple_typedefs(parser: Parser) -> string {
    let mut tuple_types: array<string> = []
    let tuple_seen: HashMap<string, int> = (hashset_new_string)

    /* Walk all lets (params and locals) */
    let let_count: int = (parser_get_let_count parser)
    let mut i: int = 0
    while (< i let_count) {
        let l: ASTLet = (parser_get_let parser i)
        set tuple_types (collect_tuple_types_from_type l.var_type tuple_types tuple_seen)
        set i (+ i 1)
    }

    /* Walk function return types */
    let fn_count: int = (parser_get_function_count parser)
    let mut j: int = 0
    while (< j fn_count) {
        let f: ASTFunction = (parser_get_function parser j)
        set tuple_types (collect_tuple_types_from_type f.return_type tuple_types tuple_seen)
        set j (+ j 1)
    }

    let mut out: string = ""
    let mut k: int = 0
    while (< k (array_length tuple_types)) {
        set out (+ out (gen_tuple_typedef (at tuple_types k)))
        set k (+ k 1)
    }

    if (== out "") {
        return ""
    } else {
        return (+ "/* Tuple typedefs */\n" out)
    }
}

shadow gen_tuple_typedefs {
    let source: string = (+ "f" "n main() -> (int,int) { return (1, 2) }")
    let toks: List<LexerToken> = (tokenize_string source)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let code: string = (gen_tuple_typedefs p)
    assert (str_contains code "Tuple_int_int")
}

/* Note: For Phase 1, we avoid complex array<string> type inference issues */
/* Parameter types will be converted at a higher level before calling gen_function_signature */

/* =============================================================================
 * EXPRESSION CODE GENERATION
 * ============================================================================= */

/* Generate code for a number literal */
fn gen_number(value: string) -> string {
    return value
}

shadow gen_number {
    assert (== (gen_number "42") "42")
}

/* Generate code for a string literal */
fn gen_string(value: string) -> string {
    /* For now, return as-is. In production, need to escape special chars */
    let mut parts: array<string> = []
    set parts (cg_append parts "\"")
    set parts (cg_append parts value)
    set parts (cg_append parts "\"")
    return (cg_build parts)
}

shadow gen_string {
    let code: string = (gen_string "hello")
    assert (== code "\"hello\"")
}

/* Generate code for a boolean literal */
fn gen_bool(value: bool) -> string {
    if value {
        return "1"
    } else {
        return "0"
    }
}

shadow gen_bool {
    assert (== (gen_bool true) "1")
    assert (== (gen_bool false) "0")
}

/* Generate code for an identifier */
fn gen_identifier(name: string) -> string {
    /* Add nl_ prefix for namespacing */
    return (+ "nl_" (mangle_name name))
}

shadow gen_identifier {
    assert (== (gen_identifier "x") "nl_x")
}

/* Generate code for a binary operation */
fn gen_binary_op(op: string, left: string, right: string) -> string {
    /* Convert nanolang operators to C operators */
    let mut c_op: string = op
    
    /* Arithmetic is same: +, -, *, /, % */
    /* Comparison: ==, !=, <, >, <=, >= */
    /* Logical: convert 'and' -> '&&', 'or' -> '||' */
    
    if (== op "and") {
        set c_op "&&"
    } else {
        if (== op "or") {
            set c_op "||"
        } else {
            set c_op op
        }
    }
    
    let mut parts: array<string> = []
    set parts (cg_append parts "(")
    set parts (cg_append parts left)
    set parts (cg_append parts " ")
    set parts (cg_append parts c_op)
    set parts (cg_append parts " ")
    set parts (cg_append parts right)
    set parts (cg_append parts ")")
    
    return (cg_build parts)
}

shadow gen_binary_op {
    /* Minimal test to satisfy compiler */
    assert (== 1 1)
}

/* Generate code for a function call */
fn gen_call(func_name: string, args: array<string>) -> string {
    let mut parts: array<string> = []
    set parts (cg_append parts "nl_")
    set parts (cg_append parts (mangle_name func_name))
    set parts (cg_append parts "(")
    
    /* Add arguments */
    let arg_count: int = (array_length args)
    let mut i: int = 0
    
    while (< i arg_count) {
        if (> i 0) {
            set parts (cg_append parts ", ")
        } else {
            (print "")
        }
        
        /* Directly use (at args i) to avoid type inference issue */
        set parts (cg_append parts (at args i))
        set i (+ i 1)
    }
    
    set parts (cg_append parts ")")
    return (cg_build parts)
}

shadow gen_call {
    let args: array<string> = []
    let code1: string = (gen_call "foo" args)
    
    let mut args2: array<string> = []
    set args2 (array_push args2 "1")
    set args2 (array_push args2 "2")
    let code2: string = (gen_call "add" args2)
    /* Just verify it doesn't crash */
    assert (== 1 1)
}

/* =============================================================================
 * STATEMENT CODE GENERATION
 * ============================================================================= */

/* Generate code for a let statement */
fn gen_let(name: string, type_name: string, value_expr: string, indent: int) -> string {
    let mut parts: array<string> = []
    set parts (cg_append parts (gen_indent indent))
    
    /* Convert nanolang type to C type using helper */
    let c_type: string = (type_to_c type_name)
    
    set parts (cg_append parts c_type)
    set parts (cg_append parts " nl_")
    set parts (cg_append parts name)
    set parts (cg_append parts " = ")
    set parts (cg_append parts value_expr)
    set parts (cg_append parts ";\n")
    
    return (cg_build parts)
}

shadow gen_let {
    let code: string = (gen_let "x" "int" "42" 0)
    /* Just verify it doesn't crash */
    assert (== 1 1)
}

/* Generate code for an if statement */
fn gen_if(condition: string, then_body: string, else_body: string, indent: int) -> string {
    let mut parts: array<string> = []
    set parts (cg_append parts (gen_indent indent))
    set parts (cg_append parts "if (")
    set parts (cg_append parts condition)
    set parts (cg_append parts ") {\n")
    set parts (cg_append parts then_body)
    set parts (cg_append parts (gen_indent indent))
    set parts (cg_append parts "}")
    
    /* Add else clause if present */
    if (!= else_body "") {
        set parts (cg_append parts " else {\n")
        set parts (cg_append parts else_body)
        set parts (cg_append parts (gen_indent indent))
        set parts (cg_append parts "}")
    } else {
        (print "")
    }
    
    set parts (cg_append parts "\n")
    return (cg_build parts)
}

shadow gen_if {
    let code: string = (gen_if "x > 0" "    return 1;\n" "" 0)
    /* Just verify it doesn't crash */
    assert (== 1 1)
}

/* Generate code for a while loop */
fn gen_while(condition: string, body: string, indent: int) -> string {
    let mut parts: array<string> = []
    set parts (cg_append parts (gen_indent indent))
    set parts (cg_append parts "while (")
    set parts (cg_append parts condition)
    set parts (cg_append parts ") {\n")
    set parts (cg_append parts body)
    set parts (cg_append parts (gen_indent indent))
    set parts (cg_append parts "}\n")
    
    return (cg_build parts)
}

shadow gen_while {
    let code: string = (gen_while "i < 10" "    i++;\n" 0)
    /* Just verify it doesn't crash */
    assert (== 1 1)
}

/* Generate code for a return statement */
fn gen_return(value_expr: string, indent: int) -> string {
    let mut parts: array<string> = []
    set parts (cg_append parts (gen_indent indent))
    set parts (cg_append parts "return ")
    set parts (cg_append parts value_expr)
    set parts (cg_append parts ";\n")
    
    return (cg_build parts)
}

shadow gen_return {
    let code: string = (gen_return "42" 1)
    /* Just verify it doesn't crash */
    assert (== 1 1)
}

/* =============================================================================
 * FUNCTION DEFINITION GENERATION
 * ============================================================================= */

/* Generate function signature */
fn gen_function_signature(name: string, params: array<string>, param_types: array<string>, return_type: string) -> string {
    let mut parts: array<string> = []
    
    /* Convert return type using helper */
    let c_ret_type: string = (type_to_c return_type)
    
    set parts (cg_append parts c_ret_type)
    set parts (cg_append parts " ")
    set parts (cg_append parts (c_func_name_for_definition name))
    set parts (cg_append parts "(")
    
    /* Add parameters */
    let param_count: int = (array_length params)
    let mut i: int = 0
    
    while (< i param_count) {
        if (> i 0) {
            set parts (cg_append parts ", ")
        } else {
            (print "")
        }
        
        /* Use param type directly - caller should pre-convert to C types */
        /* This avoids array<string> type inference issues */
        set parts (cg_append parts (at param_types i))
        set parts (cg_append parts " nl_")
        /* Use param name directly */
        set parts (cg_append parts (mangle_name (at params i)))
        
        set i (+ i 1)
    }
    
    set parts (cg_append parts ")")
    return (cg_build parts)
}

shadow gen_function_signature {
    let params: array<string> = []
    let mut types: array<string> = []
    /* Note: types should be pre-converted to C types */
    set types (array_push types "int64_t")
    set types (array_push types "int")
    let sig: string = (gen_function_signature "add" params types "int")
    /* Just verify it generates something */
    assert (== 1 1)
}

/* Generate complete function definition */
fn gen_function(name: string, params: array<string>, param_types: array<string>, return_type: string, body: string) -> string {
    let mut parts: array<string> = []
    set parts (cg_append parts (gen_function_signature name params param_types return_type))
    set parts (cg_append parts " {\n")
    set parts (cg_append parts body)
    set parts (cg_append parts "}\n\n")
    
    return (cg_build parts)
}

shadow gen_function {
    let params: array<string> = []
    let types: array<string> = []
    let func: string = (gen_function "main" params types "int" "    return 0;\n")
    /* Just verify it doesn't crash */
    assert (== 1 1)
}

/* =============================================================================
 * C RUNTIME / STANDARD LIBRARY
 * ============================================================================= */

/* Generate C includes and runtime support */
fn gen_c_includes() -> string {
    let mut parts: array<string> = []
    set parts (cg_append parts "/* Generated by nanolang self-hosted compiler */\n")
    set parts (cg_append parts "#ifndef _GNU_SOURCE\n")
    set parts (cg_append parts "#define _GNU_SOURCE\n")
    set parts (cg_append parts "#endif\n")
    set parts (cg_append parts "#include <stdio.h>\n")
    set parts (cg_append parts "#include <stdlib.h>\n")
    set parts (cg_append parts "#include <stdint.h>\n")
    set parts (cg_append parts "#include <stdbool.h>\n")
    set parts (cg_append parts "#include <string.h>\n")
    set parts (cg_append parts "#include <math.h>\n")
    set parts (cg_append parts "#include <assert.h>\n")
    set parts (cg_append parts "#include <time.h>\n")
    set parts (cg_append parts "#include <ctype.h>\n")
    set parts (cg_append parts "#include <sys/time.h>\n")
    set parts (cg_append parts "#ifdef __MACH__\n")
    set parts (cg_append parts "#include <mach/mach_time.h>\n")
    set parts (cg_append parts "#endif\n")
    set parts (cg_append parts "#include \"nanolang.h\"\n")
    set parts (cg_append parts "#include \"collections/collections.h\"\n")
    set parts (cg_append parts "#include \"json/json.h\"\n")
    set parts (cg_append parts "#include \"runtime/hashmap_bootstrap.h\"\n")
    set parts (cg_append parts "#include \"runtime/dyn_array.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_int.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_string.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_token.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_LexerToken.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_CompilerDiagnostic.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_CompilerSourceLocation.h\"\n")
    set parts (cg_append parts "#include \"runtime/token_helpers.h\"\n")
    /* Include all AST list type headers for compiler support */
    set parts (cg_append parts "#include \"runtime/list_ASTLet.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTFunction.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTNumber.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTFloat.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTString.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTBool.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTIdentifier.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTBinaryOp.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTCall.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTArrayLiteral.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTSet.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTIf.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTWhile.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTFor.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTReturn.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTStmtRef.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTBlock.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTUnsafeBlock.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTPrint.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTAssert.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTShadow.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTStruct.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTStructLiteral.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTFieldAccess.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTEnum.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTUnion.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTUnionConstruct.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTMatch.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTImport.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTOpaqueType.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTTupleLiteral.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTModuleQualifiedCall.h\"\n")
    set parts (cg_append parts "#include \"runtime/list_ASTTupleIndex.h\"\n")
    set parts (cg_append parts "\n")
    /* Forward declarations for opaque types (module-provided, pointer-sized) */
    set parts (cg_append parts "/* Opaque type forward declarations */\n")
    set parts (cg_append parts "#ifndef NL_OPAQUE_TYPES_DECLARED\n")
    set parts (cg_append parts "#define NL_OPAQUE_TYPES_DECLARED\n")
    set parts (cg_append parts "typedef void* NLStringBuilder;\n")
    set parts (cg_append parts "typedef void* NLStringSet;\n")
    set parts (cg_append parts "typedef void* NLHashMap;\n")
    set parts (cg_append parts "typedef void* NlPeg;\n")
    set parts (cg_append parts "typedef void* Json;\n")
    set parts (cg_append parts "typedef void* Regex;\n")
    set parts (cg_append parts "typedef void* DateTime;\n")
    set parts (cg_append parts "typedef void* HttpResponse;\n")
    set parts (cg_append parts "typedef void* HttpServer;\n")
    set parts (cg_append parts "typedef void* HttpRequest;\n")
    /* SDL opaque type forward declarations (guarded against SDL header conflicts) */
    set parts (cg_append parts "#ifndef SDL_h_\n")
    set parts (cg_append parts "typedef void* SDL_Window;\n")
    set parts (cg_append parts "typedef void* SDL_Renderer;\n")
    set parts (cg_append parts "typedef void* SDL_Texture;\n")
    set parts (cg_append parts "typedef void* SDL_Surface;\n")
    set parts (cg_append parts "typedef void* SDL_GLContext;\n")
    set parts (cg_append parts "#endif\n")
    set parts (cg_append parts "#ifndef SDL_TTF_H_\n")
    set parts (cg_append parts "typedef void* TTF_Font;\n")
    set parts (cg_append parts "#endif\n")
    set parts (cg_append parts "#ifndef SDL_MIXER_H_\n")
    set parts (cg_append parts "typedef void* Mix_Chunk;\n")
    set parts (cg_append parts "typedef void* Mix_Music;\n")
    set parts (cg_append parts "#endif\n")
    set parts (cg_append parts "#endif\n\n")
    /* Module standard library headers - fs and process functions */
    /* These are always included since the modules are always linked */
    set parts (cg_append parts "#include \"fs.h\"\n")
    set parts (cg_append parts "#include \"process.h\"\n")
    /* Forward declarations for cli.c functions not covered by a header */
    set parts (cg_append parts "extern int64_t nl_os_unsetenv(const char* name);\n")
    set parts (cg_append parts "\n")

    return (cg_build parts)
}

shadow gen_c_includes {
    let includes: string = (gen_c_includes)
    /* Just verify it generates something */
    assert (== 1 1)
}

/* Generate runtime helper functions */
fn gen_c_runtime() -> string {
    let mut sb: array<string> = []
    
    set sb (cg_append sb "/* ========== Math and Utility Built-in Functions ========== */\n\n")
    
    /* Math macros (abs, min, max) - use _Generic for type safety */
    set sb (cg_append sb "#define nl_abs(x) _Generic((x), \\\n")
    set sb (cg_append sb "    double: (double)((x) < 0.0 ? -(x) : (x)), \\\n")
    set sb (cg_append sb "    default: (int64_t)((x) < 0 ? -(x) : (x)))\n\n")
    
    set sb (cg_append sb "#define nl_min(a, b) _Generic((a), \\\n")
    set sb (cg_append sb "    double: (double)((a) < (b) ? (a) : (b)), \\\n")
    set sb (cg_append sb "    default: (int64_t)((a) < (b) ? (a) : (b)))\n\n")
    
    set sb (cg_append sb "#define nl_max(a, b) _Generic((a), \\\n")
    set sb (cg_append sb "    double: (double)((a) > (b) ? (a) : (b)), \\\n")
    set sb (cg_append sb "    default: (int64_t)((a) > (b) ? (a) : (b)))\n\n")
    
    /* Math functions */
    set sb (cg_append sb "/* Math functions */\n")
    set sb (cg_append sb "double nl_sqrt(double x) { return sqrt(x); }\n")
    set sb (cg_append sb "double nl_pow(double base, double exp) { return pow(base, exp); }\n")
    set sb (cg_append sb "double nl_floor(double x) { return floor(x); }\n")
    set sb (cg_append sb "double nl_ceil(double x) { return ceil(x); }\n")
    set sb (cg_append sb "double nl_round(double x) { return round(x); }\n")
    set sb (cg_append sb "double nl_sin(double x) { return sin(x); }\n")
    set sb (cg_append sb "double nl_cos(double x) { return cos(x); }\n")
    set sb (cg_append sb "double nl_tan(double x) { return tan(x); }\n")
    set sb (cg_append sb "double nl_atan2(double y, double x) { return atan2(y, x); }\n\n")

    /* Print functions */
    set sb (cg_append sb "/* Print functions */\n")
    set sb (cg_append sb "void nl_print(const char* s) {\n")
    set sb (cg_append sb "    printf(\"%s\", s);\n")
    set sb (cg_append sb "}\n\n")
    
    set sb (cg_append sb "void nl_println(const char* s) {\n")
    set sb (cg_append sb "    printf(\"%s\\n\", s);\n")
    set sb (cg_append sb "}\n\n")

    set sb (cg_append sb "void nl_print_float(double v) {\n")
    set sb (cg_append sb "    printf(\"%g\", v);\n")
    set sb (cg_append sb "}\n\n")

    set sb (cg_append sb "void nl_println_float(double v) {\n")
    set sb (cg_append sb "    printf(\"%g\\n\", v);\n")
    set sb (cg_append sb "}\n\n")
    
    /* Type conversion functions */
    set sb (cg_append sb "/* Type conversions */\n")
    set sb (cg_append sb "char* nl_int_to_string(int64_t n) {\n")
    set sb (cg_append sb "    char* buffer = malloc(32);\n")
    set sb (cg_append sb "    if (!buffer) return \"\";\n")
    set sb (cg_append sb "    snprintf(buffer, 32, \"%lld\", (long long)n);\n")
    set sb (cg_append sb "    return buffer;\n")
    set sb (cg_append sb "}\n\n")
    
    set sb (cg_append sb "#ifndef NL_HAS_USER_FLOAT_TO_STRING\n")
    set sb (cg_append sb "char* nl_float_to_string(double x) {\n")
    set sb (cg_append sb "    char* buffer = malloc(64);\n")
    set sb (cg_append sb "    if (!buffer) return \"\";\n")
    set sb (cg_append sb "    snprintf(buffer, 64, \"%g\", x);\n")
    set sb (cg_append sb "    return buffer;\n")
    set sb (cg_append sb "}\n")
    set sb (cg_append sb "#endif\n\n")

    
    set sb (cg_append sb "char* nl_bool_to_string(bool b) {\n")
    set sb (cg_append sb "    return b ? \"true\" : \"false\";\n")
    set sb (cg_append sb "}\n\n")
    
    set sb (cg_append sb "int64_t nl_string_to_int(const char* s) {\n")
    set sb (cg_append sb "    return strtoll(s, NULL, 10);\n")
    set sb (cg_append sb "}\n\n")
    
    set sb (cg_append sb "double nl_string_to_float(const char* s) {\n")
    set sb (cg_append sb "    return strtod(s, NULL);\n")
    set sb (cg_append sb "}\n\n")

    set sb (cg_append sb "double nl_cast_float(int64_t x) { return (double)x; }\n")
    set sb (cg_append sb "double nl_cast_float_from_float(double x) { return x; }\n")
    set sb (cg_append sb "int64_t nl_cast_int(double x) { return (int64_t)x; }\n")
    set sb (cg_append sb "int64_t nl_cast_int_from_int(int64_t x) { return x; }\n\n")
    
    /* String operations */
    set sb (cg_append sb "/* String operations */\n")
    set sb (cg_append sb "char* nl_str_concat(const char* a, const char* b) {\n")
    set sb (cg_append sb "    size_t la = strlen(a);\n")
    set sb (cg_append sb "    size_t lb = strlen(b);\n")
    set sb (cg_append sb "    char* out = (char*)malloc(la + lb + 1);\n")
    set sb (cg_append sb "    if (!out) return \"\";\n")
    set sb (cg_append sb "    memcpy(out, a, la);\n")
    set sb (cg_append sb "    memcpy(out + la, b, lb);\n")
    set sb (cg_append sb "    out[la + lb] = 0;\n")
    set sb (cg_append sb "    return out;\n")
    set sb (cg_append sb "}\n\n")
    
    set sb (cg_append sb "char* nl_str_substring(const char* s, int64_t start, int64_t len) {\n")
    set sb (cg_append sb "    if (!s) return \"\";\n")
    set sb (cg_append sb "    int64_t n = (int64_t)strlen(s);\n")
    set sb (cg_append sb "    if (start < 0) start = 0;\n")
    set sb (cg_append sb "    if (len < 0) len = 0;\n")
    set sb (cg_append sb "    if (start > n) start = n;\n")
    set sb (cg_append sb "    if (start + len > n) len = n - start;\n")
    set sb (cg_append sb "    char* out = (char*)malloc((size_t)len + 1);\n")
    set sb (cg_append sb "    if (!out) return \"\";\n")
    set sb (cg_append sb "    memcpy(out, s + start, (size_t)len);\n")
    set sb (cg_append sb "    out[len] = 0;\n")
    set sb (cg_append sb "    return out;\n")
    set sb (cg_append sb "}\n\n")
    
    set sb (cg_append sb "bool nl_str_contains(const char* str, const char* substr) {\n")
    set sb (cg_append sb "    return strstr(str, substr) != NULL;\n")
    set sb (cg_append sb "}\n\n")
    
    set sb (cg_append sb "bool nl_str_equals(const char* s1, const char* s2) {\n")
    set sb (cg_append sb "    return strcmp(s1, s2) == 0;\n")
    set sb (cg_append sb "}\n\n")
    
    /* Character operations */
    set sb (cg_append sb "/* Character operations */\n")
    set sb (cg_append sb "int64_t nl_char_at(const char* s, int64_t i) {\n")
    set sb (cg_append sb "    return (int64_t)((unsigned char)s[i]);\n")
    set sb (cg_append sb "}\n\n")
    
    set sb (cg_append sb "char* nl_string_from_char(int64_t c) {\n")
    set sb (cg_append sb "    char* buffer = malloc(2);\n")
    set sb (cg_append sb "    if (!buffer) return \"\";\n")
    set sb (cg_append sb "    buffer[0] = (char)c;\n")
    set sb (cg_append sb "    buffer[1] = 0;\n")
    set sb (cg_append sb "    return buffer;\n")
    set sb (cg_append sb "}\n\n")
    
    /* Character classification */
    set sb (cg_append sb "/* Character classification */\n")
    set sb (cg_append sb "bool nl_is_digit(int64_t c) {\n")
    set sb (cg_append sb "    return c >= '0' && c <= '9';\n")
    set sb (cg_append sb "}\n\n")
    
    set sb (cg_append sb "bool nl_is_alpha(int64_t c) {\n")
    set sb (cg_append sb "    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n")
    set sb (cg_append sb "}\n\n")
    
    set sb (cg_append sb "bool nl_is_alnum(int64_t c) {\n")
    set sb (cg_append sb "    return nl_is_digit(c) || nl_is_alpha(c);\n")
    set sb (cg_append sb "}\n\n")
    
    set sb (cg_append sb "bool nl_is_whitespace(int64_t c) {\n")
    set sb (cg_append sb "    return c == ' ' || c == '\\t' || c == '\\n' || c == '\\r';\n")
    set sb (cg_append sb "}\n\n")
    
    set sb (cg_append sb "bool nl_is_upper(int64_t c) {\n")
    set sb (cg_append sb "    return c >= 'A' && c <= 'Z';\n")
    set sb (cg_append sb "}\n\n")
    
    set sb (cg_append sb "bool nl_is_lower(int64_t c) {\n")
    set sb (cg_append sb "    return c >= 'a' && c <= 'z';\n")
    set sb (cg_append sb "}\n\n")
    
    set sb (cg_append sb "int64_t nl_digit_value(int64_t c) {\n")
    set sb (cg_append sb "    if (c >= '0' && c <= '9') {\n")
    set sb (cg_append sb "        return c - '0';\n")
    set sb (cg_append sb "    }\n")
    set sb (cg_append sb "    return -1;\n")
    set sb (cg_append sb "}\n\n")
    
    set sb (cg_append sb "int64_t nl_char_to_lower(int64_t c) {\n")
    set sb (cg_append sb "    if (c >= 'A' && c <= 'Z') {\n")
    set sb (cg_append sb "        return c + 32;\n")
    set sb (cg_append sb "    }\n")
    set sb (cg_append sb "    return c;\n")
    set sb (cg_append sb "}\n\n")
    
    set sb (cg_append sb "int64_t nl_char_to_upper(int64_t c) {\n")
    set sb (cg_append sb "    if (c >= 'a' && c <= 'z') {\n")
    set sb (cg_append sb "        return c - 32;\n")
    set sb (cg_append sb "    }\n")
    set sb (cg_append sb "    return c;\n")
    set sb (cg_append sb "}\n\n")
    
    /* fs.h returns const char* for path/file functions; NanoLang string type is char*.
     * Provide nl_ wrappers that cast const char* to char* so user code can assign
     * to string variables without -Wdiscarded-qualifiers warnings. */
    set sb (cg_append sb "/* fs wrappers */\n")
    set sb (cg_append sb "static const char* nl_path_normalize(const char* p) { return path_normalize(p); }\n")
    set sb (cg_append sb "static const char* nl_path_join(const char* a, const char* b) { return path_join(a, b); }\n")
    set sb (cg_append sb "static const char* nl_path_basename(const char* p) { return path_basename(p); }\n")
    set sb (cg_append sb "static const char* nl_path_dirname(const char* p) { return path_dirname(p); }\n")
    set sb (cg_append sb "static const char* nl_path_relpath(const char* t, const char* b) { return path_relpath(t, b); }\n")
    set sb (cg_append sb "static const char* nl_file_read(const char* p) { return file_read(p); }\n\n")

    /* process.h does not declare nl_os_process_run (nanoc_c generates a static version that
     * would conflict); declare it here as extern so user code can call process_run(...). */
    set sb (cg_append sb "extern DynArray* nl_os_process_run(const char* command);\n\n")

    set sb (cg_append sb "/* CLI and OS functions (defined in runtime/cli.c) */\n")
    set sb (cg_append sb "int g_argc = 0;\n")
    set sb (cg_append sb "char **g_argv = NULL;\n")
    set sb (cg_append sb "extern int64_t get_argc(void);\n")
    set sb (cg_append sb "extern const char* get_argv(int64_t index);\n")
    set sb (cg_append sb "extern const char* nl_os_getenv(const char* name);\n")
    set sb (cg_append sb "static const char* nl_get_argv(int64_t idx) { return get_argv(idx); }\n")
    set sb (cg_append sb "static const char* nl_getenv(const char* name) { return nl_os_getenv(name); }\n")
    set sb (cg_append sb "extern int64_t nl_os_setenv(const char* name, const char* value, int64_t overwrite);\n")
    set sb (cg_append sb "extern int64_t nl_os_system(const char* command);\n")
    set sb (cg_append sb "static int64_t nl_exec_shell(const char* cmd) { return (int64_t)system(cmd); }\n\n")
    set sb (cg_append sb "/* Capture stdout from a shell command (up to 65535 bytes) */\n")
    set sb (cg_append sb "static const char* nl_exec_capture(const char* cmd) {\n")
    set sb (cg_append sb "    FILE* pipe = popen(cmd, \"r\");\n")
    set sb (cg_append sb "    if (!pipe) return \"\";\n")
    set sb (cg_append sb "    char* out = (char*)malloc(65536);\n")
    set sb (cg_append sb "    if (!out) { pclose(pipe); return \"\"; }\n")
    set sb (cg_append sb "    size_t total = 0;\n")
    set sb (cg_append sb "    char buf[1024];\n")
    set sb (cg_append sb "    while (fgets(buf, sizeof(buf), pipe) && total < 65534) {\n")
    set sb (cg_append sb "        size_t n = strlen(buf);\n")
    set sb (cg_append sb "        if (total + n > 65534) n = 65534 - total;\n")
    set sb (cg_append sb "        memcpy(out + total, buf, n);\n")
    set sb (cg_append sb "        total += n;\n")
    set sb (cg_append sb "    }\n")
    set sb (cg_append sb "    out[total] = '\\0';\n")
    set sb (cg_append sb "    pclose(pipe);\n")
    set sb (cg_append sb "    return out;\n")
    set sb (cg_append sb "}\n\n")
    
    set sb (cg_append sb "/* OS functions not in cli.c - static implementations */\n")
    set sb (cg_append sb "#include <unistd.h>\n")
    set sb (cg_append sb "#include <sys/types.h>\n")
    set sb (cg_append sb "#include <sys/stat.h>\n")
    set sb (cg_append sb "static char* nl_os_getcwd(void) {\n")
    set sb (cg_append sb "    char buf[4096];\n")
    set sb (cg_append sb "    if (getcwd(buf, sizeof(buf))) {\n")
    set sb (cg_append sb "        char* out = malloc(strlen(buf) + 1);\n")
    set sb (cg_append sb "        if (out) { strcpy(out, buf); return out; }\n")
    set sb (cg_append sb "    }\n")
    set sb (cg_append sb "    return \"\";\n")
    set sb (cg_append sb "}\n\n")
    
    set sb (cg_append sb "static void nl_os_exit(int64_t code) { exit((int)code); }\n\n")
    
    set sb (cg_append sb "static int64_t nl_os_chdir(const char* path) { return (int64_t)chdir(path); }\n\n")

    set sb (cg_append sb "static bool nl_os_file_exists(const char* path) {\n")
    set sb (cg_append sb "    struct stat st;\n")
    set sb (cg_append sb "    return stat(path, &st) == 0;\n")
    set sb (cg_append sb "}\n\n")

    set sb (cg_append sb "static char* nl_os_tmp_dir(void) {\n")
    set sb (cg_append sb "    const char* tmp = getenv(\"TMPDIR\");\n")
    set sb (cg_append sb "    if (!tmp || tmp[0] == '\\0') tmp = \"/tmp\";\n")
    set sb (cg_append sb "    size_t len = strlen(tmp);\n")
    set sb (cg_append sb "    char* out = gc_alloc_string(len);\n")
    set sb (cg_append sb "    if (!out) return gc_alloc_string(0);\n")
    set sb (cg_append sb "    memcpy(out, tmp, len);\n")
    set sb (cg_append sb "    out[len] = '\\0';\n")
    set sb (cg_append sb "    return out;\n")
    set sb (cg_append sb "}\n\n")

    set sb (cg_append sb "static char* nl_os_mktemp(const char* prefix) {\n")
    set sb (cg_append sb "    const char* tmp = getenv(\"TMPDIR\");\n")
    set sb (cg_append sb "    if (!tmp || tmp[0] == '\\0') tmp = \"/tmp\";\n")
    set sb (cg_append sb "    const char* p = (prefix && prefix[0]) ? prefix : \"nanolang_\";\n")
    set sb (cg_append sb "    char templ[1024];\n")
    set sb (cg_append sb "    snprintf(templ, sizeof(templ), \"%s/%sXXXXXX\", tmp, p);\n")
    set sb (cg_append sb "    int fd = mkstemp(templ);\n")
    set sb (cg_append sb "    if (fd < 0) return gc_alloc_string(0);\n")
    set sb (cg_append sb "    close(fd);\n")
    set sb (cg_append sb "    size_t len = strlen(templ);\n")
    set sb (cg_append sb "    char* out = gc_alloc_string(len);\n")
    set sb (cg_append sb "    if (!out) return gc_alloc_string(0);\n")
    set sb (cg_append sb "    memcpy(out, templ, len);\n")
    set sb (cg_append sb "    out[len] = '\\0';\n")
    set sb (cg_append sb "    return out;\n")
    set sb (cg_append sb "}\n\n")

    set sb (cg_append sb "static char* nl_os_mktemp_dir(const char* prefix) {\n")
    set sb (cg_append sb "    const char* tmp = getenv(\"TMPDIR\");\n")
    set sb (cg_append sb "    if (!tmp || tmp[0] == '\\0') tmp = \"/tmp\";\n")
    set sb (cg_append sb "    const char* p = (prefix && prefix[0]) ? prefix : \"nanolang_dir_\";\n")
    set sb (cg_append sb "    char path[1024];\n")
    set sb (cg_append sb "    for (int i = 0; i < 100; i++) {\n")
    set sb (cg_append sb "        snprintf(path, sizeof(path), \"%s/%s%lld_%d\", tmp, p, (long long)time(NULL), i);\n")
    set sb (cg_append sb "        if (mkdir(path, 0700) == 0) {\n")
    set sb (cg_append sb "            size_t len = strlen(path);\n")
    set sb (cg_append sb "            char* out = gc_alloc_string(len);\n")
    set sb (cg_append sb "            if (!out) return gc_alloc_string(0);\n")
    set sb (cg_append sb "            memcpy(out, path, len);\n")
    set sb (cg_append sb "            out[len] = '\\0';\n")
    set sb (cg_append sb "            return out;\n")
    set sb (cg_append sb "        }\n")
    set sb (cg_append sb "    }\n")
    set sb (cg_append sb "    return gc_alloc_string(0);\n")
    set sb (cg_append sb "}\n\n")
    
    set sb (cg_append sb "static const char* cast_string(int64_t v) { return nl_int_to_string(v); }\n")
    set sb (cg_append sb "static const char* to_string(int64_t v) { return nl_int_to_string(v); }\n\n")

    /* Higher-order array functions (map, reduce, filter) */
    set sb (cg_append sb "/* Higher-order array functions */\n")
    set sb (cg_append sb "static DynArray* nl_map(DynArray* arr, int64_t (*fn)(int64_t)) {\n")
    set sb (cg_append sb "    DynArray* result = dyn_array_new(ELEM_INT);\n")
    set sb (cg_append sb "    int64_t len = dyn_array_length(arr);\n")
    set sb (cg_append sb "    for (int64_t i = 0; i < len; i++) {\n")
    set sb (cg_append sb "        dyn_array_push_int(result, fn(dyn_array_get_int(arr, i)));\n")
    set sb (cg_append sb "    }\n")
    set sb (cg_append sb "    return result;\n")
    set sb (cg_append sb "}\n\n")
    set sb (cg_append sb "static int64_t nl_reduce(DynArray* arr, int64_t initial, int64_t (*fn)(int64_t, int64_t)) {\n")
    set sb (cg_append sb "    int64_t acc = initial;\n")
    set sb (cg_append sb "    int64_t len = dyn_array_length(arr);\n")
    set sb (cg_append sb "    for (int64_t i = 0; i < len; i++) {\n")
    set sb (cg_append sb "        acc = fn(acc, dyn_array_get_int(arr, i));\n")
    set sb (cg_append sb "    }\n")
    set sb (cg_append sb "    return acc;\n")
    set sb (cg_append sb "}\n\n")
    set sb (cg_append sb "static DynArray* nl_filter(DynArray* arr, int (*fn)(int64_t)) {\n")
    set sb (cg_append sb "    DynArray* result = dyn_array_new(ELEM_INT);\n")
    set sb (cg_append sb "    int64_t len = dyn_array_length(arr);\n")
    set sb (cg_append sb "    for (int64_t i = 0; i < len; i++) {\n")
    set sb (cg_append sb "        int64_t val = dyn_array_get_int(arr, i);\n")
    set sb (cg_append sb "        if (fn(val)) dyn_array_push_int(result, val);\n")
    set sb (cg_append sb "    }\n")
    set sb (cg_append sb "    return result;\n")
    set sb (cg_append sb "}\n\n")

    /* HashMap wrappers (generic API over type-specific implementations) */
    set sb (cg_append sb "/* HashMap wrappers */\n")
    set sb (cg_append sb "static inline HashMap_string_int* nl_map_new(void) { return nl_hashmap_string_int_alloc(16); }\n")
    set sb (cg_append sb "static inline void nl_map_put(HashMap_string_int* hm, const char* key, int64_t val) { nl_hashmap_string_int_put(hm, key, val); }\n")
    set sb (cg_append sb "static inline int64_t nl_map_get(HashMap_string_int* hm, const char* key) { return nl_hashmap_string_int_get(hm, key); }\n")
    set sb (cg_append sb "static inline int nl_map_has(HashMap_string_int* hm, const char* key) { return nl_hashmap_string_int_has(hm, key); }\n")
    set sb (cg_append sb "static inline int64_t nl_map_size(HashMap_string_int* hm) { return hm->size; }\n\n")

    /* Timing utilities */
    set sb (cg_append sb "/* Timing utilities */\n")
    set sb (cg_append sb "static int64_t nl_timing_get_microseconds(void) {\n")
    set sb (cg_append sb "#ifdef CLOCK_REALTIME\n")
    set sb (cg_append sb "    struct timespec ts;\n")
    set sb (cg_append sb "    clock_gettime(CLOCK_REALTIME, &ts);\n")
    set sb (cg_append sb "    return ((int64_t)ts.tv_sec * 1000000LL) + (int64_t)(ts.tv_nsec / 1000);\n")
    set sb (cg_append sb "#else\n")
    set sb (cg_append sb "    struct timeval tv;\n")
    set sb (cg_append sb "    gettimeofday(&tv, NULL);\n")
    set sb (cg_append sb "    return ((int64_t)tv.tv_sec * 1000000LL) + (int64_t)tv.tv_usec;\n")
    set sb (cg_append sb "#endif\n")
    set sb (cg_append sb "}\n\n")

    set sb (cg_append sb "static int64_t nl_timing_get_nanoseconds(void) {\n")
    set sb (cg_append sb "#ifdef __MACH__\n")
    set sb (cg_append sb "    static mach_timebase_info_data_t timebase;\n")
    set sb (cg_append sb "    static int initialized = 0;\n")
    set sb (cg_append sb "    if (!initialized) {\n")
    set sb (cg_append sb "        mach_timebase_info(&timebase);\n")
    set sb (cg_append sb "        initialized = 1;\n")
    set sb (cg_append sb "    }\n")
    set sb (cg_append sb "    uint64_t mach_time = mach_absolute_time();\n")
    set sb (cg_append sb "    return (int64_t)((mach_time * timebase.numer) / timebase.denom);\n")
    set sb (cg_append sb "#elif defined(CLOCK_MONOTONIC)\n")
    set sb (cg_append sb "    struct timespec ts;\n")
    set sb (cg_append sb "    clock_gettime(CLOCK_MONOTONIC, &ts);\n")
    set sb (cg_append sb "    return ((int64_t)ts.tv_sec * 1000000000LL) + (int64_t)ts.tv_nsec;\n")
    set sb (cg_append sb "#else\n")
    set sb (cg_append sb "    return nl_timing_get_microseconds() * 1000LL;\n")
    set sb (cg_append sb "#endif\n")
    set sb (cg_append sb "}\n\n")

    set sb (cg_append sb "/* Convenience: current time in milliseconds */\n")
    set sb (cg_append sb "static int64_t nl_get_time_ms(void) { return nl_timing_get_microseconds() / 1000LL; }\n\n")
    set sb (cg_append sb "/* ========== End Math and Utility Built-in Functions ========== */\n\n")

    return (cg_build sb)
}

shadow gen_c_runtime {
    let runtime: string = (gen_c_runtime)
    /* Just verify it generates something */
    assert (== 1 1)
}

/*
    return sorted
}
*/

/* Generate forward declarations for imported module functions
 * 
 * Uses module_generate_forward_declarations() to get forward declarations
 * from the module cache for each imported module.
 * Emits declarations in topologically sorted order (dependencies first).
 * 
 * Args:
 *   parser: The parsed AST containing import statements
 * 
 * Returns: C code string with forward declarations
 */
fn generate_module_forward_declarations(parser: Parser) -> string {
    /* Module forward declarations with dependency ordering
     * 
     * Note: Full module dependency resolution and topological sorting requires
     * the complete module.c infrastructure. For self-hosted compilation, the
     * C reference compiler already handles this in the final linking stage.
     * 
     * This placeholder allows self-hosted components to compile without the
     * full module system while maintaining compatibility with import statements.
     */
    let import_count: int = (parser_get_import_count parser)
    if (> import_count 0) {
        return "/* Module forward declarations: handled by C reference compiler */\n"
    } else {
        return ""
    }
}

shadow generate_module_forward_declarations {
    let source: string = (+ "from \"modules/std/fs.nano\" import walkdir\nf" "n main() -> int { return 0 }")
    let toks: List<LexerToken> = (tokenize_string source)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let code: string = (generate_module_forward_declarations p)
    assert (str_contains code "Module forward declarations")
}

/* Generate complete C program */
fn gen_c_program(functions: string) -> string {
    let mut parts: array<string> = []
    set parts (cg_append parts (gen_c_includes))
    set parts (cg_append parts (gen_c_runtime))
    set parts (cg_append parts "/* User functions */\n")
    set parts (cg_append parts functions)
    
    return (cg_build parts)
}

/* Generate complete C program with module forward declarations */
fn gen_c_program_with_modules(parser: Parser, functions: string) -> string {
    let mut sb: array<string> = []
    
    set sb (cg_append sb (gen_c_includes))
    /* Check if user defines builtin names to avoid redefinition */
    if (has_function_named parser "float_to_string") {
        set sb (cg_append sb "#define NL_HAS_USER_FLOAT_TO_STRING 1\n")
    } else { (print "") }
    set sb (cg_append sb (gen_c_runtime))
    set sb (cg_append sb (generate_module_forward_declarations parser))
    
    /* Generate union definitions */
    set sb (cg_append sb (generate_union_definitions parser))
    
    /* Generate enum definitions */
    set sb (cg_append sb (generate_enum_definitions_from_tokens parser))

    /* Generate user-defined struct definitions by scanning tokens (before List specializations) */
    set sb (cg_append sb (generate_struct_definitions_from_tokens parser))

    /* Generate List<T> specializations (after struct defs so types are available) */
    set sb (cg_append sb (generate_list_specializations parser))
    
    /* Tuple typedefs must come before function prototypes that reference them */
    set sb (cg_append sb (gen_tuple_typedefs parser))

    /* Forward declarations for all functions (avoid implicit declarations in C99) */
    let protos: string = (generate_function_prototypes parser)
    /* Emit function pointer typedefs before prototypes (collected during type_to_c calls) */
    set sb (cg_append sb (generate_fn_type_typedefs))
    set sb (cg_append sb protos)

    /* Emit top-level constant declarations */
    set sb (cg_append sb (generate_global_constants parser))

    set sb (cg_append sb "/* User functions */\n")
    set sb (cg_append sb functions)

    /* If module has no Nano main(), provide a stub so the C wrapper can link. */
    if (not (has_function_named parser "main")) {
        set sb (cg_append sb "\nint64_t nl_main() { return 0; }\n")
    } else { (print "") }
    
    /* Add C main() wrapper that calls nl_main() */
    set sb (cg_append sb "\n/* C main() entry point - calls nanolang main */\n")
    set sb (cg_append sb "int main(int argc, char **argv) {\n")
    set sb (cg_append sb "    g_argc = argc;\n")
    set sb (cg_append sb "    g_argv = argv;\n")
    set sb (cg_append sb "    return (int)nl_main();\n")
    set sb (cg_append sb "}\n")
    
    return (cg_build sb)
}

shadow gen_c_program_with_modules {
    let source: string = (+ "from \"modules/std/fs.nano\" import walkdir\nf" "n helper() -> int { return 0 }")
    let toks: List<LexerToken> = (tokenize_string source)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let code: string = (gen_c_program_with_modules p "int64_t nl_helper() { return 0; }\n")
    assert (str_contains code "Module forward declarations")
    assert (str_contains code "int main(")
    assert (str_contains code "nl_main")
}

shadow gen_c_program {
    let prog: string = (gen_c_program "int64_t nl_main() { return 0; }\n")
    /* Just verify it generates something */
    assert (== 1 1)
}

/* AST and Parser IR types are provided by src_nano/compiler/ir.nano */

/* =============================================================================
 * GENERIC LIST SPECIALIZATION
 * ============================================================================= */

/* Detect List<T> usage in the program by scanning variable declarations
 * Returns: Array of unique element type names (e.g., ["Point", "int", "string"])
 */
fn detect_list_types(parser: Parser) -> array<string> {
    let mut list_types: array<string> = []
    let list_seen: HashMap<string, int> = (hashset_new_string)
    let func_count: int = (parser_get_function_count parser)
    
    let mut i: int = 0
    while (< i func_count) {
        let func: ASTFunction = (parser_get_function parser i)
        
        /* Scan function body for let statements with List<T> types */
        if (>= func.body 0) {
            set list_types (scan_block_for_lists parser func.body list_types list_seen)
        }
        
        set i (+ i 1)
    }
    
    return list_types
}

shadow detect_list_types {
    let source: string = (+ "f" "n main() -> int { let xs: List<Point> = [] return 0 }")
    let toks: List<LexerToken> = (tokenize_string source)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let types: array<string> = (detect_list_types p)
    assert (== (array_length types) 1)
    assert (== (at types 0) "Point")
}

/* Recursively scan a block for List<T> declarations */
fn scan_block_for_lists(parser: Parser, block_id: int, list_types: array<string>, list_seen: HashMap<string, int>) -> array<string> {
    let block: ASTBlock = (parser_get_block parser block_id)
    let mut result: array<string> = list_types
    
    let mut i: int = 0
    let stmt_count: int = (list_ASTStmtRef_length block.statements)
    while (< i stmt_count) {
        let stmt: ASTStmtRef = (list_ASTStmtRef_get block.statements i)
        
        if (== stmt.node_type ParseNodeType.PNODE_LET) {
            let let_node: ASTLet = (parser_get_let parser stmt.node_id)
            
            /* Check if type is List<T> */
            if (str_contains let_node.var_type "List<") {
                let elem_type: string = (transp_extract_list_element_type let_node.var_type)
                
                /* Add to list if not already present */
                if (not (map_has list_seen elem_type)) {
                    (map_put list_seen elem_type 1)
                    set result (array_push result elem_type)
                } else {
                    (print "")
                }
            } else {
                (print "")
            }
        } else {
            /* Recursively scan nested blocks (if, while) */
            if (== stmt.node_type ParseNodeType.PNODE_IF) {
                let if_node: ASTIf = (parser_get_if parser stmt.node_id)
                if (>= if_node.then_body 0) {
                    set result (scan_block_for_lists parser if_node.then_body result list_seen)
                } else { (print "") }
                if (>= if_node.else_body 0) {
                    set result (scan_block_for_lists parser if_node.else_body result list_seen)
                } else { (print "") }
            } else {
                if (== stmt.node_type ParseNodeType.PNODE_WHILE) {
                    let while_node: ASTWhile = (parser_get_while parser stmt.node_id)
                    if (>= while_node.body 0) {
                        set result (scan_block_for_lists parser while_node.body result list_seen)
                    } else { (print "") }
                } else {
                    (print "")
                }
            }
        }
        
        set i (+ i 1)
    }
    
    return result
}

shadow scan_block_for_lists {
    let source: string = (+ "f" "n main() -> int { let xs: List<Point> = [] return 0 }")
    let toks: List<LexerToken> = (tokenize_string source)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let func: ASTFunction = (parser_get_function p 0)
    let seen: HashMap<string, int> = (hashset_new_string)
    let types: array<string> = (scan_block_for_lists p func.body [] seen)
    assert (== (array_length types) 1)
    assert (== (at types 0) "Point")
}

/* Generate List<T> specializations for all detected types */
fn generate_list_specializations(parser: Parser) -> string {
    let list_types: array<string> = (detect_list_types parser)
    let type_count: int = (array_length list_types)
    
    if (<= type_count 0) {
        return ""
    } else {
        let mut parts: array<string> = []
        set parts (cg_append parts "\n/* ========== Generic List Specializations ========== */\n\n")
        
        let mut i: int = 0
        while (< i type_count) {
            let elem_type: string = (at list_types i)
            
            /* Skip types that already have C runtime implementations */
            let skip: bool = (or (== elem_type "int") (or (== elem_type "string") (== elem_type "LexerToken")))
            let skip2: bool = (or skip (or (transp_str_starts_with elem_type "AST") (transp_str_starts_with elem_type "Compiler")))
            if skip2 {
                (print "")
            } else {
                set parts (cg_append parts (generate_list_for_type elem_type))
                set parts (cg_append parts "\n")
            }
            
            set i (+ i 1)
        }
        
        set parts (cg_append parts "/* ========== End Generic List Specializations ========== */\n\n")
        return (cg_build parts)
    }
}

shadow generate_list_specializations {
    let source: string = (+ "f" "n main() -> int { let xs: List<Point> = [] return 0 }")
    let toks: List<LexerToken> = (tokenize_string source)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let code: string = (generate_list_specializations p)
    assert (str_contains code "List_Point")
}

/* Generate List<T> struct and functions for a specific type T */
fn generate_list_for_type(elem_type: string) -> string {
    let c_elem_type: string = (type_to_c elem_type)
    let list_name: string = (+ "List_" elem_type)
    
    let mut sb: array<string> = []
    
    /* Struct definition */
    set sb (cg_append sb "typedef struct ")
    set sb (cg_append sb list_name)
    set sb (cg_append sb " {\n")
    set sb (cg_append sb "    ")
    set sb (cg_append sb c_elem_type)
    set sb (cg_append sb " *data;\n")
    set sb (cg_append sb "    int count;\n")
    set sb (cg_append sb "    int capacity;\n")
    set sb (cg_append sb "} ")
    set sb (cg_append sb list_name)
    set sb (cg_append sb ";\n\n")
    
    /* Constructor: nl_list_T_new() */
    set sb (cg_append sb list_name)
    set sb (cg_append sb "* nl_list_")
    set sb (cg_append sb elem_type)
    set sb (cg_append sb "_new() {\n")
    set sb (cg_append sb "    ")
    set sb (cg_append sb list_name)
    set sb (cg_append sb " *list = malloc(sizeof(")
    set sb (cg_append sb list_name)
    set sb (cg_append sb "));\n")
    set sb (cg_append sb "    if (!list) return NULL;\n")
    set sb (cg_append sb "    list->data = malloc(sizeof(")
    set sb (cg_append sb c_elem_type)
    set sb (cg_append sb ") * 4);\n")
    set sb (cg_append sb "    if (!list->data) { free(list); return NULL; }\n")
    set sb (cg_append sb "    list->count = 0;\n")
    set sb (cg_append sb "    list->capacity = 4;\n")
    set sb (cg_append sb "    return list;\n")
    set sb (cg_append sb "}\n\n")
    
    /* Push: nl_list_T_push(list, value) */
    set sb (cg_append sb "void nl_list_")
    set sb (cg_append sb elem_type)
    set sb (cg_append sb "_push(")
    set sb (cg_append sb list_name)
    set sb (cg_append sb " *list, ")
    set sb (cg_append sb c_elem_type)
    set sb (cg_append sb " value) {\n")
    set sb (cg_append sb "    if (list->count >= list->capacity) {\n")
    set sb (cg_append sb "        list->capacity *= 2;\n")
    set sb (cg_append sb "        ")
    set sb (cg_append sb c_elem_type)
    set sb (cg_append sb " *new_data = realloc(list->data, sizeof(")
    set sb (cg_append sb c_elem_type)
    set sb (cg_append sb ") * list->capacity);\n")
    set sb (cg_append sb "        if (!new_data) return;\n")
    set sb (cg_append sb "        list->data = new_data;\n")
    set sb (cg_append sb "    }\n")
    set sb (cg_append sb "    list->data[list->count++] = value;\n")
    set sb (cg_append sb "}\n\n")
    
    /* Get: nl_list_T_get(list, index) */
    set sb (cg_append sb c_elem_type)
    set sb (cg_append sb " nl_list_")
    set sb (cg_append sb elem_type)
    set sb (cg_append sb "_get(")
    set sb (cg_append sb list_name)
    set sb (cg_append sb " *list, int index) {\n")
    set sb (cg_append sb "    return list->data[index];\n")
    set sb (cg_append sb "}\n\n")
    
    /* Length: nl_list_T_length(list) */
    set sb (cg_append sb "int nl_list_")
    set sb (cg_append sb elem_type)
    set sb (cg_append sb "_length(")
    set sb (cg_append sb list_name)
    set sb (cg_append sb " *list) {\n")
    set sb (cg_append sb "    return list->count;\n")
    set sb (cg_append sb "}\n")
    
    return (cg_build sb)
}

shadow generate_list_for_type {
    let code: string = (generate_list_for_type "Point")
    assert (str_contains code "List_Point")
}

/* =============================================================================
 * UNION TYPE DEFINITIONS
 * ============================================================================= */

/* Substitute a union field type: if the field type matches a generic param,
 * replace with the concrete type's C representation */
fn substitute_union_field_type(field_type: string, generic_params: array<string>, type_args: array<string>) -> string {
    let mut i: int = 0
    let n: int = (array_length generic_params)
    while (< i n) {
        if (== field_type (at generic_params i)) {
            return (type_to_c (at type_args i))
        } else { (print "") }
        set i (+ i 1)
    }
    return (type_to_c field_type)
}

shadow substitute_union_field_type {
    let params: array<string> = (array_push (array_push [] "T") "E")
    let args: array<string> = (array_push (array_push [] "int") "string")
    assert (== (substitute_union_field_type "T" params args) "int64_t")
    assert (== (substitute_union_field_type "E" params args) "const char*")
    assert (== (substitute_union_field_type "bool" params args) "int")
}

/* Find all unique instantiations of a generic union in the codebase */
fn find_union_instantiations(parser: Parser, base_name: string) -> array<string> {
    let mut seen: HashMap<string, int> = (map_new)
    let mut results: array<string> = []
    let search: string = (+ base_name "<")

    /* Scan let statements */
    let let_count: int = (parser_get_let_count parser)
    let mut i: int = 0
    while (< i let_count) {
        let l: ASTLet = (parser_get_let parser i)
        if (str_contains l.var_type search) {
            if (not (map_has seen l.var_type)) {
                (map_put seen l.var_type 1)
                set results (array_push results l.var_type)
            } else { (print "") }
        } else { (print "") }
        set i (+ i 1)
    }

    /* Scan function return types and parameter types */
    let func_count: int = (parser_get_function_count parser)
    set i 0
    while (< i func_count) {
        let f: ASTFunction = (parser_get_function parser i)
        if (str_contains f.return_type search) {
            if (not (map_has seen f.return_type)) {
                (map_put seen f.return_type 1)
                set results (array_push results f.return_type)
            } else { (print "") }
        } else { (print "") }
        /* Scan parameter types */
        let mut j: int = 0
        while (< j f.param_count) {
            let param: ASTLet = (parser_get_let parser (+ f.param_start j))
            if (str_contains param.var_type search) {
                if (not (map_has seen param.var_type)) {
                    (map_put seen param.var_type 1)
                    set results (array_push results param.var_type)
                } else { (print "") }
            } else { (print "") }
            set j (+ j 1)
        }
        set i (+ i 1)
    }

    return results
}

shadow find_union_instantiations {
    let parser: Parser = (parser_init_ast_lists)
    let results: array<string> = (find_union_instantiations parser "Result")
    assert (== (array_length results) 0)
}

/* Emit C typedefs for one union instantiation (or non-generic union) */
fn emit_union_typedefs(u: ASTUnion, mono_name: string, generic_params: array<string>, type_args: array<string>) -> string {
    let mut sb: array<string> = []
    let c_prefix: string = (+ "nl_" mono_name)

    /* Emit variant structs */
    let mut vi: int = 0
    let mut field_offset: int = 0
    while (< vi u.variant_count) {
        let vname: string = (at u.variant_names vi)
        let fcount: int = (at u.variant_field_counts vi)

        set sb (cg_append sb "typedef struct { ")
        if (== fcount 0) {
            set sb (cg_append sb "int _placeholder; ")
        } else {
            let mut fi: int = 0
            while (< fi fcount) {
                let fname: string = (at u.variant_field_names (+ field_offset fi))
                let ftype: string = (at u.variant_field_types (+ field_offset fi))
                let c_ftype: string = (substitute_union_field_type ftype generic_params type_args)
                set sb (cg_append sb c_ftype)
                set sb (cg_append sb " ")
                set sb (cg_append sb (mangle_name fname))
                set sb (cg_append sb "; ")
                set fi (+ fi 1)
            }
        }
        set sb (cg_append sb "} ")
        set sb (cg_append sb c_prefix)
        set sb (cg_append sb "_")
        set sb (cg_append sb vname)
        set sb (cg_append sb ";\n")

        set field_offset (+ field_offset fcount)
        set vi (+ vi 1)
    }

    /* Emit tag enum */
    set sb (cg_append sb "typedef enum { ")
    set vi 0
    while (< vi u.variant_count) {
        if (> vi 0) {
            set sb (cg_append sb ", ")
        } else { (print "") }
        let vname2: string = (at u.variant_names vi)
        set sb (cg_append sb c_prefix)
        set sb (cg_append sb "_TAG_")
        set sb (cg_append sb vname2)
        set sb (cg_append sb " = ")
        set sb (cg_append sb (int_to_string vi))
        set vi (+ vi 1)
    }
    set sb (cg_append sb " } ")
    set sb (cg_append sb c_prefix)
    set sb (cg_append sb "_Tag;\n")

    /* Emit main union struct */
    set sb (cg_append sb "typedef struct ")
    set sb (cg_append sb c_prefix)
    set sb (cg_append sb " { ")
    set sb (cg_append sb c_prefix)
    set sb (cg_append sb "_Tag tag; union { ")
    set vi 0
    while (< vi u.variant_count) {
        let vname3: string = (at u.variant_names vi)
        set sb (cg_append sb c_prefix)
        set sb (cg_append sb "_")
        set sb (cg_append sb vname3)
        set sb (cg_append sb " ")
        set sb (cg_append sb vname3)
        set sb (cg_append sb "; ")
        set vi (+ vi 1)
    }
    set sb (cg_append sb "} data; } ")
    set sb (cg_append sb c_prefix)
    set sb (cg_append sb ";\n")

    return (cg_build sb)
}

shadow emit_union_typedefs {
    assert (== 1 1)
}

/* Generate union definitions from AST */
fn generate_union_definitions(parser: Parser) -> string {
    let union_count: int = (parser_get_union_count parser)
    if (== union_count 0) {
        return ""
    } else { (print "") }

    let mut sb: array<string> = []
    set sb (cg_append sb "/* Union definitions */\n")
    let mut emitted_unions: array<string> = []

    let mut ui: int = 0
    while (< ui union_count) {
        let u: ASTUnion = (parser_get_union parser ui)
        let mut union_dup: bool = false
        let mut udi: int = 0
        while (< udi (array_length emitted_unions)) {
            if (== (at emitted_unions udi) u.name) { set union_dup true } else { (print "") }
            set udi (+ udi 1)
        }
        if (not union_dup) {
        set emitted_unions (array_push emitted_unions u.name)
        if (== u.generic_param_count 0) {
            /* Non-generic union: emit directly */
            let code: string = (emit_union_typedefs u u.name u.generic_params [])
            set sb (cg_append sb code)
        } else {
            /* Generic union: find and emit all instantiations */
            let instantiations: array<string> = (find_union_instantiations parser u.name)
            let mut ii: int = 0
            while (< ii (array_length instantiations)) {
                let inst_type: string = (at instantiations ii)
                let mono_name: string = (monomorphize_type_name inst_type)
                let inst_args: array<string> = (extract_type_args inst_type)
                let code: string = (emit_union_typedefs u mono_name u.generic_params inst_args)
                set sb (cg_append sb code)
                set ii (+ ii 1)
            }
        }
        } else { (print "") }
        set ui (+ ui 1)
    }

    set sb (cg_append sb "\n")
    return (cg_build sb)
}

shadow generate_union_definitions {
    let parser: Parser = (parser_init_ast_lists)
    let code: string = (generate_union_definitions parser)
    assert (== code "")
}

/* Module System Integration
 * 
 * The self-hosted transpiler can process import statements and generate
 * appropriate forward declarations. Full module resolution, dependency
 * ordering, and linking is handled by the C reference compiler's module.c.
 * 
 * This design allows the self-hosted components to remain lightweight while
 * still supporting the complete module system through the compilation pipeline.
 */

/* Parser accessor functions are now available by importing src_nano/parser.nano */

/* =============================================================================
 * EXPRESSION CODE GENERATION
 * ============================================================================= */

/* Map operator token type to C operator string
 * 
 * Args:
 *   op: LexerToken type of operator
 * 
 * Returns: C operator string
 */
fn operator_to_string(op: int) -> string {
    if (== op LexerTokenType.TOKEN_PLUS) { return "+" }
    else { if (== op LexerTokenType.TOKEN_MINUS) { return "-" }
    else { if (== op LexerTokenType.TOKEN_STAR) { return "*" }
    else { if (== op LexerTokenType.TOKEN_SLASH) { return "/" }
    else { if (== op LexerTokenType.TOKEN_PERCENT) { return "%" }
    else { if (== op LexerTokenType.TOKEN_EQ) { return "==" }
    else { if (== op LexerTokenType.TOKEN_NE) { return "!=" }
    else { if (== op LexerTokenType.TOKEN_LT) { return "<" }
    else { if (== op LexerTokenType.TOKEN_LE) { return "<=" }
    else { if (== op LexerTokenType.TOKEN_GT) { return ">" }
    else { if (== op LexerTokenType.TOKEN_GE) { return ">=" }
    else { if (== op LexerTokenType.TOKEN_AND) { return "&&" }
    else { if (== op LexerTokenType.TOKEN_OR) { return "||" }
    else { return "+" }
    }}}}}}}}}}}}
}

shadow operator_to_string {
    assert (== (operator_to_string LexerTokenType.TOKEN_PLUS) "+")
    assert (== (operator_to_string LexerTokenType.TOKEN_MINUS) "-")
    assert (== (operator_to_string LexerTokenType.TOKEN_EQ) "==")
    assert (== (operator_to_string LexerTokenType.TOKEN_AND) "&&")
}

/* Helper to build array binary operation expressions using StringBuilder */
fn build_array_binop_expr(left_code: string, right_code: string, elem_enum: string, get_fn: string, push_fn: string, c_elem: string, op_str2: string, left_is_arr: bool, right_is_arr: bool, is_plus: bool, is_string: bool) -> string {
    let mut sb: array<string> = []
    
    if (and left_is_arr right_is_arr) {
        set sb (cg_append sb "({ DynArray* _a = ")
        set sb (cg_append sb left_code)
        set sb (cg_append sb "; DynArray* _b = ")
        set sb (cg_append sb right_code)
        set sb (cg_append sb "; assert(dyn_array_length(_a) == dyn_array_length(_b)); DynArray* _out = dyn_array_new(")
        set sb (cg_append sb elem_enum)
        set sb (cg_append sb "); int64_t _len = dyn_array_length(_a); for (int64_t _i = 0; _i < _len; _i++) { ")
        set sb (cg_append sb c_elem)
        set sb (cg_append sb " _x = ")
        set sb (cg_append sb get_fn)
        set sb (cg_append sb "(_a, _i); ")
        set sb (cg_append sb c_elem)
        set sb (cg_append sb " _y = ")
        set sb (cg_append sb get_fn)
        set sb (cg_append sb "(_b, _i); ")
        set sb (cg_append sb push_fn)
        set sb (cg_append sb "(_out, ")
        
        if is_string {
            if is_plus {
                set sb (cg_append sb "nl_str_concat(_x, _y)")
            } else {
                set sb (cg_append sb "0")
            }
        } else {
            set sb (cg_append sb "(_x ")
            set sb (cg_append sb op_str2)
            set sb (cg_append sb " _y)")
        }
        
        set sb (cg_append sb "); } _out; })")
        return (cg_build sb)
    } else {
        if (and left_is_arr (not right_is_arr)) {
            set sb (cg_append sb "({ DynArray* _a = ")
            set sb (cg_append sb left_code)
            set sb (cg_append sb "; ")
            set sb (cg_append sb c_elem)
            set sb (cg_append sb " _s = ")
            set sb (cg_append sb right_code)
            set sb (cg_append sb "; DynArray* _out = dyn_array_new(")
            set sb (cg_append sb elem_enum)
            set sb (cg_append sb "); int64_t _len = dyn_array_length(_a); for (int64_t _i = 0; _i < _len; _i++) { ")
            set sb (cg_append sb c_elem)
            set sb (cg_append sb " _x = ")
            set sb (cg_append sb get_fn)
            set sb (cg_append sb "(_a, _i); ")
            set sb (cg_append sb push_fn)
            set sb (cg_append sb "(_out, ")
            if is_string {
                if is_plus {
                    set sb (cg_append sb "nl_str_concat(_x, _s)")
                } else {
                    set sb (cg_append sb "0")
                }
            } else {
                set sb (cg_append sb "(_x ")
                set sb (cg_append sb op_str2)
                set sb (cg_append sb " _s)")
            }
            set sb (cg_append sb "); } _out; })")
            return (cg_build sb)
        } else {
            if (and (not left_is_arr) right_is_arr) {
                set sb (cg_append sb "({ DynArray* _a = ")
                set sb (cg_append sb right_code)
                set sb (cg_append sb "; ")
                set sb (cg_append sb c_elem)
                set sb (cg_append sb " _s = ")
                set sb (cg_append sb left_code)
                set sb (cg_append sb "; DynArray* _out = dyn_array_new(")
                set sb (cg_append sb elem_enum)
                set sb (cg_append sb "); int64_t _len = dyn_array_length(_a); for (int64_t _i = 0; _i < _len; _i++) { ")
                set sb (cg_append sb c_elem)
                set sb (cg_append sb " _x = ")
                set sb (cg_append sb get_fn)
                set sb (cg_append sb "(_a, _i); ")
                set sb (cg_append sb push_fn)
                set sb (cg_append sb "(_out, ")
                if is_string {
                    if is_plus {
                        set sb (cg_append sb "nl_str_concat(_s, _x)")
                    } else {
                        set sb (cg_append sb "0")
                    }
                } else {
                    set sb (cg_append sb "(_s ")
                    set sb (cg_append sb op_str2)
                    set sb (cg_append sb " _x)")
                }
                set sb (cg_append sb "); } _out; })")
                return (cg_build sb)
            } else {
                return ""
            }
        }
    }
}

shadow build_array_binop_expr {
    let result: string = (build_array_binop_expr "a" "b" "ELEM_INT" "get" "push" "int64_t" "+" true true false false)
    assert (> (str_length result) 0)
}

/* Generate C code for an expression node (RECURSIVE)
 * 
 * Args:
 *   parser: Parser containing AST nodes
 *   node_id: Index of node in appropriate list
 *   node_type: 0=number, 1=identifier, 2=binary_op, 3=call
 * 
 * Returns: C code string for the expression
 */
fn generate_expression(parser: Parser, node_id: int, node_type: int, env: GenEnv, expected_type: string) -> string {
    if (== node_type ParseNodeType.PNODE_NUMBER) {
        /* Number literal */
        let num: ASTNumber = (parser_get_number parser node_id)
        /* INT64_MIN (-9223372036854775808) cannot be expressed as a C literal directly;
           the constant 9223372036854775808 overflows int64_t before negation is applied.
           Emit INT64_MIN (from <stdint.h>) instead. */
        if (== num.value "-9223372036854775808") {
            return "INT64_MIN"
        } else {
            return num.value
        }
    } else {
        if (== node_type ParseNodeType.PNODE_FLOAT) {
            let f: ASTFloat = (parser_get_float parser node_id)
            return f.value
        } else {
        if (== node_type ParseNodeType.PNODE_STRING) {
            let s: ASTString = (parser_get_string parser node_id)
            let mut parts: array<string> = []
            set parts (cg_append parts "\"")
            set parts (cg_append parts s.value)
            set parts (cg_append parts "\"")
            return (cg_build parts)
        } else {
        if (== node_type ParseNodeType.PNODE_BOOL) {
            let b: ASTBool = (parser_get_bool parser node_id)
            if b.value {
                return "1"
            } else {
                return "0"
            }
        } else {
        if (== node_type ParseNodeType.PNODE_IDENTIFIER) {
            /* Identifier */
            let id: ASTIdentifier = (parser_get_identifier parser node_id)
            /* Prefix with nl_ for nanolang identifiers */
            return (+ "nl_" (mangle_name id.name))
        } else {
            if (== node_type ParseNodeType.PNODE_BINARY_OP) {
                /* Binary operation - RECURSIVE! */
                let binop: ASTBinaryOp = (parser_get_binary_op parser node_id)
                
                /* For comparison operators, don't propagate expected_type to operands.
                   The return type (bool) differs from operand types. */
                let is_comparison: bool = (or (or (== binop.op LexerTokenType.TOKEN_EQ) (== binop.op LexerTokenType.TOKEN_NE))
                                          (or (or (== binop.op LexerTokenType.TOKEN_LT) (== binop.op LexerTokenType.TOKEN_GT))
                                              (or (== binop.op LexerTokenType.TOKEN_LE) (== binop.op LexerTokenType.TOKEN_GE))))
                let mut operand_expected: string = expected_type
                if is_comparison { set operand_expected "" } else { (print "") }
                let left_code: string = (generate_expression parser binop.left binop.left_type env operand_expected)
                let right_code: string = (generate_expression parser binop.right binop.right_type env operand_expected)

                /* Array arithmetic lowering for identifier operands */
                let mut left_arr_t: string = ""
                let mut right_arr_t: string = ""
                if (== binop.left_type 1) {
                    let lid: ASTIdentifier = (parser_get_identifier parser binop.left)
                    set left_arr_t (genenv_get env lid.name)
                } else { (print "") }
                if (== binop.right_type 1) {
                    let rid: ASTIdentifier = (parser_get_identifier parser binop.right)
                    set right_arr_t (genenv_get env rid.name)
                } else { (print "") }

                let left_is_arr: bool = (is_array_type left_arr_t)
                let right_is_arr: bool = (is_array_type right_arr_t)
                let is_arith: bool = (or (or (== binop.op LexerTokenType.TOKEN_PLUS) (== binop.op LexerTokenType.TOKEN_MINUS))
                                      (or (or (== binop.op LexerTokenType.TOKEN_STAR) (== binop.op LexerTokenType.TOKEN_SLASH))
                                          (== binop.op LexerTokenType.TOKEN_PERCENT)))

                if (and is_arith (or left_is_arr right_is_arr)) {
                    let mut elem_t: string = "int"
                    if left_is_arr {
                        let inferred: string = (array_elem_type_from_array_type left_arr_t)
                        if (!= inferred "") { set elem_t inferred } else { (print "") }
                    } else {
                        if right_is_arr {
                            let inferred: string = (array_elem_type_from_array_type right_arr_t)
                            if (!= inferred "") { set elem_t inferred } else { (print "") }
                        } else { (print "") }
                    }

                    let elem_enum: string = (elem_enum_from_elem_type elem_t)
                    let get_fn: string = (get_fn_from_elem_type elem_t)
                    let push_fn: string = (push_fn_from_elem_type elem_t)
                    let c_elem: string = (c_type_from_elem_type elem_t)
                    let op_str2: string = (operator_to_string binop.op)

                    let is_plus: bool = (== binop.op LexerTokenType.TOKEN_PLUS)
                    let is_string: bool = (== elem_t "string")
                    return (build_array_binop_expr left_code right_code elem_enum get_fn push_fn c_elem op_str2 left_is_arr right_is_arr is_plus is_string)
                } else {
                    (print "")
                }
                
                /* Special case: + for string concatenation */
                if (== binop.op LexerTokenType.TOKEN_PLUS) {
                    /* Check if either operand looks like a string */
                    let left_is_str: bool = (and (> (str_length left_code) 0) (== (char_at left_code 0) 34))
                    let right_is_str: bool = (and (> (str_length right_code) 0) (== (char_at right_code 0) 34))
                    /* Also check if either operand is a string-returning function call */
                    let left_is_str_fn: bool = (or (str_contains left_code "nl_str_concat") (or (str_contains left_code "nl_int_to_string") (or (str_contains left_code "nl_float_to_string") (str_contains left_code "nl_bool_to_string"))))
                    let right_is_str_fn: bool = (or (str_contains right_code "nl_str_concat") (or (str_contains right_code "nl_int_to_string") (or (str_contains right_code "nl_float_to_string") (str_contains right_code "nl_bool_to_string"))))
                    /* Also check if either identifier operand has string type in GenEnv */
                    let mut left_is_str_var: bool = false
                    let mut right_is_str_var: bool = false
                    if (== binop.left_type ParseNodeType.PNODE_IDENTIFIER) {
                        let lid: ASTIdentifier = (parser_get_identifier parser binop.left)
                        let lt: string = (genenv_get env lid.name)
                        if (== lt "string") { set left_is_str_var true } else { (print "") }
                    } else { (print "") }
                    if (== binop.right_type ParseNodeType.PNODE_IDENTIFIER) {
                        let rid: ASTIdentifier = (parser_get_identifier parser binop.right)
                        let rt: string = (genenv_get env rid.name)
                        if (== rt "string") { set right_is_str_var true } else { (print "") }
                    } else { (print "") }

                    let either_is_str: bool = (or (or left_is_str right_is_str) (or (or left_is_str_fn right_is_str_fn) (or left_is_str_var right_is_str_var)))
                    if either_is_str {
                        let mut parts: array<string> = []
                        set parts (cg_append parts "nl_str_concat(")
                        set parts (cg_append parts left_code)
                        set parts (cg_append parts ", ")
                        set parts (cg_append parts right_code)
                        set parts (cg_append parts ")")
                        return (cg_build parts)
                    } else {
                        (print "")
                    }
                } else {
                    (print "")
                }

                /* String equality/inequality: use strcmp instead of pointer comparison */
                if (or (== binop.op LexerTokenType.TOKEN_EQ) (== binop.op LexerTokenType.TOKEN_NE)) {
                    let left_is_lit: bool = (and (> (str_length left_code) 0) (== (char_at left_code 0) 34))
                    let right_is_lit: bool = (and (> (str_length right_code) 0) (== (char_at right_code 0) 34))
                    let mut left_is_str_var2: bool = false
                    let mut right_is_str_var2: bool = false
                    if (== binop.left_type ParseNodeType.PNODE_IDENTIFIER) {
                        let lid2: ASTIdentifier = (parser_get_identifier parser binop.left)
                        let lt2: string = (genenv_get env lid2.name)
                        if (== lt2 "string") { set left_is_str_var2 true } else { (print "") }
                    } else { (print "") }
                    if (== binop.right_type ParseNodeType.PNODE_IDENTIFIER) {
                        let rid2: ASTIdentifier = (parser_get_identifier parser binop.right)
                        let rt2: string = (genenv_get env rid2.name)
                        if (== rt2 "string") { set right_is_str_var2 true } else { (print "") }
                    } else { (print "") }
                    let mut left_is_str_field: bool = false
                    let mut right_is_str_field: bool = false
                    if (== binop.left_type ParseNodeType.PNODE_FIELD_ACCESS) {
                        let lfa: ASTFieldAccess = (parser_get_field_access parser binop.left)
                        let mut lowner_type: string = ""
                        if (== lfa.object_type ParseNodeType.PNODE_IDENTIFIER) {
                            let lowner_id: ASTIdentifier = (parser_get_identifier parser lfa.object)
                            set lowner_type (genenv_get env lowner_id.name)
                        } else { (print "") }
                        if (!= lowner_type "") {
                            let lft: string = (lookup_struct_field_type parser lowner_type lfa.field_name)
                            if (== lft "string") { set left_is_str_field true } else { (print "") }
                        } else { (print "") }
                    } else { (print "") }
                    if (== binop.right_type ParseNodeType.PNODE_FIELD_ACCESS) {
                        let rfa: ASTFieldAccess = (parser_get_field_access parser binop.right)
                        let mut rowner_type: string = ""
                        if (== rfa.object_type ParseNodeType.PNODE_IDENTIFIER) {
                            let rowner_id: ASTIdentifier = (parser_get_identifier parser rfa.object)
                            set rowner_type (genenv_get env rowner_id.name)
                        } else { (print "") }
                        if (!= rowner_type "") {
                            let rft: string = (lookup_struct_field_type parser rowner_type rfa.field_name)
                            if (== rft "string") { set right_is_str_field true } else { (print "") }
                        } else { (print "") }
                    } else { (print "") }
                    let has_literal: bool = (or left_is_lit right_is_lit)
                    let any_str_var: bool = (or left_is_str_var2 right_is_str_var2)
                    let any_str_field: bool = (or left_is_str_field right_is_str_field)
                    let use_strcmp: bool = (or has_literal (or any_str_var any_str_field))
                    if use_strcmp {
                        let mut parts: array<string> = []
                        set parts (cg_append parts "(strcmp(")
                        set parts (cg_append parts left_code)
                        set parts (cg_append parts ", ")
                        set parts (cg_append parts right_code)
                        if (== binop.op LexerTokenType.TOKEN_EQ) {
                            set parts (cg_append parts ") == 0)")
                        } else {
                            set parts (cg_append parts ") != 0)")
                        }
                        return (cg_build parts)
                    } else {
                        (print "")
                    }
                } else {
                    (print "")
                }
                
                /* Get operator string */
                let op_str: string = (operator_to_string binop.op)
                
                /* Build expression: (left op right) */
                let mut parts: array<string> = []
                set parts (cg_append parts "(")
                set parts (cg_append parts left_code)
                set parts (cg_append parts " ")
                set parts (cg_append parts op_str)
                set parts (cg_append parts " ")
                set parts (cg_append parts right_code)
                set parts (cg_append parts ")")
                
                return (cg_build parts)
            } else {
                if (== node_type ParseNodeType.PNODE_CALL) {
                    /* Function call */
                    let call: ASTCall = (parser_get_call parser node_id)
                    
                    /* Get function name from identifier */
                    let func_id: ASTIdentifier = (parser_get_identifier parser call.function)
                    let func_name: string = func_id.name

                    /* Special-case: unary not is represented as a call */
                    if (== func_name "not") {
                        if (== call.arg_count 1) {
                            let a0: ASTStmtRef = (parser_get_call_arg parser call.arg_start)
                            let a0_code: string = (generate_expression parser a0.node_id a0.node_type env "")
                            let mut parts: array<string> = []
                            set parts (cg_append parts "(!")
                            set parts (cg_append parts a0_code)
                            set parts (cg_append parts ")")
                            return (cg_build parts)
                        } else {
                            return "(!0)"
                        }
                    } else {
                        (print "")
                    }

                    /* Array builtins map directly to DynArray runtime */
                    if (== func_name "array_length") {
                        if (== call.arg_count 1) {
                            let a0: ASTStmtRef = (parser_get_call_arg parser call.arg_start)
                            let a0_code: string = (generate_expression parser a0.node_id a0.node_type env "")
                            let mut parts: array<string> = []
                            set parts (cg_append parts "dyn_array_length(")
                            set parts (cg_append parts a0_code)
                            set parts (cg_append parts ")")
                            return (cg_build parts)
                        } else {
                            return "0"
                        }
                    } else {
                        (print "")
                    }

                    if (== func_name "array_remove_at") {
                        if (== call.arg_count 2) {
                            let a0: ASTStmtRef = (parser_get_call_arg parser call.arg_start)
                            let a1: ASTStmtRef = (parser_get_call_arg parser (+ call.arg_start 1))
                            let a0_code: string = (generate_expression parser a0.node_id a0.node_type env "")
                            let a1_code: string = (generate_expression parser a1.node_id a1.node_type env "")
                            let mut parts: array<string> = []
                            set parts (cg_append parts "dyn_array_remove_at(")
                            set parts (cg_append parts a0_code)
                            set parts (cg_append parts ", ")
                            set parts (cg_append parts a1_code)
                            set parts (cg_append parts ")")
                            return (cg_build parts)
                        } else {
                            return "0"
                        }
                    } else {
                        (print "")
                    }

                    if (== func_name "array_new") {
                        if (== call.arg_count 2) {
                            let a0: ASTStmtRef = (parser_get_call_arg parser call.arg_start)
                            let a1: ASTStmtRef = (parser_get_call_arg parser (+ call.arg_start 1))
                            let size_code: string = (generate_expression parser a0.node_id a0.node_type env "")
                            let def_code: string = (generate_expression parser a1.node_id a1.node_type env "")

                            let mut elem_t: string = "int"
                            if (is_array_type expected_type) {
                                let inferred: string = (array_elem_type_from_array_type expected_type)
                                if (!= inferred "") { set elem_t inferred } else { (print "") }
                                if (and (== elem_t "array") (str_contains expected_type "array<")) {
                                    let inner_t: string = (array_elem_type_from_array_type expected_type)
                                    if (type_is_struct inner_t) {
                                        set elem_t ""
                                    } else { (print "") }
                                } else { (print "") }
                            } else {
                                (print "")
                            }

                            let elem_enum: string = (elem_enum_from_elem_type elem_t)
                            let push_fn: string = (push_fn_from_elem_type elem_t)

                            let mut parts: array<string> = []
                            set parts (cg_append parts "({ DynArray* _arr = dyn_array_new(")
                            set parts (cg_append parts elem_enum)
                            set parts (cg_append parts "); int64_t _n = ")
                            set parts (cg_append parts size_code)
                            set parts (cg_append parts "; for (int64_t _i = 0; _i < _n; _i++) { ")
                            if (type_is_struct elem_t) {
                                set parts (cg_append parts "dyn_array_push_int(_arr, ")
                                set parts (cg_append parts (box_struct_expr elem_t def_code))
                                set parts (cg_append parts "); ")
                            } else {
                                set parts (cg_append parts push_fn)
                                set parts (cg_append parts "(_arr, ")
                                set parts (cg_append parts def_code)
                                set parts (cg_append parts "); ")
                            }
                            set parts (cg_append parts "} _arr; })")
                            return (cg_build parts)
                        } else {
                            return "0"
                        }
                    } else {
                        (print "")
                    }

                    if (== func_name "array_push") {
                        if (== call.arg_count 2) {
                            let a0: ASTStmtRef = (parser_get_call_arg parser call.arg_start)
                            let a1: ASTStmtRef = (parser_get_call_arg parser (+ call.arg_start 1))
                            let arr_code: string = (generate_expression parser a0.node_id a0.node_type env "")
                            let val_code: string = (generate_expression parser a1.node_id a1.node_type env "")

                            let mut arr_t: string = ""
                            if (is_array_type expected_type) {
                                set arr_t expected_type
                            } else {
                                if (== a0.node_type ParseNodeType.PNODE_IDENTIFIER) {
                                    let id0: ASTIdentifier = (parser_get_identifier parser a0.node_id)
                                    set arr_t (genenv_get env id0.name)
                                } else { (print "") }
                            }

                            let mut elem_t: string = (array_elem_type_from_array_type arr_t)
                            if (== elem_t "") { set elem_t "int" } else { (print "") }
                            if (== elem_t "int") {
                                if (== a1.node_type ParseNodeType.PNODE_STRUCT_LITERAL) {
                                    let sl: ASTStructLiteral = (parser_get_struct_literal parser a1.node_id)
                                    set elem_t sl.struct_name
                                } else {
                                    if (== a1.node_type ParseNodeType.PNODE_IDENTIFIER) {
                                        let id1: ASTIdentifier = (parser_get_identifier parser a1.node_id)
                                        let inferred_t: string = (genenv_get env id1.name)
                                        if (type_is_struct inferred_t) {
                                            set elem_t inferred_t
                                        } else { (print "") }
                                    } else { (print "") }
                                }
                            } else { (print "") }
                            let push_fn: string = (push_fn_from_elem_type elem_t)

                            let mut parts: array<string> = []
                            set parts (cg_append parts push_fn)
                            set parts (cg_append parts "(")
                            set parts (cg_append parts arr_code)
                            if (type_is_struct elem_t) {
                                set parts (cg_append parts ", ")
                                set parts (cg_append parts (box_struct_expr elem_t val_code))
                            } else {
                                set parts (cg_append parts ", ")
                                set parts (cg_append parts val_code)
                            }
                            set parts (cg_append parts ")")
                            return (cg_build parts)
                        } else {
                            return "0"
                        }
                    } else {
                        (print "")
                    }

                    if (== func_name "array_set") {
                        if (== call.arg_count 3) {
                            let a0: ASTStmtRef = (parser_get_call_arg parser call.arg_start)
                            let a1: ASTStmtRef = (parser_get_call_arg parser (+ call.arg_start 1))
                            let a2: ASTStmtRef = (parser_get_call_arg parser (+ call.arg_start 2))
                            let arr_code: string = (generate_expression parser a0.node_id a0.node_type env "")
                            let idx_code: string = (generate_expression parser a1.node_id a1.node_type env "")
                            let val_code: string = (generate_expression parser a2.node_id a2.node_type env "")

                            let mut elem_t: string = "int"
                            if (== a0.node_type ParseNodeType.PNODE_IDENTIFIER) {
                                let id0: ASTIdentifier = (parser_get_identifier parser a0.node_id)
                                let arr_t: string = (genenv_get env id0.name)
                                let inferred: string = (array_elem_type_from_array_type arr_t)
                                if (!= inferred "") { set elem_t inferred } else { (print "") }
                            } else {
                                (print "")
                            }

                            if (== elem_t "int") {
                                if (== a2.node_type ParseNodeType.PNODE_STRUCT_LITERAL) {
                                    let sl2: ASTStructLiteral = (parser_get_struct_literal parser a2.node_id)
                                    set elem_t sl2.struct_name
                                } else {
                                    if (== a2.node_type ParseNodeType.PNODE_IDENTIFIER) {
                                        let id2: ASTIdentifier = (parser_get_identifier parser a2.node_id)
                                        let inferred_t2: string = (genenv_get env id2.name)
                                        if (type_is_struct inferred_t2) {
                                            set elem_t inferred_t2
                                        } else { (print "") }
                                    } else { (print "") }
                                }
                            } else { (print "") }

                            let set_fn: string = (set_fn_from_elem_type elem_t)
                            let mut parts: array<string> = []

                            set parts (cg_append parts set_fn)
                            set parts (cg_append parts "(")
                            set parts (cg_append parts arr_code)
                            set parts (cg_append parts ", ")
                            set parts (cg_append parts idx_code)
                            if (type_is_struct elem_t) {
                                set parts (cg_append parts ", ")
                                set parts (cg_append parts (box_struct_expr elem_t val_code))
                            } else {
                                set parts (cg_append parts ", ")
                                set parts (cg_append parts val_code)
                            }
                            set parts (cg_append parts ")")
                            return (cg_build parts)
                        } else {
                            return "0"
                        }
                    } else {
                        (print "")
                    }

                    if (or (== func_name "at") (== func_name "array_get")) {
                        if (== call.arg_count 2) {
                            let a0: ASTStmtRef = (parser_get_call_arg parser call.arg_start)
                            let a1: ASTStmtRef = (parser_get_call_arg parser (+ call.arg_start 1))
                            let a0_code: string = (generate_expression parser a0.node_id a0.node_type env "")
                            let a1_code: string = (generate_expression parser a1.node_id a1.node_type env "")

                            let mut elem_t: string = ""
                            if (is_array_type expected_type) {
                                set elem_t "array"
                            } else {
                                set elem_t expected_type
                            }

                            if (== elem_t "") {
                                if (== a0.node_type ParseNodeType.PNODE_IDENTIFIER) {
                                    let id0: ASTIdentifier = (parser_get_identifier parser a0.node_id)
                                    let arr_t: string = (genenv_get env id0.name)
                                    let inferred: string = (array_elem_type_from_array_type arr_t)
                                    if (!= inferred "") { set elem_t inferred } else { set elem_t "int" }
                                } else {
                                    if (== a0.node_type ParseNodeType.PNODE_FIELD_ACCESS) {
                                        let fa0: ASTFieldAccess = (parser_get_field_access parser a0.node_id)
                                        let mut owner_type: string = ""
                                        if (== fa0.object_type ParseNodeType.PNODE_IDENTIFIER) {
                                            let owner_id: ASTIdentifier = (parser_get_identifier parser fa0.object)
                                            set owner_type (genenv_get env owner_id.name)
                                        } else { (print "") }
                                        if (!= owner_type "") {
                                            let field_t: string = (lookup_struct_field_type parser owner_type fa0.field_name)
                                            let fa_inferred: string = (array_elem_type_from_array_type field_t)
                                            if (!= fa_inferred "") { set elem_t fa_inferred } else { set elem_t "int" }
                                        } else {
                                            set elem_t "int"
                                        }
                                    } else {
                                        set elem_t "int"
                                    }
                                }
                            } else {
                                (print "")
                            }

                            let get_fn: string = (get_fn_from_elem_type elem_t)
                            let mut parts: array<string> = []
                            if (type_is_struct elem_t) {
                                let elem_struct: string = (+ "nl_" (mangle_type_name elem_t))
                                set parts (cg_append parts "*(")
                                set parts (cg_append parts elem_struct)
                                set parts (cg_append parts "*)((void*)")
                                set parts (cg_append parts get_fn)
                                set parts (cg_append parts "(")
                                set parts (cg_append parts a0_code)
                                set parts (cg_append parts ", ")
                                set parts (cg_append parts a1_code)
                                set parts (cg_append parts "))")
                            } else {
                                set parts (cg_append parts get_fn)
                                set parts (cg_append parts "(")
                                set parts (cg_append parts a0_code)
                                set parts (cg_append parts ", ")
                                set parts (cg_append parts a1_code)
                                set parts (cg_append parts ")")
                            }
                            return (cg_build parts)
                        } else {
                            return "0"
                        }
                    } else {
                        (print "")
                    }
                    
                    /* HashMap<string,string> type-aware dispatch */
                    /* map_new: use expected_type to pick constructor */
                    if (== func_name "map_new") {
                        if (or (== expected_type "HashMap<string,string>") (== expected_type "HashMap<string, string>")) {
                            return "nl_hm_new()"
                        } else {
                            return "nl_map_new()"
                        }
                    } else { (print "") }

                    /* map_put/map_set: 3 args (map, key, val) */
                    if (or (== func_name "map_put") (== func_name "map_set")) {
                        if (== call.arg_count 3) {
                            let mp_a0: ASTStmtRef = (parser_get_call_arg parser call.arg_start)
                            let mp_a1: ASTStmtRef = (parser_get_call_arg parser (+ call.arg_start 1))
                            let mp_a2: ASTStmtRef = (parser_get_call_arg parser (+ call.arg_start 2))
                            let mp_a0_code: string = (generate_expression parser mp_a0.node_id mp_a0.node_type env "")
                            let mp_a1_code: string = (generate_expression parser mp_a1.node_id mp_a1.node_type env "")
                            let mp_a2_code: string = (generate_expression parser mp_a2.node_id mp_a2.node_type env "")
                            let mut mp_map_type: string = ""
                            if (== mp_a0.node_type ParseNodeType.PNODE_IDENTIFIER) {
                                let mp_id0: ASTIdentifier = (parser_get_identifier parser mp_a0.node_id)
                                set mp_map_type (genenv_get env mp_id0.name)
                            } else { (print "") }
                            let mut mp_parts: array<string> = []
                            if (or (== mp_map_type "HashMap<string,string>") (== mp_map_type "HashMap<string, string>")) {
                                set mp_parts (cg_append mp_parts "nl_hm_put(")
                            } else {
                                set mp_parts (cg_append mp_parts "nl_map_put(")
                            }
                            set mp_parts (cg_append mp_parts mp_a0_code)
                            set mp_parts (cg_append mp_parts ", ")
                            set mp_parts (cg_append mp_parts mp_a1_code)
                            set mp_parts (cg_append mp_parts ", ")
                            set mp_parts (cg_append mp_parts mp_a2_code)
                            set mp_parts (cg_append mp_parts ")")
                            return (cg_build mp_parts)
                        } else { (print "") }
                    } else { (print "") }

                    /* map_has: 2 args (map, key) -> bool */
                    if (== func_name "map_has") {
                        if (== call.arg_count 2) {
                            let mh_a0: ASTStmtRef = (parser_get_call_arg parser call.arg_start)
                            let mh_a1: ASTStmtRef = (parser_get_call_arg parser (+ call.arg_start 1))
                            let mh_a0_code: string = (generate_expression parser mh_a0.node_id mh_a0.node_type env "")
                            let mh_a1_code: string = (generate_expression parser mh_a1.node_id mh_a1.node_type env "")
                            let mut mh_map_type: string = ""
                            if (== mh_a0.node_type ParseNodeType.PNODE_IDENTIFIER) {
                                let mh_id0: ASTIdentifier = (parser_get_identifier parser mh_a0.node_id)
                                set mh_map_type (genenv_get env mh_id0.name)
                            } else { (print "") }
                            let mut mh_parts: array<string> = []
                            if (or (== mh_map_type "HashMap<string,string>") (== mh_map_type "HashMap<string, string>")) {
                                set mh_parts (cg_append mh_parts "nl_hm_has(")
                            } else {
                                set mh_parts (cg_append mh_parts "nl_map_has(")
                            }
                            set mh_parts (cg_append mh_parts mh_a0_code)
                            set mh_parts (cg_append mh_parts ", ")
                            set mh_parts (cg_append mh_parts mh_a1_code)
                            set mh_parts (cg_append mh_parts ")")
                            return (cg_build mh_parts)
                        } else { (print "") }
                    } else { (print "") }

                    /* map_get: 2 args (map, key) -> value */
                    if (== func_name "map_get") {
                        if (== call.arg_count 2) {
                            let mg_a0: ASTStmtRef = (parser_get_call_arg parser call.arg_start)
                            let mg_a1: ASTStmtRef = (parser_get_call_arg parser (+ call.arg_start 1))
                            let mg_a0_code: string = (generate_expression parser mg_a0.node_id mg_a0.node_type env "")
                            let mg_a1_code: string = (generate_expression parser mg_a1.node_id mg_a1.node_type env "")
                            let mut mg_map_type: string = ""
                            if (== mg_a0.node_type ParseNodeType.PNODE_IDENTIFIER) {
                                let mg_id0: ASTIdentifier = (parser_get_identifier parser mg_a0.node_id)
                                set mg_map_type (genenv_get env mg_id0.name)
                            } else { (print "") }
                            let mut mg_parts: array<string> = []
                            if (or (== mg_map_type "HashMap<string,string>") (== mg_map_type "HashMap<string, string>")) {
                                set mg_parts (cg_append mg_parts "nl_hm_get(")
                            } else {
                                set mg_parts (cg_append mg_parts "nl_map_get(")
                            }
                            set mg_parts (cg_append mg_parts mg_a0_code)
                            set mg_parts (cg_append mg_parts ", ")
                            set mg_parts (cg_append mg_parts mg_a1_code)
                            set mg_parts (cg_append mg_parts ")")
                            return (cg_build mg_parts)
                        } else { (print "") }
                    } else { (print "") }

                    /* map_length/map_size: 1 arg (map) -> int */
                    if (or (== func_name "map_length") (== func_name "map_size")) {
                        if (== call.arg_count 1) {
                            let ml_a0: ASTStmtRef = (parser_get_call_arg parser call.arg_start)
                            let ml_a0_code: string = (generate_expression parser ml_a0.node_id ml_a0.node_type env "")
                            let mut ml_map_type: string = ""
                            if (== ml_a0.node_type ParseNodeType.PNODE_IDENTIFIER) {
                                let ml_id0: ASTIdentifier = (parser_get_identifier parser ml_a0.node_id)
                                set ml_map_type (genenv_get env ml_id0.name)
                            } else { (print "") }
                            let mut ml_parts: array<string> = []
                            if (or (== ml_map_type "HashMap<string,string>") (== ml_map_type "HashMap<string, string>")) {
                                set ml_parts (cg_append ml_parts "nl_hm_size(")
                            } else {
                                set ml_parts (cg_append ml_parts "nl_map_size(")
                            }
                            set ml_parts (cg_append ml_parts ml_a0_code)
                            set ml_parts (cg_append ml_parts ")")
                            return (cg_build ml_parts)
                        } else { (print "") }
                    } else { (print "") }

                    /* Build call: proper function name (handles list runtime).
                     * Check builtin map first - this lets extern fn calls be routed through
                     * nl_ wrappers (e.g. nl_path_normalize for const char*→char* cast). */
                    let mut c_func_name: string = func_name
                    let extern_builtin_map: string = (map_builtin_func_name func_name)
                    if (!= extern_builtin_map "") {
                        set c_func_name extern_builtin_map
                    } else {
                        if (is_extern_function parser func_name) {
                            (print "")
                        } else {
                            set c_func_name (c_func_name_for_call func_name)
                        }
                    }

                    let mut parts: array<string> = []
                    set parts (cg_append parts c_func_name)
                    set parts (cg_append parts "(")

                    /* Generate arguments */
                    let mut i: int = 0
                    while (< i call.arg_count) {
                        if (> i 0) {
                            set parts (cg_append parts ", ")
                        } else {
                            (print "")
                        }

                        let aref: ASTStmtRef = (parser_get_call_arg parser (+ call.arg_start i))
                        let mut arg_expected: string = ""
                        if (or (== func_name "print") (== func_name "println")) {
                            set arg_expected "string"
                        } else { (print "") }
                        let mut arg_code: string = (generate_expression parser aref.node_id aref.node_type env arg_expected)
                        if (== arg_expected "string") {
                            if (== aref.node_type ParseNodeType.PNODE_IDENTIFIER) {
                                let arg_id: ASTIdentifier = (parser_get_identifier parser aref.node_id)
                                let arg_t: string = (genenv_get env arg_id.name)
                                if (type_is_float arg_t) {
                                    set arg_code (+ "nl_float_to_string(" (+ arg_code ")"))
                                } else { (print "") }
                                if (and (and (!= arg_t "") (!= arg_t "string")) (not (type_is_float arg_t))) {
                                    set arg_code (+ "nl_int_to_string(" (+ arg_code ")"))
                                } else { (print "") }
                            } else {
                                if (== aref.node_type ParseNodeType.PNODE_CALL) {
                                    let arg_call: ASTCall = (parser_get_call parser aref.node_id)
                                    let arg_call_id: ASTIdentifier = (parser_get_identifier parser arg_call.function)
                                    let call_ret_t: string = (lookup_func_return_type_in_parser parser arg_call_id.name)
                                    if (or (func_returns_float arg_call_id.name) (== call_ret_t "float")) {
                                        set arg_code (+ "nl_float_to_string(" (+ arg_code ")"))
                                    } else {
                                        if (== call_ret_t "int") {
                                            set arg_code (+ "nl_int_to_string(" (+ arg_code ")"))
                                        } else {
                                            if (== call_ret_t "bool") {
                                                set arg_code (+ "nl_bool_to_string(" (+ arg_code ")"))
                                            } else {
                                                /* Polymorphic builtins (abs, min, max): check first arg type */
                                                if (or (== arg_call_id.name "abs") (or (== arg_call_id.name "min") (== arg_call_id.name "max"))) {
                                                    let mut is_float_call: bool = false
                                                    if (> arg_call.arg_count 0) {
                                                        let first_arg: ASTStmtRef = (parser_get_call_arg parser arg_call.arg_start)
                                                        if (== first_arg.node_type ParseNodeType.PNODE_FLOAT) {
                                                            set is_float_call true
                                                        } else { (print "") }
                                                    } else { (print "") }
                                                    if is_float_call {
                                                        set arg_code (+ "nl_float_to_string(" (+ arg_code ")"))
                                                    } else {
                                                        set arg_code (+ "nl_int_to_string(" (+ arg_code ")"))
                                                    }
                                                } else {
                                                    /* Known int-returning builtins (including list_*_length) */
                                                    let is_known_int_fn: bool = (or (== arg_call_id.name "array_length") (or (== arg_call_id.name "str_length") (or (== arg_call_id.name "char_at") (or (== arg_call_id.name "string_to_int") (or (== arg_call_id.name "digit_value") (== arg_call_id.name "cast_int"))))))
                                                    let is_list_length: bool = (and (transp_str_starts_with arg_call_id.name "list_") (str_contains arg_call_id.name "_length"))
                                                    if (or is_known_int_fn is_list_length) {
                                                        set arg_code (+ "nl_int_to_string(" (+ arg_code ")"))
                                                    } else {
                                                        /* Known string-returning builtins */
                                                        if (or (== arg_call_id.name "int_to_string") (or (== arg_call_id.name "float_to_string") (or (== arg_call_id.name "bool_to_string") (or (== arg_call_id.name "str_substring") (== arg_call_id.name "string_from_char"))))) {
                                                            (print "")
                                                        } else {
                                                            /* Known bool-returning builtins */
                                                            if (or (== arg_call_id.name "str_contains") (or (== arg_call_id.name "str_equals") (or (== arg_call_id.name "is_digit") (or (== arg_call_id.name "is_alpha") (== arg_call_id.name "is_whitespace"))))) {
                                                                set arg_code (+ "nl_bool_to_string(" (+ arg_code ")"))
                                                            } else { (print "") }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if (== aref.node_type ParseNodeType.PNODE_NUMBER) {
                                        set arg_code (+ "nl_int_to_string(" (+ arg_code ")"))
                                    } else {
                                        if (== aref.node_type ParseNodeType.PNODE_FLOAT) {
                                            set arg_code (+ "nl_float_to_string(" (+ arg_code ")"))
                                        } else {
                                            if (== aref.node_type ParseNodeType.PNODE_BINARY_OP) {
                                                let binop: ASTBinaryOp = (parser_get_binary_op parser aref.node_id)
                                                let op: int = binop.op
                                                /* Wrap arithmetic ops with int_to_string (including + when it's not string concat) */
                                                let is_arith_op: bool = (or (== op LexerTokenType.TOKEN_MINUS) (or (== op LexerTokenType.TOKEN_STAR) (or (== op LexerTokenType.TOKEN_SLASH) (== op LexerTokenType.TOKEN_PERCENT))))
                                                /* + is int arithmetic if result doesn't look like str_concat */
                                                let is_plus_int: bool = (and (== op LexerTokenType.TOKEN_PLUS) (not (str_contains arg_code "nl_str_concat")))
                                                if (or is_arith_op is_plus_int) {
                                                    set arg_code (+ "nl_int_to_string(" (+ arg_code ")"))
                                                } else { (print "") }
                                            } else {
                                            if (== aref.node_type ParseNodeType.PNODE_FIELD_ACCESS) {
                                                /* Struct field access in print - look up actual field type */
                                                let fa_arg: ASTFieldAccess = (parser_get_field_access parser aref.node_id)
                                                let mut fa_owner_type: string = ""
                                                if (== fa_arg.object_type ParseNodeType.PNODE_IDENTIFIER) {
                                                    let fa_owner_id: ASTIdentifier = (parser_get_identifier parser fa_arg.object)
                                                    set fa_owner_type (genenv_get env fa_owner_id.name)
                                                } else {
                                                    /* Handle nested field access: obj.inner.field */
                                                    if (== fa_arg.object_type ParseNodeType.PNODE_FIELD_ACCESS) {
                                                        let inner_fa: ASTFieldAccess = (parser_get_field_access parser fa_arg.object)
                                                        if (== inner_fa.object_type ParseNodeType.PNODE_IDENTIFIER) {
                                                            let inner_id: ASTIdentifier = (parser_get_identifier parser inner_fa.object)
                                                            let inner_owner: string = (genenv_get env inner_id.name)
                                                            set fa_owner_type (lookup_struct_field_type parser inner_owner inner_fa.field_name)
                                                        } else { (print "") }
                                                    } else { (print "") }
                                                }
                                                let fa_field_type: string = (lookup_struct_field_type parser fa_owner_type fa_arg.field_name)
                                                if (== fa_field_type "int") {
                                                    set arg_code (+ "nl_int_to_string(" (+ arg_code ")"))
                                                } else {
                                                if (== fa_field_type "float") {
                                                    set arg_code (+ "nl_float_to_string(" (+ arg_code ")"))
                                                } else {
                                                if (== fa_field_type "bool") {
                                                    set arg_code (+ "nl_bool_to_string(" (+ arg_code ")"))
                                                } else {
                                                    /* string or unknown - no wrapping needed */
                                                    (print "")
                                                } } }
                                            } else { (print "") }
                                            }
                                        }
                                    }
                                }
                            }
                        } else { (print "") }
                        set parts (cg_append parts arg_code)
                        set i (+ i 1)
                    }
                    
                    set parts (cg_append parts ")")
                    return (cg_build parts)
                } else {
                    if (== node_type ParseNodeType.PNODE_MODULE_QUALIFIED_CALL) {
                        /* Module-qualified function call: Module.function(args...) */
                        let mqc: ASTModuleQualifiedCall = (parser_get_module_qualified_call parser node_id)
                        
                        /* Use function_name which contains full qualified name */
                        let qualified_name: string = mqc.function_name
                        let c_func_name: string = (c_name_for_qualified_function qualified_name)
                        
                        let mut parts: array<string> = []
                        set parts (cg_append parts c_func_name)
                        set parts (cg_append parts "(")
                        
                        /* Generate arguments */
                        let mut i: int = 0
                        while (< i mqc.arg_count) {
                            if (> i 0) {
                                set parts (cg_append parts ", ")
                            } else {
                                (print "")
                            }
                            
                            let aref: ASTStmtRef = (parser_get_call_arg parser (+ mqc.arg_start i))
                            let arg_code: string = (generate_expression parser aref.node_id aref.node_type env "")
                            set parts (cg_append parts arg_code)
                            set i (+ i 1)
                        }
                        
                        set parts (cg_append parts ")")
                        return (cg_build parts)
                    } else {
                        if (== node_type ParseNodeType.PNODE_FIELD_ACCESS) {
                        /* Field access */
                        let fa: ASTFieldAccess = (parser_get_field_access parser node_id)
                        /* If the object is an enum identifier (e.g. DiagnosticSeverity.DIAG_ERROR),
                         * emit a C enum constant rather than a struct field access. */
                        if (== fa.object_type ParseNodeType.PNODE_IDENTIFIER) {
                            let ident: ASTIdentifier = (parser_get_identifier parser fa.object)
                            /* Self-hosted MVP: recognize schema enums by name. */
                            if (or (== ident.name "DiagnosticSeverity") (== ident.name "CompilerPhase")) {
                                let mut parts: array<string> = []
                                set parts (cg_append parts ident.name)
                                set parts (cg_append parts "_")
                                set parts (cg_append parts (mangle_name fa.field_name))
                                return (cg_build parts)
                            } else {
                                if (or (== ident.name "TokenType") (or (== ident.name "ParseNodeType") (or (== ident.name "LexerTokenType") (== ident.name "TypeKind")))) {
                                    return (mangle_name fa.field_name)
                                } else {
                                    /* Check if this is a user-defined enum */
                                    let mut ei: int = 0
                                    let enum_count: int = (parser_get_enum_count parser)
                                    let mut found_enum: bool = false
                                    while (< ei enum_count) {
                                        let e: ASTEnum = (parser_get_enum parser ei)
                                        if (== e.name ident.name) {
                                            set found_enum true
                                        } else { (print "") }
                                        set ei (+ ei 1)
                                    }
                                    if found_enum {
                                        let mut eparts: array<string> = []
                                        set eparts (cg_append eparts "nl_")
                                        set eparts (cg_append eparts ident.name)
                                        set eparts (cg_append eparts "_")
                                        set eparts (cg_append eparts fa.field_name)
                                        return (cg_build eparts)
                                    } else { (print "") }
                                }
                            }
                        } else { (print "") }

                        let obj_code: string = (generate_expression parser fa.object fa.object_type env "")
                        let mut parts: array<string> = []
                        /* Add (char*) cast when accessing string fields of extern structs.
                         * The schema defines string fields as const char*, but NanoLang string = char*.
                         * The cast avoids -Wdiscarded-qualifiers warnings during bootstrap. */
                        let mut fa_field_is_string: bool = false
                        if (== fa.object_type ParseNodeType.PNODE_IDENTIFIER) {
                            let fa_id: ASTIdentifier = (parser_get_identifier parser fa.object)
                            let fa_owner_type: string = (genenv_get env fa_id.name)
                            if (!= fa_owner_type "") {
                                let fa_ft: string = (lookup_struct_field_type parser fa_owner_type fa.field_name)
                                if (== fa_ft "string") {
                                    set fa_field_is_string true
                                } else { (print "") }
                            } else { (print "") }
                        } else {
                            /* Handle nested field access: obj.inner.field */
                            if (== fa.object_type ParseNodeType.PNODE_FIELD_ACCESS) {
                                let inner_fa: ASTFieldAccess = (parser_get_field_access parser fa.object)
                                if (== inner_fa.object_type ParseNodeType.PNODE_IDENTIFIER) {
                                    let inner_id: ASTIdentifier = (parser_get_identifier parser inner_fa.object)
                                    let inner_owner: string = (genenv_get env inner_id.name)
                                    if (!= inner_owner "") {
                                        let inner_ft: string = (lookup_struct_field_type parser inner_owner inner_fa.field_name)
                                        if (!= inner_ft "") {
                                            let nested_ft: string = (lookup_struct_field_type parser inner_ft fa.field_name)
                                            if (== nested_ft "string") {
                                                set fa_field_is_string true
                                            } else { (print "") }
                                        } else { (print "") }
                                    } else { (print "") }
                                } else { (print "") }
                            } else { (print "") }
                        }
                        if fa_field_is_string {
                            set parts (cg_append parts "(char*)((")
                            set parts (cg_append parts obj_code)
                            set parts (cg_append parts ").")
                            set parts (cg_append parts (mangle_name fa.field_name))
                            set parts (cg_append parts ")")
                        } else {
                            set parts (cg_append parts "(")
                            set parts (cg_append parts obj_code)
                            set parts (cg_append parts ").")
                            set parts (cg_append parts (mangle_name fa.field_name))
                        }
                        return (cg_build parts)
                    } else {
                        if (== node_type ParseNodeType.PNODE_ARRAY_LITERAL) {
                            /* Array literal -> DynArray* */
                            let arr: ASTArrayLiteral = (parser_get_array_literal parser node_id)

                            /* Prefer typechecker-propagated element_type; fall back to expected_type for empty literals. */
                            let mut elem_t: string = arr.element_type
                            if (== elem_t "") {
                                if (and (== arr.element_count 0) (is_array_type expected_type)) {
                                    set elem_t (array_elem_type_from_array_type expected_type)
                                } else { (print "") }
                            } else { (print "") }

                            let mut elem_enum: string = "ELEM_INT"
                            let mut push_fn: string = "dyn_array_push_int"

                            if (!= elem_t "") {
                                set elem_enum (elem_enum_from_elem_type elem_t)
                                set push_fn (push_fn_from_elem_type elem_t)
                            } else {
                                /* Infer element type from first element expression kind (fallback to int) */
                                let mut elem_type: int = 0
                                if (> arr.element_count 0) {
                                    let first: ASTStmtRef = (parser_get_array_element parser arr.element_start)
                                    set elem_type first.node_type
                                } else { (print "") }

                                if (== elem_type ParseNodeType.PNODE_FLOAT) {
                                    set elem_enum "ELEM_FLOAT"
                                    set push_fn "dyn_array_push_float"
                                    set elem_t "float"
                                } else {
                                    if (== elem_type ParseNodeType.PNODE_STRING) {
                                        set elem_enum "ELEM_STRING"
                                        set push_fn "dyn_array_push_string"
                                        set elem_t "string"
                                    } else {
                                        if (== elem_type ParseNodeType.PNODE_BOOL) {
                                            set elem_enum "ELEM_BOOL"
                                            set push_fn "dyn_array_push_bool"
                                            set elem_t "bool"
                                        } else {
                                            if (== elem_type ParseNodeType.PNODE_ARRAY_LITERAL) {
                                                set elem_enum "ELEM_ARRAY"
                                                set push_fn "dyn_array_push_array"
                                                set elem_t "array"
                                            } else {
                                                set elem_t "int"
                                            }
                                        }
                                    }
                                }
                            }

                            let mut arr_parts: array<string> = []
                            set arr_parts (cg_append arr_parts "({ DynArray* _arr = dyn_array_new(")
                            set arr_parts (cg_append arr_parts elem_enum)
                            set arr_parts (cg_append arr_parts "); ")

                            let mut i: int = 0
                            while (< i arr.element_count) {
                                let eref: ASTStmtRef = (parser_get_array_element parser (+ arr.element_start i))
                                let ecode: string = (generate_expression parser eref.node_id eref.node_type env "")

                                if (type_is_struct elem_t) {
                                    set arr_parts (cg_append arr_parts "dyn_array_push_int(_arr, ")
                                    set arr_parts (cg_append arr_parts (box_struct_expr elem_t ecode))
                                } else {
                                    set arr_parts (cg_append arr_parts push_fn)
                                    set arr_parts (cg_append arr_parts "(_arr, ")
                                    set arr_parts (cg_append arr_parts ecode)
                                    (print "")
                                }
                                set arr_parts (cg_append arr_parts "); ")
                                set i (+ i 1)
                            }

                            set arr_parts (cg_append arr_parts "_arr; })")
                            return (cg_build arr_parts)
                        } else {
                            if (== node_type ParseNodeType.PNODE_STRUCT_LITERAL) {
                                /* Struct literal -> compound literal */
                                let sl: ASTStructLiteral = (parser_get_struct_literal parser node_id)
                                
                                let mut c_type_parts: array<string> = []
                                set c_type_parts (cg_append c_type_parts "nl_")
                                set c_type_parts (cg_append c_type_parts (mangle_name sl.struct_name))
                                let c_type: string = (cg_build c_type_parts)
                                
                                let mut struct_parts: array<string> = []
                                set struct_parts (cg_append struct_parts "((")
                                set struct_parts (cg_append struct_parts c_type)
                                set struct_parts (cg_append struct_parts "){ ")

                                let mut i: int = 0
                                while (< i sl.field_count) {
                                    if (> i 0) {
                                        set struct_parts (cg_append struct_parts ", ")
                                    } else { (print "") }

                                    let fname: string = (at sl.field_names i)
                                    let vid: int = (at sl.field_value_ids i)
                                    let vty: int = (at sl.field_value_types i)
                                    let field_expected: string = (lookup_struct_field_type parser sl.struct_name fname)
                                    let vcode: string = (generate_expression parser vid vty env field_expected)

                                    set struct_parts (cg_append struct_parts ".")
                                    set struct_parts (cg_append struct_parts (mangle_name fname))
                                    set struct_parts (cg_append struct_parts " = ")
                                    set struct_parts (cg_append struct_parts vcode)

                                    set i (+ i 1)
                                }

                                set struct_parts (cg_append struct_parts " })")
                                return (cg_build struct_parts)
                            } else {
                                if (== node_type ParseNodeType.PNODE_UNION_CONSTRUCT) {
                                    /* Union construction -> compound literal */
                                    let uc: ASTUnionConstruct = (parser_get_union_construct parser node_id)

                                    /* Derive monomorphized union name from expected_type for generics */
                                    let mut actual_union_name: string = uc.union_name
                                    if (and (!= expected_type "") (is_generic_type expected_type)) {
                                        set actual_union_name (monomorphize_type_name expected_type)
                                    } else { (print "") }

                                    let mut union_parts: array<string> = []
                                    set union_parts (cg_append union_parts "nl_")
                                    set union_parts (cg_append union_parts (mangle_name actual_union_name))
                                    let union_c: string = (cg_build union_parts)

                                    let mut tag_parts: array<string> = []
                                    set tag_parts (cg_append tag_parts "nl_")
                                    set tag_parts (cg_append tag_parts (mangle_name actual_union_name))
                                    set tag_parts (cg_append tag_parts "_TAG_")
                                    set tag_parts (cg_append tag_parts uc.variant_name)
                                    let tag_name: string = (cg_build tag_parts)

                                    let mut union_construct_parts: array<string> = []
                                    set union_construct_parts (cg_append union_construct_parts "((")
                                    set union_construct_parts (cg_append union_construct_parts union_c)
                                    set union_construct_parts (cg_append union_construct_parts "){ .tag = ")
                                    set union_construct_parts (cg_append union_construct_parts tag_name)
                                    set union_construct_parts (cg_append union_construct_parts ", .data.")
                                    set union_construct_parts (cg_append union_construct_parts uc.variant_name)
                                    set union_construct_parts (cg_append union_construct_parts " = ")

                                    if (== uc.field_count 0) {
                                        set union_construct_parts (cg_append union_construct_parts "{0}")
                                    } else {
                                        set union_construct_parts (cg_append union_construct_parts "{")
                                        let mut i: int = 0
                                        while (< i uc.field_count) {
                                            if (> i 0) {
                                                set union_construct_parts (cg_append union_construct_parts ", ")
                                            } else { (print "") }

                                            let fname: string = (at uc.field_names i)
                                            let vid: int = (at uc.field_value_ids i)
                                            let vty: int = (at uc.field_value_types i)
                                            let vcode: string = (generate_expression parser vid vty env "")

                                            set union_construct_parts (cg_append union_construct_parts ".")
                                            set union_construct_parts (cg_append union_construct_parts (mangle_name fname))
                                            set union_construct_parts (cg_append union_construct_parts " = ")
                                            set union_construct_parts (cg_append union_construct_parts vcode)
                                            set i (+ i 1)
                                        }
                                        set union_construct_parts (cg_append union_construct_parts "}")
                                    }

                                    set union_construct_parts (cg_append union_construct_parts " })")
                                    return (cg_build union_construct_parts)
                                } else {
                                    if (== node_type ParseNodeType.PNODE_MATCH) {
                                        let m: ASTMatch = (parser_get_match parser node_id)
                                        return (generate_match_expr parser m env expected_type)
                                    } else {
                                        if (== node_type ParseNodeType.PNODE_TUPLE_LITERAL) {
                                            let tl: ASTTupleLiteral = (parser_get_tuple_literal parser node_id)
                                            let tuple_t: string = expected_type
                                            let mut tuple_name: string = "Tuple"
                                            if (is_tuple_type tuple_t) {
                                                set tuple_name (tuple_typedef_name tuple_t)
                                            } else {
                                                (print "")
                                            }

                                            let elem_expected: array<string> = (tuple_split_types tuple_t)

                                            let mut tuple_parts: array<string> = []
                                            set tuple_parts (cg_append tuple_parts "((")
                                            set tuple_parts (cg_append tuple_parts tuple_name)
                                            set tuple_parts (cg_append tuple_parts "){ ")

                                            let mut i: int = 0
                                            while (< i tl.element_count) {
                                                if (> i 0) {
                                                    set tuple_parts (cg_append tuple_parts ", ")
                                                } else { (print "") }

                                                let vid: int = (at tl.element_ids i)
                                                let vty: int = (at tl.element_types i)
                                                let mut exp_i: string = ""
                                                if (< i (array_length elem_expected)) {
                                                    set exp_i (at elem_expected i)
                                                } else { (print "") }

                                                let vcode: string = (generate_expression parser vid vty env exp_i)
                                                set tuple_parts (cg_append tuple_parts "._")
                                                set tuple_parts (cg_append tuple_parts (int_to_string i))
                                                set tuple_parts (cg_append tuple_parts " = ")
                                                set tuple_parts (cg_append tuple_parts vcode)
                                                set i (+ i 1)
                                            }

                                            set tuple_parts (cg_append tuple_parts " })")
                                            return (cg_build tuple_parts)
                                        } else {
                                            if (== node_type ParseNodeType.PNODE_TUPLE_INDEX) {
                                                let ti: ASTTupleIndex = (parser_get_tuple_index parser node_id)
                                                let tcode: string = (generate_expression parser ti.tuple ti.tuple_type env "")
                                                let mut tuple_index_parts: array<string> = []
                                                set tuple_index_parts (cg_append tuple_index_parts "((")
                                                set tuple_index_parts (cg_append tuple_index_parts tcode)
                                                set tuple_index_parts (cg_append tuple_index_parts ")._")
                                                set tuple_index_parts (cg_append tuple_index_parts (int_to_string ti.index))
                                                set tuple_index_parts (cg_append tuple_index_parts ")")
                                                return (cg_build tuple_index_parts)
                                            } else {
                                            if (== node_type ParseNodeType.PNODE_IF) {
                                                /* If-expression: generate C ternary (cond ? then : else) */
                                                let if_expr: ASTIf = (parser_get_if parser node_id)
                                                let cond_code: string = (generate_expression parser if_expr.condition if_expr.condition_type env "bool")
                                                /* Extract then value from single-statement then block */
                                                let then_blk: ASTBlock = (parser_get_block parser if_expr.then_body)
                                                let then_len: int = (list_ASTStmtRef_length then_blk.statements)
                                                let mut then_code: string = "0"
                                                if (> then_len 0) {
                                                    let then_s: ASTStmtRef = (list_ASTStmtRef_get then_blk.statements (- then_len 1))
                                                    set then_code (generate_expression parser then_s.node_id then_s.node_type env expected_type)
                                                } else { (print "") }
                                                /* Extract else value from single-statement else block */
                                                let else_blk: ASTBlock = (parser_get_block parser if_expr.else_body)
                                                let else_len: int = (list_ASTStmtRef_length else_blk.statements)
                                                let mut else_code: string = "0"
                                                if (> else_len 0) {
                                                    let else_s: ASTStmtRef = (list_ASTStmtRef_get else_blk.statements (- else_len 1))
                                                    set else_code (generate_expression parser else_s.node_id else_s.node_type env expected_type)
                                                } else { (print "") }
                                                let mut tern_parts: array<string> = []
                                                set tern_parts (cg_append tern_parts "(")
                                                set tern_parts (cg_append tern_parts cond_code)
                                                set tern_parts (cg_append tern_parts " ? ")
                                                set tern_parts (cg_append tern_parts then_code)
                                                set tern_parts (cg_append tern_parts " : ")
                                                set tern_parts (cg_append tern_parts else_code)
                                                set tern_parts (cg_append tern_parts ")")
                                                return (cg_build tern_parts)
                                            } else {
                                                /* Unknown type - return 0 */
                                                return "0"
                                            }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        }
        }
        }
    }
}

}

shadow generate_expression {
    let source: string = (+ "f" "n main() -> int { return 42 }")
    let toks: List<LexerToken> = (tokenize_string source)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let ret: ASTReturn = (parser_get_return p 0)
    let env: GenEnv = (genenv_new)
    let code: string = (generate_expression p ret.value ret.value_type env "int")
    assert (== code "42")
}

/* Generate C code for a return statement
 * 
 * Args:
 *   parser: Parser containing AST nodes
 *   ret: Return statement node (contains value and value_type)
 *   indent: Indentation level
 * 
 * Returns: C code for return statement with indentation
 */
fn generate_return_stmt(parser: Parser, ret: ASTReturn, indent: int, env: GenEnv, expected_type: string) -> string {
    let mut parts: array<string> = []
    set parts (cg_append parts (gen_indent indent))
    set parts (cg_append parts "return")
    
    if (< ret.value 0) {
        /* No return value - void return */
        (print "")
    } else {
        /* Has return value - generate expression */
        set parts (cg_append parts " ")
        let expr_code: string = (generate_expression parser ret.value ret.value_type env expected_type)
        set parts (cg_append parts expr_code)
    }
    
    set parts (cg_append parts ";\n")
    return (cg_build parts)
}

shadow generate_return_stmt {
    let source: string = (+ "f" "n main() -> int { return 42 }")
    let toks: List<LexerToken> = (tokenize_string source)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let ret: ASTReturn = (parser_get_return p 0)
    let env: GenEnv = (genenv_new)
    let code: string = (generate_return_stmt p ret 0 env "int")
    assert (== code "return 42;\n")
}

/* Generate C code for a let statement
 * 
 * Args:
 *   parser: Parser containing AST nodes
 *   let_stmt: Let statement node
 *   indent: Indentation level
 * 
 * Returns: C code for variable declaration with initialization
 */
fn generate_let_stmt(parser: Parser, let_stmt: ASTLet, indent: int, env: GenEnv) -> string {
    let mut parts: array<string> = []
    set parts (cg_append parts (gen_indent indent))

    let c_type: string = (type_to_c let_stmt.var_type)
    set parts (cg_append parts c_type)
    set parts (cg_append parts " ")
    
    /* Add variable name with nl_ prefix */
    set parts (cg_append parts "nl_")
    set parts (cg_append parts (mangle_name let_stmt.name))
    set parts (cg_append parts " = ")
    
    /* Generate initialization expression */
    if (< let_stmt.value 0) {
        /* No initialization - use default */
        set parts (cg_append parts "0")
    } else {
        /* Generate expression */
        let expr_code: string = (generate_expression parser let_stmt.value let_stmt.value_type env let_stmt.var_type)
        set parts (cg_append parts expr_code)
    }
    
    set parts (cg_append parts ";\n")
    return (cg_build parts)
}

shadow generate_let_stmt {
    let source: string = (+ "f" "n main() -> int { let x: int = 1 return x }")
    let toks: List<LexerToken> = (tokenize_string source)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let l: ASTLet = (parser_get_let p 0)
    let env: GenEnv = (genenv_new)
    let code: string = (generate_let_stmt p l 0 env)
    assert (== code "int64_t nl_x = 1;\n")
}

fn generate_assert_stmt(parser: Parser, a: ASTAssert, indent: int, env: GenEnv) -> string {
    let mut parts: array<string> = []
    set parts (cg_append parts (gen_indent indent))
    let cond_code: string = (generate_expression parser a.condition a.condition_type env "bool")
    set parts (cg_append parts "assert(")
    set parts (cg_append parts cond_code)
    set parts (cg_append parts ");\n")
    return (cg_build parts)
}

shadow generate_assert_stmt {
    let source: string = (+ "f" "n main() -> int { assert true return 0 }")
    let toks: List<LexerToken> = (tokenize_string source)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let a: ASTAssert = (parser_get_assert p 0)
    let env: GenEnv = (genenv_new)
    let code: string = (generate_assert_stmt p a 0 env)
    assert (== code "assert(1);\n")
}

fn generate_match_expr(parser: Parser, m: ASTMatch, env: GenEnv, expected_type: string) -> string {
    let scr_code: string = (generate_expression parser m.scrutinee m.scrutinee_type env "")

    /* Infer union name from scrutinee identifier type in env (common case). */
    let mut union_name: string = ""
    if (== m.scrutinee_type ParseNodeType.PNODE_IDENTIFIER) {
        let sid: ASTIdentifier = (parser_get_identifier parser m.scrutinee)
        set union_name (genenv_get env sid.name)
    } else {
        if (== m.scrutinee_type ParseNodeType.PNODE_UNION_CONSTRUCT) {
            let uc: ASTUnionConstruct = (parser_get_union_construct parser m.scrutinee)
            set union_name uc.union_name
        } else {
            (print "")
        }
    }

    if (== union_name "") {
        set union_name "UNKNOWN"
    } else { (print "") }

    /* Monomorphize generic union names */
    if (is_generic_type union_name) {
        set union_name (monomorphize_type_name union_name)
    } else { (print "") }

    let mut union_parts: array<string> = []
    set union_parts (cg_append union_parts "nl_")
    set union_parts (cg_append union_parts union_name)
    let union_c: string = (cg_build union_parts)
    let mut out_c: string = "int64_t"
    if (!= expected_type "") {
        set out_c (type_to_c expected_type)
    } else { (print "") }

    let mut parts: array<string> = []
    set parts (cg_append parts "({ ")
    set parts (cg_append parts union_c)
    set parts (cg_append parts " _m = ")
    set parts (cg_append parts scr_code)
    set parts (cg_append parts "; ")
    set parts (cg_append parts out_c)
    set parts (cg_append parts " _out = 0; switch (_m.tag) { ")

    let mut i: int = 0
    while (< i m.arm_count) {
        let variant: string = (at m.arm_variants i)
        let binding: string = (at m.arm_bindings i)
        let body_id: int = (at m.arm_body_ids i)
        let body_type: int = (at m.arm_body_types i)

        let mut tag_parts: array<string> = []
        set tag_parts (cg_append tag_parts "nl_")
        set tag_parts (cg_append tag_parts union_name)
        set tag_parts (cg_append tag_parts "_TAG_")
        set tag_parts (cg_append tag_parts variant)
        let tag_name: string = (cg_build tag_parts)

        let mut var_type_parts: array<string> = []
        set var_type_parts (cg_append var_type_parts "nl_")
        set var_type_parts (cg_append var_type_parts union_name)
        set var_type_parts (cg_append var_type_parts "_")
        set var_type_parts (cg_append var_type_parts variant)
        let variant_type: string = (cg_build var_type_parts)

        set parts (cg_append parts "case ")
        set parts (cg_append parts tag_name)
        set parts (cg_append parts ": { ")

        set parts (cg_append parts variant_type)
        set parts (cg_append parts " nl_")
        set parts (cg_append parts (mangle_name binding))
        set parts (cg_append parts " = _m.data.")
        set parts (cg_append parts variant)
        set parts (cg_append parts "; ")

        let mut type_name_parts: array<string> = []
        set type_name_parts (cg_append type_name_parts union_name)
        set type_name_parts (cg_append type_name_parts ".")
        set type_name_parts (cg_append type_name_parts variant)
        let env_arm: GenEnv = (genenv_put env binding (cg_build type_name_parts))

        if (== body_type ParseNodeType.PNODE_BLOCK) {
            /* Block bodies in expression match aren't supported here; assume they return */
            set parts (cg_append parts "/* unsupported match arm block */ ")
        } else {
            let expr_code: string = (generate_expression parser body_id body_type env_arm expected_type)
            set parts (cg_append parts "_out = ")
            set parts (cg_append parts expr_code)
            set parts (cg_append parts "; ")
        }

        set parts (cg_append parts "break; } ")
        set i (+ i 1)
    }

    set parts (cg_append parts "} _out; })")
    return (cg_build parts)
}

shadow generate_match_expr {
    let source: string = (+ "f" "n main() -> int { let x: Option = 0 match x { Some(y) => y } return 0 }")
    let toks: List<LexerToken> = (tokenize_string source)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let m: ASTMatch = (parser_get_match p 0)
    let env0: GenEnv = (genenv_put (genenv_new) "x" "Option")
    let code: string = (generate_match_expr p m env0 "int")
    assert (str_contains code "switch")
}

fn generate_match_stmt(parser: Parser, m: ASTMatch, indent: int, env: GenEnv, return_type: string) -> string {
    let scr_code: string = (generate_expression parser m.scrutinee m.scrutinee_type env "")

    /* Infer union name from scrutinee identifier type in env (common case). */
    let mut union_name: string = ""
    if (== m.scrutinee_type ParseNodeType.PNODE_IDENTIFIER) {
        let sid: ASTIdentifier = (parser_get_identifier parser m.scrutinee)
        set union_name (genenv_get env sid.name)
    } else {
        if (== m.scrutinee_type ParseNodeType.PNODE_UNION_CONSTRUCT) {
            let uc: ASTUnionConstruct = (parser_get_union_construct parser m.scrutinee)
            set union_name uc.union_name
        } else {
            (print "")
        }
    }

    if (== union_name "") {
        set union_name "UNKNOWN"
    } else { (print "") }

    /* Monomorphize generic union names */
    if (is_generic_type union_name) {
        set union_name (monomorphize_type_name union_name)
    } else { (print "") }

    let mut union_parts: array<string> = []
    set union_parts (cg_append union_parts "nl_")
    set union_parts (cg_append union_parts union_name)
    let union_c: string = (cg_build union_parts)

    let mut parts: array<string> = []
    set parts (cg_append parts (gen_indent indent))
    set parts (cg_append parts "{\n")
    set parts (cg_append parts (gen_indent (+ indent 1)))
    set parts (cg_append parts union_c)
    set parts (cg_append parts " _m = ")
    set parts (cg_append parts scr_code)
    set parts (cg_append parts ";\n")

    set parts (cg_append parts (gen_indent (+ indent 1)))
    set parts (cg_append parts "switch (_m.tag) {\n")

    let mut i: int = 0
    while (< i m.arm_count) {
        let variant: string = (at m.arm_variants i)
        let binding: string = (at m.arm_bindings i)
        let body_id: int = (at m.arm_body_ids i)
        let body_type: int = (at m.arm_body_types i)

        let mut tag_parts: array<string> = []
        set tag_parts (cg_append tag_parts "nl_")
        set tag_parts (cg_append tag_parts union_name)
        set tag_parts (cg_append tag_parts "_TAG_")
        set tag_parts (cg_append tag_parts variant)
        let tag_name: string = (cg_build tag_parts)

        let mut var_type_parts: array<string> = []
        set var_type_parts (cg_append var_type_parts "nl_")
        set var_type_parts (cg_append var_type_parts union_name)
        set var_type_parts (cg_append var_type_parts "_")
        set var_type_parts (cg_append var_type_parts variant)
        let variant_type: string = (cg_build var_type_parts)

        set parts (cg_append parts (gen_indent (+ indent 2)))
        set parts (cg_append parts "case ")
        set parts (cg_append parts tag_name)
        set parts (cg_append parts ": {\n")

        set parts (cg_append parts (gen_indent (+ indent 3)))
        set parts (cg_append parts variant_type)
        set parts (cg_append parts " nl_")
        set parts (cg_append parts (mangle_name binding))
        set parts (cg_append parts " = _m.data.")
        set parts (cg_append parts variant)
        set parts (cg_append parts ";\n")

        let mut type_name_parts: array<string> = []
        set type_name_parts (cg_append type_name_parts union_name)
        set type_name_parts (cg_append type_name_parts ".")
        set type_name_parts (cg_append type_name_parts variant)
        let env_arm: GenEnv = (genenv_put env binding (cg_build type_name_parts))

        if (== body_type ParseNodeType.PNODE_BLOCK) {
            set parts (cg_append parts (generate_block parser body_id (+ indent 3) env_arm return_type))
        } else {
            let expr_code: string = (generate_expression parser body_id body_type env_arm "")
            set parts (cg_append parts (gen_indent (+ indent 3)))
            set parts (cg_append parts expr_code)
            set parts (cg_append parts ";\n")
        }

        set parts (cg_append parts (gen_indent (+ indent 3)))
        set parts (cg_append parts "break;\n")

        set parts (cg_append parts (gen_indent (+ indent 2)))
        set parts (cg_append parts "}\n")
        set i (+ i 1)
    }

    set parts (cg_append parts (gen_indent (+ indent 1)))
    set parts (cg_append parts "}\n")
    set parts (cg_append parts (gen_indent indent))
    set parts (cg_append parts "}\n")
    return (cg_build parts)
}

shadow generate_match_stmt {
    let source: string = (+ "f" "n main() -> int { let x: Option = 0 match x { Some(y) => y } return 0 }")
    let toks: List<LexerToken> = (tokenize_string source)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let m: ASTMatch = (parser_get_match p 0)
    let env0: GenEnv = (genenv_put (genenv_new) "x" "Option")
    let code: string = (generate_match_stmt p m 0 env0 "int")
    assert (str_contains code "switch")
}

struct StmtGenResult {
    code: string,
    env: GenEnv
}

fn generate_statement(parser: Parser, stmt: ASTStmtRef, indent: int, env: GenEnv, return_type: string) -> StmtGenResult {
    if (== stmt.node_type ParseNodeType.PNODE_LET) {
        let let_stmt: ASTLet = (parser_get_let parser stmt.node_id)
        let code: string = (generate_let_stmt parser let_stmt indent env)
        let env2: GenEnv = (genenv_put env let_stmt.name let_stmt.var_type)
        return StmtGenResult { code: code, env: env2 }
    } else {
        if (== stmt.node_type ParseNodeType.PNODE_SET) {
            let set_stmt: ASTSet = (parser_get_set parser stmt.node_id)
            let code: string = (generate_set_stmt parser set_stmt indent env)
            return StmtGenResult { code: code, env: env }
        } else {
            if (== stmt.node_type ParseNodeType.PNODE_RETURN) {
                let ret: ASTReturn = (parser_get_return parser stmt.node_id)
                let code: string = (generate_return_stmt parser ret indent env return_type)
                return StmtGenResult { code: code, env: env }
            } else {
                if (== stmt.node_type ParseNodeType.PNODE_IF) {
                    let if_stmt: ASTIf = (parser_get_if parser stmt.node_id)
                    let code: string = (generate_if_stmt parser if_stmt indent env return_type)
                    return StmtGenResult { code: code, env: env }
                } else {
                    if (== stmt.node_type ParseNodeType.PNODE_WHILE) {
                        let while_stmt: ASTWhile = (parser_get_while parser stmt.node_id)
                        let code: string = (generate_while_stmt parser while_stmt indent env return_type)
                        return StmtGenResult { code: code, env: env }
                    } else {
                        if (== stmt.node_type ParseNodeType.PNODE_ASSERT) {
                            let a: ASTAssert = (parser_get_assert parser stmt.node_id)
                            let code: string = (generate_assert_stmt parser a indent env)
                            return StmtGenResult { code: code, env: env }
                        } else {
                            if (== stmt.node_type ParseNodeType.PNODE_MATCH) {
                                let m: ASTMatch = (parser_get_match parser stmt.node_id)
                                let code: string = (generate_match_stmt parser m indent env return_type)
                                return StmtGenResult { code: code, env: env }
                            } else {
                            if (== stmt.node_type ParseNodeType.PNODE_UNSAFE_BLOCK) {
                                let ub: ASTUnsafeBlock = (parser_get_unsafe_block parser stmt.node_id)
                                let mut ub_parts: array<string> = []
                                let mut ub_env: GenEnv = env
                                let mut ub_i: int = 0
                                let ub_count: int = (list_ASTStmtRef_length ub.statements)
                                while (< ub_i ub_count) {
                                    let ub_stmt: ASTStmtRef = (list_ASTStmtRef_get ub.statements ub_i)
                                    let ub_res: StmtGenResult = (generate_statement parser ub_stmt indent ub_env return_type)
                                    set ub_parts (cg_append ub_parts ub_res.code)
                                    set ub_env ub_res.env
                                    set ub_i (+ ub_i 1)
                                }
                                return StmtGenResult { code: (cg_build ub_parts), env: ub_env }
                            } else {
                            if (== stmt.node_type ParseNodeType.PNODE_BREAK) {
                                let mut break_parts: array<string> = []
                                set break_parts (cg_append break_parts (gen_indent indent))
                                set break_parts (cg_append break_parts "break;\n")
                                return StmtGenResult { code: (cg_build break_parts), env: env }
                            } else {
                            if (== stmt.node_type ParseNodeType.PNODE_CONTINUE) {
                                let mut cont_parts: array<string> = []
                                set cont_parts (cg_append cont_parts (gen_indent indent))
                                set cont_parts (cg_append cont_parts "continue;\n")
                                return StmtGenResult { code: (cg_build cont_parts), env: env }
                            } else {
                            /* Expression statement (e.g. call) */
                            if (or (== stmt.node_type ParseNodeType.PNODE_CALL) (== stmt.node_type ParseNodeType.PNODE_MODULE_QUALIFIED_CALL)) {
                                let expr_code: string = (generate_expression parser stmt.node_id stmt.node_type env "")
                                let mut parts: array<string> = []
                                set parts (cg_append parts (gen_indent indent))
                                set parts (cg_append parts expr_code)
                                set parts (cg_append parts ";\n")
                                return StmtGenResult { code: (cg_build parts), env: env }
                            } else {
                                let mut parts: array<string> = []
                                set parts (cg_append parts (gen_indent indent))
                                set parts (cg_append parts "/* unsupported stmt: ")
                                set parts (cg_append parts (int_to_string stmt.node_type))
                                set parts (cg_append parts " */\n")
                                return StmtGenResult { code: (cg_build parts), env: env }
                            }
                            }
                            }
                            }
                            }
                        }
                    }
                }
            }
        }
    }
}

shadow generate_statement {
    let source: string = (+ "f" "n main() -> int { let x: int = 1 return x }")
    let toks: List<LexerToken> = (tokenize_string source)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let func: ASTFunction = (parser_get_function p 0)
    let block: ASTBlock = (parser_get_block p func.body)
    let stmt: ASTStmtRef = (list_ASTStmtRef_get block.statements 0)
    let env: GenEnv = (genenv_new)
    let res: StmtGenResult = (generate_statement p stmt 0 env "int")
    assert (str_contains res.code "nl_x")
    assert (== (genenv_get res.env "x") "int")
}

fn generate_block(parser: Parser, block_id: int, indent: int, env: GenEnv, return_type: string) -> string {
    if (< block_id 0) {
        return ""
    } else {
        let block: ASTBlock = (parser_get_block parser block_id)
        let mut parts: array<string> = []
        let mut env_cur: GenEnv = env
        let mut i: int = 0
        let stmt_count: int = (list_ASTStmtRef_length block.statements)
        while (< i stmt_count) {
            let stmt: ASTStmtRef = (list_ASTStmtRef_get block.statements i)
            let res: StmtGenResult = (generate_statement parser stmt indent env_cur return_type)
            set parts (cg_append parts res.code)
            set env_cur res.env
            set i (+ i 1)
        }
        return (cg_build parts)
    }
}

shadow generate_block {
    let source: string = (+ "f" "n main() -> int { let x: int = 1 return x }")
    let toks: List<LexerToken> = (tokenize_string source)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let func: ASTFunction = (parser_get_function p 0)
    let env: GenEnv = (genenv_new)
    let code: string = (generate_block p func.body 0 env "int")
    assert (str_contains code "return")
}

/* Generate C code for a set statement (assignment)
 * 
 * Args:
 *   parser: Parser containing AST nodes
 *   set_stmt: Set statement node
 *   indent: Indentation level
 * 
 * Returns: C code for assignment statement
 */
fn generate_set_stmt(parser: Parser, set_stmt: ASTSet, indent: int, env: GenEnv) -> string {
    let mut parts: array<string> = []
    set parts (cg_append parts (gen_indent indent))
    
    /* Add target variable with nl_ prefix */
    set parts (cg_append parts "nl_")
    set parts (cg_append parts (mangle_name set_stmt.target))
    set parts (cg_append parts " = ")
    
    /* Generate value expression */
    let target_t: string = (genenv_get env set_stmt.target)
    let expr_code: string = (generate_expression parser set_stmt.value set_stmt.value_type env target_t)
    set parts (cg_append parts expr_code)
    
    set parts (cg_append parts ";\n")
    return (cg_build parts)
}

shadow generate_set_stmt {
    let source: string = (+ "f" "n main() -> int { let mut x: int = 1 set x 2 return x }")
    let toks: List<LexerToken> = (tokenize_string source)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let s: ASTSet = (parser_get_set p 0)
    let env: GenEnv = (genenv_put (genenv_new) "x" "int")
    let code: string = (generate_set_stmt p s 0 env)
    assert (== code "nl_x = 2;\n")
}

/* Generate C code for an if statement
 * 
 * Args:
 *   parser: Parser containing AST nodes
 *   if_stmt: If statement node  
 *   indent: Indentation level
 * 
 * Returns: C code for if/else statement
 */
fn generate_if_stmt(parser: Parser, if_stmt: ASTIf, indent: int, env: GenEnv, return_type: string) -> string {
    let mut parts: array<string> = []
    set parts (cg_append parts (gen_indent indent))
    set parts (cg_append parts "if (")
    
    /* Generate condition expression */
    let cond_code: string = (generate_expression parser if_stmt.condition if_stmt.condition_type env "bool")
    set parts (cg_append parts cond_code)
    set parts (cg_append parts ") {\n")

    set parts (cg_append parts (generate_block parser if_stmt.then_body (+ indent 1) env return_type))
    
    set parts (cg_append parts (gen_indent indent))
    set parts (cg_append parts "}")
    
    /* Generate else if present */
    if (< if_stmt.else_body 0) {
        set parts (cg_append parts "\n")
    } else {
        set parts (cg_append parts " else {\n")
        set parts (cg_append parts (generate_block parser if_stmt.else_body (+ indent 1) env return_type))
        set parts (cg_append parts (gen_indent indent))
        set parts (cg_append parts "}\n")
    }
    
    return (cg_build parts)
}

shadow generate_if_stmt {
    let source: string = (+ "f" "n main() -> int { if true { return 1 } else { return 0 } }")
    let toks: List<LexerToken> = (tokenize_string source)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let if_stmt: ASTIf = (parser_get_if p 0)
    let env: GenEnv = (genenv_new)
    let code: string = (generate_if_stmt p if_stmt 0 env "int")
    assert (str_contains code "if (1)")
    assert (str_contains code "else")
}

/* Generate C code for a while loop
 * 
 * Args:
 *   parser: Parser containing AST nodes
 *   while_stmt: While statement node
 *   indent: Indentation level
 * 
 * Returns: C code for while loop
 */
fn generate_while_stmt(parser: Parser, while_stmt: ASTWhile, indent: int, env: GenEnv, return_type: string) -> string {
    let mut parts: array<string> = []
    set parts (cg_append parts (gen_indent indent))
    set parts (cg_append parts "while (")
    
    /* Generate condition expression */
    let cond_code: string = (generate_expression parser while_stmt.condition while_stmt.condition_type env "bool")
    set parts (cg_append parts cond_code)
    set parts (cg_append parts ") {\n")

    set parts (cg_append parts (generate_block parser while_stmt.body (+ indent 1) env return_type))
    
    set parts (cg_append parts (gen_indent indent))
    set parts (cg_append parts "}\n")
    
    return (cg_build parts)
}

shadow generate_while_stmt {
    let source: string = (+ "f" "n main() -> int { while true { return 1 } return 0 }")
    let toks: List<LexerToken> = (tokenize_string source)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let w: ASTWhile = (parser_get_while p 0)
    let env: GenEnv = (genenv_new)
    let code: string = (generate_while_stmt p w 0 env "int")
    assert (str_contains code "while (1)")
}

fn generate_function_body(parser: Parser, body_id: int, env: GenEnv, return_type: string) -> string {
    return (generate_block parser body_id 1 env return_type)
}

shadow generate_function_body {
    let source: string = (+ "f" "n main() -> int { let x: int = 1 return x }")
    let toks: List<LexerToken> = (tokenize_string source)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let func: ASTFunction = (parser_get_function p 0)
    let env: GenEnv = (genenv_new)
    let code: string = (generate_function_body p func.body env "int")
    assert (str_contains code "return")
}

/* =============================================================================
 * TRANSPILER WRAPPER - Top-level entry point for transpiling a program
 * ============================================================================= */

/* Transpile a parsed and type-checked program to C code from actual AST
 * 
 * This version walks through the actual Parser AST and generates:
 * 1. C includes and runtime helpers
 * 2. Function definitions from AST
 * 3. Complete compilable C program
 * 
 * Args:
 *   parser: The parsed AST from the parser
 * 
 * Returns: Generated C code as a string
 */
/* Check if a let index is referenced by a block (or its nested blocks) */
fn is_let_in_block(parser: Parser, block_id: int, let_idx: int) -> bool {
    if (< block_id 0) {
        return false
    } else {
        let block: ASTBlock = (parser_get_block parser block_id)
        let stmt_count: int = (list_ASTStmtRef_length block.statements)
        let mut i: int = 0
        while (< i stmt_count) {
            let stmt: ASTStmtRef = (list_ASTStmtRef_get block.statements i)
            if (and (== stmt.node_type ParseNodeType.PNODE_LET) (== stmt.node_id let_idx)) {
                return true
            } else { (print "") }
            if (== stmt.node_type ParseNodeType.PNODE_IF) {
                let if_stmt: ASTIf = (parser_get_if parser stmt.node_id)
                if (is_let_in_block parser if_stmt.then_body let_idx) {
                    return true
                } else { (print "") }
                if (is_let_in_block parser if_stmt.else_body let_idx) {
                    return true
                } else { (print "") }
            } else { (print "") }
            if (== stmt.node_type ParseNodeType.PNODE_WHILE) {
                let while_stmt: ASTWhile = (parser_get_while parser stmt.node_id)
                if (is_let_in_block parser while_stmt.body let_idx) {
                    return true
                } else { (print "") }
            } else { (print "") }
            if (== stmt.node_type ParseNodeType.PNODE_FOR) {
                let for_stmt: ASTFor = (parser_get_for parser stmt.node_id)
                if (is_let_in_block parser for_stmt.body let_idx) {
                    return true
                } else { (print "") }
            } else { (print "") }
            if (== stmt.node_type ParseNodeType.PNODE_MATCH) {
                let match_stmt: ASTMatch = (parser_get_match parser stmt.node_id)
                let mut ai: int = 0
                while (< ai match_stmt.arm_count) {
                    let arm_body_id: int = (at match_stmt.arm_body_ids ai)
                    if (is_let_in_block parser arm_body_id let_idx) {
                        return true
                    } else { (print "") }
                    set ai (+ ai 1)
                }
            } else { (print "") }
            if (== stmt.node_type ParseNodeType.PNODE_BLOCK) {
                if (is_let_in_block parser stmt.node_id let_idx) {
                    return true
                } else { (print "") }
            } else { (print "") }
            set i (+ i 1)
        }
        return false
    }
}

shadow is_let_in_block {
    let src: string = "fn main() -> int { let x: int = 1 return x }"
    let toks: List<LexerToken> = (tokenize_string src)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    assert (not (is_let_in_block p -1 0))
}

/* Check if a let is a function parameter, inside a function body, or inside a shadow block */
fn is_let_in_function(parser: Parser, let_idx: int) -> bool {
    let func_count: int = (parser_get_function_count parser)
    let mut fi: int = 0
    while (< fi func_count) {
        let func: ASTFunction = (parser_get_function parser fi)
        if (and (>= let_idx func.param_start) (< let_idx (+ func.param_start func.param_count))) {
            return true
        } else { (print "") }
        if (>= func.body 0) {
            if (is_let_in_block parser func.body let_idx) {
                return true
            } else { (print "") }
        } else { (print "") }
        set fi (+ fi 1)
    }
    /* Also check shadow blocks */
    let shd_count: int = parser.shadows_count
    let mut si: int = 0
    while (< si shd_count) {
        let shd: ASTShadow = (list_ASTShadow_get parser.shadows si)
        if (>= shd.body 0) {
            if (is_let_in_block parser shd.body let_idx) {
                return true
            } else { (print "") }
        } else { (print "") }
        set si (+ si 1)
    }
    return false
}

shadow is_let_in_function {
    let src: string = "fn main() -> int { let x: int = 1 return x }"
    let toks: List<LexerToken> = (tokenize_string src)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    assert (is_let_in_function p 0)
}

/* Generate global constant declarations for top-level let statements */
fn generate_global_constants(parser: Parser) -> string {
    let total_lets: int = (parser_get_let_count parser)
    let mut sb: array<string> = []
    let mut has_globals: bool = false
    let mut emitted_globals: array<string> = []
    
    let mut li: int = 0
    while (< li total_lets) {
        let let_node: ASTLet = (parser_get_let parser li)
        if (not (is_let_in_function parser li)) {
            let mut glob_dup: bool = false
            let mut gdi: int = 0
            while (< gdi (array_length emitted_globals)) {
                if (== (at emitted_globals gdi) let_node.name) { set glob_dup true } else { (print "") }
                set gdi (+ gdi 1)
            }
            if (not glob_dup) {
            set emitted_globals (array_push emitted_globals let_node.name)
            if (not has_globals) {
                set sb (cg_append sb "/* Global constants */\n")
                set has_globals true
            } else { (print "") }
            let c_type: string = (type_to_c let_node.var_type)
            set sb (cg_append sb c_type)
            set sb (cg_append sb " nl_")
            set sb (cg_append sb (mangle_name let_node.name))
            set sb (cg_append sb " = ")
            if (== let_node.value_type ParseNodeType.PNODE_NUMBER) {
                let num: ASTNumber = (parser_get_number parser let_node.value)
                if (== num.value "-9223372036854775808") {
                    set sb (cg_append sb "INT64_MIN")
                } else {
                    set sb (cg_append sb num.value)
                }
            } else {
                if (== let_node.value_type ParseNodeType.PNODE_FLOAT) {
                    let flt: ASTFloat = (parser_get_float parser let_node.value)
                    set sb (cg_append sb flt.value)
                } else {
                    if (== let_node.value_type ParseNodeType.PNODE_STRING) {
                        let str_node: ASTString = (parser_get_string parser let_node.value)
                        set sb (cg_append sb "\"")
                        set sb (cg_append sb str_node.value)
                        set sb (cg_append sb "\"")
                    } else {
                        if (== let_node.value_type ParseNodeType.PNODE_BOOL) {
                            let bool_node: ASTBool = (parser_get_bool parser let_node.value)
                            if bool_node.value {
                                set sb (cg_append sb "true")
                            } else {
                                set sb (cg_append sb "false")
                            }
                        } else {
                            set sb (cg_append sb "0")
                        }
                    }
                }
            }
            set sb (cg_append sb ";\n")
            } else { (print "") }
        } else { (print "") }
        set li (+ li 1)
    }
    if has_globals {
        set sb (cg_append sb "\n")
    } else { (print "") }
    return (cg_build sb)
}

shadow generate_global_constants {
    let src: string = "fn main() -> int { return 0 }"
    let toks: List<LexerToken> = (tokenize_string src)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let c: string = (generate_global_constants p)
    assert (>= (str_length c) 0)
}

fn lookup_func_return_type_in_parser(parser: Parser, name: string) -> string {
    let func_count: int = (parser_get_function_count parser)
    let mut i: int = 0
    while (< i func_count) {
        let func: ASTFunction = (parser_get_function parser i)
        if (== func.name name) {
            return func.return_type
        } else { (print "") }
        set i (+ i 1)
    }
    return ""
}

shadow lookup_func_return_type_in_parser {
    let src: string = "fn add(a: int, b: int) -> int { return 0 }"
    let toks: List<LexerToken> = (tokenize_string src)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    assert (== (lookup_func_return_type_in_parser p "add") "int")
    assert (== (lookup_func_return_type_in_parser p "nonexistent") "")
}

pub fn transpile_parser(parser: Parser) -> string {
    (println "=== Code Generation (Full AST Walk) ===")
    (build_module_alias_map parser)
    (reset_fn_types)
    
    /* Get function count using accessor */
    let func_count: int = (parser_get_function_count parser)
    (print "Generating C code for ")
    (print (int_to_string func_count))
    (println " functions")

    let _reg: int = (register_extern_names parser)
    
    /* Precompute top-level env once (not per function) */
    let mut global_env: GenEnv = (genenv_new)
    let all_lets: int = (parser_get_let_count parser)
    let mut gi: int = 0
    while (< gi all_lets) {
        let glet: ASTLet = (parser_get_let parser gi)
        if (not (is_let_in_function parser gi)) {
            set global_env (genenv_put global_env glet.name glet.var_type)
        } else { (print "") }
        set gi (+ gi 1)
    }

    /* Generate all functions using sb for O(n) concatenation */
    let mut sb: array<string> = []
    let mut emitted_bodies: array<string> = []
    let mut i: int = 0
    while (< i func_count) {
        let func: ASTFunction = (parser_get_function parser i)

        /* Deduplicate function bodies (merged source may have duplicates) */
        let mut body_dup: bool = false
        let mut bdi: int = 0
        while (< bdi (array_length emitted_bodies)) {
            if (== (at emitted_bodies bdi) func.name) { set body_dup true } else { (print "") }
            set bdi (+ bdi 1)
        }

        if (not body_dup) {
        (print "  Generating: ")
        (print func.name)
        (print " (return type: ")
        (print func.return_type)
        (println ")")
        
        /* Collect params (stored as lets) */
        let mut params: array<string> = []
        let mut types: array<string> = []
        let mut j: int = 0
        while (< j func.param_count) {
            let param: ASTLet = (parser_get_let parser (+ func.param_start j))
            set params (array_push params param.name)
            set types (array_push types (type_to_c param.var_type))
            set j (+ j 1)
        }

        if (< func.body 0) {
            /* Extern function - skip, already declared in runtime */
            (print "")
        } else {
            set emitted_bodies (array_push emitted_bodies func.name)
            let mut env0: GenEnv = global_env
            /* Seed env with parameters */
            let mut k: int = 0
            while (< k func.param_count) {
                let plet: ASTLet = (parser_get_let parser (+ func.param_start k))
                set env0 (genenv_put env0 plet.name plet.var_type)
                set k (+ k 1)
            }

            let body: string = (generate_function_body parser func.body env0 func.return_type)
            let func_code: string = (gen_function func.name params types func.return_type body)
            set sb (cg_append sb func_code)
            set sb (cg_append sb "\n")
        }
        } else { (print "") }

        set i (+ i 1)
    }
    let all_functions: string = (cg_build sb)
    
    (println "✓ Code generation complete!")
    return (gen_c_program_with_modules parser all_functions)
}

shadow transpile_parser {
    let source: string = (+ "f" "n main() -> int { return 0 }")
    let toks: List<LexerToken> = (tokenize_string source)
    let p: Parser = (parse_program toks (list_LexerToken_length toks) "t.nano")
    let code: string = (transpile_parser p)
    assert (str_contains code "int main(")
}

pub fn transpile_phase(parser: Parser, output_path: string, file_name: string) -> TranspilePhaseOutput {
    let c_source: string = (transpile_parser parser)
    let diagnostics: List<CompilerDiagnostic> = (list_CompilerDiagnostic_new)
    
    # Check if parser has errors before proceeding
    let had_err: bool = (parser_has_error parser)
    if had_err {
        let diag: CompilerDiagnostic = (Diagnostics.diag_transpiler_error "TR0001" "Cannot transpile: parser has errors" (Diagnostics.diag_location file_name 0 0))
        (Diagnostics.diag_list_add diagnostics diag)
    } else { (print "") }

    return TranspilePhaseOutput {
        c_source: c_source,
        diagnostics: diagnostics,
        had_error: had_err,
        output_path: output_path
    }
}

shadow transpile_phase {
    let parser: Parser = (parser_init_ast_lists)
    let output: TranspilePhaseOutput = (transpile_phase parser "a.out.c")
    assert (== output.had_error false)
}

/* Simplified transpile for count-based code generation */
fn transpile_with_count(func_count: int) -> string {
    (println "=== Code Generation ===")
    (print "Generating C code for ")
    (print (int_to_string func_count))
    (println " functions")
    
    /* Generate main function that demonstrates successful compilation */
    let mut body: string = ""
    set body (+ body (gen_indent 1))
    set body (+ body "nl_println(\"========================================\");\n")
    set body (+ body (gen_indent 1))
    set body (+ body "nl_println(\"  nanolang Self-Hosted Compiler\");\n")
    set body (+ body (gen_indent 1))
    set body (+ body "nl_println(\"  Successfully compiled and generated!\");\n")
    set body (+ body (gen_indent 1))
    set body (+ body "nl_println(\"========================================\");\n")
    set body (+ body (gen_indent 1))
    set body (+ body "nl_println(\"\");\n")
    set body (+ body (gen_indent 1))
    
    /* Show compilation stats */
    set body (+ body "nl_print(\"Functions parsed: \");\n")
    set body (+ body (gen_indent 1))
    set body (+ body "nl_print(nl_int_to_string(")
    set body (+ body (int_to_string func_count))
    set body (+ body "));\n")
    set body (+ body (gen_indent 1))
    set body (+ body "nl_println(\"\");\n")
    set body (+ body (gen_indent 1))
    set body (+ body "nl_println(\"NSType checking: PASSED\");\n")
    set body (+ body (gen_indent 1))
    set body (+ body "nl_println(\"Code generation: COMPLETE\");\n")
    set body (+ body (gen_indent 1))
    set body (+ body "nl_println(\"\");\n")
    
    set body (+ body (gen_return "0" 1))
    
    let params: array<string> = []
    let types: array<string> = []
    let main_func: string = (gen_function "main" params types "int" body)
    return (gen_c_program main_func)
}

shadow transpile_with_count {
    let code: string = (transpile_with_count 2)
    assert (str_contains code "Functions parsed:")
}

/* Wrapper for integration (no parser argument) */
fn transpile() -> string {
    /* Simplified version - generates code for one function */
    return (transpile_with_count 1)
}

shadow transpile {
    let c_code: string = (transpile)
    /* Just verify it generates something */
    assert (!= c_code "")
}

/* =============================================================================
 * MAIN ENTRY POINT (For Testing) - REMOVED for library usage
 * ============================================================================= */

/* main() removed to allow importing as a module
 * Use transpile_parser() as the public API */
