/* Modular Self-Hosted NanoLang Compiler
 * 
 * This is the TRUE self-hosted compiler that uses import aliases
 * to compose modular components written in NanoLang.
 * 
 * Components:
 * - Lexer (tokenization)
 * - Parser (AST generation) 
 * - TypeChecker (type validation)
 * - Transpiler (C code generation)
 * 
 * Usage: nanoc input.nano -o output
 */

import "lexer_main.nano" as Lexer
import "parser.nano" as Parser  
import "typecheck.nano" as TypeCheck
import "transpiler.nano" as Transpile

/* Command line argument parsing */
struct CompilerArgs {
    input_file: string,
    output_file: string,
    keep_c: bool,
    verbose: bool,
    show_help: bool,
    has_error: bool
}

fn parse_args() -> CompilerArgs {
    /* For now, use hardcoded defaults
     * TODO: Parse actual command line args */
    return CompilerArgs {
        input_file: "test.nano",
        output_file: "a.out",
        keep_c: false,
        verbose: false,
        show_help: false,
        has_error: false
    }
}

fn show_usage() -> void {
    (println "")
    (println "NanoLang Modular Self-Hosted Compiler v0.4.0")
    (println "")
    (println "Usage: nanoc <input.nano> [options]")
    (println "")
    (println "Options:")
    (println "  -o <file>    Output executable name")
    (println "  -k, --keep   Keep generated C file")
    (println "  -v           Verbose output")
    (println "  -h, --help   Show this help")
    (println "")
    (println "Components:")
    (println "  Lexer:       lexer_main.nano")
    (println "  Parser:      parser.nano")
    (println "  TypeChecker: typecheck.nano")
    (println "  Transpiler:  transpiler.nano")
    (println "")
    (println "All components written in NanoLang!")
    (println "")
}

fn compile_file(input: string, output: string, keep_c: bool, verbose: bool) -> int {
    if verbose {
        (println "=== NanoLang Modular Compiler ===")
        (println "Input:  ")
        (println input)
        (println "Output: ")
        (println output)
        (println "")
    } else {
        /* quiet mode */
    }
    
    /* Step 1: Read source file */
    if verbose {
        (println "Reading source file...")
    }
    let source: string = (read_file input)
    
    /* Step 2: Lexer - Tokenize */
    if verbose {
        (println "Tokenizing...")
    } else {
        /* quiet */
    }
    /* TODO: Call Lexer.tokenize once we have it exported */
    /* let tokens = (Lexer.tokenize source) */
    
    /* Step 3: Parser - Build AST */
    if verbose {
        (println "Parsing...")
    } else {
        /* quiet */
    }
    /* TODO: Call Parser.parse_program */
    /* let ast = (Parser.parse_program tokens) */
    
    /* Step 4: TypeChecker - Validate types */
    if verbose {
        (println "Type checking...")
    } else {
        /* quiet */
    }
    /* TODO: Call TypeCheck.typecheck */
    /* let type_ok = (TypeCheck.typecheck ast) */
    
    /* Step 5: Transpiler - Generate C */
    if verbose {
        (println "Generating C code...")
    } else {
        /* quiet */
    }
    /* TODO: Call Transpile.transpile */
    /* let c_code = (Transpile.transpile ast) */
    
    /* Step 6: Write C file */
    let c_file: string = (str_concat output ".c")
    if verbose {
        (println "Writing C file: ")
        (println c_file)
    } else {
        /* quiet */
    }
    /* (write_file c_file c_code) */
    
    /* Step 7: Compile C to binary */
    if verbose {
        (println "Compiling C to binary...")
    } else {
        /* quiet */
    }
    let gcc_cmd: string = (str_concat "gcc " c_file)
    let gcc_cmd2: string = (str_concat gcc_cmd " -o ")
    let gcc_cmd3: string = (str_concat gcc_cmd2 output)
    let gcc_result: int = (system gcc_cmd3)
    
    if (!= gcc_result 0) {
        (println "ERROR: C compilation failed!")
        return 1
    }
    
    /* Step 8: Clean up */
    if (not keep_c) {
        if verbose {
            (println "Removing C file...")
        } else {
            /* no-op */
        }
        /* TODO: file_remove(c_file) */
    } else {
        /* keep C file */
    }
    
    if verbose {
        (println "")
        (println "Compilation successful!")
        (println "Output: ")
        (println output)
    } else {
        /* quiet */
    }
    
    return 0
}

fn main() -> int {
    (println "")
    (println "ðŸš€ NanoLang Modular Self-Hosted Compiler")
    (println "Lexer + Parser + TypeChecker + Transpiler")
    (println "All written in NanoLang with import aliases!")
    (println "")
    
    let args: CompilerArgs = (parse_args)
    
    if args.show_help {
        (show_usage)
        return 0
    } else {
        if args.has_error {
            (show_usage)
            return 1
        } else {
            return (compile_file args.input_file args.output_file args.keep_c args.verbose)
        }
    }
}

shadow show_usage {
    (show_usage)
    assert (== 1 1)
}

shadow parse_args {
    let args: CompilerArgs = (parse_args)
    assert (str_equals args.output_file "a.out")
}

shadow main {
    /* Integration test - just verify it runs */
    assert (== (main) 0)
}
