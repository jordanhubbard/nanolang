/* Modular Self-Hosted NanoLang Compiler
 * 
 * This is the TRUE self-hosted compiler that uses import aliases
 * to compose modular components written in NanoLang.
 * 
 * Components:
 * - Lexer (tokenization)
 * - Parser (AST generation) 
 * - TypeChecker (type validation)
 * - Transpiler (C code generation)
 * 
 * Usage: nanoc input.nano -o output
 */

import "src_nano/compiler/ir.nano"
import "lexer_main.nano" as Lexer
import "parser.nano" as Parser  
import "typecheck.nano" as TypeCheck
import "transpiler.nano" as Transpile

/* Command line argument parsing */
struct CompilerArgs {
    input_file: string,
    output_file: string,
    keep_c: bool,
    verbose: bool,
    show_help: bool,
    has_error: bool
}

fn parse_args() -> CompilerArgs {
    /* This proof-of-concept uses hardcoded defaults.
     * For full CLI arg parsing, see nanoc_v06.nano */
    return CompilerArgs {
        input_file: "test.nano",
        output_file: "a.out",
        keep_c: false,
        verbose: false,
        show_help: false,
        has_error: false
    }
}

fn show_usage() -> void {
    (println "")
    (println "NanoLang Modular Self-Hosted Compiler v0.4.0")
    (println "")
    (println "Usage: nanoc <input.nano> [options]")
    (println "")
    (println "Options:")
    (println "  -o <file>    Output executable name")
    (println "  -k, --keep   Keep generated C file")
    (println "  -v           Verbose output")
    (println "  -h, --help   Show this help")
    (println "")
    (println "Components:")
    (println "  Lexer:       lexer_main.nano")
    (println "  Parser:      parser.nano")
    (println "  TypeChecker: typecheck.nano")
    (println "  Transpiler:  transpiler.nano")
    (println "")
    (println "All components written in NanoLang!")
    (println "")
}

fn severity_to_string(severity: int) -> string {
    if (== severity DiagnosticSeverity.DIAG_ERROR) {
        return "error"
    } else {
        if (== severity DiagnosticSeverity.DIAG_WARNING) {
            return "warning"
        } else {
            return "info"
        }
    }
}

fn phase_to_string(phase: int) -> string {
    if (== phase CompilerPhase.PHASE_LEXER) { return "lexer" }
    else { if (== phase CompilerPhase.PHASE_PARSER) { return "parser" }
    else { if (== phase CompilerPhase.PHASE_TYPECHECK) { return "typecheck" }
    else { if (== phase CompilerPhase.PHASE_TRANSPILER) { return "transpiler" }
    else { if (== phase CompilerPhase.PHASE_RUNTIME) { return "runtime" }
    else { return "unknown" } } } } }
}

fn print_single_diagnostic(diag: CompilerDiagnostic) -> void {
    let severity_label: string = (severity_to_string diag.severity)
    let phase_label: string = (phase_to_string diag.phase)
    (print "  [")
    (print phase_label)
    (print "] ")
    (print severity_label)
    (print " ")
    (print diag.code)
    (print ": ")
    (println diag.message)
    if (!= diag.location.file "") {
        (print "      at ")
        (print diag.location.file)
        (print ":")
        (print (int_to_string diag.location.line))
        (print ":")
        (println (int_to_string diag.location.column))
    }
}

fn print_phase_diagnostics(phase_label: string, diagnostics: List<CompilerDiagnostic>) -> void {
    let count: int = (list_CompilerDiagnostic_length diagnostics)
    if (<= count 0) {
        return
    } else {
        (print "[")
        (print phase_label)
        (println "] diagnostics:")
        let mut i: int = 0
        while (< i count) {
            let diag: CompilerDiagnostic = (list_CompilerDiagnostic_get diagnostics i)
            (print_single_diagnostic diag)
            set i (+ i 1)
        }
    }
}

fn phase_failed(phase_label: string, had_error: bool, diagnostics: List<CompilerDiagnostic>) -> bool {
    (print_phase_diagnostics phase_label diagnostics)
    if had_error {
        (print "[")
        (print phase_label)
        (println "] failed.")
        return true
    } else {
        return false
    }
}

fn compile_file(input: string, output: string, keep_c: bool, verbose: bool) -> int {
    if verbose {
        (println "=== NanoLang Modular Compiler ===")
        (println "Input:  ")
        (println input)
        (println "Output: ")
        (println output)
        (println "")
    } else {
        /* quiet mode */
    }
    
    /* Step 1: Read source file */
    if verbose {
        (println "Reading source file...")
    }
    let source: string = (file_read input)
    
    /* Step 2: Lexer - Tokenize */
    if verbose {
        (println "Tokenizing...")
    }
    let lex_output: LexPhaseOutput = (Lexer.lex_phase_run source input)
    if verbose {
        (print "  Tokens: ")
        (println (int_to_string lex_output.token_count))
    }
    if (phase_failed "Lexer" lex_output.had_error lex_output.diagnostics) {
        return 1
    }
    
    /* Step 3: Parser - Build AST */
    if verbose {
        (println "Parsing...")
    }
    let parse_output: ParsePhaseOutput = (Parser.parse_phase_run lex_output)
    let parser_state: Parser = parse_output.parser
    if verbose {
        (print "  Functions: ")
        (println (int_to_string parser_state.functions_count))
    }
    if (phase_failed "Parser" parse_output.had_error parse_output.diagnostics) {
        return 1
    }
    
    /* Step 4: TypeChecker - Validate types */
    if verbose {
        (println "NSType checking...")
    }
    let type_output: TypecheckPhaseOutput = (TypeCheck.typecheck_phase parser_state)
    if verbose {
        (println "  NSType check complete")
    }
    if (phase_failed "Typecheck" type_output.had_error type_output.diagnostics) {
        return 1
    }
    
    /* Step 5: Transpiler - Generate C */
    if verbose {
        (println "Generating C code...")
    }
    let c_file: string = (+ output ".c")
    let transpile_output: TranspilePhaseOutput = (Transpile.transpile_phase parser_state c_file)
    if (phase_failed "Transpiler" transpile_output.had_error transpile_output.diagnostics) {
        return 1
    }
    let c_code: string = transpile_output.c_source
    
    /* Step 6: Write C file */
    if verbose {
        (println "Writing C file: ")
        (println c_file)
    } else {
        /* quiet */
    }
    /* (write_file c_file c_code) */
    
    /* Step 7: Compile C to binary */
    if verbose {
        (println "Compiling C to binary...")
    } else {
        /* quiet */
    }
    let gcc_cmd: string = (+ (+ (+ "gcc " c_file) " -o ") output)
    let gcc_result: int = (system gcc_cmd)
    
    if (!= gcc_result 0) {
        (println "ERROR: C compilation failed!")
        return 1
    }
    
    /* Step 8: Clean up
     * File removal available via stdlib file operations */
    if (not keep_c) {
        if verbose {
            (println "Removing C file...")
        } else {
            /* no-op */
        }
    } else {
        /* keep C file */
    }
    
    if verbose {
        (println "")
        (println "Compilation successful!")
        (println "Output: ")
        (println output)
    } else {
        /* quiet */
    }
    
    return 0
}

fn main() -> int {
    (println "")
    (println "ðŸš€ NanoLang Modular Self-Hosted Compiler")
    (println "Lexer + Parser + TypeChecker + Transpiler")
    (println "All written in NanoLang with import aliases!")
    (println "")
    
    let args: CompilerArgs = (parse_args)
    
    if args.show_help {
        (show_usage)
        return 0
    } else {
        if args.has_error {
            (show_usage)
            return 1
        } else {
            return (compile_file args.input_file args.output_file args.keep_c args.verbose)
        }
    }
}

shadow show_usage {
    (show_usage)
    assert (== 1 1)
}

shadow parse_args {
    let args: CompilerArgs = (parse_args)
    assert (str_equals args.output_file "a.out")
}

shadow main {
    /* Integration test - just verify it runs */
    assert (== (main) 0)
}
