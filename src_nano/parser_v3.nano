/* =============================================================================
 * nanolang Parser v3 - Incremental Implementation
 * =============================================================================
 * Building on parser_mvp.nano, adding actual parsing logic
 */

/* AST Node Types */
enum ParseNodeType {
    PNODE_NUMBER = 0,
    PNODE_STRING = 1,
    PNODE_BOOL = 2,
    PNODE_IDENTIFIER = 3,
    PNODE_BINARY_OP = 4,
    PNODE_CALL = 5,
    PNODE_LET = 6,
    PNODE_BLOCK = 7,
    PNODE_PROGRAM = 8
}

/* Token types - matching lexer */
enum TokenType {
    EOF = 0,
    NUMBER = 1,
    STRING = 3,
    IDENTIFIER = 4,
    TRUE = 5,
    FALSE = 6,
    LPAREN = 7,
    RPAREN = 8,
    LBRACE = 9,
    RBRACE = 10,
    COMMA = 13,
    COLON = 14,
    ASSIGN = 16,
    LET = 20,
    MUT = 21,
    PLUS = 42,
    MINUS = 43,
    STAR = 44
}

/* LexToken structure */
struct LexToken {
    token_type: int,
    value: string,
    line: int,
    column: int
}

/* AST Node Types */
struct ASTNumber {
    node_type: int,
    line: int,
    column: int,
    value: string
}

struct ASTIdentifier {
    node_type: int,
    line: int,
    column: int,
    name: string
}

struct ASTBinaryOp {
    node_type: int,
    line: int,
    column: int,
    op: int,
    left: int,
    right: int
}

/* Parser State */
struct Parser {
    position: int,
    token_count: int,
    has_error: bool
}

/* Create new parser */
fn parser_new(token_count: int) -> Parser {
    return Parser {
        position: 0,
        token_count: token_count,
        has_error: false
    }
}

shadow parser_new {
    let p: Parser = (parser_new 10)
    assert (== p.position 0)
    assert (== p.token_count 10)
    assert (== p.has_error false)
}

/* Check if at end */
fn parser_is_at_end(p: Parser) -> bool {
    return (>= p.position p.token_count)
}

shadow parser_is_at_end {
    let p: Parser = (parser_new 5)
    assert (== (parser_is_at_end p) false)
    
    set p.position 5
    assert (== (parser_is_at_end p) true)
}

/* Advance parser */
fn parser_advance(p: Parser) -> bool {
    if (< p.position p.token_count) {
        set p.position (+ p.position 1)
        return true
    } else {
        return false
    }
}

shadow parser_advance {
    let mut p: Parser = (parser_new 3)
    
    let ok1: bool = (parser_advance p)
    assert (== ok1 true)
    assert (== p.position 1)
    
    let ok2: bool = (parser_advance p)
    assert (== ok2 true)
    assert (== p.position 2)
    
    let ok3: bool = (parser_advance p)
    assert (== ok3 true)
    assert (== p.position 3)
    
    let ok4: bool = (parser_advance p)
    assert (== ok4 false)
    assert (== p.position 3)
}

/* Create number node */
fn create_number_node(value: string, line: int, column: int) -> ASTNumber {
    return ASTNumber {
        node_type: ParseNodeType.PNODE_NUMBER,
        line: line,
        column: column,
        value: value
    }
}

shadow create_number_node {
    let node: ASTNumber = (create_number_node "42" 1 1)
    assert (== node.node_type ParseNodeType.PNODE_NUMBER)
    assert (== node.value "42")
}

/* Create identifier node */
fn create_identifier_node(name: string, line: int, column: int) -> ASTIdentifier {
    return ASTIdentifier {
        node_type: ParseNodeType.PNODE_IDENTIFIER,
        line: line,
        column: column,
        name: name
    }
}

shadow create_identifier_node {
    let node: ASTIdentifier = (create_identifier_node "x" 1 1)
    assert (== node.node_type ParseNodeType.PNODE_IDENTIFIER)
    assert (== node.name "x")
}

fn main() -> int {
    (println "Parser v3: Token management working")
    (println "Ready for expression parsing")
    return 0
}

shadow main {
    assert (== (main) 0)
}

