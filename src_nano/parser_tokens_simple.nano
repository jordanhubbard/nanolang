/* =============================================================================
 * nanolang Parser - Token Management (Simplified)
 * =============================================================================
 * Handles token stream navigation without conflicting type definitions
 */

/* Parser state - simple token management */
struct ParserState {
    token_count: int,
    current: int,
    has_error: bool
}

/* Create new parser */
fn parser_new() -> ParserState {
    let p: ParserState = ParserState{
        token_count: 0,
        current: 0,
        has_error: false
    }
    return p
}

shadow parser_new {
    let p: ParserState = (parser_new)
    assert (== p.current 0)
    assert (== p.has_error false)
}

/* Initialize parser with token count */
fn parser_init(token_count: int) -> ParserState {
    let p: ParserState = ParserState{
        token_count: token_count,
        current: 0,
        has_error: false
    }
    return p
}

shadow parser_init {
    let p: ParserState = (parser_init 10)
    assert (== p.token_count 10)
    assert (== p.current 0)
}

/* Check if at end of tokens */
fn parser_is_at_end(p: ParserState) -> bool {
    return (>= p.current p.token_count)
}

shadow parser_is_at_end {
    let p: ParserState = (parser_init 5)
    assert (== (parser_is_at_end p) false)
    
    set p.current 5
    assert (== (parser_is_at_end p) true)
    
    set p.current 10
    assert (== (parser_is_at_end p) true)
}

/* Get current position */
fn parser_position(p: ParserState) -> int {
    return p.current
}

shadow parser_position {
    let p: ParserState = (parser_init 10)
    assert (== (parser_position p) 0)
    
    set p.current 3
    assert (== (parser_position p) 3)
}

/* Advance to next token */
fn parser_advance(p: ParserState) -> bool {
    if (< p.current p.token_count) {
        set p.current (+ p.current 1)
        return true
    } else {
        return false
    }
}

shadow parser_advance {
    let p: ParserState = (parser_init 3)
    
    /* Advance from 0 to 1 */
    let ok1: bool = (parser_advance p)
    assert (== ok1 true)
    assert (== p.current 1)
    
    /* Advance from 1 to 2 */
    let ok2: bool = (parser_advance p)
    assert (== ok2 true)
    assert (== p.current 2)
    
    /* Advance from 2 to 3 */
    let ok3: bool = (parser_advance p)
    assert (== ok3 true)
    assert (== p.current 3)
    
    /* Try to advance past end */
    let ok4: bool = (parser_advance p)
    assert (== ok4 false)
    assert (== p.current 3)
}

/* Peek ahead by offset */
fn parser_can_peek(p: ParserState, offset: int) -> bool {
    let pos: int = (+ p.current offset)
    return (< pos p.token_count)
}

shadow parser_can_peek {
    let p: ParserState = (parser_init 5)
    
    /* At position 0 */
    assert (== (parser_can_peek p 0) true)   /* current token */
    assert (== (parser_can_peek p 1) true)   /* next token */
    assert (== (parser_can_peek p 4) true)   /* last token */
    assert (== (parser_can_peek p 5) false)  /* past end */
    
    /* Move to position 3 */
    set p.current 3
    assert (== (parser_can_peek p 0) true)
    assert (== (parser_can_peek p 1) true)
    assert (== (parser_can_peek p 2) false)
}

/* Set error state */
fn parser_set_error(p: ParserState) -> int {
    set p.has_error true
    return 0
}

shadow parser_set_error {
    let p: ParserState = (parser_new)
    assert (== p.has_error false)
    
    let result: int = (parser_set_error p)
    assert (== p.has_error true)
    assert (== result 0)
}

/* Check error state */
fn parser_has_error(p: ParserState) -> bool {
    return p.has_error
}

shadow parser_has_error {
    let p: ParserState = (parser_new)
    assert (== (parser_has_error p) false)
    
    (parser_set_error p)
    assert (== (parser_has_error p) true)
}

/* Main test */
fn main() -> int {
    (println "Parser Phase 1: Token Management (Simplified)")
    (println "==============================================")
    (println "")
    (println "✅ Token navigation: Working")
    (println "✅ Position tracking: Working")
    (println "✅ Error handling: Working")
    (println "")
    (println "Phase 1 Complete! Ready for expression parsing.")
    return 0
}

shadow main {
    assert (== (main) 0)
}

