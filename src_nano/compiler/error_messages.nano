/* =============================================================================
 * Elm-Style Error Messages for NanoLang
 * =============================================================================
 * High-quality, helpful error messages that guide users to solutions.
 * 
 * Design Principles (from Elm):
 * 1. **Be clear and specific** - Tell exactly what went wrong
 * 2. **Show the code** - Display the problematic code with highlighting
 * 3. **Suggest fixes** - Provide actionable recommendations
 * 4. **Be friendly** - Use encouraging, non-judgmental language
 * 5. **Add context** - Explain why this is an error
 * 
 * Example:
 *   -- TYPE MISMATCH ---------------------------------------- src/Main.nano
 *   
 *   The function `add` expects 2 arguments, but I see 3:
 *   
 *   12| let result: int = (add 1 2 3)
 *                           ^^^^^^^^^^
 *   
 *   This `add` function has type:
 *   
 *       fn(int, int) -> int
 *   
 *   But you are calling it with 3 arguments. Did you mean to use a
 *   different function?
 */

import "src_nano/compiler/diagnostics.nano"
import "src_nano/compiler/ir.nano"

/* =============================================================================
 * ERROR MESSAGE STRUCTURE
 * ============================================================================= */

struct ErrorMessage {
    title: string,           # e.g., "TYPE MISMATCH"
    file: string,            # e.g., "src/Main.nano"
    line: int,
    column: int,
    problem: string,         # Main description
    code_snippet: string,    # The problematic code
    explanation: string,     # Why this is an error
    suggestion: string       # How to fix it
}

pub fn error_message_new(title: string, file: string, line: int, column: int) -> ErrorMessage {
    return ErrorMessage {
        title: title,
        file: file,
        line: line,
        column: column,
        problem: "",
        code_snippet: "",
        explanation: "",
        suggestion: ""
    }
}

shadow error_message_new {
    let err: ErrorMessage = (error_message_new "TEST ERROR" "test.nano" 10 5)
    assert (== err.title "TEST ERROR")
    assert (== err.file "test.nano")
    assert (== err.line 10)
}

/* =============================================================================
 * STRING HELPERS FOR FORMATTING
 * ============================================================================= */

fn repeat_string(s: string, count: int) -> string {
    let mut out: string = ""
    let mut i: int = 0
    while (< i count) {
        set out (+ out s)
        set i (+ i 1)
    }
    return out
}

shadow repeat_string {
    assert (== (repeat_string "ab" 2) "abab")
}

fn pad_right(s: string, target_len: int) -> string {
    let len: int = (str_length s)
    if (>= len target_len) {
        return s
    }
    return (+ s (repeat_string " " (- target_len len)))
}

shadow pad_right {
    assert (== (pad_right "hi" 4) "hi  ")
}

fn wrap_backticks(value: string) -> string {
    return (+ "`" (+ value "`"))
}

shadow wrap_backticks {
    assert (== (wrap_backticks "value") "`value`")
}

fn get_line_from_source(source: string, target_line: int) -> string {
    let mut current_line: int = 1
    let mut start_idx: int = 0
    let mut i: int = 0
    let total_len: int = (str_length source)
    
    while (< i total_len) {
        if (== (char_at source i) 10) { # 10 is '\n'
            if (== current_line target_line) {
                return (str_substring source start_idx (- i start_idx))
            }
            set current_line (+ current_line 1)
            set start_idx (+ i 1)
        }
        set i (+ i 1)
    }
    
    if (== current_line target_line) {
        return (str_substring source start_idx (- total_len start_idx))
    }
    
    return ""
}

shadow get_line_from_source {
    let source: string = "line 1
line 2
line 3"
    let l1: string = (get_line_from_source source 1)
    # (print "Line 1: [") (print l1) (println "]")
    assert (== l1 "line 1")
    let l2: string = (get_line_from_source source 2)
    # (print "Line 2: [") (print l2) (println "]")
    assert (== l2 "line 2")
    let l3: string = (get_line_from_source source 3)
    # (print "Line 3: [") (print l3) (println "]")
    assert (== l3 "line 3")
}

/* =============================================================================
 * ERROR FORMATTING
 * ============================================================================= */

/* Format an error message in Elm style */
pub fn format_error_elm_style(err: ErrorMessage, source: string) -> string {
    let mut out: string = ""
    
    # 1. Header line: -- TITLE ---------------------------------------- FILE
    let mut header_base: string = (+ "-- " (+ err.title " "))
    let mut dash_count: int = (- 60 (str_length header_base))
    if (< dash_count 5) { set dash_count 5 }
    let mut full_header: string = (+ header_base (+ (repeat_string "-" dash_count) (+ " " err.file)))
    
    set out (+ full_header "\n\n")
    
    # 2. Problem description
    set out (+ out (+ err.problem "\n\n"))
    
    # 3. Code snippet with highlighting
    if (> err.line 0) {
        let line_content: string = (get_line_from_source source err.line)
        let line_num_str: string = (int_to_string err.line)
        let padding: string = (repeat_string " " (str_length line_num_str))
        
        set out (+ out (+ line_num_str (+ "| " (+ line_content "\n"))))
        set out (+ out (+ padding (+ "| " (+ (repeat_string " " (- err.column 1)) "^\n\n"))))
    }
    
    # 4. Explanation
    if (!= err.explanation "") {
        set out (+ out (+ err.explanation "\n\n"))
    }
    
    # 5. Suggestion
    if (!= err.suggestion "") {
        set out (+ out (+ "Hint: " (+ err.suggestion "\n")))
    }
    
    return out
}

/* =============================================================================
 * CONVERT DIAGNOSTICS TO ELM ERRORS
 * ============================================================================= */

fn build_error_explanations() -> HashMap<string, string> {
    let m: HashMap<string, string> = (map_new)
    (map_put m "E0001" "NanoLang enforces explicit types, so the expression must match the expected annotation.")
    (map_put m "E0002" "The compiler could not find a declaration with this name in the current scope.")
    (map_put m "E0003" "Functions require the exact number of arguments specified in their signature.")
    (map_put m "E0004" "Each argument must match the corresponding parameter type declared in the function signature.")
    (map_put m "E0005" "Bindings are immutable unless declared with `mut`, so you cannot reassign them.")
    return m
}

shadow build_error_explanations {
    let m: HashMap<string, string> = (build_error_explanations)
    assert (map_has m "E0002")
}

fn build_error_suggestions() -> HashMap<string, string> {
    let m: HashMap<string, string> = (map_new)
    (map_put m "E0001" "Convert the expression to the expected type or change the annotation.")
    (map_put m "E0002" "Check for typos or declare the identifier with `let` before using it.")
    (map_put m "E0003" "Add the missing arguments or remove extras so the call arity matches the definition.")
    (map_put m "E0004" "Convert the argument to the required type or update the function signature if the annotation is wrong.")
    (map_put m "E0005" "Declare the variable with `mut` or create a new binding instead of reassigning.")
    return m
}

shadow build_error_suggestions {
    let m: HashMap<string, string> = (build_error_suggestions)
    assert (map_has m "E0005")
}

fn explanation_for_code(code: string) -> string {
    let explanations: HashMap<string, string> = (build_error_explanations)
    if (map_has explanations code) {
        return (map_get explanations code)
    } else {
        return ""
    }
}

shadow explanation_for_code {
    assert (str_contains (explanation_for_code "E0002") "scope")
}

fn suggestion_for_code(code: string) -> string {
    let suggestions: HashMap<string, string> = (build_error_suggestions)
    if (map_has suggestions code) {
        return (map_get suggestions code)
    } else {
        return ""
    }
}

shadow suggestion_for_code {
    assert (str_contains (suggestion_for_code "E0005") "mut")
}

pub fn diagnostic_to_elm_error(diag: CompilerDiagnostic) -> ErrorMessage {
    let mut title: string = "INFO"
    if (== diag.code "E0001") {
        set title "TYPE MISMATCH"
    } else {
        if (== diag.code "E0002") {
            set title "UNDEFINED IDENTIFIER"
        } else {
            if (== diag.severity 2) {
                set title "ERROR"
            } else {
                if (== diag.severity 1) {
                    set title "WARNING"
                } else {
                    (print "")
                }
            }
        }
    }

    let loc: CompilerSourceLocation = diag.location
    return ErrorMessage {
        title: title,
        file: loc.file,
        line: loc.line,
        column: loc.column,
        problem: diag.message,
        code_snippet: "",
        explanation: (explanation_for_code diag.code),
        suggestion: (suggestion_for_code diag.code)
    }
}

shadow diagnostic_to_elm_error {
    let loc: CompilerSourceLocation = CompilerSourceLocation { file: "test.nano", line: 2, column: 5 }
    let diag: CompilerDiagnostic = CompilerDiagnostic { severity: DiagnosticSeverity.DIAG_ERROR, phase: CompilerPhase.PHASE_TYPECHECK, code: "E0002", message: "Undefined identifier", location: loc }
    let err: ErrorMessage = (diagnostic_to_elm_error diag)
    assert (== err.title "UNDEFINED IDENTIFIER")
    assert (str_contains err.explanation "declaration")
}

pub fn format_diagnostics_elm_style(diags: List<CompilerDiagnostic>, source: string) -> string {
    let mut out: string = ""
    let count: int = (diag_list_count diags)
    let mut i: int = 0
    
    while (< i count) {
        let diag: CompilerDiagnostic = (diag_list_get diags i)
        let elm_err: ErrorMessage = (diagnostic_to_elm_error diag)
        set out (+ out (format_error_elm_style elm_err source))
        set out (+ out "\n")
        set i (+ i 1)
    }
    
    return out
}

shadow format_error_elm_style {
    let err: ErrorMessage = (error_message_new "TYPE MISMATCH" "test.nano" 1 1)
    let source: string = "let x: int = \"hello\""
    let formatted: string = (format_error_elm_style err source)
    (println formatted)
}

shadow format_diagnostics_elm_style {
    let loc: CompilerSourceLocation = CompilerSourceLocation { file: "test.nano", line: 1, column: 1 }
    let diag: CompilerDiagnostic = CompilerDiagnostic { severity: DiagnosticSeverity.DIAG_ERROR, phase: CompilerPhase.PHASE_TYPECHECK, code: "E0001", message: "Type mismatch", location: loc }
    let diags: List<CompilerDiagnostic> = (diag_list_new)
    (diag_list_add diags diag)
    let output: string = (format_diagnostics_elm_style diags "let x: int = 0")
    assert (str_contains output "TYPE MISMATCH")
}

/* =============================================================================
 * COMMON ERROR PATTERNS
 * ============================================================================= */

/* NSType mismatch error */
pub fn error_type_mismatch(
    file: string,
    line: int,
    column: int,
    expected: string,
    found: string,
    context: string
) -> ErrorMessage {
    let problem: string = (encode_type_mismatch_message context expected found "")
    let mut explanation: string = (explanation_for_code "E0001")
    if (== context "function_argument") {
        set explanation (+ "The function signature declares this parameter as " (+ (wrap_backticks expected) "."))
    } else {
        if (== context "variable_assignment") {
            set explanation (+ "The variable was declared with type " (+ (wrap_backticks expected) "."))
        } else {
            (print "")
        }
    }
    let suggestion: string = (suggestion_for_code "E0001")
    return ErrorMessage {
        title: "TYPE MISMATCH",
        file: file,
        line: line,
        column: column,
        problem: problem,
        code_snippet: "",
        explanation: explanation,
        suggestion: suggestion
    }
}

shadow error_type_mismatch {
    let err: ErrorMessage = (error_type_mismatch "test.nano" 10 5 "int" "string" "argument")
    assert (== err.title "TYPE MISMATCH")
}

/* Undefined variable error */
pub fn error_undefined_variable(
    file: string,
    line: int,
    column: int,
    var_name: string,
    similar_names: List<string>
) -> ErrorMessage {
    let problem: string = (encode_undefined_name_message var_name)
    let explanation: string = (explanation_for_code "E0002")
    let name_count: int = (list_string_length similar_names)
    let mut suggestion: string = (+ "Make sure to declare " (+ (wrap_backticks var_name) " with `let` before using it."))
    if (> name_count 0) {
        let mut hint: string = "Did you mean one of these?\n"
        let mut i: int = 0
        while (< i name_count) {
            let candidate: string = (list_string_get similar_names i)
            set hint (+ hint (+ "    " (+ candidate "\n")))
            set i (+ i 1)
        }
        set suggestion hint
    } else {
        (print "")
    }
    return ErrorMessage {
        title: "UNDEFINED VARIABLE",
        file: file,
        line: line,
        column: column,
        problem: problem,
        code_snippet: "",
        explanation: explanation,
        suggestion: suggestion
    }
}

shadow error_undefined_variable {
    let similar: List<string> = (list_string_new)
    let err: ErrorMessage = (error_undefined_variable "test.nano" 10 5 "countr" similar)
    assert (== err.title "UNDEFINED VARIABLE")
}

/* Arity mismatch error */
pub fn error_arity_mismatch(
    file: string,
    line: int,
    column: int,
    function_name: string,
    expected_args: int,
    found_args: int
) -> ErrorMessage {
    let problem: string = (encode_wrong_arg_count_message function_name expected_args found_args)
    let explanation: string = (+ "The function " (+ (wrap_backticks function_name) " requires exactly this many arguments."))
    let mut suggestion: string = "Add the missing arguments to match the function signature."
    if (> found_args expected_args) {
        set suggestion "Remove the extra arguments to match the function signature."
    } else {
        (print "")
    }
    return ErrorMessage {
        title: "WRONG NUMBER OF ARGUMENTS",
        file: file,
        line: line,
        column: column,
        problem: problem,
        code_snippet: "",
        explanation: explanation,
        suggestion: suggestion
    }
}

shadow error_arity_mismatch {
    let err: ErrorMessage = (error_arity_mismatch "test.nano" 10 5 "add" 2 3)
    assert (== err.title "WRONG NUMBER OF ARGUMENTS")
}

/* Missing return error */
pub fn error_missing_return(
    file: string,
    line: int,
    column: int,
    function_name: string,
    expected_type: string
) -> ErrorMessage {
    let problem: string = (encode_missing_return_message function_name expected_type)
    let explanation: string = "All execution paths in a function must return a value of the declared type. Right now, some branches don't return anything."
    let suggestion: string = (+ "Add a `return` statement to all branches that currently fall through, returning a value of type " (+ (wrap_backticks expected_type) "."))
    return ErrorMessage {
        title: "MISSING RETURN",
        file: file,
        line: line,
        column: column,
        problem: problem,
        code_snippet: "",
        explanation: explanation,
        suggestion: suggestion
    }
}

shadow error_missing_return {
    let err: ErrorMessage = (error_missing_return "test.nano" 20 1 "calculate" "int")
    assert (== err.title "MISSING RETURN")
}

/* Immutable assignment error */
pub fn error_immutable_assignment(
    file: string,
    line: int,
    column: int,
    var_name: string
) -> ErrorMessage {
    let problem: string = (encode_immutable_assignment_message var_name)
    let explanation: string = "In NanoLang, variables are immutable by default. Once you assign a value to an immutable variable, you cannot change it later."
    let suggestion: string = (+ "To make this variable mutable, add the `mut` keyword:\n    let mut " (+ var_name ": <type> = <value>"))
    return ErrorMessage {
        title: "CANNOT ASSIGN TO IMMUTABLE VARIABLE",
        file: file,
        line: line,
        column: column,
        problem: problem,
        code_snippet: "",
        explanation: explanation,
        suggestion: suggestion
    }
}

shadow error_immutable_assignment {
    let err: ErrorMessage = (error_immutable_assignment "test.nano" 15 5 "count")
    assert (== err.title "CANNOT ASSIGN TO IMMUTABLE VARIABLE")
}

pub fn encode_type_mismatch_message(context: string, expected: string, found: string, detail: string) -> string {
    let expected_label: string = (wrap_backticks expected)
    let found_label: string = (wrap_backticks found)
    let mut base: string = (+ "I expected a value of type " (+ expected_label (+ ", but found " (+ found_label "."))))
    if (!= detail "") {
        set base (+ detail (+ ": " base))
    }
    return base
}

shadow encode_type_mismatch_message {
    let msg: string = (encode_type_mismatch_message "function_argument" "int" "string" "Argument 1 of add")
    assert (str_contains msg "Argument 1 of add")
}

pub fn encode_undefined_name_message(name: string) -> string {
    let name_label: string = (wrap_backticks name)
    return (+ "I cannot find a definition for " (+ name_label "."))
}

shadow encode_undefined_name_message {
    let msg: string = (encode_undefined_name_message "countr")
    assert (str_contains msg "countr")
}

pub fn encode_wrong_arg_count_message(function_name: string, expected_args: int, found_args: int) -> string {
    let fn_label: string = (wrap_backticks function_name)
    return (+ "The function " (+ fn_label (+ " expects " (+ (int_to_string expected_args) (+ " argument(s), but I see " (+ (int_to_string found_args) "."))))))
}

shadow encode_wrong_arg_count_message {
    let msg: string = (encode_wrong_arg_count_message "add" 2 3)
    assert (str_contains msg "expects 2")
}

pub fn encode_missing_return_message(function_name: string, expected_type: string) -> string {
    let fn_label: string = (wrap_backticks function_name)
    let type_label: string = (wrap_backticks expected_type)
    return (+ "The function " (+ fn_label (+ " promises to return " (+ type_label ", but this path has no return statement."))))
}

shadow encode_missing_return_message {
    let msg: string = (encode_missing_return_message "compute" "int")
    assert (str_contains msg "compute")
}

pub fn encode_immutable_assignment_message(var_name: string) -> string {
    let name_label: string = (wrap_backticks var_name)
    return (+ "Cannot assign to " (+ name_label " because it was declared immutable."))
}

shadow encode_immutable_assignment_message {
    let msg: string = (encode_immutable_assignment_message "total")
    assert (str_contains msg "immutable")
}

/* Unsafe call outside unsafe block */
pub fn error_unsafe_required(
    file: string,
    line: int,
    column: int,
    function_name: string
) -> ErrorMessage {
    let problem: string = (+ "The function " (+ (wrap_backticks function_name) " is marked as unsafe and must be called inside an `unsafe` block."))
    let explanation: string = "Unsafe functions can cause memory errors or undefined behavior if used incorrectly. NanoLang requires you to explicitly mark where unsafe code is used."
    let suggestion: string = (+ "Wrap the call in an unsafe block:\n    unsafe {\n        (" (+ function_name " ...)\n    }"))
    return ErrorMessage {
        title: "UNSAFE OPERATION",
        file: file,
        line: line,
        column: column,
        problem: problem,
        code_snippet: "",
        explanation: explanation,
        suggestion: suggestion
    }
}

shadow error_unsafe_required {
    let err: ErrorMessage = (error_unsafe_required "test.nano" 25 10 "malloc")
    assert (== err.title "UNSAFE OPERATION")
}

/* Resource use-after-consume error (for affine types) */
pub fn error_use_after_consume(
    file: string,
    line: int,
    column: int,
    resource_name: string,
    consumed_at_line: int
) -> ErrorMessage {
    let problem: string = (+ "I cannot use " (+ (wrap_backticks resource_name) (+ " because it was already consumed at line " (+ (int_to_string consumed_at_line) "."))))
    let explanation: string = (+ (wrap_backticks resource_name) " is a resource type. Resource types can only be used once. After you pass it to a consuming function, you cannot use it again.")
    let suggestion: string = "Restructure your code so the resource is consumed last, or use a function that borrows instead of consuming."
    return ErrorMessage {
        title: "USE AFTER CONSUME",
        file: file,
        line: line,
        column: column,
        problem: problem,
        code_snippet: "",
        explanation: explanation,
        suggestion: suggestion
    }
}

shadow error_use_after_consume {
    let err: ErrorMessage = (error_use_after_consume "test.nano" 50 5 "file" 42)
    assert (== err.title "USE AFTER CONSUME")
}

/* Resource leak error (for affine types) */
pub fn error_resource_leak(
    file: string,
    line: int,
    column: int,
    resource_name: string,
    resource_type: string
) -> ErrorMessage {
    let problem: string = (+ "The resource " (+ (wrap_backticks resource_name) (+ " of type " (+ (wrap_backticks resource_type) " was not consumed before the function returns."))))
    let explanation: string = (+ "Resource types like " (+ (wrap_backticks resource_type) " must be explicitly closed or consumed. This prevents resource leaks (like leaving files open)."))
    let suggestion: string = (+ "Add a call to consume the resource before returning:\n    unsafe { (close_" (+ resource_name (+ " " (+ resource_name ") }"))))
    return ErrorMessage {
        title: "RESOURCE LEAK",
        file: file,
        line: line,
        column: column,
        problem: problem,
        code_snippet: "",
        explanation: explanation,
        suggestion: suggestion
    }
}

shadow error_resource_leak {
    let err: ErrorMessage = (error_resource_leak "test.nano" 60 1 "file" "FileHandle")
    assert (== err.title "RESOURCE LEAK")
}

/* =============================================================================
 * ERROR TEMPLATES
 * ============================================================================= */

/* Get a friendly error template for common mistakes */
pub fn get_error_template(error_code: string) -> string {
    if (== error_code "E0001") {
        return "TYPE MISMATCH: I expected a value of type `<expected>`, but found `<found>`."
    } else {
        if (== error_code "E0002") {
            return "UNDEFINED IDENTIFIER: I cannot find a definition for `<name>` in the current scope."
        } else {
            if (== error_code "E0003") {
                return "WRONG NUMBER OF ARGUMENTS: The function `<name>` expects <n> argument(s), but I see <m>."
            } else {
                if (== error_code "E0004") {
                    return "ARGUMENT TYPE MISMATCH: Argument <n> of `<fn>` must be `<expected>`, but got `<found>`."
                } else {
                    if (== error_code "E0005") {
                        return "IMMUTABLE VARIABLE: Cannot assign to `<name>` because it was declared immutable. Use `let mut` to allow reassignment."
                    } else {
                        return (+ "Unknown error code: " error_code)
                    }
                }
            }
        }
    }
}

shadow get_error_template {
    let template: string = (get_error_template "E0001")
    (println template)
}

/* =============================================================================
 * USAGE EXAMPLES
 * =============================================================================
 * 
 * Instead of:
 *   Error at line 42: NSType mismatch
 * 
 * We show:
 *   -- TYPE MISMATCH ---------------------------------------- src/main.nano
 *   
 *   I expected a value of type `int`, but found `string`:
 *   
 *   42| let count: int = "hello"
 *                        ^^^^^^^
 *   
 *   The variable `count` was declared with type `int` on line 42.
 *   
 *   Hint: If you want to convert a string to an integer, try:
 *       (string_to_int "hello")
 * 
 * This makes errors:
 * 1. **Easier to understand** - Clear description of what went wrong
 * 2. **Easier to locate** - Shows the exact code
 * 3. **Easier to fix** - Provides concrete suggestions
 * 4. **Less intimidating** - Friendly, helpful tone
 * 
 * Future Enhancements:
 * - Color highlighting (when terminal supports it)
 * - Multi-line code snippets
 * - Links to documentation
 * - Similar error grouping (show all type mismatches together)
 * - Interactive error browser (for IDEs)
 */


