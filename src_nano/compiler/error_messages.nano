/* =============================================================================
 * Elm-Style Error Messages for NanoLang
 * =============================================================================
 * High-quality, helpful error messages that guide users to solutions.
 * 
 * Design Principles (from Elm):
 * 1. **Be clear and specific** - Tell exactly what went wrong
 * 2. **Show the code** - Display the problematic code with highlighting
 * 3. **Suggest fixes** - Provide actionable recommendations
 * 4. **Be friendly** - Use encouraging, non-judgmental language
 * 5. **Add context** - Explain why this is an error
 * 
 * Example:
 *   -- TYPE MISMATCH ---------------------------------------- src/Main.nano
 *   
 *   The function `add` expects 2 arguments, but I see 3:
 *   
 *   12| let result: int = (add 1 2 3)
 *                           ^^^^^^^^^^
 *   
 *   This `add` function has type:
 *   
 *       fn(int, int) -> int
 *   
 *   But you are calling it with 3 arguments. Did you mean to use a
 *   different function?
 */

import "src_nano/compiler/diagnostics.nano"
import "src_nano/compiler/ir.nano"

/* =============================================================================
 * ERROR MESSAGE STRUCTURE
 * ============================================================================= */

struct ErrorMessage {
    title: string,           # e.g., "TYPE MISMATCH"
    file: string,            # e.g., "src/Main.nano"
    line: int,
    column: int,
    problem: string,         # Main description
    code_snippet: string,    # The problematic code
    explanation: string,     # Why this is an error
    suggestion: string       # How to fix it
}

pub fn error_message_new(title: string, file: string, line: int, column: int) -> ErrorMessage {
    return ErrorMessage {
        title: title,
        file: file,
        line: line,
        column: column,
        problem: "",
        code_snippet: "",
        explanation: "",
        suggestion: ""
    }
}

shadow error_message_new {
    let err: ErrorMessage = (error_message_new "TEST ERROR" "test.nano" 10 5)
    assert (== err.title "TEST ERROR")
    assert (== err.file "test.nano")
    assert (== err.line 10)
}

/* =============================================================================
 * STRING HELPERS FOR FORMATTING
 * ============================================================================= */

fn repeat_string(s: string, count: int) -> string {
    let mut out: string = ""
    let mut i: int = 0
    while (< i count) {
        set out (+ out s)
        set i (+ i 1)
    }
    return out
}

shadow repeat_string {
    assert (== (repeat_string "ab" 2) "abab")
}

fn pad_right(s: string, target_len: int) -> string {
    let len: int = (str_length s)
    if (>= len target_len) {
        return s
    }
    return (+ s (repeat_string " " (- target_len len)))
}

shadow pad_right {
    assert (== (pad_right "hi" 4) "hi  ")
}

fn wrap_backticks(value: string) -> string {
    return (+ "`" (+ value "`"))
}

shadow wrap_backticks {
    assert (== (wrap_backticks "value") "`value`")
}

fn get_line_from_source(source: string, target_line: int) -> string {
    let mut current_line: int = 1
    let mut start_idx: int = 0
    let mut i: int = 0
    let total_len: int = (str_length source)
    
    while (< i total_len) {
        if (== (char_at source i) 10) { # 10 is '\n'
            if (== current_line target_line) {
                return (str_substring source start_idx (- i start_idx))
            }
            set current_line (+ current_line 1)
            set start_idx (+ i 1)
        }
        set i (+ i 1)
    }
    
    if (== current_line target_line) {
        return (str_substring source start_idx (- total_len start_idx))
    }
    
    return ""
}

shadow get_line_from_source {
    let source: string = "line 1
line 2
line 3"
    let l1: string = (get_line_from_source source 1)
    # (print "Line 1: [") (print l1) (println "]")
    assert (== l1 "line 1")
    let l2: string = (get_line_from_source source 2)
    # (print "Line 2: [") (print l2) (println "]")
    assert (== l2 "line 2")
    let l3: string = (get_line_from_source source 3)
    # (print "Line 3: [") (print l3) (println "]")
    assert (== l3 "line 3")
}

/* =============================================================================
 * ERROR FORMATTING
 * ============================================================================= */

/* Format an error message in Elm style */
pub fn format_error_elm_style(err: ErrorMessage, source: string) -> string {
    let mut out: string = ""
    
    # 1. Header line: -- TITLE ---------------------------------------- FILE
    let mut header_base: string = (+ "-- " (+ err.title " "))
    let mut dash_count: int = (- 60 (str_length header_base))
    if (< dash_count 5) { set dash_count 5 }
    let mut full_header: string = (+ header_base (+ (repeat_string "-" dash_count) (+ " " err.file)))
    
    set out (+ full_header "\n\n")
    
    # 2. Problem description
    set out (+ out (+ err.problem "\n\n"))
    
    # 3. Code snippet with highlighting
    if (> err.line 0) {
        let line_content: string = (get_line_from_source source err.line)
        let line_num_str: string = (int_to_string err.line)
        let padding: string = (repeat_string " " (str_length line_num_str))
        
        set out (+ out (+ line_num_str (+ "| " (+ line_content "\n"))))
        set out (+ out (+ padding (+ "| " (+ (repeat_string " " (- err.column 1)) "^\n\n"))))
    }
    
    # 4. Explanation
    if (!= err.explanation "") {
        set out (+ out (+ err.explanation "\n\n"))
    }
    
    # 5. Suggestion
    if (!= err.suggestion "") {
        set out (+ out (+ "Hint: " (+ err.suggestion "\n")))
    }
    
    return out
}

/* =============================================================================
 * CONVERT DIAGNOSTICS TO ELM ERRORS
 * ============================================================================= */

fn build_error_explanations() -> HashMap<string, string> {
    let m: HashMap<string, string> = (map_new)
    (map_put m "E0001" "NanoLang enforces explicit types, so the expression must match the expected annotation.")
    (map_put m "E0002" "The compiler could not find a declaration with this name in the current scope.")
    (map_put m "E0003" "Functions require the exact number of arguments specified in their signature.")
    (map_put m "E0004" "Each argument must match the corresponding parameter type declared in the function signature.")
    (map_put m "E0005" "Bindings are immutable unless declared with `mut`, so you cannot reassign them.")
    return m
}

shadow build_error_explanations {
    let m: HashMap<string, string> = (build_error_explanations)
    assert (map_has m "E0002")
}

fn build_error_suggestions() -> HashMap<string, string> {
    let m: HashMap<string, string> = (map_new)
    (map_put m "E0001" "Convert the expression to the expected type or change the annotation.")
    (map_put m "E0002" "Check for typos or declare the identifier with `let` before using it.")
    (map_put m "E0003" "Add the missing arguments or remove extras so the call arity matches the definition.")
    (map_put m "E0004" "Convert the argument to the required type or update the function signature if the annotation is wrong.")
    (map_put m "E0005" "Declare the variable with `mut` or create a new binding instead of reassigning.")
    return m
}

shadow build_error_suggestions {
    let m: HashMap<string, string> = (build_error_suggestions)
    assert (map_has m "E0005")
}

fn explanation_for_code(code: string) -> string {
    let explanations: HashMap<string, string> = (build_error_explanations)
    if (map_has explanations code) {
        return (map_get explanations code)
    } else {
        return ""
    }
}

shadow explanation_for_code {
    assert (str_contains (explanation_for_code "E0002") "scope")
}

fn suggestion_for_code(code: string) -> string {
    let suggestions: HashMap<string, string> = (build_error_suggestions)
    if (map_has suggestions code) {
        return (map_get suggestions code)
    } else {
        return ""
    }
}

shadow suggestion_for_code {
    assert (str_contains (suggestion_for_code "E0005") "mut")
}

pub fn diagnostic_to_elm_error(diag: CompilerDiagnostic) -> ErrorMessage {
    let mut title: string = (cond
        ((== diag.code "E0001") "TYPE MISMATCH")
        ((== diag.code "E0002") "UNDEFINED IDENTIFIER")
        ((== diag.severity 2) "ERROR")
        ((== diag.severity 1) "WARNING")
        (else "INFO")
    )
    
    let loc: CompilerSourceLocation = diag.location
    return ErrorMessage {
        title: title,
        file: loc.file,
        line: loc.line,
        column: loc.column,
        problem: diag.message,
        code_snippet: "",
        explanation: (explanation_for_code diag.code),
        suggestion: (suggestion_for_code diag.code)
    }
}

shadow diagnostic_to_elm_error {
    let loc: CompilerSourceLocation = CompilerSourceLocation { file: "test.nano", line: 2, column: 5 }
    let diag: CompilerDiagnostic = CompilerDiagnostic { severity: DiagnosticSeverity.DIAG_ERROR, phase: CompilerPhase.PHASE_TYPECHECK, code: "E0002", message: "Undefined identifier", location: loc }
    let err: ErrorMessage = (diagnostic_to_elm_error diag)
    assert (== err.title "UNDEFINED IDENTIFIER")
    assert (str_contains err.explanation "declaration")
}

pub fn format_diagnostics_elm_style(diags: List<CompilerDiagnostic>, source: string) -> string {
    let mut out: string = ""
    let count: int = (diag_list_count diags)
    let mut i: int = 0
    
    while (< i count) {
        let diag: CompilerDiagnostic = (diag_list_get diags i)
        let elm_err: ErrorMessage = (diagnostic_to_elm_error diag)
        set out (+ out (format_error_elm_style elm_err source))
        set out (+ out "\n")
        set i (+ i 1)
    }
    
    return out
}

shadow format_error_elm_style {
    let err: ErrorMessage = (error_message_new "TYPE MISMATCH" "test.nano" 1 1)
    let source: string = "let x: int = \"hello\""
    let formatted: string = (format_error_elm_style err source)
    (println formatted)
}

shadow format_diagnostics_elm_style {
    let loc: CompilerSourceLocation = CompilerSourceLocation { file: "test.nano", line: 1, column: 1 }
    let diag: CompilerDiagnostic = CompilerDiagnostic { severity: DiagnosticSeverity.DIAG_ERROR, phase: CompilerPhase.PHASE_TYPECHECK, code: "E0001", message: "Type mismatch", location: loc }
    let diags: List<CompilerDiagnostic> = (diag_list_new)
    (diag_list_add diags diag)
    let output: string = (format_diagnostics_elm_style diags "let x: int = 0")
    assert (str_contains output "TYPE MISMATCH")
}

/* =============================================================================
 * COMMON ERROR PATTERNS
 * ============================================================================= */

/* NSType mismatch error */
pub fn error_type_mismatch(
    file: string,
    line: int,
    column: int,
    expected: string,
    found: string,
    context: string
) -> ErrorMessage {
    let err: ErrorMessage = (error_message_new "TYPE MISMATCH" file line column)
    
    # TODO: Build problem string with expected vs found
    # "I expected a value of type `int`, but found `string`"
    
    # TODO: Build explanation based on context
    # If context is "function_argument":
    #   "The function signature declares this parameter as `int`"
    # If context is "variable_assignment":
    #   "The variable was declared with type `int`"
    
    # TODO: Build suggestion
    # "Did you mean to use (string_to_int ...)?""
    
    return err
}

shadow error_type_mismatch {
    let err: ErrorMessage = (error_type_mismatch "test.nano" 10 5 "int" "string" "argument")
    assert (== err.title "TYPE MISMATCH")
}

/* Undefined variable error */
pub fn error_undefined_variable(
    file: string,
    line: int,
    column: int,
    var_name: string,
    similar_names: List<string>
) -> ErrorMessage {
    let err: ErrorMessage = (error_message_new "UNDEFINED VARIABLE" file line column)
    
    # TODO: Build problem string
    # "I cannot find a variable named `countr`"
    
    # TODO: Build suggestion based on similar names
    # If similar_names has entries:
    #   "Did you mean one of these?"
    #   "    counter"
    #   "    count"
    # Else:
    #   "Make sure to declare `countr` with `let` before using it"
    
    return err
}

shadow error_undefined_variable {
    let similar: List<string> = (list_string_new)
    let err: ErrorMessage = (error_undefined_variable "test.nano" 10 5 "countr" similar)
    assert (== err.title "UNDEFINED VARIABLE")
}

/* Arity mismatch error */
pub fn error_arity_mismatch(
    file: string,
    line: int,
    column: int,
    function_name: string,
    expected_args: int,
    found_args: int
) -> ErrorMessage {
    let err: ErrorMessage = (error_message_new "WRONG NUMBER OF ARGUMENTS" file line column)
    
    # TODO: Build problem string
    # "The function `add` expects 2 arguments, but I see 3"
    
    # TODO: Build explanation
    # "This `add` function has type:"
    # "    fn(int, int) -> int"
    
    # TODO: Build suggestion
    # If found_args > expected_args:
    #   "Remove the extra arguments"
    # If found_args < expected_args:
    #   "Add the missing arguments"
    
    return err
}

shadow error_arity_mismatch {
    let err: ErrorMessage = (error_arity_mismatch "test.nano" 10 5 "add" 2 3)
    assert (== err.title "WRONG NUMBER OF ARGUMENTS")
}

/* Missing return error */
pub fn error_missing_return(
    file: string,
    line: int,
    column: int,
    function_name: string,
    expected_type: string
) -> ErrorMessage {
    let err: ErrorMessage = (error_message_new "MISSING RETURN" file line column)
    
    # TODO: Build problem string
    # "The function `calculate` is declared to return `int`, but some branches don't return a value"
    
    # TODO: Build explanation
    # "All execution paths in a function must return a value of the declared type."
    # "Right now, if the condition is false, the function doesn't return anything."
    
    # TODO: Build suggestion
    # "Add a return statement to the else branch:"
    # "    } else {"
    # "        return 0  # or some other default value"
    # "    }"
    
    return err
}

shadow error_missing_return {
    let err: ErrorMessage = (error_missing_return "test.nano" 20 1 "calculate" "int")
    assert (== err.title "MISSING RETURN")
}

/* Immutable assignment error */
pub fn error_immutable_assignment(
    file: string,
    line: int,
    column: int,
    var_name: string
) -> ErrorMessage {
    let err: ErrorMessage = (error_message_new "CANNOT ASSIGN TO IMMUTABLE VARIABLE" file line column)
    
    # TODO: Build problem string
    # "I cannot assign to `count` because it was declared as immutable"
    
    # TODO: Build explanation
    # "In NanoLang, variables are immutable by default. Once you assign a value"
    # "to an immutable variable, you cannot change it later."
    
    # TODO: Build suggestion
    # "To make this variable mutable, add the `mut` keyword:"
    # "    let mut count: int = 0"
    
    return err
}

shadow error_immutable_assignment {
    let err: ErrorMessage = (error_immutable_assignment "test.nano" 15 5 "count")
    assert (== err.title "CANNOT ASSIGN TO IMMUTABLE VARIABLE")
}

pub fn encode_type_mismatch_message(context: string, expected: string, found: string, detail: string) -> string {
    let expected_label: string = (wrap_backticks expected)
    let found_label: string = (wrap_backticks found)
    let mut base: string = (+ "I expected a value of type " (+ expected_label (+ ", but found " (+ found_label "."))))
    if (!= detail "") {
        set base (+ detail (+ ": " base))
    }
    return base
}

shadow encode_type_mismatch_message {
    let msg: string = (encode_type_mismatch_message "function_argument" "int" "string" "Argument 1 of add")
    assert (str_contains msg "Argument 1 of add")
}

pub fn encode_undefined_name_message(name: string) -> string {
    let name_label: string = (wrap_backticks name)
    return (+ "I cannot find a definition for " (+ name_label "."))
}

shadow encode_undefined_name_message {
    let msg: string = (encode_undefined_name_message "countr")
    assert (str_contains msg "countr")
}

pub fn encode_wrong_arg_count_message(function_name: string, expected_args: int, found_args: int) -> string {
    let fn_label: string = (wrap_backticks function_name)
    return (+ "The function " (+ fn_label (+ " expects " (+ (int_to_string expected_args) (+ " argument(s), but I see " (+ (int_to_string found_args) "."))))))
}

shadow encode_wrong_arg_count_message {
    let msg: string = (encode_wrong_arg_count_message "add" 2 3)
    assert (str_contains msg "expects 2")
}

pub fn encode_missing_return_message(function_name: string, expected_type: string) -> string {
    let fn_label: string = (wrap_backticks function_name)
    let type_label: string = (wrap_backticks expected_type)
    return (+ "The function " (+ fn_label (+ " promises to return " (+ type_label ", but this path has no return statement."))))
}

shadow encode_missing_return_message {
    let msg: string = (encode_missing_return_message "compute" "int")
    assert (str_contains msg "compute")
}

pub fn encode_immutable_assignment_message(var_name: string) -> string {
    let name_label: string = (wrap_backticks var_name)
    return (+ "Cannot assign to " (+ name_label " because it was declared immutable."))
}

shadow encode_immutable_assignment_message {
    let msg: string = (encode_immutable_assignment_message "total")
    assert (str_contains msg "immutable")
}

/* Unsafe call outside unsafe block */
pub fn error_unsafe_required(
    file: string,
    line: int,
    column: int,
    function_name: string
) -> ErrorMessage {
    let err: ErrorMessage = (error_message_new "UNSAFE OPERATION" file line column)
    
    # TODO: Build problem string
    # "The function `malloc` is marked as unsafe and must be called inside an unsafe block"
    
    # TODO: Build explanation
    # "Unsafe functions can cause memory errors or undefined behavior if used incorrectly."
    # "NanoLang requires you to explicitly mark where unsafe code is used."
    
    # TODO: Build suggestion
    # "Wrap the call in an unsafe block:"
    # "    unsafe {"
    # "        (malloc 100)"
    # "    }"
    
    return err
}

shadow error_unsafe_required {
    let err: ErrorMessage = (error_unsafe_required "test.nano" 25 10 "malloc")
    assert (== err.title "UNSAFE OPERATION")
}

/* Resource use-after-consume error (for affine types) */
pub fn error_use_after_consume(
    file: string,
    line: int,
    column: int,
    resource_name: string,
    consumed_at_line: int
) -> ErrorMessage {
    let err: ErrorMessage = (error_message_new "USE AFTER CONSUME" file line column)
    
    # TODO: Build problem string
    # "I cannot use `file` because it was already consumed at line 42"
    
    # TODO: Build explanation
    # "`file` is a resource type (FileHandle). Resource types can only be used once."
    # "After you pass it to a consuming function like `close_file`, you cannot use it again."
    
    # TODO: Build suggestion
    # "If you need to use the resource multiple times, consider:"
    # "1. Restructure your code so the resource is consumed last"
    # "2. Use a function that borrows instead of consuming"
    
    return err
}

shadow error_use_after_consume {
    let err: ErrorMessage = (error_use_after_consume "test.nano" 50 5 "file" 42)
    assert (== err.title "USE AFTER CONSUME")
}

/* Resource leak error (for affine types) */
pub fn error_resource_leak(
    file: string,
    line: int,
    column: int,
    resource_name: string,
    resource_type: string
) -> ErrorMessage {
    let err: ErrorMessage = (error_message_new "RESOURCE LEAK" file line column)
    
    # TODO: Build problem string
    # "The resource `file` of type `FileHandle` was not consumed before the function returns"
    
    # TODO: Build explanation
    # "Resource types like `FileHandle` must be explicitly closed or consumed."
    # "This prevents resource leaks (like leaving files open)."
    
    # TODO: Build suggestion
    # "Add a call to consume the resource:"
    # "    unsafe { (close_file file) }"
    
    return err
}

shadow error_resource_leak {
    let err: ErrorMessage = (error_resource_leak "test.nano" 60 1 "file" "FileHandle")
    assert (== err.title "RESOURCE LEAK")
}

/* =============================================================================
 * ERROR TEMPLATES
 * ============================================================================= */

/* Get a friendly error template for common mistakes */
pub fn get_error_template(error_code: string) -> string {
    # TODO: Return helpful templates for common errors
    # E0001: NSType mismatch
    # E0002: Undefined variable
    # E0003: Arity mismatch
    # etc.
    
    return "Error template placeholder"
}

shadow get_error_template {
    let template: string = (get_error_template "E0001")
    (println template)
}

/* =============================================================================
 * USAGE EXAMPLES
 * =============================================================================
 * 
 * Instead of:
 *   Error at line 42: NSType mismatch
 * 
 * We show:
 *   -- TYPE MISMATCH ---------------------------------------- src/main.nano
 *   
 *   I expected a value of type `int`, but found `string`:
 *   
 *   42| let count: int = "hello"
 *                        ^^^^^^^
 *   
 *   The variable `count` was declared with type `int` on line 42.
 *   
 *   Hint: If you want to convert a string to an integer, try:
 *       (string_to_int "hello")
 * 
 * This makes errors:
 * 1. **Easier to understand** - Clear description of what went wrong
 * 2. **Easier to locate** - Shows the exact code
 * 3. **Easier to fix** - Provides concrete suggestions
 * 4. **Less intimidating** - Friendly, helpful tone
 * 
 * Future Enhancements:
 * - Color highlighting (when terminal supports it)
 * - Multi-line code snippets
 * - Links to documentation
 * - Similar error grouping (show all type mismatches together)
 * - Interactive error browser (for IDEs)
 */


