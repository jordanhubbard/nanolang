# Helper functions for lexer - split out to reduce nesting

# Token struct definition
struct Token {
    type: int,
    value: string,
    line: int,
    column: int
}

# TokenType enum
enum TokenType {
    TOKEN_EOF,
    TOKEN_NUMBER,
    TOKEN_FLOAT,
    TOKEN_STRING,
    TOKEN_IDENTIFIER,
    TOKEN_TRUE,
    TOKEN_FALSE,
    TOKEN_LPAREN,
    TOKEN_RPAREN,
    TOKEN_LBRACE,
    TOKEN_RBRACE,
    TOKEN_LBRACKET,
    TOKEN_RBRACKET,
    TOKEN_COMMA,
    TOKEN_COLON,
    TOKEN_ARROW,
    TOKEN_ASSIGN,
    TOKEN_DOT,
    TOKEN_EXTERN,
    TOKEN_FN,
    TOKEN_LET,
    TOKEN_MUT,
    TOKEN_SET,
    TOKEN_IF,
    TOKEN_ELSE,
    TOKEN_WHILE,
    TOKEN_FOR,
    TOKEN_IN,
    TOKEN_RETURN,
    TOKEN_ASSERT,
    TOKEN_SHADOW,
    TOKEN_PRINT,
    TOKEN_ARRAY,
    TOKEN_STRUCT,
    TOKEN_ENUM,
    TOKEN_TYPE_INT,
    TOKEN_TYPE_FLOAT,
    TOKEN_TYPE_BOOL,
    TOKEN_TYPE_STRING,
    TOKEN_TYPE_VOID,
    TOKEN_PLUS,
    TOKEN_MINUS,
    TOKEN_STAR,
    TOKEN_SLASH,
    TOKEN_PERCENT,
    TOKEN_EQ,
    TOKEN_NE,
    TOKEN_LT,
    TOKEN_LE,
    TOKEN_GT,
    TOKEN_GE,
    TOKEN_AND,
    TOKEN_OR,
    TOKEN_NOT,
    TOKEN_RANGE
}

fn is_identifier_start(c: int) -> bool {
    return (or (and (>= c 65) (<= c 90)) (and (>= c 97) (<= c 122)) (== c 95))
}

fn is_identifier_char(c: int) -> bool {
    return (or (is_identifier_start c) (and (>= c 48) (<= c 57)))
}

fn is_whitespace_char(c: int) -> bool {
    return (or (== c 32) (== c 9) (== c 10) (== c 13))
}

fn is_digit_char(c: int) -> bool {
    return (and (>= c 48) (<= c 57))
}

# Check keyword - simplified with early returns
fn check_keyword(s: string, keyword: string, token_type: int) -> int {
    if (== s keyword) {
        return token_type
    } else {
        return -1
    }
}

fn keyword_or_identifier(s: string) -> int {
    let result: int = (check_keyword s "extern" TOKEN_EXTERN)
    if (!= result -1) { return result }
    set result (check_keyword s "fn" TOKEN_FN)
    if (!= result -1) { return result }
    set result (check_keyword s "let" TOKEN_LET)
    if (!= result -1) { return result }
    set result (check_keyword s "mut" TOKEN_MUT)
    if (!= result -1) { return result }
    set result (check_keyword s "set" TOKEN_SET)
    if (!= result -1) { return result }
    set result (check_keyword s "if" TOKEN_IF)
    if (!= result -1) { return result }
    set result (check_keyword s "else" TOKEN_ELSE)
    if (!= result -1) { return result }
    set result (check_keyword s "while" TOKEN_WHILE)
    if (!= result -1) { return result }
    set result (check_keyword s "for" TOKEN_FOR)
    if (!= result -1) { return result }
    set result (check_keyword s "in" TOKEN_IN)
    if (!= result -1) { return result }
    set result (check_keyword s "return" TOKEN_RETURN)
    if (!= result -1) { return result }
    set result (check_keyword s "assert" TOKEN_ASSERT)
    if (!= result -1) { return result }
    set result (check_keyword s "shadow" TOKEN_SHADOW)
    if (!= result -1) { return result }
    set result (check_keyword s "print" TOKEN_PRINT)
    if (!= result -1) { return result }
    set result (check_keyword s "array" TOKEN_ARRAY)
    if (!= result -1) { return result }
    set result (check_keyword s "struct" TOKEN_STRUCT)
    if (!= result -1) { return result }
    set result (check_keyword s "enum" TOKEN_ENUM)
    if (!= result -1) { return result }
    set result (check_keyword s "true" TOKEN_TRUE)
    if (!= result -1) { return result }
    set result (check_keyword s "false" TOKEN_FALSE)
    if (!= result -1) { return result }
    set result (check_keyword s "int" TOKEN_TYPE_INT)
    if (!= result -1) { return result }
    set result (check_keyword s "float" TOKEN_TYPE_FLOAT)
    if (!= result -1) { return result }
    set result (check_keyword s "bool" TOKEN_TYPE_BOOL)
    if (!= result -1) { return result }
    set result (check_keyword s "string" TOKEN_TYPE_STRING)
    if (!= result -1) { return result }
    set result (check_keyword s "void" TOKEN_TYPE_VOID)
    if (!= result -1) { return result }
    set result (check_keyword s "and" TOKEN_AND)
    if (!= result -1) { return result }
    set result (check_keyword s "or" TOKEN_OR)
    if (!= result -1) { return result }
    set result (check_keyword s "not" TOKEN_NOT)
    if (!= result -1) { return result }
    set result (check_keyword s "range" TOKEN_RANGE)
    if (!= result -1) { return result }
    return TOKEN_IDENTIFIER
}

fn main() -> int {
    return 0
}

shadow main {
    assert (== (main) 0)
}

