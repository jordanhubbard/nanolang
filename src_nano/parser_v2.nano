/* =============================================================================
 * nanolang Parser (Self-Hosted) - v2: Helper Functions
 * =============================================================================
 * Extends MVP with parser helper functions for token stream management
 */

/* Token types - must match lexer */
enum TokenType {
    EOF = 0,
    NUMBER = 1,
    FLOAT = 2,
    STRING = 3,
    IDENTIFIER = 4,
    TRUE = 5,
    FALSE = 6,
    
    LPAREN = 7,
    RPAREN = 8,
    LBRACE = 9,
    RBRACE = 10,
    LBRACKET = 11,
    RBRACKET = 12,
    COMMA = 13,
    COLON = 14,
    ARROW = 15,
    ASSIGN = 16,
    DOT = 17,
    
    FN = 19,
    LET = 20,
    MUT = 21,
    SET = 22,
    IF = 23,
    ELSE = 24,
    WHILE = 25,
    RETURN = 28
}

/* Token from lexer */
struct LexToken {
    token_type: int,  /* TokenType */
    value: string,
    line: int,
    column: int
}

/* AST Node Types */
enum ParseNodeType {
    PNODE_NUMBER = 0,
    PNODE_STRING = 1,
    PNODE_BOOL = 2,
    PNODE_IDENTIFIER = 3,
    PNODE_BINARY_OP = 4,
    PNODE_CALL = 5,
    PNODE_LET = 6,
    PNODE_BLOCK = 7,
    PNODE_PROGRAM = 8
}

/* AST Node Structures */
struct ASTNumber {
    node_type: int,  /* ParseNodeType.PNODE_NUMBER */
    line: int,
    column: int,
    value: string
}

struct ASTString {
    node_type: int,  /* ParseNodeType.PNODE_STRING */
    line: int,
    column: int,
    value: string
}

struct ASTBool {
    node_type: int,  /* ParseNodeType.PNODE_BOOL */
    line: int,
    column: int,
    value: bool
}

struct ASTIdentifier {
    node_type: int,  /* ParseNodeType.PNODE_IDENTIFIER */
    line: int,
    column: int,
    name: string
}

/* Parser State */
struct Parser {
    position: int,
    token_count: int,
    has_error: bool
}

/* ============================================================================
 * Parser Helper Functions
 * ============================================================================
 * Core utilities for token stream management
 */

/* Create new parser */
fn parser_new(token_count: int) -> Parser {
    return Parser {
        position: 0,
        token_count: token_count,
        has_error: false
    }
}

shadow parser_new {
    let p: Parser = (parser_new 10)
    assert (== p.position 0)
    assert (== p.token_count 10)
    assert (== p.has_error false)
}

/* Check if we're at end of tokens */
fn parser_is_at_end(p: Parser) -> bool {
    return (>= p.position p.token_count)
}

shadow parser_is_at_end {
    let mut p: Parser = (parser_new 5)
    assert (== (parser_is_at_end p) false)
    set p.position 5
    assert (== (parser_is_at_end p) true)
    set p.position 10
    assert (== (parser_is_at_end p) true)
}

/* Get current position */
fn parser_position(p: Parser) -> int {
    return p.position
}

shadow parser_position {
    let p: Parser = (parser_new 5)
    assert (== (parser_position p) 0)
}

/* Check if parser has errors */
fn parser_has_error(p: Parser) -> bool {
    return p.has_error
}

shadow parser_has_error {
    let p: Parser = (parser_new 5)
    assert (== (parser_has_error p) false)
}

/* ============================================================================
 * AST Node Creation Functions
 * ============================================================================
 */

fn create_number_node(value: string, line: int, column: int) -> ASTNumber {
    return ASTNumber {
        node_type: ParseNodeType.PNODE_NUMBER,
        line: line,
        column: column,
        value: value
    }
}

shadow create_number_node {
    let node: ASTNumber = (create_number_node "42" 1 1)
    assert (== node.node_type ParseNodeType.PNODE_NUMBER)
    assert (== node.line 1)
    assert (== node.column 1)
}

fn create_string_node(value: string, line: int, column: int) -> ASTString {
    return ASTString {
        node_type: ParseNodeType.PNODE_STRING,
        line: line,
        column: column,
        value: value
    }
}

shadow create_string_node {
    let node: ASTString = (create_string_node "hello" 1 1)
    assert (== node.node_type ParseNodeType.PNODE_STRING)
}

fn create_bool_node(value: bool, line: int, column: int) -> ASTBool {
    return ASTBool {
        node_type: ParseNodeType.PNODE_BOOL,
        line: line,
        column: column,
        value: value
    }
}

shadow create_bool_node {
    let node: ASTBool = (create_bool_node true 1 1)
    assert (== node.node_type ParseNodeType.PNODE_BOOL)
    assert (== node.value true)
}

fn create_identifier_node(name: string, line: int, column: int) -> ASTIdentifier {
    return ASTIdentifier {
        node_type: ParseNodeType.PNODE_IDENTIFIER,
        line: line,
        column: column,
        name: name
    }
}

shadow create_identifier_node {
    let node: ASTIdentifier = (create_identifier_node "x" 1 1)
    assert (== node.node_type ParseNodeType.PNODE_IDENTIFIER)
}

/* ============================================================================
 * Integration Test
 * ============================================================================
 */

fn test_parser_helpers() -> int {
    /* Test parser creation */
    let p: Parser = (parser_new 10)
    if (!= p.token_count 10) { return 1 } else {}
    
    /* Test is_at_end */
    if (== (parser_is_at_end p) true) { return 2 } else {}
    
    /* Test node creation */
    let num: ASTNumber = (create_number_node "42" 1 1)
    if (!= num.node_type ParseNodeType.PNODE_NUMBER) { return 3 } else {}
    
    let str: ASTString = (create_string_node "test" 1 5)
    if (!= str.node_type ParseNodeType.PNODE_STRING) { return 4 } else {}
    
    let id: ASTIdentifier = (create_identifier_node "x" 2 1)
    if (!= id.node_type ParseNodeType.PNODE_IDENTIFIER) { return 5 } else {}
    
    return 0
}

shadow test_parser_helpers {
    assert (== (test_parser_helpers) 0)
}

/* ============================================================================
 * Main
 * ============================================================================
 */

fn main() -> int {
    (println "Nanolang Self-Hosted Parser v2")
    (println "Status: Helper functions implemented")
    (println "")
    (print "Tests: ")
    let result: int = (test_parser_helpers)
    if (== result 0) {
        (println "All helper tests passed!")
        return 0
    } else {
        (print "Test failed with code: ")
        (println result)
        return 1
    }
}

shadow main {
    assert (== (main) 0)
}

