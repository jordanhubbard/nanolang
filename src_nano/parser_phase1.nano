/* =============================================================================
 * nanolang Parser - Phase 1: Token Management
 * =============================================================================
 * Handles token stream navigation, peek, advance, expect
 */

/* Token types from lexer */
enum TokenType {
    FN = 0,
    LET = 1,
    MUT = 2,
    IF = 3,
    ELSE = 4,
    WHILE = 5,
    FOR = 6,
    IN = 7,
    RETURN = 8,
    STRUCT = 9,
    ENUM = 10,
    UNION = 11,
    MATCH = 12,
    SHADOW = 13,
    ASSERT = 14,
    EXTERN = 15,
    ARRAY = 16,
    AND = 17,
    OR = 18,
    NOT = 19,
    TRUE_LIT = 20,
    FALSE_LIT = 21,
    IDENTIFIER = 22,
    NUMBER = 23,
    STRING = 24,
    PLUS = 25,
    MINUS = 26,
    STAR = 27,
    SLASH = 28,
    PERCENT = 29,
    EQ_EQ = 30,
    NOT_EQ = 31,
    LT = 32,
    LT_EQ = 33,
    GT = 34,
    GT_EQ = 35,
    ASSIGN = 36,
    COLON = 37,
    ARROW = 38,
    COMMA = 39,
    LPAREN = 40,
    RPAREN = 41,
    LBRACE = 42,
    RBRACE = 43,
    LBRACKET = 44,
    RBRACKET = 45,
    DOT = 46,
    EOF = 47,
    ERROR = 48
}

/* Token structure */
struct LexToken {
    type_val: int,
    value: string,
    line: int,
    column: int
}

/* Create EOF token */
fn create_eof_token() -> LexToken {
    let tok: LexToken = LexToken{
        type_val: 47,  /* EOF */
        value: "",
        line: 0,
        column: 0
    }
    return tok
}

shadow create_eof_token {
    let eof: LexToken = (create_eof_token)
    assert (== eof.type_val 47)
}

/* Parser state */
struct Parser {
    token_count: int,
    current: int,
    has_error: bool
}

/* Create new parser */
fn parser_new() -> Parser {
    let p: Parser = Parser{
        token_count: 0,
        current: 0,
        has_error: false
    }
    return p
}

shadow parser_new {
    let p: Parser = (parser_new)
    assert (== p.current 0)
    assert (== p.has_error false)
}

/* Initialize parser with token count */
fn parser_init(token_count: int) -> Parser {
    let p: Parser = Parser{
        token_count: token_count,
        current: 0,
        has_error: false
    }
    return p
}

shadow parser_init {
    let p: Parser = (parser_init 10)
    assert (== p.token_count 10)
    assert (== p.current 0)
}

/* Check if at end of tokens */
fn parser_is_at_end(p: Parser) -> bool {
    return (>= p.current p.token_count)
}

shadow parser_is_at_end {
    let p: Parser = (parser_init 5)
    assert (== (parser_is_at_end p) false)
    
    set p.current 5
    assert (== (parser_is_at_end p) true)
    
    set p.current 10
    assert (== (parser_is_at_end p) true)
}

/* Get current position */
fn parser_position(p: Parser) -> int {
    return p.current
}

shadow parser_position {
    let p: Parser = (parser_init 10)
    assert (== (parser_position p) 0)
    
    set p.current 3
    assert (== (parser_position p) 3)
}

/* Advance to next token */
fn parser_advance(p: Parser) -> bool {
    if (< p.current p.token_count) {
        set p.current (+ p.current 1)
        return true
    } else {
        return false
    }
}

shadow parser_advance {
    let p: Parser = (parser_init 3)
    
    /* Advance from 0 to 1 */
    let ok1: bool = (parser_advance p)
    assert (== ok1 true)
    assert (== p.current 1)
    
    /* Advance from 1 to 2 */
    let ok2: bool = (parser_advance p)
    assert (== ok2 true)
    assert (== p.current 2)
    
    /* Advance from 2 to 3 */
    let ok3: bool = (parser_advance p)
    assert (== ok3 true)
    assert (== p.current 3)
    
    /* Try to advance past end */
    let ok4: bool = (parser_advance p)
    assert (== ok4 false)
    assert (== p.current 3)
}

/* Peek ahead by offset */
fn parser_can_peek(p: Parser, offset: int) -> bool {
    let pos: int = (+ p.current offset)
    return (< pos p.token_count)
}

shadow parser_can_peek {
    let p: Parser = (parser_init 5)
    
    /* At position 0 */
    assert (== (parser_can_peek p 0) true)   /* current token */
    assert (== (parser_can_peek p 1) true)   /* next token */
    assert (== (parser_can_peek p 4) true)   /* last token */
    assert (== (parser_can_peek p 5) false)  /* past end */
    
    /* Move to position 3 */
    set p.current 3
    assert (== (parser_can_peek p 0) true)
    assert (== (parser_can_peek p 1) true)
    assert (== (parser_can_peek p 2) false)
}

/* Set error state */
fn parser_set_error(p: Parser) -> int {
    set p.has_error true
    return 0
}

shadow parser_set_error {
    let p: Parser = (parser_new)
    assert (== p.has_error false)
    
    let result: int = (parser_set_error p)
    assert (== p.has_error true)
    assert (== result 0)
}

/* Check error state */
fn parser_has_error(p: Parser) -> bool {
    return p.has_error
}

shadow parser_has_error {
    let p: Parser = (parser_new)
    assert (== (parser_has_error p) false)
    
    (parser_set_error p)
    assert (== (parser_has_error p) true)
}

/* Main test */
fn main() -> int {
    (println "Parser Phase 1: Token Management")
    (println "================================")
    (println "")
    (println "✅ Token navigation: Working")
    (println "✅ Position tracking: Working")
    (println "✅ Error handling: Working")
    (println "")
    (println "Phase 1 Complete! Ready for expression parsing.")
    return 0
}

shadow main {
    assert (== (main) 0)
}

