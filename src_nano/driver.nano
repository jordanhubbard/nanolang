/* =============================================================================
 * NanoLang Compiler Driver (Self-Hosted)
 * =============================================================================
 * Pure NanoLang implementation of the compiler driver that orchestrates
 * the entire compilation pipeline: lex → parse → typecheck → transpile → cc
 * 
 * This replaces bin/nanoc (C implementation) with a self-hosted version.
 * 
 * Usage:
 *   nanoc_nano input.nano -o output
 *   nanoc_nano input.nano -o output -I include_path
 *   nanoc_nano --help
 *   nanoc_nano --version
 */

/* Import filesystem helpers */
from "modules/std/fs.nano" import read, write

/* Import compiler phases - these already have clean interfaces */
import "src_nano/compiler/ir.nano"
from "src_nano/compiler/error_messages.nano" import format_diagnostics_elm_style

/* Import phase wrapper functions */
from "src_nano/lexer_main.nano" import lex_phase_run
from "src_nano/parser.nano" import parse_phase_run
from "src_nano/typecheck.nano" import typecheck_phase
from "src_nano/transpiler.nano" import transpile_phase

/* Import process execution for C compiler */
/* FFI bindings for CLI + process control */
extern fn get_argc() -> int
extern fn get_argv(index: int) -> string
extern fn nl_os_system(command: string) -> int

/* =============================================================================
 * RESULT TYPE FOR ARGUMENT PARSING
 * ============================================================================= */

union ResultArgs {
    Ok { value: CompilerArgs },
    Err { error: string }
}

/* =============================================================================
 * COMMAND-LINE ARGUMENTS
 * ============================================================================= */

fn runtime_argc() -> int {
    let mut count: int = 0
    unsafe {
        set count (get_argc)
    }
    return count
}

shadow runtime_argc {
    assert true
}

fn runtime_argv(index: int) -> string {
    let mut arg: string = ""
    unsafe {
        set arg (get_argv index)
    }
    return arg
}

shadow runtime_argv {
    assert true
}

struct CompilerArgs {
    input_file: string,
    output_file: string,
    verbose: bool,
    help: bool,
    version: bool,
    extra_cc_args: string
}

/* Create default compiler arguments */
fn args_new() -> CompilerArgs {
    return CompilerArgs {
        input_file: "",
        output_file: "a.out",
        verbose: false,
        help: false,
        version: false,
        extra_cc_args: ""
    }
}

shadow args_new {
    let args: CompilerArgs = (args_new)
    assert (== args.input_file "")
    assert (not args.verbose)
    assert (== args.output_file "a.out")
    assert (== args.extra_cc_args "")
}

/* Parse command-line arguments */
fn parse_args() -> ResultArgs {
    let arg_count: int = (runtime_argc)
    if (< arg_count 2) {
        return ResultArgs.Err { error: "No input file specified. Use --help for usage." }
    }
    
    let mut input_file: string = ""
    let mut output_file: string = "a.out"
    let mut verbose_flag: bool = false
    let mut extra_cc_args: string = ""
    let mut i: int = 1
    while (< i arg_count) {
        let token: string = (runtime_argv i)
        if (== token "--help") {
            return ResultArgs.Ok { value: CompilerArgs {
                input_file: "",
                output_file: output_file,
                verbose: verbose_flag,
                help: true,
                version: false,
                extra_cc_args: extra_cc_args
            } }
        }
        if (== token "--version") {
            return ResultArgs.Ok { value: CompilerArgs {
                input_file: "",
                output_file: output_file,
                verbose: verbose_flag,
                help: false,
                version: true,
                extra_cc_args: extra_cc_args
            } }
        }
        if (== token "-v") {
            set verbose_flag true
        } else {
            if (== token "-o") {
                set i (+ i 1)
                if (>= i arg_count) {
                    return ResultArgs.Err { error: "Missing output file after -o" }
                }
                let out_path: string = (runtime_argv i)
                if (== out_path "") {
                    return ResultArgs.Err { error: "Invalid output file path" }
                }
                set output_file out_path
            } else {
                if (== token "-I") {
                    set i (+ i 1)
                    if (>= i arg_count) {
                        return ResultArgs.Err { error: "Missing include path after -I" }
                    }
                    let include_path: string = (runtime_argv i)
                    set extra_cc_args (+ extra_cc_args (+ " -I " include_path))
                } else {
                    if (== token "-L") {
                        set i (+ i 1)
                        if (>= i arg_count) {
                            return ResultArgs.Err { error: "Missing library path after -L" }
                        }
                        let lib_path: string = (runtime_argv i)
                        set extra_cc_args (+ extra_cc_args (+ " -L " lib_path))
                    } else {
                        if (== token "-l") {
                            set i (+ i 1)
                            if (>= i arg_count) {
                                return ResultArgs.Err { error: "Missing library name after -l" }
                            }
                            let lib_name: string = (runtime_argv i)
                            set extra_cc_args (+ extra_cc_args (+ " -l " lib_name))
                        } else {
                            if (== token "--") {
                                set i (+ i 1)
                                if (>= i arg_count) {
                                    return ResultArgs.Err { error: "Expected input file after --" }
                                }
                                let remainder: string = (runtime_argv i)
                                if (!= input_file "") {
                                    return ResultArgs.Err { error: "Multiple input files specified" }
                                }
                                set input_file remainder
                            } else {
                                if (== input_file "") {
                                    if (and (> (str_length token) 0) (== (str_substring token 0 1) "-")) {
                                        let err_flag: string = (+ "Unknown flag: " token)
                                        return ResultArgs.Err { error: err_flag }
                                    }
                                    set input_file token
                                } else {
                                    let err: string = "Multiple input files specified"
                                    return ResultArgs.Err { error: err }
                                }
                            }
                        }
                    }
                }
            }
        }
        set i (+ i 1)
    }
    
    if (== input_file "") {
        return ResultArgs.Err { error: "No input file specified. Use --help for usage." }
    }
    
    return ResultArgs.Ok { value: CompilerArgs {
        input_file: input_file,
        output_file: output_file,
        verbose: verbose_flag,
        help: false,
        version: false,
        extra_cc_args: extra_cc_args
    } }
}

shadow parse_args {
    # Test requires mocking CLI args provided by runtime
    assert true
}

/* =============================================================================
 * COMPILATION PIPELINE
 * ============================================================================= */

/* =============================================================================
 * PHASE INTERFACES (from existing compiler_modular.nano)
 * =============================================================================
 * 
 * These interfaces already exist and are tested. The driver will call them:
 * 
 * 1. Lexer Phase:
 *    fn lex_phase_run(source: string, filename: string) -> LexPhaseOutput
 *    - Returns: { tokens, token_count, had_error, diagnostics }
 * 
 * 2. Parser Phase:
 *    fn parse_phase_run(lex_output: LexPhaseOutput) -> ParsePhaseOutput
 *    - Returns: { parser, had_error, diagnostics }
 * 
 * 3. TypeChecker Phase:
 *    fn typecheck_phase(parser_state: Parser) -> TypecheckPhaseOutput
 *    - Returns: { had_error, diagnostics }
 * 
 * 4. Transpiler Phase:
 *    fn transpile_phase(parser_state: Parser, c_file: string) -> TranspilePhaseOutput
 *    - Returns: { c_source, had_error, diagnostics }
 * 
 * All phase outputs include:
 *    - had_error: bool
 *    - diagnostics: List<CompilerDiagnostic>
 * 
 * This allows uniform error handling across all phases.
 * ============================================================================= */

/* Compilation phase constants 
 * Using literal integers since const isn't fully supported yet
 * 1 = PHASE_LEX
 * 2 = PHASE_PARSE
 * 3 = PHASE_TYPECHECK
 * 4 = PHASE_TRANSPILE
 * 5 = PHASE_CC
 */

/* Phase result union - holds outputs from each compilation phase */
union CompilationPhaseResult {
    LexResult { output: LexPhaseOutput },
    ParseResult { output: ParsePhaseOutput },
    TypeCheckResult { output: TypecheckPhaseOutput },
    CCompileResult { binary_path: string },
    Error { message: string, phase: int }
}

/* Run the lexer phase */
fn run_lexer(input_file: string, source_code: string, verbose_mode: bool) -> CompilationPhaseResult {
    if verbose_mode {
        (println "Phase 1: Lexing...")
    }
    
    /* Run lexer */
    let lex_output: LexPhaseOutput = (lex_phase_run source_code input_file)
    
    if lex_output.had_error {
        /* Format error message from diagnostics */
        let error_msg: string = (format_diagnostics_elm_style lex_output.diagnostics source_code)
        return CompilationPhaseResult.Error {
            message: error_msg,
            phase: 1  # PHASE_LEX
        }
    }
    
    if verbose_mode {
        (print "  Tokens: ")
        (println (int_to_string lex_output.token_count))
    }
    
    return CompilationPhaseResult.LexResult { output: lex_output }
}

shadow run_lexer {
    # Test requires a valid .nano file
    # For now, skip detailed testing
    (println "run_lexer: shadow test OK")
}

/* Run the parser phase */
fn run_parser(lex_output: LexPhaseOutput, input_file: string, source_code: string, verbose_mode: bool) -> CompilationPhaseResult {
    if verbose_mode {
        (print "Phase 2: Parsing ") (println input_file)
    }
    
    /* Run parser */
    let parse_output: ParsePhaseOutput = (parse_phase_run lex_output input_file)
    
    if parse_output.had_error {
        /* Format error message from diagnostics */
        let error_msg: string = (format_diagnostics_elm_style parse_output.diagnostics source_code)
        return CompilationPhaseResult.Error {
            message: error_msg,
            phase: 2  # PHASE_PARSE
        }
    }
    
    if verbose_mode {
        (print "  Functions: ")
        (println (int_to_string parse_output.parser.functions_count))
    }
    
    return CompilationPhaseResult.ParseResult { output: parse_output }
}

shadow run_parser {
    # Test requires LexPhaseOutput
    # For now, skip detailed testing
    (println "run_parser: shadow test OK")
}

/* Run the type checker phase */
fn run_typechecker(parser_state: Parser, source_code: string, input_file: string, verbose_mode: bool) -> CompilationPhaseResult {
    if verbose_mode {
        (println "Phase 3: NSType checking...")
    }
    
    /* Run typechecker */
    let type_output: TypecheckPhaseOutput = (typecheck_phase parser_state input_file)
    
    if type_output.had_error {
        /* Format error message from diagnostics */
        let error_msg: string = (format_diagnostics_elm_style type_output.diagnostics source_code)
        return CompilationPhaseResult.Error {
            message: error_msg,
            phase: 3  # PHASE_TYPECHECK
        }
    }
    
    if verbose_mode {
        (println "  NSType check complete")
    }
    
    return CompilationPhaseResult.TypeCheckResult { output: type_output }
}

shadow run_typechecker {
    # Test requires Parser state
    # For now, skip detailed testing
    (println "run_typechecker: shadow test OK")
}

/* Run the transpiler phase */
fn run_transpiler(parser_state: Parser, source_code: string, input_file: string, c_file: string, verbose_mode: bool) -> CompilationPhaseResult {
    if verbose_mode {
        (println "Phase 4: Transpiling to C...")
    }
    
    /* Run transpiler */
    let transpile_output: TranspilePhaseOutput = (transpile_phase parser_state c_file input_file)
    
    if transpile_output.had_error {
        /* Format error message from diagnostics */
        let error_msg: string = (format_diagnostics_elm_style transpile_output.diagnostics source_code)
        return CompilationPhaseResult.Error {
            message: error_msg,
            phase: 4  # PHASE_TRANSPILE
        }
    }
    
    /* Write generated C code to file */
    let write_result: int = (write c_file transpile_output.c_source)
    if (!= write_result 0) {
        let error_msg: string = "Failed to write C file"
        return CompilationPhaseResult.Error {
            message: error_msg,
            phase: 4  # PHASE_TRANSPILE
        }
    }
    
    if verbose_mode {
        (println "  C file created:")
        (println c_file)
    }
    
    /* Return success - we don't have a TranspileResult variant, so we'll continue to CC phase */
    return CompilationPhaseResult.CCompileResult {
        binary_path: c_file
    }
}

shadow run_transpiler {
    # Test requires Parser state
    # For now, skip detailed testing
    (println "run_transpiler: shadow test OK")
}

/* Run the C compiler phase */
fn run_cc(c_file: string, output_file: string, verbose_mode: bool, extra_cc_args: string) -> CompilationPhaseResult {
    if verbose_mode {
        (println "Phase 5: Compiling C code...")
    }
    
    /* Build the cc command */
    let runtime_files: string = "src/runtime/list_int.c src/runtime/list_string.c src/runtime/list_LexerToken.c src/runtime/token_helpers.c src/runtime/gc.c src/runtime/dyn_array.c src/runtime/gc_struct.c src/runtime/nl_string.c src/runtime/cli.c src/runtime/schema_lists.c"
    
    let mut cc_cmd: string = "cc -o "
    set cc_cmd (+ cc_cmd output_file)
    set cc_cmd (+ cc_cmd " ")
    set cc_cmd (+ cc_cmd c_file)
    set cc_cmd (+ cc_cmd " -Isrc ")
    set cc_cmd (+ cc_cmd runtime_files)
    if (!= extra_cc_args "") {
        set cc_cmd (+ cc_cmd " ")
        set cc_cmd (+ cc_cmd extra_cc_args)
    }
    
    if verbose_mode {
        (println "  Command:")
        (println cc_cmd)
    }
    
    /* Execute C compiler */
    let mut exit_code: int = 0
    unsafe {
        set exit_code (nl_os_system cc_cmd)
    }
    
    if (!= exit_code 0) {
        let error_msg: string = (+ "C compilation failed with exit code: " (int_to_string exit_code))
        return CompilationPhaseResult.Error {
            message: error_msg,
            phase: 5  # PHASE_CC
        }
    }
    
    if verbose_mode {
        (println "  Binary created:")
        (println output_file)
    }
    
    return CompilationPhaseResult.CCompileResult {
        binary_path: output_file
    }
}

shadow run_cc {
    # CC wiring is Step 7 (not yet implemented)
    (println "run_cc: placeholder OK")
}

/* Run the complete compilation pipeline 
 * All 5 phases now wired: Lex -> Parse -> TypeCheck -> Transpile -> CC ✅
 */
fn compile(c_args: CompilerArgs) -> int {
    if c_args.verbose {
        (println "=== NanoLang Self-Hosted Compiler ===")
        (println c_args.input_file)
    }
    
    /* Pre-read source for error reporting */
    let source: string = (read c_args.input_file)
    
    /* Phase 1: Lex */
    let lex_result: CompilationPhaseResult = (run_lexer c_args.input_file source c_args.verbose)
    match lex_result {
        LexResult(lex) => {
            /* Phase 2: Parse */
            let parse_result: CompilationPhaseResult = (run_parser lex.output c_args.input_file source c_args.verbose)
            match parse_result {
                ParseResult(parse) => {
                    /* Phase 3: NSType check */
                    let type_result: CompilationPhaseResult = (run_typechecker parse.output.parser source c_args.input_file c_args.verbose)
                    match type_result {
                        TypeCheckResult(type_out) => {
                            /* Phase 4: Transpile */
                            let c_file: string = (+ c_args.output_file ".c")
                            let transpile_result: CompilationPhaseResult = (run_transpiler parse.output.parser source c_args.input_file c_file c_args.verbose)
                            match transpile_result {
                                CCompileResult(c_out) => {
                                    /* Phase 5: Compile C to binary */
                                    let cc_result: CompilationPhaseResult = (run_cc c_file c_args.output_file c_args.verbose c_args.extra_cc_args)
                                    match cc_result {
                                        CCompileResult(binary) => {
                                            /* Success! */
                                            if c_args.verbose {
                                                (println "")
                                                (println "✅ Compilation complete!")
                                                (println binary.binary_path)
                                            }
                                            return 0
                                        }
                                        Error(e5) => {
                                            (println "Compilation failed:")
                                            (println e5.message)
                                            return 1
                                        }
                                    }
                                }
                                Error(e4) => {
                                    (println "Compilation failed:")
                                    (println e4.message)
                                    return 1
                                }
                            }
                        }
                        Error(e3) => {
                            (println "Compilation failed in Phase 3 (TypeCheck):")
                            (println e3.message)
                            return 1
                        }
                    }
                }
                Error(e2) => {
                    (println "Compilation failed in Phase 2 (Parse):")
                    (println e2.message)
                    return 1
                }
            }
        }
        Error(e1) => {
            (println "Compilation failed in Phase 1 (Lex):")
            (println e1.message)
            return 1
        }
    }
}

shadow compile {
    # Test requires valid .nano file
    # For now, skip detailed testing
    (println "compile: shadow test OK")
}

/* =============================================================================
 * HELP & VERSION
 * ============================================================================= */

fn print_help() -> void {
    (println "")
    (println "NanoLang Compiler (Self-Hosted)")
    (println "Usage: nanoc_nano [options] input.nano")
    (println "")
    (println "Options:")
    (println "  -o <file>        Output file name")
    (println "  -I <path>        Add include path")
    (println "  -L <path>        Add library path")
    (println "  -l <lib>         Link library")
    (println "  -v               Verbose output")
    (println "  --help           Show this help")
    (println "  --version        Show version")
    (println "")
    (println "Examples:")
    (println "  nanoc_nano hello.nano -o hello")
    (println "  nanoc_nano game.nano -o game -I modules/ -l SDL2")
    (println "")
}

shadow print_help {
    (print_help)
}

fn print_version() -> void {
    (println "nanoc_nano 0.1.0 (self-hosted)")
    (println "NanoLang Compiler - Pure NanoLang Implementation")
}

shadow print_version {
    (print_version)
}

/* =============================================================================
 * MAIN ENTRY POINT
 * ============================================================================= */

fn main() -> int {
    # Parse command-line arguments
    let args_result: ResultArgs = (parse_args)
    
    match args_result {
        Ok(res) => {
            let c_args: CompilerArgs = res.value
            
            # Handle --help
            if c_args.help {
                (print_help)
                return 0
            }
            
            # Handle --version
            if c_args.version {
                (print_version)
                return 0
            }
            
            # Validate input file
            if (== c_args.input_file "") {
                (println "Error: No input file specified")
                (println "Use --help for usage information")
                return 1
            }
            
            # Run compilation
            let exit_code: int = (compile c_args)
            return exit_code
        }
        Err(err) => {
            (println "Error:")
            (println err.error)
            (println "")
            (println "Use --help for usage information")
            return 1
        }
    }
}

shadow main {
    # This requires mocking command-line args
    # For now, just verify it compiles
    (println "driver.nano shadow test: OK")
}

/* =============================================================================
 * INTEGRATION STRATEGY
 * =============================================================================
 * 
 * Phase 1: INTERFACE DOCUMENTATION (✅ COMPLETE)
 * -----------------------------------------------
 * - Document existing phase interfaces
 * - Create CompilerArgs, CompilationResult types
 * - Build argument parsing skeleton
 * - Add help/version displays
 * 
 * Phase 2: STUB INTEGRATION (NEXT)
 * ---------------------------------
 * To wire up actual compiler phases:
 * 
 * 1. Enable imports (uncomment):
 *    import "lexer_main.nano" as Lexer
 *    import "parser.nano" as Parser  
 *    import "typecheck.nano" as TypeCheck
 *    import "transpiler.nano" as Transpile
 * 
 * 2. Update run_lexer():
 *    let source: string = (file_read input_file)
 *    let lex_output: LexPhaseOutput = (Lexer.lex_phase_run source input_file)
 *    if lex_output.had_error {
 *        return CompilationResult { success: false, error: "Lex failed", ... }
 *    }
 *    return CompilationResult { success: true, output: lex_output, ... }
 * 
 * 3. Update run_parser():
 *    let parse_output: ParsePhaseOutput = (Parser.parse_phase_run tokens)
 *    if parse_output.had_error { ... error handling ... }
 *    return CompilationResult { success: true, output: parse_output, ... }
 * 
 * 4. Update run_typechecker():
 *    let type_output: TypecheckPhaseOutput = (TypeCheck.typecheck_phase ast)
 *    if type_output.had_error { ... error handling ... }
 *    return CompilationResult { success: true, ... }
 * 
 * 5. Update run_transpiler():
 *    let c_file: string = (+ output_file ".c")
 *    let transpile_output: TranspilePhaseOutput = (Transpile.transpile_phase ast c_file)
 *    if transpile_output.had_error { ... error handling ... }
 *    return CompilationResult { success: true, output: c_file, ... }
 * 
 * 6. Update run_cc():
 *    Build cc command string
 *    Execute via std::process module
 *    Check exit code
 * 
 * Phase 3: FULL INTEGRATION
 * --------------------------
 * - Replace CompilationResult.output (string) with actual phase output types
 * - Add support for -I, -L, -l flags
 * - Add support for -g, -O flags
 * - Implement incremental compilation
 * - Add --ast, --tokens debug flags
 * 
 * Phase 4: REPLACE C COMPILER (nanolang-alp.11)
 * ----------------------------------------------
 * Once this driver is complete and tested:
 * - Update bin/nanoc to call this driver instead of bin/nanoc_c
 * - Update Makefile to use self-hosted driver for Stage 2
 * - Add verify-no-nanoc_c target to enforce self-hosting
 * 
 * =============================================================================
 * SAFETY NOTES
 * =============================================================================
 * 
 * This driver is SAFE to develop because:
 * 1. It's a NEW file, not modifying existing compiler
 * 2. It DOCUMENTS existing interfaces (from compiler_modular.nano)
 * 3. Current placeholders allow compilation without breaking CI/CD
 * 4. Integration is opt-in (imports commented out until file_ready)
 * 5. Won't affect Stage 1/2/3 builds until we explicitly switch
 * 
 * The existing modular compiler (compiler_modular.nano) already has:
 * - Working phase interfaces
 * - Error handling with diagnostics
 * - Full compilation pipeline
 * 
 * This driver is essentially a cleaned-up, standalone version with:
 * - Better argument parsing
 * - Cleaner error reporting (using error_messages.nano)
 * - More maintainable structure
 * - Preparation for full self-hosting
 */

