/* AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY. */

import "src_nano/generated/compiler_schema.nano"

enum TypeKind {
    TYPE_INT,
    TYPE_FLOAT,
    TYPE_BOOL,
    TYPE_STRING,
    TYPE_VOID,
    TYPE_ARRAY,
    TYPE_STRUCT,
    TYPE_ENUM,
    TYPE_UNION,
    TYPE_GENERIC,
    TYPE_LIST_INT,
    TYPE_LIST_STRING,
    TYPE_LIST_GENERIC,
    TYPE_FUNCTION,
    TYPE_TUPLE,
    TYPE_OPAQUE,
    TYPE_UNKNOWN
}

enum DiagnosticSeverity {
    DIAG_INFO,
    DIAG_WARNING,
    DIAG_ERROR
}

enum CompilerPhase {
    PHASE_LEXER,
    PHASE_PARSER,
    PHASE_TYPECHECK,
    PHASE_TRANSPILER,
    PHASE_RUNTIME
}

struct ParseNode {
    node_type: int,
    line: int,
    column: int
}

struct ASTNumber {
    node_type: int,
    line: int,
    column: int,
    value: string
}

struct ASTFloat {
    node_type: int,
    line: int,
    column: int,
    value: string
}

struct ASTString {
    node_type: int,
    line: int,
    column: int,
    value: string
}

struct ASTBool {
    node_type: int,
    line: int,
    column: int,
    value: bool
}

struct ASTIdentifier {
    node_type: int,
    line: int,
    column: int,
    name: string
}

struct ASTBinaryOp {
    node_type: int,
    line: int,
    column: int,
    op: int,
    left: int,
    right: int,
    left_type: int,
    right_type: int
}

struct ASTCall {
    node_type: int,
    line: int,
    column: int,
    function: int,
    arg_start: int,
    arg_count: int
}

struct ASTArrayLiteral {
    node_type: int,
    line: int,
    column: int,
    element_type: string,
    element_start: int,
    element_count: int
}

struct ASTLet {
    node_type: int,
    line: int,
    column: int,
    name: string,
    var_type: string,
    value: int,
    value_type: int,
    is_mut: bool
}

struct ASTSet {
    node_type: int,
    line: int,
    column: int,
    target: string,
    value: int,
    value_type: int
}

struct ASTStmtRef {
    node_id: int,
    node_type: int
}

struct ASTIf {
    node_type: int,
    line: int,
    column: int,
    condition: int,
    condition_type: int,
    then_body: int,
    else_body: int
}

struct ASTWhile {
    node_type: int,
    line: int,
    column: int,
    condition: int,
    condition_type: int,
    body: int
}

struct ASTFor {
    node_type: int,
    line: int,
    column: int,
    var_name: string,
    iterable: int,
    iterable_type: int,
    body: int
}

struct ASTReturn {
    node_type: int,
    line: int,
    column: int,
    value: int,
    value_type: int
}

struct ASTBlock {
    node_type: int,
    line: int,
    column: int,
    statement_start: int,
    statement_count: int
}

struct ASTUnsafeBlock {
    node_type: int,
    line: int,
    column: int,
    statement_start: int,
    statement_count: int
}

struct ASTPrint {
    node_type: int,
    line: int,
    column: int,
    value: int,
    value_type: int
}

struct ASTAssert {
    node_type: int,
    line: int,
    column: int,
    condition: int,
    condition_type: int
}

struct ASTFunction {
    node_type: int,
    line: int,
    column: int,
    name: string,
    param_start: int,
    param_count: int,
    return_type: string,
    body: int
}

struct ASTShadow {
    node_type: int,
    line: int,
    column: int,
    target_name: string,
    body: int
}

struct ASTStruct {
    node_type: int,
    line: int,
    column: int,
    name: string,
    field_count: int
}

struct ASTStructLiteral {
    node_type: int,
    line: int,
    column: int,
    struct_name: string,
    field_names: array<string>,
    field_value_ids: array<int>,
    field_value_types: array<int>,
    field_count: int
}

struct ASTFieldAccess {
    node_type: int,
    line: int,
    column: int,
    object: int,
    object_type: int,
    field_name: string
}

struct ASTEnum {
    node_type: int,
    line: int,
    column: int,
    name: string,
    variant_count: int
}

struct ASTUnion {
    node_type: int,
    line: int,
    column: int,
    name: string,
    variant_count: int
}

struct ASTUnionConstruct {
    node_type: int,
    line: int,
    column: int,
    union_name: string,
    variant_name: string,
    field_names: array<string>,
    field_value_ids: array<int>,
    field_value_types: array<int>,
    field_count: int
}

struct ASTMatchArm {
    variant_name: string,
    binding_name: string,
    body_id: int,
    body_type: int
}

struct ASTMatch {
    node_type: int,
    line: int,
    column: int,
    scrutinee: int,
    scrutinee_type: int,
    arm_variants: array<string>,
    arm_bindings: array<string>,
    arm_body_ids: array<int>,
    arm_body_types: array<int>,
    arm_count: int
}

struct ASTImport {
    node_type: int,
    line: int,
    column: int,
    module_path: string,
    module_name: string
}

struct ASTOpaqueType {
    node_type: int,
    line: int,
    column: int,
    type_name: string
}

struct ASTTupleLiteral {
    node_type: int,
    line: int,
    column: int,
    element_ids: array<int>,
    element_types: array<int>,
    element_count: int
}

struct ASTTupleIndex {
    node_type: int,
    line: int,
    column: int,
    tuple: int,
    tuple_type: int,
    index: int
}

struct Parser {
    tokens: List<LexerToken>,
    position: int,
    token_count: int,
    has_error: bool,
    numbers: List<ASTNumber>,
    floats: List<ASTFloat>,
    strings: List<ASTString>,
    bools: List<ASTBool>,
    identifiers: List<ASTIdentifier>,
    binary_ops: List<ASTBinaryOp>,
    calls: List<ASTCall>,
    call_args: List<ASTStmtRef>,
    array_elements: List<ASTStmtRef>,
    array_literals: List<ASTArrayLiteral>,
    lets: List<ASTLet>,
    sets: List<ASTSet>,
    ifs: List<ASTIf>,
    whiles: List<ASTWhile>,
    fors: List<ASTFor>,
    returns: List<ASTReturn>,
    blocks: List<ASTBlock>,
    unsafe_blocks: List<ASTUnsafeBlock>,
    block_statements: List<ASTStmtRef>,
    prints: List<ASTPrint>,
    asserts: List<ASTAssert>,
    functions: List<ASTFunction>,
    shadows: List<ASTShadow>,
    structs: List<ASTStruct>,
    struct_literals: List<ASTStructLiteral>,
    field_accesses: List<ASTFieldAccess>,
    enums: List<ASTEnum>,
    unions: List<ASTUnion>,
    union_constructs: List<ASTUnionConstruct>,
    matches: List<ASTMatch>,
    imports: List<ASTImport>,
    opaque_types: List<ASTOpaqueType>,
    tuple_literals: List<ASTTupleLiteral>,
    tuple_indices: List<ASTTupleIndex>,
    numbers_count: int,
    floats_count: int,
    strings_count: int,
    bools_count: int,
    identifiers_count: int,
    binary_ops_count: int,
    calls_count: int,
    array_literals_count: int,
    lets_count: int,
    sets_count: int,
    ifs_count: int,
    whiles_count: int,
    fors_count: int,
    returns_count: int,
    blocks_count: int,
    unsafe_blocks_count: int,
    block_statements_count: int,
    prints_count: int,
    asserts_count: int,
    functions_count: int,
    shadows_count: int,
    structs_count: int,
    struct_literals_count: int,
    field_accesses_count: int,
    enums_count: int,
    unions_count: int,
    union_constructs_count: int,
    matches_count: int,
    imports_count: int,
    opaque_types_count: int,
    tuple_literals_count: int,
    tuple_indices_count: int,
    next_node_id: int,
    last_expr_node_id: int,
    last_expr_node_type: int
}

struct Type {
    kind: int,
    name: string,
    element_type_kind: int,
    element_type_name: string
}

struct OptionType {
    has_value: bool,
    value: Type
}

struct CompilerSourceLocation {
    file: string,
    line: int,
    column: int
}

struct CompilerDiagnostic {
    phase: int,
    severity: int,
    code: string,
    message: string,
    location: CompilerSourceLocation
}

struct LexPhaseOutput {
    tokens: List<LexerToken>,
    token_count: int,
    diagnostics: List<CompilerDiagnostic>,
    had_error: bool
}

struct ParsePhaseOutput {
    parser: Parser,
    diagnostics: List<CompilerDiagnostic>,
    had_error: bool
}

struct TypecheckPhaseOutput {
    environment: TypeEnvironment,
    diagnostics: List<CompilerDiagnostic>,
    had_error: bool
}

struct TranspilePhaseOutput {
    c_source: string,
    diagnostics: List<CompilerDiagnostic>,
    had_error: bool,
    output_path: string
}
