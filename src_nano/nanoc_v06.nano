/* =============================================================================
 * NanoLang v0.6 - Truly Self-Hosted Compiler Driver
 * =============================================================================
 * 
 * Complete compiler implementation in NanoLang that does NOT depend on bin/nanoc_c.
 * 
 * Pipeline:
 * 1. Lexer:       tokenize_file_result() -> Result<TokenList, Diagnostic>
 * 2. Parser:      parse_program() -> Parser
 * 3. Typechecker: typecheck_parser() -> int
 * 4. Transpiler:  transpile_parser() -> string (C code)
 * 5. C Compiler:  system("cc ...") -> int
 * 
 * This is TRUE SELF-HOSTING - no dependency on nanoc_c!
 */

import "src_nano/compiler/lexer.nano"
import "src_nano/parser.nano"
import "src_nano/typecheck.nano"
import "src_nano/transpiler.nano"
import "src_nano/compiler/diagnostics.nano" as Diagnostics

/* CLI argument access */
extern fn get_argc() -> int
extern fn get_argv(index: int) -> string

/* File I/O */
extern fn file_read(path: string) -> string
extern fn file_write(path: string, content: string) -> int
extern fn file_exists(path: string) -> bool

/* System commands - wrapper to avoid stdlib.h system() conflict */
extern fn nl_exec_shell(cmd: string) -> int

/* =============================================================================
 * CLI ARGUMENT PARSING
 * ============================================================================= */

struct CompileOptions {
    input_file: string,
    output_file: string,
    verbose: bool,
    keep_c: bool,
    show_help: bool
}

fn default_options() -> CompileOptions {
    return CompileOptions {
        input_file: "",
        output_file: "a.out",
        verbose: false,
        keep_c: false,
        show_help: false
    }
}

fn parse_args() -> CompileOptions {
    let argc: int = (get_argc)
    let mut opts: CompileOptions = (default_options)
    let mut i: int = 1
    
    while (< i argc) {
        let arg: string = (get_argv i)
        
        if (str_equals arg "-h") {
            set opts CompileOptions {
                input_file: opts.input_file,
                output_file: opts.output_file,
                verbose: opts.verbose,
                keep_c: opts.keep_c,
                show_help: true
            }
        } else {
            if (str_equals arg "--help") {
                set opts CompileOptions {
                    input_file: opts.input_file,
                    output_file: opts.output_file,
                    verbose: opts.verbose,
                    keep_c: opts.keep_c,
                    show_help: true
                }
            } else {
                if (str_equals arg "-v") {
                    set opts CompileOptions {
                        input_file: opts.input_file,
                        output_file: opts.output_file,
                        verbose: true,
                        keep_c: opts.keep_c,
                        show_help: opts.show_help
                    }
                } else {
                    if (str_equals arg "--verbose") {
                        set opts CompileOptions {
                            input_file: opts.input_file,
                            output_file: opts.output_file,
                            verbose: true,
                            keep_c: opts.keep_c,
                            show_help: opts.show_help
                        }
                    } else {
                        if (str_equals arg "-k") {
                            set opts CompileOptions {
                                input_file: opts.input_file,
                                output_file: opts.output_file,
                                verbose: opts.verbose,
                                keep_c: true,
                                show_help: opts.show_help
                            }
                        } else {
                            if (str_equals arg "--keep-c") {
                                set opts CompileOptions {
                                    input_file: opts.input_file,
                                    output_file: opts.output_file,
                                    verbose: opts.verbose,
                                    keep_c: true,
                                    show_help: opts.show_help
                                }
                            } else {
                                if (str_equals arg "-o") {
                                    if (< (+ i 1) argc) {
                                        set i (+ i 1)
                                        let output: string = (get_argv i)
                                        set opts CompileOptions {
                                            input_file: opts.input_file,
                                            output_file: output,
                                            verbose: opts.verbose,
                                            keep_c: opts.keep_c,
                                            show_help: opts.show_help
                                        }
                                    } else {
                                        (print "")
                                    }
                                } else {
                                    /* Assume it's the input file if no option prefix */
                                    if (== opts.input_file "") {
                                        set opts CompileOptions {
                                            input_file: arg,
                                            output_file: opts.output_file,
                                            verbose: opts.verbose,
                                            keep_c: opts.keep_c,
                                            show_help: opts.show_help
                                        }
                                    } else {
                                        (print "")
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        set i (+ i 1)
    }
    
    return opts
}

/* =============================================================================
 * TOOLCHAIN CONFIGURATION
 * ============================================================================= */

fn resolve_cc_binary() -> string {
    let nano_cc: string = (getenv "NANO_CC")
    if (!= nano_cc "") {
        return nano_cc
    } else {
        let cc_env: string = (getenv "CC")
        if (!= cc_env "") {
            return cc_env
        } else {
            return "cc"
        }
    }
}

/* =============================================================================
 * STRING HELPERS
 * ============================================================================= */

fn nlc_str_starts_with(s: string, prefix: string) -> bool {
    let len_s: int = (str_length s)
    let len_p: int = (str_length prefix)
    if (< len_s len_p) {
        return false
    } else {
        return (str_equals (str_substring s 0 len_p) prefix)
    }
}

fn nlc_str_ends_with(s: string, suffix: string) -> bool {
    let len_s: int = (str_length s)
    let len_x: int = (str_length suffix)
    if (< len_s len_x) {
        return false
    } else {
        return (str_equals (str_substring s (- len_s len_x) len_x) suffix)
    }
}

fn nlc_str_index_of(s: string, needle: string) -> int {
    let len_s: int = (str_length s)
    let len_n: int = (str_length needle)
    if (== len_n 0) {
        return 0
    } else {
        let mut i: int = 0
        while (<= (+ i len_n) len_s) {
            if (str_equals (str_substring s i len_n) needle) {
                return i
            } else {
                (print "")
            }
            set i (+ i 1)
        }
        return -1
    }
}

fn nlc_str_last_index_of(s: string, needle: string) -> int {
    let len_s: int = (str_length s)
    let len_n: int = (str_length needle)
    if (== len_n 0) {
        return len_s
    } else {
        let mut i: int = (- len_s len_n)
        while (>= i 0) {
            if (str_equals (str_substring s i len_n) needle) {
                return i
            } else {
                set i (- i 1)
            }
        }
        return -1
    }
}

fn nlc_array_contains_string(arr: array<string>, needle: string) -> bool {
    let mut i: int = 0
    while (< i (array_length arr)) {
        if (str_equals (at arr i) needle) {
            return true
        } else {
            (print "")
        }
        set i (+ i 1)
    }
    return false
}

/* =============================================================================
 * IMPORT RESOLUTION (SIMPLIFIED)
 * ============================================================================= */

fn nl_path_dirname(path: string) -> string {
    let mut p: string = path
    if (nlc_str_ends_with p "/") {
        set p (str_substring p 0 (- (str_length p) 1))
    } else { (print "") }

    let idx: int = (nlc_str_last_index_of p "/")
    if (== idx -1) {
        return "."
    } else {
        if (== idx 0) { return "/" } else { return (str_substring p 0 idx) }
    }
}

fn nl_path_join(dir: string, rel: string) -> string {
    if (or (== dir "") (== dir ".")) {
        return rel
    } else {
        if (nlc_str_ends_with dir "/") {
            return (str_concat dir rel)
        } else {
            return (str_concat (str_concat dir "/") rel)
        }
    }
}

fn find_repo_root(start_dir: string) -> string {
    let mut dir: string = start_dir
    let mut i: int = 0
    while (< i 25) {
        let marker1: string = (nl_path_join dir ".beads/issues.jsonl")
        let marker2: string = (nl_path_join dir "src_nano/nanoc_v06.nano")
        if (or (file_exists marker1) (file_exists marker2)) {
            return dir
        } else {
            let parent: string = (nl_path_dirname dir)
            if (or (== parent dir) (== parent "")) {
                return ""
            } else {
                set dir parent
            }
        }
        set i (+ i 1)
    }
    return ""
}

fn split_lines(s: string) -> array<string> {
    let len: int = (str_length s)
    let mut out: array<string> = []
    let mut start: int = 0
    let mut i: int = 0

    while (< i len) {
        if (str_equals (str_substring s i 1) "\n") {
            set out (array_push out (str_substring s start (- i start)))
            set start (+ i 1)
        } else { (print "") }
        set i (+ i 1)
    }

    if (<= start len) {
        set out (array_push out (str_substring s start (- len start)))
    } else { (print "") }
    return out
}

fn parse_import_path_from_line(line: string) -> string {
    /* Handle both: import "path" and from "path" import ... */
    let has_import: bool = (nlc_str_starts_with line "import \"")
    let has_from: bool = (nlc_str_starts_with line "from \"")
    
    if (or has_import has_from) {
        let first_q: int = (nlc_str_index_of line "\"")
        let last_q: int = (nlc_str_last_index_of line "\"")
        if (and (>= first_q 0) (> last_q first_q)) {
            return (str_substring line (+ first_q 1) (- last_q (+ first_q 1)))
        } else {
            return ""
        }
    } else {
        return ""
    }
}

fn strip_pub_decl(line: string) -> string {
    if (nlc_str_starts_with line "pub fn ") {
        return (str_concat "fn " (str_substring line 7 (- (str_length line) 7)))
    } else {
        if (nlc_str_starts_with line "pub struct ") {
            return (str_concat "struct " (str_substring line 11 (- (str_length line) 11)))
        } else {
            if (nlc_str_starts_with line "pub enum ") {
                return (str_concat "enum " (str_substring line 9 (- (str_length line) 9)))
            } else {
                if (nlc_str_starts_with line "pub union ") {
                    return (str_concat "union " (str_substring line 10 (- (str_length line) 10)))
                } else {
                    return line
                }
            }
        }
    }
}

fn resolve_import_path(current_file: string, import_path: string, repo_root: string) -> string {
    if (== import_path "") {
        return ""
    } else {
        if (nlc_str_starts_with import_path "/") {
            return import_path
        } else {
            if (or (nlc_str_starts_with import_path "./") (nlc_str_starts_with import_path "../")) {
                return (nl_path_join (nl_path_dirname current_file) import_path)
            } else {
                if (!= repo_root "") {
                    return (nl_path_join repo_root import_path)
                } else {
                    return import_path
                }
            }
        }
    }
}

struct CollectResult {
    visited: array<string>,
    order: array<string>,
    ok: bool
}

fn collect_files_dfs(path: string, repo_root: string, visited: array<string>, order: array<string>, ok: bool) -> CollectResult {
    if (not ok) {
        return CollectResult { visited: visited, order: order, ok: false }
    } else { (print "") }

    if (nlc_array_contains_string visited path) {
        return CollectResult { visited: visited, order: order, ok: true }
    } else {
        let mut visited2: array<string> = (array_push visited path)
        let src: string = (file_read path)
        let lines: array<string> = (split_lines src)

        let mut order2: array<string> = order
        let mut ok2: bool = true
        let mut i: int = 0
        while (< i (array_length lines)) {
            let imp: string = (parse_import_path_from_line (at lines i))
            if (!= imp "") {
                let dep: string = (resolve_import_path path imp repo_root)
                if (== dep "") {
                    (print "Error: bad import path in ")
                    (println path)
                    set ok2 false
                } else {
                    if (file_exists dep) {
                        let res: CollectResult = (collect_files_dfs dep repo_root visited2 order2 ok2)
                        set visited2 res.visited
                        set order2 res.order
                        set ok2 res.ok
                    } else {
                        (print "Error: import not found: ")
                        (println dep)
                        set ok2 false
                    }
                }
            } else { (print "") }
            set i (+ i 1)
        }

        if ok2 {
            set order2 (array_push order2 path)
        } else { (print "") }
        return CollectResult { visited: visited2, order: order2, ok: ok2 }
    }
}

fn merge_with_imports(input_file: string) -> string {
    let repo_root: string = (find_repo_root (nl_path_dirname input_file))
    let start: string = input_file

    let visited0: array<string> = []
    let order0: array<string> = []
    let res: CollectResult = (collect_files_dfs start repo_root visited0 order0 true)
    let files: array<string> = res.order
    if (not res.ok) {
        return ""
    } else { (print "") }

    let mut merged: string = ""
    let mut i: int = 0
    while (< i (array_length files)) {
        let src: string = (file_read (at files i))
        let lines: array<string> = (split_lines src)
        let mut j: int = 0
        while (< j (array_length lines)) {
            let line: string = (at lines j)
            let imp: string = (parse_import_path_from_line line)
            if (== imp "") {
                set merged (str_concat merged (strip_pub_decl line))
                set merged (str_concat merged "\n")
            } else {
                (print "")
            }
            set j (+ j 1)
        }
        set i (+ i 1)
    }
    return merged
}

/* =============================================================================
 * COMPILATION PIPELINE
 * ============================================================================= */

fn compile_program(input_file: string, output_file: string, verbose: bool, keep_c: bool) -> int {
    if verbose {
        (println "")
        (println "╔══════════════════════════════════════════════════════════════╗")
        (println "║  NanoLang v0.6 - Self-Hosted Compiler                       ║")
        (println "╚══════════════════════════════════════════════════════════════╝")
        (println "")
        (print "Input:  ")
        (println input_file)
        (print "Output: ")
        (println output_file)
        (println "")
    } else {
        (print "")
    }
    
    /* Step 0: Merge imports into single source */
    if verbose {
        (println "[0/5] Resolving imports...")
    } else {
        (print "")
    }
    
    let merged_source: string = (merge_with_imports input_file)
    let temp_source_file: string = "/tmp/nanolang_merged.nano"
    let mut source_to_compile: string = input_file
    
    if (!= merged_source "") {
        /* Imports resolved - use merged file */
        if verbose {
            (print "  ✓ Merged source: ")
            (print (int_to_string (str_length merged_source)))
            (println " bytes")
        } else {
            (print "")
        }
        let write_merged: int = (file_write temp_source_file merged_source)
        /* DEBUG: Also write to /tmp/merged_debug.nano for inspection */
        let debug_write: int = (file_write "/tmp/merged_debug.nano" merged_source)
        (print "")  /* Suppress unused variable warning */
        if (== write_merged 0) {
            set source_to_compile temp_source_file
        } else {
            set source_to_compile input_file
        }
    } else {
        /* No imports or merge failed - use original file */
        if verbose {
            (println "  ✓ No imports to resolve")
        } else {
            (print "")
        }
    }
    
    /* Step 1: Lexer - Tokenize source file */
    if verbose {
        (println "[1/5] Lexing...")
    } else {
        (print "")
    }
    
    /* Create diagnostics list for lexer */
    let diags: List<CompilerDiagnostic> = (list_CompilerDiagnostic_new)
    
    let tokens: List<LexerToken> = (tokenize_file source_to_compile diags)
    let token_count: int = (list_LexerToken_length tokens)
    
    if (== token_count 0) {
        (println "Error: Failed to tokenize input file")
        return 1
    } else {
        (print "")
            
            if verbose {
                (print "  ✓ Tokenized ")
                (print (int_to_string token_count))
                (println " tokens")
            } else {
                (print "")
            }
            
            /* Step 2: Parser - Build AST */
            if verbose {
                (println "[2/5] Parsing...")
            } else {
                (print "")
            }
            
            let parser: Parser = (parse_program tokens token_count source_to_compile)
            if (parser_has_error parser) {
                let tok: LexerToken = (parser_current parser)
                (print "Parse error at line ")
                (print (int_to_string tok.line))
                (print ", column ")
                (print (int_to_string tok.column))
                (print ": unexpected token '")
                (print tok.value)
                (println "'")
                return 1
            } else {
                (print "")
            }
            
            let func_count: int = (parser_get_function_count parser)
            let lets_count: int = (parser_get_let_count parser)
            (println (+ "DEBUG: Parser has " (+ (int_to_string lets_count) (+ " lets, " (+ (int_to_string func_count) " functions")))))
            if verbose {
                (print "  ✓ Parsed ")
                (print (int_to_string func_count))
                (println " functions")
            } else {
                (print "")
            }
            
            /* Step 3: Typechecker - Verify semantics */
            if verbose {
                (println "[3/5] NSType checking...")
            } else {
                (print "")
            }
            
            let typecheck_result: int = (typecheck_parser parser)
            if (!= typecheck_result 0) {
                (println "NSType checking failed")
                return 1
            } else {
                (print "")
            }
            
            if verbose {
                (println "  ✓ NSType checking passed")
            } else {
                (print "")
            }
            
            /* Step 4: Transpiler - Generate C code */
            if verbose {
                (println "[4/5] Generating C code...")
            } else {
                (print "")
            }
            
            let c_code: string = (transpile_parser parser)
            
            if verbose {
                (print "  ✓ Generated ")
                (print (int_to_string (str_length c_code)))
                (println " bytes of C code")
            } else {
                (print "")
            }
            
            /* Write C code to temporary file */
            let c_file: string = "/tmp/nanolang_temp.c"
            let write_result: int = (file_write c_file c_code)
            if (!= write_result 0) {
                (println "Error: Failed to write C file")
                return 1
            } else {
                (print "")
            }
            
            /* Step 5: C Compiler - Compile to executable */
            if verbose {
                (println "[5/5] Compiling C to executable...")
            } else {
                (print "")
            }
            
            /* Build C compiler command with runtime library files
             * The transpiler generates calls to runtime functions (dyn_array_*, gc_*, etc.)
             * We must link with the runtime C sources to provide these implementations.
             * This matches what the C compiler does in src/main.c line 461.
             */
            let cc_bin: string = (resolve_cc_binary)
            let mut cc_cmd: string = (str_concat cc_bin " -std=c99 -Isrc ")
            let extra_cflags: string = (getenv "NANO_CFLAGS")
            if (!= extra_cflags "") {
                set cc_cmd (str_concat cc_cmd extra_cflags)
                set cc_cmd (str_concat cc_cmd " ")
            } else {
                (print "")
            }
            set cc_cmd (str_concat cc_cmd c_file)
            set cc_cmd (str_concat cc_cmd " -o ")
            set cc_cmd (str_concat cc_cmd output_file)
            /* Add runtime library sources */
            set cc_cmd (str_concat cc_cmd " src/runtime/list_int.c")
            set cc_cmd (str_concat cc_cmd " src/runtime/list_string.c")
            set cc_cmd (str_concat cc_cmd " src/runtime/list_LexerToken.c")
            set cc_cmd (str_concat cc_cmd " src/runtime/token_helpers.c")
            set cc_cmd (str_concat cc_cmd " src/runtime/gc.c")
            set cc_cmd (str_concat cc_cmd " src/runtime/dyn_array.c")
            set cc_cmd (str_concat cc_cmd " src/runtime/gc_struct.c")
            set cc_cmd (str_concat cc_cmd " src/runtime/nl_string.c")
            set cc_cmd (str_concat cc_cmd " src/runtime/cli.c")
            set cc_cmd (str_concat cc_cmd " -lm")
            let extra_ldflags: string = (getenv "NANO_LDFLAGS")
            if (!= extra_ldflags "") {
                set cc_cmd (str_concat cc_cmd " ")
                set cc_cmd (str_concat cc_cmd extra_ldflags)
            } else {
                (print "")
            }
            set cc_cmd (str_concat cc_cmd " 2>&1")
            
            if verbose {
                (print "  Command: ")
                (println cc_cmd)
            } else {
                (print "")
            }
            
            let cc_result: int = (nl_exec_shell cc_cmd)
            if (!= cc_result 0) {
                (println "Error: C compilation failed")
                return 1
            } else {
                (print "")
            }
            
            if verbose {
                (println "  ✓ Executable created")
                (println "")
                (println "╔══════════════════════════════════════════════════════════════╗")
                (println "║  ✅ COMPILATION SUCCESSFUL (100% NanoLang Pipeline)         ║")
                (println "╚══════════════════════════════════════════════════════════════╝")
                (println "")
            } else {
                (print "")
            }
            
            /* Clean up temp file unless --keep-c */
            if (not keep_c) {
                let rm_cmd: string = (str_concat "rm -f " c_file)
                let rm_result: int = (nl_exec_shell rm_cmd)
                /* Ignore result - cleanup is non-critical */
                (print "")
            } else {
                if verbose {
                    (print "Kept C file: ")
                    (println c_file)
                } else {
                    (print "")
                }
            }
            
            return 0
    }
}

/* =============================================================================
 * MAIN ENTRY POINT
 * ============================================================================= */

fn show_usage() -> int {
    (println "")
    (println "╔══════════════════════════════════════════════════════════════╗")
    (println "║  NanoLang v0.6 - Self-Hosted Compiler                       ║")
    (println "╚══════════════════════════════════════════════════════════════╝")
    (println "")
    (println "Usage: nanoc <input.nano> [-o output] [options]")
    (println "")
    (println "Options:")
    (println "  -o <file>        Output executable (default: a.out)")
    (println "  -v, --verbose    Verbose compilation output")
    (println "  -k, --keep-c     Keep generated C file")
    (println "  -h, --help       Show this help")
    (println "")
    (println "This compiler is 100% written in NanoLang!")
    (println "Pipeline: Lex → Parse → Typecheck → Transpile → Compile")
    (println "")
    return 0
}

fn main() -> int {
    let opts: CompileOptions = (parse_args)
    
    if opts.show_help {
        return (show_usage)
    } else {
        (print "")
    }
    
    if (== opts.input_file "") {
        (println "Error: No input file specified")
        (println "Try 'nanoc --help' for usage information")
        return 1
    } else {
        (print "")
    }
    
    if (not (file_exists opts.input_file)) {
        (print "Error: Input file not found: ")
        (println opts.input_file)
        return 1
    } else {
        (print "")
    }
    
    return (compile_program opts.input_file opts.output_file opts.verbose opts.keep_c)
}

shadow main {
    /* Basic sanity check */
    assert (== 1 1)
}
