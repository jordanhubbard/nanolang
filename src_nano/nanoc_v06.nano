/* =============================================================================
 * NanoLang v0.6 - Truly Self-Hosted Compiler Driver
 * =============================================================================
 * 
 * Complete compiler implementation in NanoLang that does NOT depend on bin/nanoc_c.
 * 
 * Pipeline:
 * 1. Lexer:       tokenize_file_result() -> Result<TokenList, Diagnostic>
 * 2. Parser:      parse_program() -> Parser
 * 3. Typechecker: typecheck_parser() -> int
 * 4. Transpiler:  transpile_parser() -> string (C code)
 * 5. C Compiler:  system("cc ...") -> int
 * 
 * This is TRUE SELF-HOSTING - no dependency on nanoc_c!
 */

import "src_nano/compiler/lexer.nano"
import "src_nano/parser.nano"
import "src_nano/typecheck.nano"
import "src_nano/transpiler.nano"
import "src_nano/compiler/diagnostics.nano" as Diagnostics

/* CLI argument access */
extern fn get_argc() -> int
extern fn get_argv(index: int) -> string

/* File I/O */
extern fn file_read(path: string) -> string
extern fn file_write(path: string, content: string) -> int
extern fn file_exists(path: string) -> bool

/* System commands - wrapper to avoid stdlib.h system() conflict */
extern fn nl_exec_shell(cmd: string) -> int

/* =============================================================================
 * CLI ARGUMENT PARSING
 * ============================================================================= */

struct CompileOptions {
    input_file: string,
    output_file: string,
    verbose: bool,
    keep_c: bool,
    show_intermediate_code: bool,
    llm_diags_json_path: string,
    show_help: bool
}

fn default_options() -> CompileOptions {
    return CompileOptions {
        input_file: "",
        output_file: "a.out",
        verbose: false,
        keep_c: false,
        show_intermediate_code: false,
        llm_diags_json_path: "",
        show_help: false
    }
}

shadow default_options {
    let opts: CompileOptions = (default_options)
    assert (== opts.output_file "a.out")
    assert (not opts.verbose)
    assert (not opts.show_help)
}

fn parse_args() -> CompileOptions {
    let argc: int = (get_argc)
    let mut opts: CompileOptions = (default_options)
    let mut i: int = 1
    
    while (< i argc) {
        let arg: string = (get_argv i)
        
        if (== arg "-h") {
            set opts CompileOptions {
                input_file: opts.input_file,
                output_file: opts.output_file,
                verbose: opts.verbose,
                keep_c: opts.keep_c,
                show_intermediate_code: opts.show_intermediate_code,
                llm_diags_json_path: opts.llm_diags_json_path,
                show_help: true
            }
        } else {
            if (== arg "--help") {
                set opts CompileOptions {
                    input_file: opts.input_file,
                    output_file: opts.output_file,
                    verbose: opts.verbose,
                    keep_c: opts.keep_c,
                    show_intermediate_code: opts.show_intermediate_code,
                    llm_diags_json_path: opts.llm_diags_json_path,
                    show_help: true
                }
            } else {
                if (== arg "-v") {
                    set opts CompileOptions {
                        input_file: opts.input_file,
                        output_file: opts.output_file,
                        verbose: true,
                        keep_c: opts.keep_c,
                        show_intermediate_code: opts.show_intermediate_code,
                        llm_diags_json_path: opts.llm_diags_json_path,
                        show_help: opts.show_help
                    }
                } else {
                    if (== arg "--verbose") {
                        set opts CompileOptions {
                            input_file: opts.input_file,
                            output_file: opts.output_file,
                            verbose: true,
                            keep_c: opts.keep_c,
                            show_intermediate_code: opts.show_intermediate_code,
                            llm_diags_json_path: opts.llm_diags_json_path,
                            show_help: opts.show_help
                        }
                    } else {
                        if (== arg "-k") {
                            set opts CompileOptions {
                                input_file: opts.input_file,
                                output_file: opts.output_file,
                                verbose: opts.verbose,
                                keep_c: true,
                                show_intermediate_code: opts.show_intermediate_code,
                                llm_diags_json_path: opts.llm_diags_json_path,
                                show_help: opts.show_help
                            }
                        } else {
                            if (== arg "--keep-c") {
                                set opts CompileOptions {
                                    input_file: opts.input_file,
                                    output_file: opts.output_file,
                                    verbose: opts.verbose,
                                    keep_c: true,
                                    show_intermediate_code: opts.show_intermediate_code,
                                    llm_diags_json_path: opts.llm_diags_json_path,
                                    show_help: opts.show_help
                                }
                            } else {
                                if (== arg "-fshow-intermediate-code") {
                                    set opts CompileOptions {
                                        input_file: opts.input_file,
                                        output_file: opts.output_file,
                                        verbose: opts.verbose,
                                        keep_c: opts.keep_c,
                                        show_intermediate_code: true,
                                        llm_diags_json_path: opts.llm_diags_json_path,
                                        show_help: opts.show_help
                                    }
                                } else {
                                if (== arg "--llm-diags-json") {
                                    if (< (+ i 1) argc) {
                                        set i (+ i 1)
                                        let p: string = (get_argv i)
                                        set opts CompileOptions {
                                            input_file: opts.input_file,
                                            output_file: opts.output_file,
                                            verbose: opts.verbose,
                                            keep_c: opts.keep_c,
                                            show_intermediate_code: opts.show_intermediate_code,
                                            llm_diags_json_path: p,
                                            show_help: opts.show_help
                                        }
                                    } else { (print "") }
                                } else {
                                if (== arg "-o") {
                                    if (< (+ i 1) argc) {
                                        set i (+ i 1)
                                        let output: string = (get_argv i)
                                        set opts CompileOptions {
                                            input_file: opts.input_file,
                                            output_file: output,
                                            verbose: opts.verbose,
                                            keep_c: opts.keep_c,
                                            show_intermediate_code: opts.show_intermediate_code,
                                            llm_diags_json_path: opts.llm_diags_json_path,
                                            show_help: opts.show_help
                                        }
                                    } else {
                                        (print "")
                                    }
                                } else {
                                    /* Assume it's the input file if no option prefix */
                                    if (== opts.input_file "") {
                                        set opts CompileOptions {
                                            input_file: arg,
                                            output_file: opts.output_file,
                                            verbose: opts.verbose,
                                            keep_c: opts.keep_c,
                                            show_intermediate_code: opts.show_intermediate_code,
                                            llm_diags_json_path: opts.llm_diags_json_path,
                                            show_help: opts.show_help
                                        }
                                    } else {
                                        (print "")
                                    }
                                }
                                }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        set i (+ i 1)
    }
    
    return opts
}

/* =============================================================================
 * TOOLCHAIN CONFIGURATION
 * ============================================================================= */

fn resolve_cc_binary() -> string {
    let nano_cc: string = (getenv "NANO_CC")
    if (!= nano_cc "") {
        return nano_cc
    } else {
        let cc_env: string = (getenv "CC")
        if (!= cc_env "") {
            return cc_env
        } else {
            return "cc"
        }
    }
}

shadow resolve_cc_binary {
    let cc: string = (resolve_cc_binary)
    /* Should return a valid string (at minimum "cc") */
    assert (> (str_length cc) 0)
}

/* =============================================================================
 * STRING HELPERS
 * ============================================================================= */

fn nlc_str_starts_with(s: string, prefix: string) -> bool {
    let len_s: int = (str_length s)
    let len_p: int = (str_length prefix)
    if (< len_s len_p) {
        return false
    } else {
        return (== (str_substring s 0 len_p) prefix)
    }
}

fn nlc_str_ends_with(s: string, suffix: string) -> bool {
    let len_s: int = (str_length s)
    let len_x: int = (str_length suffix)
    if (< len_s len_x) {
        return false
    } else {
        return (== (str_substring s (- len_s len_x) len_x) suffix)
    }
}

fn nlc_str_index_of(s: string, needle: string) -> int {
    let len_s: int = (str_length s)
    let len_n: int = (str_length needle)
    if (== len_n 0) {
        return 0
    } else {
        let mut i: int = 0
        while (<= (+ i len_n) len_s) {
            if (== (str_substring s i len_n) needle) {
                return i
            } else {
                (print "")
            }
            set i (+ i 1)
        }
        return -1
    }
}

fn nlc_str_last_index_of(s: string, needle: string) -> int {
    let len_s: int = (str_length s)
    let len_n: int = (str_length needle)
    if (== len_n 0) {
        return len_s
    } else {
        let mut i: int = (- len_s len_n)
        while (>= i 0) {
            if (== (str_substring s i len_n) needle) {
                return i
            } else {
                set i (- i 1)
            }
        }
        return -1
    }
}

fn nlc_hashset_new_string() -> HashMap<string, int> {
    let s: HashMap<string, int> = (map_new)
    return s
}

shadow nlc_hashset_new_string {
    let s: HashMap<string, int> = (nlc_hashset_new_string)
    assert (!= s 0)  /* HashMap is a valid pointer */
}

fn nlc_hashset_has_string(hset: HashMap<string, int>, key: string) -> bool {
    return (map_has hset key)
}

shadow nlc_hashset_has_string {
    let s: HashMap<string, int> = (nlc_hashset_new_string)
    assert (not (nlc_hashset_has_string s "test"))
    (map_put s "test" 1)
    assert (nlc_hashset_has_string s "test")
}

fn nlc_hashset_add_string(hset: HashMap<string, int>, key: string) -> HashMap<string, int> {
    if (not (map_has hset key)) {
        (map_put hset key 1)
    } else { (print "") }
    return hset
}

shadow nlc_hashset_add_string {
    let s: HashMap<string, int> = (nlc_hashset_new_string)
    assert (not (nlc_hashset_has_string s "a"))
    let s2: HashMap<string, int> = (nlc_hashset_add_string s "a")
    assert (nlc_hashset_has_string s2 "a")
}

/* =============================================================================
 * IMPORT RESOLUTION (SIMPLIFIED)
 * ============================================================================= */

fn nl_path_dirname(path: string) -> string {
    let mut p: string = path
    if (nlc_str_ends_with p "/") {
        set p (str_substring p 0 (- (str_length p) 1))
    } else { (print "") }

    let idx: int = (nlc_str_last_index_of p "/")
    if (== idx -1) {
        return "."
    } else {
        if (== idx 0) { return "/" } else { return (str_substring p 0 idx) }
    }
}

fn nl_path_join(dir: string, rel: string) -> string {
    if (or (== dir "") (== dir ".")) {
        return rel
    } else {
        if (nlc_str_ends_with dir "/") {
            return (+ dir rel)
        } else {
            return (+ (+ dir "/") rel)
        }
    }
}

fn parse_env_int(name: string, default_val: int) -> int {
    let raw: string = (getenv name)
    if (== raw "") {
        return default_val
    } else {
        let n: int = (string_to_int raw)
        if (<= n 0) {
            return default_val
        } else {
            return n
        }
    }
}

shadow parse_env_int {
    assert (== (parse_env_int "___NANOLANG_TEST_ENV_INT___" 123) 123)
}

fn find_repo_root(start_dir: string) -> string {
    let mut dir: string = start_dir
    let mut i: int = 0
    let trace_env: string = (getenv "NANO_IMPORT_TRACE")
    let trace: bool = (!= trace_env "")
    while (< i 25) {
        if trace {
            (print "[import] find_repo_root: ")
            (println dir)
        } else { (print "") }
        let marker1: string = (nl_path_join dir ".beads/issues.jsonl")
        let marker2: string = (nl_path_join dir "src_nano/nanoc_v06.nano")
        if (or (file_exists marker1) (file_exists marker2)) {
            return dir
        } else {
            let parent: string = (nl_path_dirname dir)
            if (or (== parent dir) (== parent "")) {
                return ""
            } else {
                set dir parent
            }
        }
        set i (+ i 1)
    }
    return ""
}

fn split_lines(s: string) -> array<string> {
    let len: int = (str_length s)
    let mut out: array<string> = []
    let mut start: int = 0
    let mut i: int = 0

    while (< i len) {
        if (== (str_substring s i 1) "\n") {
            set out (array_push out (str_substring s start (- i start)))
            set start (+ i 1)
        } else { (print "") }
        set i (+ i 1)
    }

    if (<= start len) {
        set out (array_push out (str_substring s start (- len start)))
    } else { (print "") }
    return out
}

fn parse_import_path_from_line(line: string) -> string {
    /* Handle both: import "path" and from "path" import ... */
    let has_import: bool = (nlc_str_starts_with line "import \"")
    let has_from: bool = (nlc_str_starts_with line "from \"")
    
    if (or has_import has_from) {
        let first_q: int = (nlc_str_index_of line "\"")
        let last_q: int = (nlc_str_last_index_of line "\"")
        if (and (>= first_q 0) (> last_q first_q)) {
            return (str_substring line (+ first_q 1) (- last_q (+ first_q 1)))
        } else {
            return ""
        }
    } else {
        return ""
    }
}

fn strip_pub_decl(line: string) -> string {
    if (nlc_str_starts_with line "pub fn ") {
        return (+ "fn " (str_substring line 7 (- (str_length line) 7)))
    } else {
        if (nlc_str_starts_with line "pub struct ") {
            return (+ "struct " (str_substring line 11 (- (str_length line) 11)))
        } else {
            if (nlc_str_starts_with line "pub enum ") {
                return (+ "enum " (str_substring line 9 (- (str_length line) 9)))
            } else {
                if (nlc_str_starts_with line "pub union ") {
                    return (+ "union " (str_substring line 10 (- (str_length line) 10)))
                } else {
                    return line
                }
            }
        }
    }
}

fn resolve_import_path(current_file: string, import_path: string, repo_root: string) -> string {
    if (== import_path "") {
        return ""
    } else {
        if (nlc_str_starts_with import_path "/") {
            return import_path
        } else {
            if (or (nlc_str_starts_with import_path "./") (nlc_str_starts_with import_path "../")) {
                return (nl_path_join (nl_path_dirname current_file) import_path)
            } else {
                if (!= repo_root "") {
                    return (nl_path_join repo_root import_path)
                } else {
                    return import_path
                }
            }
        }
    }
}

struct CollectResult {
    visited: array<string>,
    visited_set: HashMap<string, int>,
    order: array<string>,
    ok: bool,
    lines_scanned: int
}

fn collect_files_dfs(path: string, repo_root: string, visited: array<string>, visited_set: HashMap<string, int>, order: array<string>, ok: bool, max_files: int, max_lines: int, max_lines_per_file: int, lines_scanned: int, trace: bool) -> CollectResult {
    if (not ok) {
        return CollectResult { visited: visited, visited_set: visited_set, order: order, ok: false, lines_scanned: lines_scanned }
    } else { (print "") }

    if (nlc_hashset_has_string visited_set path) {
        return CollectResult { visited: visited, visited_set: visited_set, order: order, ok: true, lines_scanned: lines_scanned }
    } else {
        let mut visited2: array<string> = (array_push visited path)
        let mut visited_set2: HashMap<string, int> = visited_set
        set visited_set2 (nlc_hashset_add_string visited_set2 path)
        if (> (array_length visited2) max_files) {
            (print "Error: import scan exceeded max files (")
            (print max_files)
            (print "): ")
            (println path)
            return CollectResult { visited: visited2, visited_set: visited_set2, order: order, ok: false, lines_scanned: lines_scanned }
        } else { (print "") }
        let src: string = (file_read path)
        let lines: array<string> = (split_lines src)

        let mut order2: array<string> = order
        let mut ok2: bool = true
        let mut i: int = 0
        let mut lines_scanned2: int = lines_scanned
        if trace {
            (print "[import] ")
            (println path)
        } else { (print "") }
        while (< i (array_length lines)) {
            set lines_scanned2 (+ lines_scanned2 1)
            if (> lines_scanned2 max_lines) {
                (print "Error: import scan exceeded max lines (")
                (print max_lines)
                (print ") while scanning: ")
                (println path)
                return CollectResult { visited: visited2, visited_set: visited_set2, order: order2, ok: false, lines_scanned: lines_scanned2 }
            } else { (print "") }
            if (> i max_lines_per_file) {
                (print "Error: import scan exceeded max lines per file (")
                (print max_lines_per_file)
                (print ") while scanning: ")
                (println path)
                return CollectResult { visited: visited2, visited_set: visited_set2, order: order2, ok: false, lines_scanned: lines_scanned2 }
            } else { (print "") }
            if (and trace (== (% lines_scanned2 500) 0)) {
                (print "[import] scanned lines: ")
                (println lines_scanned2)
            } else { (print "") }
            let imp: string = (parse_import_path_from_line (at lines i))
            if (!= imp "") {
                let dep: string = (resolve_import_path path imp repo_root)
                if (== dep "") {
                    (print "Error: bad import path in ")
                    (println path)
                    set ok2 false
                } else {
                    if (file_exists dep) {
                        let res: CollectResult = (collect_files_dfs dep repo_root visited2 visited_set2 order2 ok2 max_files max_lines max_lines_per_file lines_scanned2 trace)
                        set visited2 res.visited
                        set visited_set2 res.visited_set
                        set order2 res.order
                        set ok2 res.ok
                        set lines_scanned2 res.lines_scanned
                    } else {
                        (print "Error: import not found: ")
                        (println dep)
                        set ok2 false
                    }
                }
            } else { (print "") }
            set i (+ i 1)
        }

        if ok2 {
            set order2 (array_push order2 path)
        } else { (print "") }
        return CollectResult { visited: visited2, visited_set: visited_set2, order: order2, ok: ok2, lines_scanned: lines_scanned2 }
    }
}

fn merge_with_imports(input_file: string) -> string {
    let repo_root: string = (find_repo_root (nl_path_dirname input_file))
    let start: string = input_file
    let max_files: int = (parse_env_int "NANO_IMPORT_MAX_FILES" 5000)
    let max_lines: int = (parse_env_int "NANO_IMPORT_MAX_LINES" 50000)
    let max_lines_per_file: int = (parse_env_int "NANO_IMPORT_MAX_LINES_PER_FILE" 20000)
    let trace_env: string = (getenv "NANO_IMPORT_TRACE")
    let trace: bool = (!= trace_env "")
    if trace {
        (print "[import] repo_root: ")
        (println repo_root)
        (print "[import] start: ")
        (println start)
    } else { (print "") }

    let visited0: array<string> = []
    let visited_set0: HashMap<string, int> = (nlc_hashset_new_string)
    let order0: array<string> = []
    let res: CollectResult = (collect_files_dfs start repo_root visited0 visited_set0 order0 true max_files max_lines max_lines_per_file 0 trace)
    let files: array<string> = res.order
    if (not res.ok) {
        return ""
    } else { (print "") }

    let mut merged: string = ""
    let mut i: int = 0
    while (< i (array_length files)) {
        let src: string = (file_read (at files i))
        let lines: array<string> = (split_lines src)
        let mut j: int = 0
        while (< j (array_length lines)) {
            let line: string = (at lines j)
            let imp: string = (parse_import_path_from_line line)
            if (== imp "") {
                set merged (+ merged (strip_pub_decl line))
                set merged (+ merged "\n")
            } else {
                (print "")
            }
            set j (+ j 1)
        }
        set i (+ i 1)
    }
    return merged
}

/* =============================================================================
 * COMPILATION PIPELINE
 * ============================================================================= */

fn llm_escape_json(s: string) -> string {
    let mut out: string = ""
    let n: int = (str_length s)
    let q: string = (string_from_char 34)
    let mut i: int = 0
    while (< i n) {
        let c: int = (char_at s i)
        if (== c 92) {
            set out (+ out "\\\\")
        } else {
            if (== c 34) {
                set out (+ out "\\")
                set out (+ out q)
            } else {
                if (== c 10) {
                    set out (+ out "\\n")
                } else {
                    if (== c 13) {
                        set out (+ out "\\r")
                    } else {
                        if (== c 9) {
                            set out (+ out "\\t")
                        } else {
                            set out (+ out (string_from_char c))
                        }
                    }
                }
            }
        }
        set i (+ i 1)
    }
    return out
}

fn llm_write_diags_json(path: string, input_file: string, output_file: string, exit_code: int, diags: List<CompilerDiagnostic>) -> int {
    let mut s: string = ""
    let q: string = (string_from_char 34)
    set s (+ s "{")
    set s (+ s q)
    set s (+ s "tool")
    set s (+ s q)
    set s (+ s ":")
    set s (+ s q)
    set s (+ s "nanoc")
    set s (+ s q)
    set s (+ s ",")
    set s (+ s q)
    set s (+ s "success")
    set s (+ s q)
    set s (+ s ":")
    if (== exit_code 0) { set s (+ s "true") } else { set s (+ s "false") }
    set s (+ s ",")
    set s (+ s q)
    set s (+ s "exit_code")
    set s (+ s q)
    set s (+ s ":")
    set s (+ s (int_to_string exit_code))
    set s (+ s ",")
    set s (+ s q)
    set s (+ s "input_file")
    set s (+ s q)
    set s (+ s ":")
    set s (+ s q)
    set s (+ s (llm_escape_json input_file))
    set s (+ s q)
    set s (+ s ",")
    set s (+ s q)
    set s (+ s "output_file")
    set s (+ s q)
    set s (+ s ":")
    set s (+ s q)
    set s (+ s (llm_escape_json output_file))
    set s (+ s q)
    set s (+ s ",")
    set s (+ s q)
    set s (+ s "diagnostics")
    set s (+ s q)
    set s (+ s ":[")

    let n: int = (list_CompilerDiagnostic_length diags)
    let mut i: int = 0
    while (< i n) {
        let d: CompilerDiagnostic = (list_CompilerDiagnostic_get diags i)
        if (> i 0) { set s (+ s ",") } else { (print "") }
        set s (+ s "{")
        set s (+ s q)
        set s (+ s "code")
        set s (+ s q)
        set s (+ s ":")
        set s (+ s q)
        set s (+ s (llm_escape_json d.code))
        set s (+ s q)
        set s (+ s ",")
        set s (+ s q)
        set s (+ s "message")
        set s (+ s q)
        set s (+ s ":")
        set s (+ s q)
        set s (+ s (llm_escape_json d.message))
        set s (+ s q)
        set s (+ s ",")
        set s (+ s q)
        set s (+ s "phase")
        set s (+ s q)
        set s (+ s ":")
        set s (+ s (int_to_string d.phase))
        set s (+ s ",")
        set s (+ s q)
        set s (+ s "severity")
        set s (+ s q)
        set s (+ s ":")
        set s (+ s (int_to_string d.severity))
        set s (+ s ",")
        set s (+ s q)
        set s (+ s "location")
        set s (+ s q)
        set s (+ s ":{")
        set s (+ s q)
        set s (+ s "file")
        set s (+ s q)
        set s (+ s ":")
        set s (+ s q)
        set s (+ s (llm_escape_json d.location.file))
        set s (+ s q)
        set s (+ s ",")
        set s (+ s q)
        set s (+ s "line")
        set s (+ s q)
        set s (+ s ":")
        set s (+ s (int_to_string d.location.line))
        set s (+ s ",")
        set s (+ s q)
        set s (+ s "column")
        set s (+ s q)
        set s (+ s ":")
        set s (+ s (int_to_string d.location.column))
        set s (+ s "}}")
        set i (+ i 1)
    }
    set s (+ s "]}")
    return (file_write path s)
}

fn compile_program(input_file: string, output_file: string, verbose: bool, keep_c: bool, show_intermediate_code: bool, llm_diags_json_path: string) -> int {
    if verbose {
        (println "")
        (println "╔══════════════════════════════════════════════════════════════╗")
        (println "║  NanoLang v0.6 - Self-Hosted Compiler                       ║")
        (println "╚══════════════════════════════════════════════════════════════╝")
        (println "")
        (print "Input:  ")
        (println input_file)
        (print "Output: ")
        (println output_file)
        (println "")
    } else {
        (print "")
    }
    
    /* Step 0: Merge imports into single source */
    if verbose {
        (println "[0/5] Resolving imports...")
    } else {
        (print "")
    }
    
    let merged_source: string = (merge_with_imports input_file)
    let temp_source_file: string = "/tmp/nanolang_merged.nano"
    let mut source_to_compile: string = input_file
    
    if (== merged_source "") {
        (println "Error: import resolution failed")
        return 1
    } else {
        /* Imports resolved - use merged file */
        if verbose {
            (print "  ✓ Merged source: ")
            (print (int_to_string (str_length merged_source)))
            (println " bytes")
        } else {
            (print "")
        }
        let write_merged: int = (file_write temp_source_file merged_source)
        /* DEBUG: Also write to /tmp/merged_debug.nano for inspection */
        let debug_write: int = (file_write "/tmp/merged_debug.nano" merged_source)
        (print "")  /* Suppress unused variable warning */
        if (== write_merged 0) {
            set source_to_compile temp_source_file
        } else {
            set source_to_compile input_file
        }
    }
    
    /* Step 1: Lexer - Tokenize source file */
    if verbose {
        (println "[1/5] Lexing...")
    } else {
        (print "")
    }
    
    /* Diagnostics list (start with lexer diags; may be replaced by later phase outputs) */
    let diags: List<CompilerDiagnostic> = (list_CompilerDiagnostic_new)
    
    let tokens: List<LexerToken> = (tokenize_file source_to_compile diags)
    let token_count: int = (list_LexerToken_length tokens)
    
    if (== token_count 0) {
        (println "Error: Failed to tokenize input file")
        if (not (== llm_diags_json_path "")) {
            (llm_write_diags_json llm_diags_json_path input_file output_file 1 diags)
        } else { (print "") }
        return 1
    } else {
        (print "")
            
            if verbose {
                (print "  ✓ Tokenized ")
                (print (int_to_string token_count))
                (println " tokens")
            } else {
                (print "")
            }
            
            /* Step 2: Parser - Build AST */
            if verbose {
                (println "[2/5] Parsing...")
            } else {
                (print "")
            }
            
            let parser: Parser = (parse_program tokens token_count source_to_compile)
            if (parser_has_error parser) {
                let tok: LexerToken = (parser_current parser)
                (print "Parse error at line ")
                (print (int_to_string tok.line))
                (print ", column ")
                (print (int_to_string tok.column))
                (print ": unexpected token '")
                (print tok.value)
                (println "'")
                if (not (== llm_diags_json_path "")) {
                    let msg: string = (+ "Parse error: unexpected token " tok.value)
                    let loc: CompilerSourceLocation = (Diagnostics.diag_location source_to_compile tok.line tok.column)
                    let diag: CompilerDiagnostic = (Diagnostics.diag_parser_error "P0001" msg loc)
                    (Diagnostics.diag_list_add diags diag)
                    (llm_write_diags_json llm_diags_json_path input_file output_file 1 diags)
                } else { (print "") }
                return 1
            } else {
                (print "")
            }
            
            let func_count: int = (parser_get_function_count parser)
            let lets_count: int = (parser_get_let_count parser)
            (println (+ "DEBUG: Parser has " (+ (int_to_string lets_count) (+ " lets, " (+ (int_to_string func_count) " functions")))))
            if verbose {
                (print "  ✓ Parsed ")
                (print (int_to_string func_count))
                (println " functions")
            } else {
                (print "")
            }
            
            /* Step 3: Typechecker - Verify semantics */
            if verbose {
                (println "[3/5] NSType checking...")
            } else {
                (print "")
            }
            
            let tc: TypecheckPhaseOutput = (typecheck_phase parser source_to_compile)
            if tc.had_error {
                (println "NSType checking failed")
                (println "Diagnostics:")
                let diag_count: int = (Diagnostics.diag_list_count tc.diagnostics)
                let mut diag_i: int = 0
                while (< diag_i diag_count) {
                    let diag: CompilerDiagnostic = (Diagnostics.diag_list_get tc.diagnostics diag_i)
                    (print "  [")
                    (print diag.code)
                    (print "] ")
                    (print diag.message)
                    (print " (")
                    (print diag.location.file)
                    (print ":")
                    (print (int_to_string diag.location.line))
                    (print ":")
                    (print (int_to_string diag.location.column))
                    (println ")")
                    set diag_i (+ diag_i 1)
                }
                if (not (== llm_diags_json_path "")) {
                    (llm_write_diags_json llm_diags_json_path input_file output_file 1 tc.diagnostics)
                } else { (print "") }
                return 1
            } else { (print "") }
            
            if verbose {
                (println "  ✓ NSType checking passed")
            } else {
                (print "")
            }
            
            /* Step 4: Transpiler - Generate C code */
            if verbose {
                (println "[4/5] Generating C code...")
            } else {
                (print "")
            }
            
            let c_code: string = (transpile_parser parser)
            
            if verbose {
                (print "  ✓ Generated ")
                (print (int_to_string (str_length c_code)))
                (println " bytes of C code")
            } else {
                (print "")
            }

            if show_intermediate_code {
                (print c_code)
            } else { (print "") }
            
            /* Write C code to temporary file */
            let c_file: string = "/tmp/nanolang_temp.c"
            let write_result: int = (file_write c_file c_code)
            if (!= write_result 0) {
                (println "Error: Failed to write C file")
                if (not (== llm_diags_json_path "")) {
                    let msg: string = "Failed to write temporary C file"
                    let loc: CompilerSourceLocation = (Diagnostics.diag_location source_to_compile 0 0)
                    let diag: CompilerDiagnostic = (Diagnostics.diag_transpiler_error "C0001" msg loc)
                    (Diagnostics.diag_list_add diags diag)
                    (llm_write_diags_json llm_diags_json_path input_file output_file 1 diags)
                } else { (print "") }
                return 1
            } else {
                (print "")
            }
            
            /* Step 5: C Compiler - Compile to executable */
            if verbose {
                (println "[5/5] Compiling C to executable...")
            } else {
                (print "")
            }
            
            /* Build C compiler command with runtime library files
             * The transpiler generates calls to runtime functions (dyn_array_*, gc_*, etc.)
             * We must link with the runtime C sources to provide these implementations.
             * This matches what the C compiler does in src/main.c line 461.
             */
            let cc_bin: string = (resolve_cc_binary)
            let mut cc_cmd: string = (+ cc_bin " -std=c99 -Isrc -Imodules/std ")
            let extra_cflags: string = (getenv "NANO_CFLAGS")
            if (!= extra_cflags "") {
                set cc_cmd (+ cc_cmd extra_cflags)
                set cc_cmd (+ cc_cmd " ")
            } else {
                (print "")
            }
            set cc_cmd (+ cc_cmd c_file)
            set cc_cmd (+ cc_cmd " -o ")
            set cc_cmd (+ cc_cmd output_file)
            /* Add runtime library sources */
            set cc_cmd (+ cc_cmd " src/runtime/list_int.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_string.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_LexerToken.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_token.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_CompilerDiagnostic.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_CompilerSourceLocation.c")
            set cc_cmd (+ cc_cmd " src/runtime/token_helpers.c")
            set cc_cmd (+ cc_cmd " src/runtime/gc.c")
            set cc_cmd (+ cc_cmd " src/runtime/dyn_array.c")
            set cc_cmd (+ cc_cmd " src/runtime/gc_struct.c")
            set cc_cmd (+ cc_cmd " src/runtime/nl_string.c")
            set cc_cmd (+ cc_cmd " src/runtime/cli.c")
            set cc_cmd (+ cc_cmd " src/runtime/regex.c")
            /* Add AST list runtime sources for compiler support */
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTLet.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTFunction.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTNumber.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTFloat.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTString.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTBool.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTIdentifier.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTBinaryOp.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTCall.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTArrayLiteral.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTStmtRef.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTBlock.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTUnsafeBlock.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTPrint.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTAssert.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTFieldAccess.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTSet.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTIf.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTWhile.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTFor.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTReturn.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTShadow.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTStruct.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTStructLiteral.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTEnum.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTUnion.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTUnionConstruct.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTMatch.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTImport.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTOpaqueType.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTTupleLiteral.c")
            set cc_cmd (+ cc_cmd " src/runtime/list_ASTTupleIndex.c")

            /* std/fs provides fs_walkdir + file_* used by modules/std/fs.nano */
            set cc_cmd (+ cc_cmd " modules/std/fs.c")
            set cc_cmd (+ cc_cmd " -lm")
            let extra_ldflags: string = (getenv "NANO_LDFLAGS")
            if (!= extra_ldflags "") {
                set cc_cmd (+ cc_cmd " ")
                set cc_cmd (+ cc_cmd extra_ldflags)
            } else {
                (print "")
            }
            set cc_cmd (+ cc_cmd " 2>&1")
            
            if verbose {
                (print "  Command: ")
                (println cc_cmd)
            } else {
                (print "")
            }
            
            let cc_result: int = (nl_exec_shell cc_cmd)
            if (!= cc_result 0) {
                (println "Error: C compilation failed")
                return 1
            } else {
                (print "")
            }
            
            if verbose {
                (println "  ✓ Executable created")
                (println "")
                (println "╔══════════════════════════════════════════════════════════════╗")
                (println "║  ✅ COMPILATION SUCCESSFUL (100% NanoLang Pipeline)         ║")
                (println "╚══════════════════════════════════════════════════════════════╝")
                (println "")
            } else {
                (print "")
            }
            
            /* Clean up temp file unless --keep-c */
            if (not keep_c) {
                let rm_cmd: string = (+ "rm -f " c_file)
                let rm_result: int = (nl_exec_shell rm_cmd)
                /* Ignore result - cleanup is non-critical */
                (print "")
            } else {
                if verbose {
                    (print "Kept C file: ")
                    (println c_file)
                } else {
                    (print "")
                }
            }
            
            if (not (== llm_diags_json_path "")) {
                (llm_write_diags_json llm_diags_json_path input_file output_file 0 diags)
            } else { (print "") }

            return 0
    }
}

/* =============================================================================
 * MAIN ENTRY POINT
 * ============================================================================= */

fn show_usage() -> int {
    (println "")
    (println "╔══════════════════════════════════════════════════════════════╗")
    (println "║  NanoLang v0.6 - Self-Hosted Compiler                       ║")
    (println "╚══════════════════════════════════════════════════════════════╝")
    (println "")
    (println "Usage: nanoc <input.nano> [-o output] [options]")
    (println "")
    (println "Options:")
    (println "  -o <file>        Output executable (default: a.out)")
    (println "  -v, --verbose    Verbose compilation output")
    (println "  -k, --keep-c     Keep generated C file")
    (println "  -fshow-intermediate-code  Print generated C to stdout")
    (println "  -h, --help       Show this help")
    (println "  --llm-diags-json <p>  Write machine-readable diagnostics JSON (agent-only)")
    (println "")
    (println "This compiler is 100% written in NanoLang!")
    (println "Pipeline: Lex → Parse → Typecheck → Transpile → Compile")
    (println "")
    return 0
}

shadow show_usage {
    let result: int = (show_usage)
    assert (== result 0)  /* show_usage always returns 0 */
}

fn main() -> int {
    let opts: CompileOptions = (parse_args)
    
    if opts.show_help {
        return (show_usage)
    } else {
        (print "")
    }
    
    if (== opts.input_file "") {
        (println "Error: No input file specified")
        (println "Try 'nanoc --help' for usage information")
        return 1
    } else {
        (print "")
    }
    
    if (not (file_exists opts.input_file)) {
        (print "Error: Input file not found: ")
        (println opts.input_file)
        return 1
    } else {
        (print "")
    }
    
    return (compile_program opts.input_file opts.output_file opts.verbose opts.keep_c opts.show_intermediate_code opts.llm_diags_json_path)
}

shadow main {
    /* Basic sanity check */
    assert (== 1 1)
}
