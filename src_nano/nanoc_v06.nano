/* =============================================================================
 * NanoLang v0.6 - Truly Self-Hosted Compiler Driver
 * =============================================================================
 * 
 * Complete compiler implementation in NanoLang that does NOT depend on bin/nanoc_c.
 * 
 * Pipeline:
 * 1. Lexer:       tokenize_file_result() -> Result<TokenList, Diagnostic>
 * 2. Parser:      parse_program() -> Parser
 * 3. Typechecker: typecheck_parser() -> int
 * 4. Transpiler:  transpile_parser() -> string (C code)
 * 5. C Compiler:  system("cc ...") -> int
 * 
 * This is TRUE SELF-HOSTING - no dependency on nanoc_c!
 */

import "src_nano/compiler/lexer.nano"
import "src_nano/parser.nano"
import "src_nano/typecheck.nano"
import "src_nano/transpiler.nano"

/* CLI argument access */
extern fn get_argc() -> int
extern fn get_argv(index: int) -> string

/* File I/O */
extern fn file_read(path: string) -> string
extern fn file_write(path: string, content: string) -> int
extern fn file_exists(path: string) -> bool

/* System commands - wrapper to avoid stdlib.h system() conflict */
extern fn nl_exec_shell(cmd: string) -> int

/* =============================================================================
 * CLI ARGUMENT PARSING
 * ============================================================================= */

struct CompileOptions {
    input_file: string,
    output_file: string,
    verbose: bool,
    keep_c: bool,
    show_help: bool
}

fn default_options() -> CompileOptions {
    return CompileOptions {
        input_file: "",
        output_file: "a.out",
        verbose: false,
        keep_c: false,
        show_help: false
    }
}

fn parse_args() -> CompileOptions {
    let argc: int = (get_argc)
    let mut opts: CompileOptions = (default_options)
    let mut i: int = 1
    
    while (< i argc) {
        let arg: string = (get_argv i)
        
        if (str_equals arg "-h") {
            set opts CompileOptions {
                input_file: opts.input_file,
                output_file: opts.output_file,
                verbose: opts.verbose,
                keep_c: opts.keep_c,
                show_help: true
            }
        } else {
            if (str_equals arg "--help") {
                set opts CompileOptions {
                    input_file: opts.input_file,
                    output_file: opts.output_file,
                    verbose: opts.verbose,
                    keep_c: opts.keep_c,
                    show_help: true
                }
            } else {
                if (str_equals arg "-v") {
                    set opts CompileOptions {
                        input_file: opts.input_file,
                        output_file: opts.output_file,
                        verbose: true,
                        keep_c: opts.keep_c,
                        show_help: opts.show_help
                    }
                } else {
                    if (str_equals arg "--verbose") {
                        set opts CompileOptions {
                            input_file: opts.input_file,
                            output_file: opts.output_file,
                            verbose: true,
                            keep_c: opts.keep_c,
                            show_help: opts.show_help
                        }
                    } else {
                        if (str_equals arg "-k") {
                            set opts CompileOptions {
                                input_file: opts.input_file,
                                output_file: opts.output_file,
                                verbose: opts.verbose,
                                keep_c: true,
                                show_help: opts.show_help
                            }
                        } else {
                            if (str_equals arg "--keep-c") {
                                set opts CompileOptions {
                                    input_file: opts.input_file,
                                    output_file: opts.output_file,
                                    verbose: opts.verbose,
                                    keep_c: true,
                                    show_help: opts.show_help
                                }
                            } else {
                                if (str_equals arg "-o") {
                                    if (< (+ i 1) argc) {
                                        set i (+ i 1)
                                        let output: string = (get_argv i)
                                        set opts CompileOptions {
                                            input_file: opts.input_file,
                                            output_file: output,
                                            verbose: opts.verbose,
                                            keep_c: opts.keep_c,
                                            show_help: opts.show_help
                                        }
                                    } else {
                                        (print "")
                                    }
                                } else {
                                    /* Assume it's the input file if no option prefix */
                                    if (== opts.input_file "") {
                                        set opts CompileOptions {
                                            input_file: arg,
                                            output_file: opts.output_file,
                                            verbose: opts.verbose,
                                            keep_c: opts.keep_c,
                                            show_help: opts.show_help
                                        }
                                    } else {
                                        (print "")
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        set i (+ i 1)
    }
    
    return opts
}

/* =============================================================================
 * IMPORT RESOLUTION (SIMPLIFIED)
 * ============================================================================= */

/* For bootstrap, we use a HACK: shell out to create a merged file
 * This is NOT elegant, but it gets us to 100% self-hosting
 * Once we're self-hosting, we can rewrite this properly in NanoLang
 */
fn merge_with_imports_via_shell(input_file: string) -> string {
    /* Create a shell script to merge files */
    let script: string = "/tmp/merge_imports.sh"
    let mut cmd: string = "#!/bin/bash\n"
    set cmd (str_concat cmd "# Merge NanoLang source with imports\n")
    set cmd (str_concat cmd "while IFS= read -r line || [ -n \"$line\" ]; do\n")
    set cmd (str_concat cmd "  if [[ \"$line\" =~ ^import\\ \\\"(.*)\\\" ]]; then\n")
    set cmd (str_concat cmd "    import_path=\"${BASH_REMATCH[1]}\"\n")
    set cmd (str_concat cmd "    if [ -f \"$import_path\" ]; then\n")
    set cmd (str_concat cmd "      while IFS= read -r iline || [ -n \"$iline\" ]; do\n")
    set cmd (str_concat cmd "        if [[ ! \"$iline\" =~ ^import\\ ]]; then\n")
    set cmd (str_concat cmd "          echo \"$iline\" | sed 's/^pub fn /fn /' | sed 's/^pub struct /struct /'\n")
    set cmd (str_concat cmd "        fi\n")
    set cmd (str_concat cmd "      done < \"$import_path\"\n")
    set cmd (str_concat cmd "    fi\n")
    set cmd (str_concat cmd "  else\n")
    set cmd (str_concat cmd "    echo \"$line\" | sed 's/^pub fn /fn /' | sed 's/^pub struct /struct /'\n")
    set cmd (str_concat cmd "  fi\n")
    set cmd (str_concat cmd "done < ")
    set cmd (str_concat cmd input_file)
    set cmd (str_concat cmd "\n")
    
    let write_result: int = (file_write script cmd)
    if (!= write_result 0) {
        return ""
    } else {
        (print "")
    }
    
    /* Make executable and run */
    let chmod_result: int = (nl_exec_shell "chmod +x /tmp/merge_imports.sh")
    if (!= chmod_result 0) {
        return ""
    } else {
        (print "")
    }
    
    /* Execute and capture output to temp file */
    let output_file: string = "/tmp/nanolang_merged.nano"
    let mut exec_cmd: string = "/tmp/merge_imports.sh > "
    set exec_cmd (str_concat exec_cmd output_file)
    set exec_cmd (str_concat exec_cmd " 2>&1")
    
    let exec_result: int = (nl_exec_shell exec_cmd)
    if (!= exec_result 0) {
        return ""
    } else {
        (print "")
    }
    
    /* Read merged result */
    let merged: string = (file_read output_file)
    return merged
}

/* =============================================================================
 * COMPILATION PIPELINE
 * ============================================================================= */

fn compile_program(input_file: string, output_file: string, verbose: bool, keep_c: bool) -> int {
    if verbose {
        (println "")
        (println "╔══════════════════════════════════════════════════════════════╗")
        (println "║  NanoLang v0.6 - Self-Hosted Compiler                       ║")
        (println "╚══════════════════════════════════════════════════════════════╝")
        (println "")
        (print "Input:  ")
        (println input_file)
        (print "Output: ")
        (println output_file)
        (println "")
    } else {
        (print "")
    }
    
    /* Step 0: Merge imports into single source */
    if verbose {
        (println "[0/5] Resolving imports...")
    } else {
        (print "")
    }
    
    let merged_source: string = (merge_with_imports_via_shell input_file)
    let temp_source_file: string = "/tmp/nanolang_merged.nano"
    let mut source_to_compile: string = input_file
    
    if (!= merged_source "") {
        /* Imports resolved - use merged file */
        if verbose {
            (print "  ✓ Merged source: ")
            (print (int_to_string (str_length merged_source)))
            (println " bytes")
        } else {
            (print "")
        }
        set source_to_compile temp_source_file
    } else {
        /* No imports or merge failed - use original file */
        if verbose {
            (println "  ✓ No imports to resolve")
        } else {
            (print "")
        }
    }
    
    /* Step 1: Lexer - Tokenize source file */
    if verbose {
        (println "[1/5] Lexing...")
    } else {
        (print "")
    }
    
    let tokens: List<LexToken> = (tokenize_file source_to_compile)
    let token_count: int = (list_LexToken_length tokens)
    
    if (== token_count 0) {
        (println "Error: Failed to tokenize input file")
        return 1
    } else {
        (print "")
            
            if verbose {
                (print "  ✓ Tokenized ")
                (print (int_to_string token_count))
                (println " tokens")
            } else {
                (print "")
            }
            
            /* Step 2: Parser - Build AST */
            if verbose {
                (println "[2/5] Parsing...")
            } else {
                (print "")
            }
            
            let parser: Parser = (parse_program tokens token_count)
            if (parser_has_error parser) {
                let tok: LexToken = (parser_current parser)
                (print "Parse error at line ")
                (print (int_to_string tok.line))
                (print ", column ")
                (print (int_to_string tok.column))
                (print ": unexpected token '")
                (print tok.value)
                (println "'")
                return 1
            } else {
                (print "")
            }
            
            let func_count: int = (parser_get_function_count parser)
            if verbose {
                (print "  ✓ Parsed ")
                (print (int_to_string func_count))
                (println " functions")
            } else {
                (print "")
            }
            
            /* Step 3: Typechecker - Verify semantics */
            if verbose {
                (println "[3/5] Type checking...")
            } else {
                (print "")
            }
            
            let typecheck_result: int = (typecheck_parser parser)
            if (!= typecheck_result 0) {
                (println "Type checking failed")
                return 1
            } else {
                (print "")
            }
            
            if verbose {
                (println "  ✓ Type checking passed")
            } else {
                (print "")
            }
            
            /* Step 4: Transpiler - Generate C code */
            if verbose {
                (println "[4/5] Generating C code...")
            } else {
                (print "")
            }
            
            let c_code: string = (transpile_parser parser)
            
            if verbose {
                (print "  ✓ Generated ")
                (print (int_to_string (str_length c_code)))
                (println " bytes of C code")
            } else {
                (print "")
            }
            
            /* Write C code to temporary file */
            let c_file: string = "/tmp/nanolang_temp.c"
            let write_result: int = (file_write c_file c_code)
            if (!= write_result 0) {
                (println "Error: Failed to write C file")
                return 1
            } else {
                (print "")
            }
            
            /* Step 5: C Compiler - Compile to executable */
            if verbose {
                (println "[5/5] Compiling C to executable...")
            } else {
                (print "")
            }
            
            /* Build C compiler command with runtime library files
             * The transpiler generates calls to runtime functions (dyn_array_*, gc_*, etc.)
             * We must link with the runtime C sources to provide these implementations.
             * This matches what the C compiler does in src/main.c line 461.
             */
            let mut cc_cmd: string = "cc -std=c99 -Isrc "
            set cc_cmd (str_concat cc_cmd c_file)
            set cc_cmd (str_concat cc_cmd " -o ")
            set cc_cmd (str_concat cc_cmd output_file)
            /* Add runtime library sources */
            set cc_cmd (str_concat cc_cmd " src/runtime/list_int.c")
            set cc_cmd (str_concat cc_cmd " src/runtime/list_string.c")
            set cc_cmd (str_concat cc_cmd " src/runtime/list_token.c")
            set cc_cmd (str_concat cc_cmd " src/runtime/token_helpers.c")
            set cc_cmd (str_concat cc_cmd " src/runtime/gc.c")
            set cc_cmd (str_concat cc_cmd " src/runtime/dyn_array.c")
            set cc_cmd (str_concat cc_cmd " src/runtime/gc_struct.c")
            set cc_cmd (str_concat cc_cmd " src/runtime/nl_string.c")
            set cc_cmd (str_concat cc_cmd " src/runtime/cli.c")
            set cc_cmd (str_concat cc_cmd " 2>&1")
            
            if verbose {
                (print "  Command: ")
                (println cc_cmd)
            } else {
                (print "")
            }
            
            let cc_result: int = (nl_exec_shell cc_cmd)
            if (!= cc_result 0) {
                (println "Error: C compilation failed")
                return 1
            } else {
                (print "")
            }
            
            if verbose {
                (println "  ✓ Executable created")
                (println "")
                (println "╔══════════════════════════════════════════════════════════════╗")
                (println "║  ✅ COMPILATION SUCCESSFUL (100% NanoLang Pipeline)         ║")
                (println "╚══════════════════════════════════════════════════════════════╝")
                (println "")
            } else {
                (print "")
            }
            
            /* Clean up temp file unless --keep-c */
            if (not keep_c) {
                let rm_cmd: string = (str_concat "rm -f " c_file)
                let rm_result: int = (nl_exec_shell rm_cmd)
                /* Ignore result - cleanup is non-critical */
                (print "")
            } else {
                if verbose {
                    (print "Kept C file: ")
                    (println c_file)
                } else {
                    (print "")
                }
            }
            
            return 0
    }
}

/* =============================================================================
 * MAIN ENTRY POINT
 * ============================================================================= */

fn show_usage() -> int {
    (println "")
    (println "╔══════════════════════════════════════════════════════════════╗")
    (println "║  NanoLang v0.6 - Self-Hosted Compiler                       ║")
    (println "╚══════════════════════════════════════════════════════════════╝")
    (println "")
    (println "Usage: nanoc <input.nano> [-o output] [options]")
    (println "")
    (println "Options:")
    (println "  -o <file>        Output executable (default: a.out)")
    (println "  -v, --verbose    Verbose compilation output")
    (println "  -k, --keep-c     Keep generated C file")
    (println "  -h, --help       Show this help")
    (println "")
    (println "This compiler is 100% written in NanoLang!")
    (println "Pipeline: Lex → Parse → Typecheck → Transpile → Compile")
    (println "")
    return 0
}

fn main() -> int {
    let opts: CompileOptions = (parse_args)
    
    if opts.show_help {
        return (show_usage)
    } else {
        (print "")
    }
    
    if (== opts.input_file "") {
        (println "Error: No input file specified")
        (println "Try 'nanoc --help' for usage information")
        return 1
    } else {
        (print "")
    }
    
    if (not (file_exists opts.input_file)) {
        (print "Error: Input file not found: ")
        (println opts.input_file)
        return 1
    } else {
        (print "")
    }
    
    return (compile_program opts.input_file opts.output_file opts.verbose opts.keep_c)
}

shadow main {
    /* Basic sanity check */
    assert (== 1 1)
}
