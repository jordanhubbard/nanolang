/* =============================================================================
 * nanolang Stage 1 Compiler
 * =============================================================================
 * Self-hosted compiler (Stage 1) that wraps C compiler functionality.
 * 
 * This proves self-hosting by:
 * 1. Being written entirely in nanolang
 * 2. Orchestrating full compilation pipeline
 * 3. Being compilable by itself (Stage 2)
 * 
 * Path to true self-hosting:
 *   Stage 0 (C): bin/nanoc compiles this file → bin/nanoc_stage1
 *   Stage 1: bin/nanoc_stage1 compiles this file → bin/nanoc_stage2
 *   Stage 2: bin/nanoc_stage2 compiles programs (and itself!)
 *   
 * Verification: Stage 1 and Stage 2 produce identical output
 */

import "src_nano/cli_args.nano"
import "src_nano/file_io.nano"
import "src_nano/compiler_extern.nano"

/* Compilation result codes */
let COMPILER_SUCCESS: int = 0
let COMPILER_ERROR_ARGS: int = 1
let COMPILER_ERROR_FILE: int = 2
let COMPILER_ERROR_COMPILE: int = 3

/* Command-line arguments */
struct Args {
    input_file: string,
    output_file: string,
    verbose: bool,
    keep_c: bool,
    show_help: bool,
    has_error: bool
}

/* Show usage information */
fn show_usage() -> void {
    (println "nanoc - nanolang Self-Hosted Compiler (Stage 1)")
    (println "")
    (println "Usage: nanoc <input.nano> [OPTIONS]")
    (println "")
    (println "Options:")
    (println "  -o <file>    Output executable (default: a.out)")
    (println "  --verbose    Show detailed compilation steps")
    (println "  --keep-c     Keep generated C code")
    (println "  --help       Show this help message")
    (println "  --version    Show version information")
    (println "")
    (println "Examples:")
    (println "  nanoc hello.nano")
    (println "  nanoc program.nano -o myprogram")
    (println "  nanoc example.nano --verbose --keep-c")
    (println "")
}

/* No shadow test for show_usage - uses println */

/* Show version */
fn show_version() -> void {
    (println "nanoc (Stage 1) - Self-Hosted nanolang Compiler")
    (println "Version: 1.0.0-stage1")
    (println "")
}

/* No shadow test for show_version - uses println */

/* Parse command-line arguments */
fn parse_args() -> Args {
    let argc: int = (get_argc)
    
    /* Default values */
    let mut input: string = ""
    let mut output: string = "a.out"
    let mut verbose: bool = false
    let mut keep_c: bool = false
    let mut help: bool = false
    let mut error: bool = false
    
    /* Need at least program name + one argument */
    if (< argc 2) {
        set error true
        return Args {
            input_file: "",
            output_file: output,
            verbose: false,
            keep_c: false,
            show_help: false,
            has_error: true
        }
    }
    
    /* Check for special flags first */
    let first_arg: string = (get_argv 1)
    if (== first_arg "--help") {
        return Args {
            input_file: "",
            output_file: output,
            verbose: false,
            keep_c: false,
            show_help: true,
            has_error: false
        }
    }
    
    if (== first_arg "--version") {
        (show_version)
        return Args {
            input_file: "",
            output_file: output,
            verbose: false,
            keep_c: false,
            show_help: true,
            has_error: false
        }
    }
    
    /* First argument is input file */
    set input first_arg
    
    /* Parse remaining options */
    let mut i: int = 2
    while (< i argc) {
        let arg: string = (get_argv i)
        
        if (== arg "-o") {
            /* Next arg is output file */
            set i (+ i 1)
            if (< i argc) {
                set output (get_argv i)
            } else {
                (println "Error: -o requires output filename")
                set error true
            }
        } else if (== arg "--verbose") {
            set verbose true
        } else if (== arg "--keep-c") {
            set keep_c true
        } else {
            (print "Error: Unknown option: ")
            (println arg)
            set error true
        }
        
        set i (+ i 1)
    }
    
    return Args {
        input_file: input,
        output_file: output,
        verbose: verbose,
        keep_c: keep_c,
        show_help: help,
        has_error: error
    }
}

/* No shadow test for parse_args - it uses extern functions */

/* Compile a nanolang file */
fn compile(input: string, output: string, verbose: bool, keep_c: bool) -> int {
    /* Check input file exists */
    if (not (file_exists input)) {
        (print "Error: Input file not found: ")
        (println input)
        return COMPILER_ERROR_FILE
    }
    
    if verbose {
        (println "=== nanolang Self-Hosted Compiler (Stage 1) ===")
        (println "")
        (print "Input:  ")
        (println input)
        (print "Output: ")
        (println output)
        (println "")
    }
    
    /* Call C-backed compilation function */
    let verbose_int: int = 0
    if verbose {
        set verbose_int 1
    }
    
    let keep_c_int: int = 0
    if keep_c {
        set keep_c_int 1
    }
    
    let result: int = (nl_compiler_compile_file input output verbose_int keep_c_int)
    
    if (== result 0) {
        return COMPILER_SUCCESS
    } else {
        return COMPILER_ERROR_COMPILE
    }
}

/* No shadow test for compile - it uses extern functions */

/* Main entry point */
fn main() -> int {
    let args: Args = (parse_args)
    
    let show_help: bool = args.show_help
    if show_help {
        (show_usage)
        return COMPILER_SUCCESS
    }
    
    let has_error: bool = args.has_error
    if has_error {
        (show_usage)
        return COMPILER_ERROR_ARGS
    }
    
    /* Special case: if no input file, show usage */
    let input_len: int = (str_length args.input_file)
    if (== input_len 0) {
        (show_usage)
        return COMPILER_ERROR_ARGS
    }
    
    /* Compile the input file */
    let input: string = args.input_file
    let output: string = args.output_file
    let verbose: bool = args.verbose
    let keep_c: bool = args.keep_c
    let result: int = (compile input output verbose keep_c)
    
    return result
}

/* No shadow test for main - it uses extern functions */
