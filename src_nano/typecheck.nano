/* =============================================================================
 * nanolang Type Checker (Self-Hosted) - Minimal Version
 * =============================================================================
 * Type checking for the self-hosted nanolang compiler
 * 
 * Phase 1 Scope (Minimal):
 * - Basic types: int, float, bool, string, void
 * - Variable declarations and usage
 * - Function signatures
 * - Binary operations (+, -, *, /, ==, <, >, etc.)
 * - Function calls with type checking
 * - Simple struct support (no nested/complex types yet)
 * 
 * NOT in Phase 1:
 * - Generics
 * - Unions
 * - Arrays/Lists
 * - Advanced type inference
 * - Module system
 */

import "src_nano/parser.nano"

/* =============================================================================
 * TYPE SYSTEM
 * ============================================================================= */

/* TypeKind and Type are provided by src_nano/compiler/ir.nano */

/* Function signature for type checking */
struct FunctionType {
    name: string,
    param_count: int,
    return_type: Type
    /* Note: param types stored separately in environment */
}

/* =============================================================================
 * SYMBOL TABLE / ENVIRONMENT
 * ============================================================================= */

/* Symbol in the environment (variable or function) */
struct Symbol {
    name: string,
    sym_type: Type,
    is_mutable: bool,
    is_function: bool,
    param_count: int,
    defined: bool
}

/* Environment for type checking */
struct TypeEnvironment {
    error_count: int,
    has_error: bool
}

/* Global storage for symbols - using arrays for Phase 1 */
/* Note: In production, we'd use a proper hash map */

/* =============================================================================
 * TYPE CHECKING FUNCTIONS
 * ============================================================================= */

/* Create a new type */
fn type_int() -> Type {
    return Type {
        kind: TypeKind.TYPE_INT,
        name: "",
        element_type_kind: TypeKind.TYPE_UNKNOWN,
        element_type_name: ""
    }
}

shadow type_int {
    let t: Type = (type_int)
    assert (== t.kind TypeKind.TYPE_INT)
}

fn type_float() -> Type {
    return Type {
        kind: TypeKind.TYPE_FLOAT,
        name: "",
        element_type_kind: TypeKind.TYPE_UNKNOWN,
        element_type_name: ""
    }
}

shadow type_float {
    let t: Type = (type_float)
    assert (== t.kind TypeKind.TYPE_FLOAT)
}

fn type_bool() -> Type {
    return Type {
        kind: TypeKind.TYPE_BOOL,
        name: "",
        element_type_kind: TypeKind.TYPE_UNKNOWN,
        element_type_name: ""
    }
}

shadow type_bool {
    let t: Type = (type_bool)
    assert (== t.kind TypeKind.TYPE_BOOL)
}

fn type_string() -> Type {
    return Type {
        kind: TypeKind.TYPE_STRING,
        name: "",
        element_type_kind: TypeKind.TYPE_UNKNOWN,
        element_type_name: ""
    }
}

shadow type_string {
    let t: Type = (type_string)
    assert (== t.kind TypeKind.TYPE_STRING)
}

fn type_void() -> Type {
    return Type {
        kind: TypeKind.TYPE_VOID,
        name: "",
        element_type_kind: TypeKind.TYPE_UNKNOWN,
        element_type_name: ""
    }
}

shadow type_void {
    let t: Type = (type_void)
    assert (== t.kind TypeKind.TYPE_VOID)
}

/* Create array type */
fn type_array(elem_kind: int, elem_name: string) -> Type {
    return Type {
        kind: TypeKind.TYPE_ARRAY,
        name: "",
        element_type_kind: elem_kind,
        element_type_name: elem_name
    }
}

shadow type_array {
    let t: Type = (type_array TypeKind.TYPE_INT "")
    assert (== t.kind TypeKind.TYPE_ARRAY)
    assert (== t.element_type_kind TypeKind.TYPE_INT)
}

/* Create generic list type */
fn type_list_generic(elem_name: string) -> Type {
    return Type {
        kind: TypeKind.TYPE_LIST_GENERIC,
        name: "",
        element_type_kind: TypeKind.TYPE_STRUCT,
        element_type_name: elem_name
    }
}

shadow type_list_generic {
    let t: Type = (type_list_generic "Point")
    assert (== t.kind TypeKind.TYPE_LIST_GENERIC)
    assert (== t.element_type_name "Point")
}

/* Create union type */
fn type_union(union_name: string) -> Type {
    return Type {
        kind: TypeKind.TYPE_UNION,
        name: union_name,
        element_type_kind: TypeKind.TYPE_UNKNOWN,
        element_type_name: ""
    }
}

shadow type_union {
    let t: Type = (type_union "Result")
    assert (== t.kind TypeKind.TYPE_UNION)
    assert (== t.name "Result")
}

/* Create tuple type */
fn type_tuple() -> Type {
    return Type {
        kind: TypeKind.TYPE_TUPLE,
        name: "",
        element_type_kind: TypeKind.TYPE_UNKNOWN,
        element_type_name: ""
    }
}

shadow type_tuple {
    let t: Type = (type_tuple)
    assert (== t.kind TypeKind.TYPE_TUPLE)
}

/* Check if two types are equal */
fn types_equal(t1: Type, t2: Type) -> bool {
    if (!= t1.kind t2.kind) {
        return false
    } else {
        /* For struct/union types, also check name */
        if (or (== t1.kind TypeKind.TYPE_STRUCT) (== t1.kind TypeKind.TYPE_UNION)) {
            return (== t1.name t2.name)
        } else {
            /* For array types, check element type */
            if (== t1.kind TypeKind.TYPE_ARRAY) {
                if (!= t1.element_type_kind t2.element_type_kind) {
                    return false
                } else {
                    /* If element is struct, check name */
                    if (== t1.element_type_kind TypeKind.TYPE_STRUCT) {
                        return (== t1.element_type_name t2.element_type_name)
                    } else {
                        return true
                    }
                }
            } else {
                /* For List<T>, check element type name */
                if (== t1.kind TypeKind.TYPE_LIST_GENERIC) {
                    return (== t1.element_type_name t2.element_type_name)
                } else {
                    return true
                }
            }
        }
    }
}

shadow types_equal {
    let int1: Type = (type_int)
    let int2: Type = (type_int)
    let float1: Type = (type_float)
    
    assert (types_equal int1 int2)
    assert (not (types_equal int1 float1))
}

/* Create type from string representation */
fn type_from_string(s: string) -> Type {
    if (== s "int") {
        return (type_int)
    } else {
        if (== s "float") {
            return (type_float)
        } else {
            if (== s "bool") {
                return (type_bool)
            } else {
                if (== s "string") {
                    return (type_string)
                } else {
                    if (== s "void") {
                        return (type_void)
                    } else {
                        /* Check for array<T> syntax */
                        if (str_contains s "array<") {
                            /* Parse element type from array<int>, array<string>, etc. */
                            let elem_type_str: string = (array_elem_type_from_array_decl s)
                            if (== elem_type_str "int") {
                                return (type_array TypeKind.TYPE_INT "")
                            } else {
                                if (== elem_type_str "string") {
                                    return (type_array TypeKind.TYPE_STRING "")
                                } else {
                                    if (== elem_type_str "float") {
                                        return (type_array TypeKind.TYPE_FLOAT "")
                                    } else {
                                        if (== elem_type_str "bool") {
                                            return (type_array TypeKind.TYPE_BOOL "")
                                        } else {
                                            /* Struct element type */
                                            return (type_array TypeKind.TYPE_STRUCT elem_type_str)
                                        }
                                    }
                                }
                            }
                        } else {
                            /* Check for List<T> syntax */
                            if (str_contains s "List<") {
                                /* Extract element type: "List<Point>" -> "Point" */
                                let elem_name: string = (extract_list_element_type s)
                                return (type_list_generic elem_name)
                            } else {
                                /* Assume it's a struct or union type */
                                return Type {
                                    kind: TypeKind.TYPE_STRUCT,
                                    name: s,
                                    element_type_kind: TypeKind.TYPE_UNKNOWN,
                                    element_type_name: ""
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

/* Find first occurrence of character in string */
fn str_index_of(s: string, ch: string) -> int {
    let len: int = (str_length s)
    let mut i: int = 0
    
    while (< i len) {
        let char_at: string = (str_substring s i 1)
        if (== char_at ch) {
            return i
        } else {
            (print "")
        }
        set i (+ i 1)
    }
    
    return -1
}

shadow str_index_of {
    assert (== (str_index_of "hello" "e") 1)
    assert (== (str_index_of "List<Point>" "<") 4)
    assert (== (str_index_of "hello" "x") -1)
}

/* Extract element type from List<T> string */
fn extract_list_element_type(s: string) -> string {
    /* "List<Point>" -> "Point" */
    let start: int = (+ (str_index_of s "<") 1)
    let end: int = (str_index_of s ">")
    if (and (> start 0) (> end start)) {
        return (str_substring s start (- end start))
    } else {
        return ""
    }
}

shadow extract_list_element_type {
    assert (== (extract_list_element_type "List<Point>") "Point")
    assert (== (extract_list_element_type "List<int>") "int")
}

/* Check if string starts with prefix */
fn str_starts_with(s: string, prefix: string) -> bool {
    let prefix_len: int = (str_length prefix)
    if (> prefix_len (str_length s)) {
        return false
    } else {
        let sub: string = (str_substring s 0 prefix_len)
        return (== sub prefix)
    }
}

shadow str_starts_with {
    assert (str_starts_with "list_int_new" "list_")
    assert (not (str_starts_with "hello" "list_"))
}

/* Find last occurrence of character in string */
fn str_last_index_of(s: string, ch: string) -> int {
    let len: int = (str_length s)
    let mut i: int = (- len 1)
    
    while (>= i 0) {
        let char_at: string = (str_substring s i 1)
        if (== char_at ch) {
            return i
        } else {
            (print "")
        }
        set i (- i 1)
    }
    
    return -1
}

shadow str_last_index_of {
    assert (== (str_last_index_of "list_Point_new" "_") 11)
    assert (== (str_last_index_of "hello" "x") -1)
}

/* Check type of a generic list function call
 * Handles: list_T_new, list_T_push, list_T_get, list_T_length
 * Returns: Appropriate type based on operation
 */
fn check_list_function_call(fn_name: string, arg_count: int) -> Type {
    /* Extract type name: "list_Point_new" -> "Point" */
    let elem_type: string = (extract_list_type_from_function fn_name)
    
    /* Determine operation: _new, _push, _get, _length */
    if (str_contains fn_name "_new") {
        /* list_T_new() -> List<T> */
        return (type_list_generic elem_type)
    } else {
        if (str_contains fn_name "_push") {
            /* list_T_push(list, elem) -> void */
            return (type_void)
        } else {
            if (str_contains fn_name "_get") {
                /* list_T_get(list, index) -> T */
                return (type_from_element_name elem_type)
            } else {
                if (str_contains fn_name "_length") {
                    /* list_T_length(list) -> int */
                    return (type_int)
                } else {
                    /* Unknown list operation */
                    return Type { kind: TypeKind.TYPE_UNKNOWN, name: "unknown_list_op", element_type_kind: TypeKind.TYPE_UNKNOWN, element_type_name: "" }
                }
            }
        }
    }
}

/* Check if a function name is a built-in function
 * Returns true if the function is a built-in (e.g., array_push, at, str_concat)
 */
fn is_builtin_function(fn_name: string) -> bool {
    /* Core */
    if (== fn_name "range") { return true } else { (print "") }
    if (== fn_name "print") { return true } else { (print "") }
    if (== fn_name "println") { return true } else { (print "") }
    if (== fn_name "assert") { return true } else { (print "") }
    
    /* Math */
    if (== fn_name "abs") { return true } else { (print "") }
    if (== fn_name "min") { return true } else { (print "") }
    if (== fn_name "max") { return true } else { (print "") }
    if (== fn_name "sqrt") { return true } else { (print "") }
    if (== fn_name "pow") { return true } else { (print "") }
    if (== fn_name "floor") { return true } else { (print "") }
    if (== fn_name "ceil") { return true } else { (print "") }
    if (== fn_name "round") { return true } else { (print "") }
    
    /* String operations */
    if (== fn_name "str_length") { return true } else { (print "") }
    if (== fn_name "str_concat") { return true } else { (print "") }
    if (== fn_name "str_substring") { return true } else { (print "") }
    if (== fn_name "str_contains") { return true } else { (print "") }
    if (== fn_name "str_equals") { return true } else { (print "") }
    if (== fn_name "char_at") { return true } else { (print "") }
    if (== fn_name "string_from_char") { return true } else { (print "") }
    if (== fn_name "str_starts_with") { return true } else { (print "") }
    if (== fn_name "str_ends_with") { return true } else { (print "") }
    if (== fn_name "str_index_of") { return true } else { (print "") }
    if (== fn_name "str_last_index_of") { return true } else { (print "") }
    
    /* Type conversions */
    if (== fn_name "int_to_string") { return true } else { (print "") }
    if (== fn_name "string_to_int") { return true } else { (print "") }
    if (== fn_name "cast_int") { return true } else { (print "") }
    if (== fn_name "cast_float") { return true } else { (print "") }
    if (== fn_name "cast_bool") { return true } else { (print "") }
    if (== fn_name "cast_string") { return true } else { (print "") }
    if (== fn_name "to_string") { return true } else { (print "") }
    
    /* Array operations */
    if (== fn_name "at") { return true } else { (print "") }
    if (== fn_name "array_get") { return true } else { (print "") }
    if (== fn_name "array_length") { return true } else { (print "") }
    if (== fn_name "array_new") { return true } else { (print "") }
    if (== fn_name "array_set") { return true } else { (print "") }
    if (== fn_name "array_push") { return true } else { (print "") }
    if (== fn_name "array_slice") { return true } else { (print "") }
    if (== fn_name "map") { return true } else { (print "") }
    if (== fn_name "reduce") { return true } else { (print "") }
    
    /* OS operations */
    if (== fn_name "getcwd") { return true } else { (print "") }
    if (== fn_name "getenv") { return true } else { (print "") }
    if (== fn_name "exit") { return true } else { (print "") }
    
    return false
}

shadow is_builtin_function {
    assert (is_builtin_function "array_push")
    assert (is_builtin_function "at")
    assert (is_builtin_function "println")
    assert (not (is_builtin_function "my_custom_function"))
}

/* Check return type for built-in functions
 * Returns the appropriate type based on the function name
 */
fn check_builtin_function(fn_name: string, arg_count: int) -> Type {
    /* Core functions */
    if (== fn_name "print") { return (type_void) } else { (print "") }
    if (== fn_name "println") { return (type_void) } else { (print "") }
    if (== fn_name "assert") { return (type_void) } else { (print "") }
    
    /* Math functions */
    if (== fn_name "abs") { return (type_int) } else { (print "") }
    if (== fn_name "min") { return (type_int) } else { (print "") }
    if (== fn_name "max") { return (type_int) } else { (print "") }
    if (== fn_name "sqrt") { return (type_float) } else { (print "") }
    if (== fn_name "pow") { return (type_float) } else { (print "") }
    if (== fn_name "floor") { return (type_float) } else { (print "") }
    if (== fn_name "ceil") { return (type_float) } else { (print "") }
    if (== fn_name "round") { return (type_float) } else { (print "") }
    
    /* String operations */
    if (== fn_name "str_length") { return (type_int) } else { (print "") }
    if (== fn_name "str_concat") { return (type_string) } else { (print "") }
    if (== fn_name "str_substring") { return (type_string) } else { (print "") }
    if (== fn_name "str_contains") { return (type_bool) } else { (print "") }
    if (== fn_name "str_equals") { return (type_bool) } else { (print "") }
    if (== fn_name "char_at") { return (type_int) } else { (print "") }
    if (== fn_name "string_from_char") { return (type_string) } else { (print "") }
    if (== fn_name "str_starts_with") { return (type_bool) } else { (print "") }
    if (== fn_name "str_ends_with") { return (type_bool) } else { (print "") }
    if (== fn_name "str_index_of") { return (type_int) } else { (print "") }
    if (== fn_name "str_last_index_of") { return (type_int) } else { (print "") }
    
    /* Type conversions */
    if (== fn_name "int_to_string") { return (type_string) } else { (print "") }
    if (== fn_name "string_to_int") { return (type_int) } else { (print "") }
    if (== fn_name "cast_int") { return (type_int) } else { (print "") }
    if (== fn_name "cast_float") { return (type_float) } else { (print "") }
    if (== fn_name "cast_bool") { return (type_bool) } else { (print "") }
    if (== fn_name "cast_string") { return (type_string) } else { (print "") }
    if (== fn_name "to_string") { return (type_string) } else { (print "") }
    
    /* Array operations */
    if (== fn_name "array_length") { return (type_int) } else { (print "") }
    if (== fn_name "array_set") { return (type_void) } else { (print "") }
    if (== fn_name "array_push") { return (type_array 0 "") } else { (print "") }
    if (== fn_name "at") { return Type { kind: TypeKind.TYPE_UNKNOWN, name: "array_elem", element_type_kind: TypeKind.TYPE_UNKNOWN, element_type_name: "" } } else { (print "") }
    if (== fn_name "array_get") { return Type { kind: TypeKind.TYPE_UNKNOWN, name: "array_elem", element_type_kind: TypeKind.TYPE_UNKNOWN, element_type_name: "" } } else { (print "") }
    
    /* OS operations */
    if (== fn_name "getcwd") { return (type_string) } else { (print "") }
    if (== fn_name "getenv") { return (type_string) } else { (print "") }
    if (== fn_name "exit") { return (type_void) } else { (print "") }
    
    /* Default: unknown */
    return Type { kind: TypeKind.TYPE_UNKNOWN, name: "builtin", element_type_kind: TypeKind.TYPE_UNKNOWN, element_type_name: "" }
}

shadow check_builtin_function {
    let t1: Type = (check_builtin_function "println" 1)
    assert (== t1.kind TypeKind.TYPE_VOID)
    
    let t2: Type = (check_builtin_function "array_length" 1)
    assert (== t2.kind TypeKind.TYPE_INT)
}

/* Extract element type from list function name
 * "list_Point_new" -> "Point"
 * "list_int_push" -> "int"
 */
fn extract_list_type_from_function(fn_name: string) -> string {
    /* Skip "list_" prefix */
    let after_prefix: string = (str_substring fn_name 5 (- (str_length fn_name) 5))
    
    /* Find last underscore to separate type from operation */
    let last_underscore: int = (str_last_index_of after_prefix "_")
    if (> last_underscore 0) {
        return (str_substring after_prefix 0 last_underscore)
    } else {
        return after_prefix
    }
}

shadow extract_list_type_from_function {
    assert (== (extract_list_type_from_function "list_Point_new") "Point")
    assert (== (extract_list_type_from_function "list_int_push") "int")
    assert (== (extract_list_type_from_function "list_string_get") "string")
}

/* Create type from element name (for list element types) */
fn type_from_element_name(elem_name: string) -> Type {
    if (== elem_name "int") {
        return (type_int)
    } else {
        if (== elem_name "string") {
            return (type_string)
        } else {
            if (== elem_name "float") {
                return (type_float)
            } else {
                if (== elem_name "bool") {
                    return (type_bool)
                } else {
                    /* Struct type */
                    return Type {
                        kind: TypeKind.TYPE_STRUCT,
                        name: elem_name,
                        element_type_kind: TypeKind.TYPE_UNKNOWN,
                        element_type_name: ""
                    }
                }
            }
        }
    }
}

shadow type_from_element_name {
    let t1: Type = (type_from_element_name "int")
    assert (== t1.kind TypeKind.TYPE_INT)
    
    let t2: Type = (type_from_element_name "Point")
    assert (== t2.kind TypeKind.TYPE_STRUCT)
    assert (== t2.name "Point")
}

shadow type_from_string {
    let t: Type = (type_from_string "int")
    assert (== t.kind TypeKind.TYPE_INT)
    
    let t2: Type = (type_from_string "MyStruct")
    assert (== t2.kind TypeKind.TYPE_STRUCT)
    /* String comparison in struct might not work as expected */
    /* Just check the kind for now */
}

/* Type to string for error messages */
fn type_to_string(t: Type) -> string {
    if (== t.kind TypeKind.TYPE_INT) {
        return "int"
    } else {
        if (== t.kind TypeKind.TYPE_FLOAT) {
            return "float"
        } else {
            if (== t.kind TypeKind.TYPE_BOOL) {
                return "bool"
            } else {
                if (== t.kind TypeKind.TYPE_STRING) {
                    return "string"
                } else {
                    if (== t.kind TypeKind.TYPE_VOID) {
                        return "void"
                    } else {
                        if (== t.kind TypeKind.TYPE_ARRAY) {
                            let elem_str: string = (type_kind_to_string t.element_type_kind t.element_type_name)
                            return (str_concat "array<" (str_concat elem_str ">"))
                        } else {
                            if (== t.kind TypeKind.TYPE_LIST_GENERIC) {
                                return (str_concat "List<" (str_concat t.element_type_name ">"))
                            } else {
                                if (== t.kind TypeKind.TYPE_STRUCT) {
                                    return t.name
                                } else {
                                    if (== t.kind TypeKind.TYPE_UNION) {
                                        return t.name
                                    } else {
                                        if (== t.kind TypeKind.TYPE_TUPLE) {
                                            return "tuple"
                                        } else {
                                            return "unknown"
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

/* Convert type kind to string */
fn type_kind_to_string(kind: int, name: string) -> string {
    if (== kind TypeKind.TYPE_INT) { return "int" }
    else { if (== kind TypeKind.TYPE_FLOAT) { return "float" }
    else { if (== kind TypeKind.TYPE_BOOL) { return "bool" }
    else { if (== kind TypeKind.TYPE_STRING) { return "string" }
    else { if (== kind TypeKind.TYPE_STRUCT) { return name }
    else { return "unknown" } } } } }
}

shadow type_to_string {
    assert (== (type_to_string (type_int)) "int")
    assert (== (type_to_string (type_bool)) "bool")
}

/* =============================================================================
 * SYMBOL TABLE MANAGEMENT
 * ============================================================================= */

/* Create new empty environment */
fn env_new() -> TypeEnvironment {
    return TypeEnvironment {
        error_count: 0,
        has_error: false
    }
}

shadow env_new {
    let env: TypeEnvironment = (env_new)
    assert (== env.error_count 0)
    assert (== env.has_error false)
}

/* Create a new symbol */
fn symbol_new(name: string, sym_type: Type, is_mut: bool, is_fn: bool, param_count: int) -> Symbol {
    return Symbol {
        name: name,
        sym_type: sym_type,
        is_mutable: is_mut,
        is_function: is_fn,
        param_count: param_count,
        defined: true
    }
}

shadow symbol_new {
    let sym: Symbol = (symbol_new "x" (type_int) true false 0)
    assert (== sym.is_mutable true)
    assert (== sym.is_function false)
}

/* Add symbol to environment (using array) */
fn env_add_symbol(env: TypeEnvironment, symbols: array<Symbol>, sym: Symbol) -> array<Symbol> {
    return (array_push symbols sym)
}

shadow env_add_symbol {
    /* Note: array<Symbol> not fully supported in shadow tests */
    /* This is validated in runtime usage */
    assert (== 1 1)
}

/* Look up symbol by name */
fn env_lookup(symbols: array<Symbol>, name: string) -> int {
    /* Returns index of symbol, or -1 if not found */
    let count: int = (array_length symbols)
    let mut i: int = (- count 1)  /* Search backwards for most recent definition */
    
    while (>= i 0) {
        let sym: Symbol = (at symbols i)
        if (== sym.name name) {
            return i
        } else {
            (print "")
        }
        set i (- i 1)
    }
    
    return -1
}

shadow env_lookup {
    /* Note: array<Symbol> testing skipped in shadow tests */
    assert (== 1 1)
}

/* Check if symbol exists */
fn env_has_symbol(symbols: array<Symbol>, name: string) -> bool {
    return (>= (env_lookup symbols name) 0)
}

shadow env_has_symbol {
    /* Note: array<Symbol> testing skipped in shadow tests */
    assert (== 1 1)
}

/* Get symbol type */
fn env_get_type(symbols: array<Symbol>, name: string) -> Type {
    let idx: int = (env_lookup symbols name)
    if (>= idx 0) {
        let sym: Symbol = (at symbols idx)
        return sym.sym_type
    } else {
        /* Return unknown type for undefined symbols */
        return Type { kind: TypeKind.TYPE_UNKNOWN, name: "undefined", element_type_kind: TypeKind.TYPE_UNKNOWN, element_type_name: "" }
    }
}

shadow env_get_type {
    /* Note: array<Symbol> testing skipped in shadow tests */
    assert (== 1 1)
}

/* =============================================================================
 * EXPRESSION TYPE CHECKING
 * ============================================================================= */

/* Check type of a literal number */
fn check_number_literal(value: string) -> Type {
    /* For now, all numbers are int */
    /* TODO: detect floats by checking for '.' */
    return (type_int)
}

shadow check_number_literal {
    let t: Type = (check_number_literal "42")
    assert (== t.kind TypeKind.TYPE_INT)
}

/* Check type of a string literal */
fn check_string_literal() -> Type {
    return (type_string)
}

shadow check_string_literal {
    let t: Type = (check_string_literal)
    assert (== t.kind TypeKind.TYPE_STRING)
}

/* Check type of a boolean literal */
fn check_bool_literal() -> Type {
    return (type_bool)
}

shadow check_bool_literal {
    let t: Type = (check_bool_literal)
    assert (== t.kind TypeKind.TYPE_BOOL)
}

/* Check if operator is valid for given types */
fn check_binary_op(op: string, left_type: Type, right_type: Type) -> Type {
    /* Arithmetic ops: +, -, *, /, % */
    if (or (or (or (or (== op "+") (== op "-")) (== op "*")) (== op "/")) (== op "%")) {
        /* Both operands must be int or float */
        if (and (== left_type.kind TypeKind.TYPE_INT) (== right_type.kind TypeKind.TYPE_INT)) {
            return (type_int)
        } else {
            if (or (== left_type.kind TypeKind.TYPE_FLOAT) (== right_type.kind TypeKind.TYPE_FLOAT)) {
                return (type_float)
            } else {
                /* Type error */
                return Type { kind: TypeKind.TYPE_UNKNOWN, name: "error", element_type_kind: TypeKind.TYPE_UNKNOWN, element_type_name: "" }
            }
        }
    } else {
        /* Comparison ops: ==, !=, <, >, <=, >= */
        if (or (or (or (or (or (== op "==") (== op "!=")) (== op "<")) (== op ">")) (== op "<=")) (== op ">=")) {
            /* Types must match, result is bool */
            if (types_equal left_type right_type) {
                return (type_bool)
            } else {
                return Type { kind: TypeKind.TYPE_UNKNOWN, name: "error", element_type_kind: TypeKind.TYPE_UNKNOWN, element_type_name: "" }
            }
        } else {
            /* Logical ops: and, or */
            if (or (== op "and") (== op "or")) {
                /* Both must be bool */
                if (and (== left_type.kind TypeKind.TYPE_BOOL) (== right_type.kind TypeKind.TYPE_BOOL)) {
                    return (type_bool)
                } else {
                    return Type { kind: TypeKind.TYPE_UNKNOWN, name: "error", element_type_kind: TypeKind.TYPE_UNKNOWN, element_type_name: "" }
                }
            } else {
                /* Unknown operator */
                return Type { kind: TypeKind.TYPE_UNKNOWN, name: "error", element_type_kind: TypeKind.TYPE_UNKNOWN, element_type_name: "" }
            }
        }
    }
}

shadow check_binary_op {
    let int_t: Type = (type_int)
    let bool_t: Type = (type_bool)
    
    /* Test arithmetic */
    let result1: Type = (check_binary_op "+" int_t int_t)
    assert (== result1.kind TypeKind.TYPE_INT)
    
    /* Test comparison */
    let result2: Type = (check_binary_op "==" int_t int_t)
    assert (== result2.kind TypeKind.TYPE_BOOL)
    
    /* Test logical */
    let result3: Type = (check_binary_op "and" bool_t bool_t)
    assert (== result3.kind TypeKind.TYPE_BOOL)
}

/* AST and Parser IR types are provided by src_nano/compiler/ir.nano */

/* =============================================================================
 * AST TYPE CHECKING - Expression evaluation
 * ============================================================================= */

fn op_token_to_string(op: int) -> string {
    if (== op NLTokenType.NL_TOKEN_PLUS) { return "+" }
    else {
        if (== op NLTokenType.NL_TOKEN_MINUS) { return "-" }
        else {
            if (== op NLTokenType.NL_TOKEN_STAR) { return "*" }
            else {
                if (== op NLTokenType.NL_TOKEN_SLASH) { return "/" }
                else {
                    if (== op NLTokenType.NL_TOKEN_PERCENT) { return "%" }
                    else {
                        if (== op NLTokenType.NL_TOKEN_EQ) { return "==" }
                        else {
                            if (== op NLTokenType.NL_TOKEN_NE) { return "!=" }
                            else {
                                if (== op NLTokenType.NL_TOKEN_LT) { return "<" }
                                else {
                                    if (== op NLTokenType.NL_TOKEN_GT) { return ">" }
                                    else {
                                        if (== op NLTokenType.NL_TOKEN_LE) { return "<=" }
                                        else {
                                            if (== op NLTokenType.NL_TOKEN_GE) { return ">=" }
                                            else {
                                                if (== op NLTokenType.NL_TOKEN_AND) { return "and" }
                                                else {
                                                    if (== op NLTokenType.NL_TOKEN_OR) { return "or" }
                                                    else { return "?" }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

/* Type check an expression node by ID
 * 
 * This recursively evaluates the type of an expression node.
 * Node IDs are used to reference nodes in the Parser's storage lists.
 * 
 * Args:
 *   parser: The Parser containing AST nodes
 *   node_id: Index into the appropriate AST list
 *   node_type: 0=number, 1=identifier, 2=binary_op
 *   symbols: Symbol table for identifier lookup
 * 
 * Returns: The type of the expression, or TYPE_UNKNOWN on error
 */
fn check_expr_node(parser: Parser, node_id: int, node_type: int, symbols: array<Symbol>) -> Type {
    /* Use ParseNodeType enum values */
    if (== node_type ParseNodeType.PNODE_NUMBER) {
        return (type_int)
    } else {
        if (== node_type ParseNodeType.PNODE_STRING) {
            return (type_string)
        } else {
            if (== node_type ParseNodeType.PNODE_BOOL) {
                return (type_bool)
            } else {
                if (== node_type ParseNodeType.PNODE_FLOAT) {
                    return (type_float)
                } else {
                    if (== node_type ParseNodeType.PNODE_IDENTIFIER) {
                        let id_node: ASTIdentifier = (parser_get_identifier parser node_id)
                        let var_type: Type = (env_get_type symbols id_node.name)

                        if (== var_type.kind TypeKind.TYPE_UNKNOWN) {
                            (print "Type error: Undefined identifier ")
                            (println id_node.name)
                        } else {
                            (print "")
                        }

                        return var_type
                    } else {
                        if (== node_type ParseNodeType.PNODE_CALL) {
                            let call: ASTCall = (parser_get_call parser node_id)
                            let fn_id: ASTIdentifier = (parser_get_identifier parser call.function)
                            let fn_name: string = fn_id.name
                            
                            /* Check for built-in functions first */
                            if (is_builtin_function fn_name) {
                                return (check_builtin_function fn_name call.arg_count)
                            } else {
                                /* Check for generic list functions: list_TypeName_operation */
                                if (str_contains fn_name "list_") {
                                    return (check_list_function_call fn_name call.arg_count)
                                } else {
                                    let idx: int = (env_lookup symbols fn_name)

                                    if (< idx 0) {
                                        (print "Type error: Undefined function ")
                                        (println fn_name)
                                        return Type { kind: TypeKind.TYPE_UNKNOWN, name: "undefined_fn", element_type_kind: TypeKind.TYPE_UNKNOWN, element_type_name: "" }
                                    } else {
                                        let sym: Symbol = (at symbols idx)

                                        if (and (>= sym.param_count 0) (!= sym.param_count call.arg_count)) {
                                            (print "Type error: Wrong arg count for ")
                                            (print fn_name)
                                            (print ", expected ")
                                            (print (int_to_string sym.param_count))
                                            (print ", got ")
                                            (println (int_to_string call.arg_count))
                                        } else {
                                            (print "")
                                        }

                                        return sym.sym_type
                                    }
                                }
                                }
                            }
                        } else {
                            if (== node_type ParseNodeType.PNODE_BINARY_OP) {
                                let binop: ASTBinaryOp = (parser_get_binary_op parser node_id)
                                let left_t: Type = (check_expr_node parser binop.left binop.left_type symbols)
                                let right_t: Type = (check_expr_node parser binop.right binop.right_type symbols)
                                let op_str: string = (op_token_to_string binop.op)
                                let result: Type = (check_binary_op op_str left_t right_t)

                                if (== result.kind TypeKind.TYPE_UNKNOWN) {
                                    (println "Type error: Invalid binary operation")
                                } else {
                                    (print "")
                                }

                                return result
                            } else {
                                /* Check for union construction: Option.Some { value: 42 } */
                                if (== node_type 7) {
                                    return (check_union_construct parser node_id)
                                } else {
                                    /* Check for match expression */
                                    if (== node_type 8) {
                                        return (check_match_expr parser node_id symbols)
                                    } else {
                                        return Type { kind: TypeKind.TYPE_UNKNOWN, name: "unknown_node_type", element_type_kind: TypeKind.TYPE_UNKNOWN, element_type_name: "" }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

/* Check union construction expression
 * Example: Option.Some { value: 42 }
 * Returns: The union type (TYPE_UNION with union name)
 */
fn check_union_construct(parser: Parser, node_id: int) -> Type {
    let uc: ASTUnionConstruct = (parser_get_union_construct parser node_id)
    
    /* Return union type */
    return Type {
        kind: TypeKind.TYPE_UNION,
        name: uc.union_name,
        element_type_kind: TypeKind.TYPE_UNKNOWN,
        element_type_name: ""
    }
}

/* Check match expression  
 * Example: match opt { Some(s) => s.value, None(n) => 0 }
 * Returns: Type of the match arms (must all match)
 */
fn check_match_expr(parser: Parser, node_id: int, symbols: array<Symbol>) -> Type {
    let m: ASTMatch = (parser_get_match parser node_id)
    
    /* Check scrutinee (expression being matched) */
    let scrutinee_type: Type = (check_expr_node parser m.scrutinee m.scrutinee_type symbols)
    
    if (!= scrutinee_type.kind TypeKind.TYPE_UNION) {
        (println "Type error: match expression must match on union type")
        return Type { kind: TypeKind.TYPE_UNKNOWN, name: "match_error", element_type_kind: TypeKind.TYPE_UNKNOWN, element_type_name: "" }
    } else {
        (print "")
    }
    
    /* Type check first arm to get return type */
    if (> m.arm_count 0) {
        /* For now, assume all arms have the same type */
        /* In full implementation, would check all arms match */
        let first_arm_type: Type = (check_expr_node parser (at m.arm_body_ids 0) (at m.arm_body_types 0) symbols)
        return first_arm_type
    } else {
        return Type { kind: TypeKind.TYPE_UNKNOWN, name: "empty_match", element_type_kind: TypeKind.TYPE_UNKNOWN, element_type_name: "" }
    }
}

/* Type check a return statement expression
 * 
 * Validates that the return expression type matches the expected function return type
 */
fn typecheck_return_expr(parser: Parser, ret_node: ASTReturn, expected_type: Type, symbols: array<Symbol>) -> bool {
    if (< ret_node.value 0) {
        /* No return value - expect void */
        if (== expected_type.kind TypeKind.TYPE_VOID) {
            return true
        } else {
            (println "Type error: Missing return value")
            return false
        }
    } else {
        /* Has return value - type check it */
        /* For now, assume it's valid */
        /* Full implementation would check the expression type */
        return true
    }
}

/* =============================================================================
 * AST TYPE CHECKING - Statement validation
 * ============================================================================= */

fn array_elem_type_from_array_decl(t: string) -> string {
    if (str_contains t "array<int>") {
        return "int"
    } else {
        if (str_contains t "array<float>") {
            return "float"
        } else {
            if (str_contains t "array<string>") {
                return "string"
            } else {
                if (str_contains t "array<bool>") {
                    return "bool"
                } else {
                    if (str_contains t "array<array<") {
                        return "array"
                    } else {
                        return ""
                    }
                }
            }
        }
    }
}

/* Type check a let statement
 * 
 * Validates that:
 * 1. The variable is not already defined
 * 2. The initialization expression type matches the declared type
 * 
 * Returns: Updated symbols array with the new variable
 */
fn check_let_statement(parser: Parser, let_node: ASTLet, symbols: array<Symbol>) -> array<Symbol> {
    /* Check if variable already exists in current scope */
    if (env_has_symbol symbols let_node.name) {
        /* TODO: Better error reporting with variable name */
        (println "Type error: Variable already defined")
        return symbols
    } else {
        (print "")
    }
    
    /* If initializer is an empty array literal, propagate element_type from declared type */
    if (and (>= let_node.value 0) (== let_node.value_type ParseNodeType.PNODE_ARRAY_LITERAL)) {
        let arr: ASTArrayLiteral = (parser_get_array_literal parser let_node.value)
        if (and (== arr.element_count 0) (== arr.element_type "")) {
            let elem_t: string = (array_elem_type_from_array_decl let_node.var_type)
            if (!= elem_t "") {
                (parser_set_array_literal_element_type parser let_node.value elem_t)
            } else { (print "") }
        } else { (print "") }
    } else { (print "") }

    /* Get declared type */
    let declared_type: Type = (type_from_string let_node.var_type)

    if (>= let_node.value 0) {
        let init_type: Type = (check_expr_node parser let_node.value let_node.value_type symbols)
        if (not (types_equal init_type declared_type)) {
            (print "Type error: let initializer type mismatch for ")
            (println let_node.name)
            (print "  declared: ")
            (println (type_to_string declared_type))
            (print "  init: ")
            (println (type_to_string init_type))
        } else {
            (print "")
        }
    } else {
        (print "")
    }

    let sym: Symbol = (symbol_new let_node.name declared_type let_node.is_mut false 0)
    return (env_add_symbol (env_new) symbols sym)
}

/* Type check a return statement
 * 
 * Validates that the return expression type matches the function's return type
 * 
 * Returns: true if valid, false if type error
 */
fn check_return_statement(parser: Parser, ret_node: ASTReturn, expected_type: Type, symbols: array<Symbol>) -> bool {
    /* If no return value, expect void */
    if (< ret_node.value 0) {
        return (== expected_type.kind TypeKind.TYPE_VOID)
    } else {
        let expr_t: Type = (check_expr_node parser ret_node.value ret_node.value_type symbols)
        return (types_equal expr_t expected_type)
    }
}

fn check_set_statement(parser: Parser, set_node: ASTSet, symbols: array<Symbol>) -> bool {
    let idx: int = (env_lookup symbols set_node.target)
    if (< idx 0) {
        (print "Type error: Undefined variable in set: ")
        (println set_node.target)
        return false
    } else {
        let sym: Symbol = (at symbols idx)
        if (not sym.is_mutable) {
            (print "Type error: Cannot assign to immutable variable: ")
            (println set_node.target)
            return false
        } else {
            let rhs_t: Type = (check_expr_node parser set_node.value set_node.value_type symbols)
            if (not (types_equal rhs_t sym.sym_type)) {
                (print "Type error: set type mismatch for ")
                (println set_node.target)
                return false
            } else {
                return true
            }
        }
    }
}

fn expr_kind_from_pnode(pnode_type: int) -> int {
    if (== pnode_type ParseNodeType.PNODE_NUMBER) { return 0 }
    else { if (== pnode_type ParseNodeType.PNODE_IDENTIFIER) { return 1 }
    else { if (== pnode_type ParseNodeType.PNODE_BINARY_OP) { return 2 }
    else { if (== pnode_type ParseNodeType.PNODE_CALL) { return 3 }
    else { if (== pnode_type ParseNodeType.PNODE_STRING) { return 4 }
    else { if (== pnode_type ParseNodeType.PNODE_BOOL) { return 5 }
    else { if (== pnode_type ParseNodeType.PNODE_FLOAT) { return 6 }
    else { if (== pnode_type ParseNodeType.PNODE_UNION_CONSTRUCT) { return 7 }
    else { if (== pnode_type ParseNodeType.PNODE_MATCH) { return 8 }
    else { return (- 0 1) } } } } } } } } }
}

fn check_block(parser: Parser, block_id: int, symbols: array<Symbol>, expected_return: Type) -> bool {
    let block: ASTBlock = (parser_get_block parser block_id)
    let mut local_symbols: array<Symbol> = symbols
    let mut ok: bool = true

    let mut i: int = 0
    while (< i block.statement_count) {
        let stmt: ASTStmtRef = (parser_get_block_statement parser (+ block.statement_start i))

        if (== stmt.node_type ParseNodeType.PNODE_LET) {
            let let_node: ASTLet = (parser_get_let parser stmt.node_id)
            set local_symbols (check_let_statement parser let_node local_symbols)
        } else { if (== stmt.node_type ParseNodeType.PNODE_SET) {
            let set_node: ASTSet = (parser_get_set parser stmt.node_id)
            if (not (check_set_statement parser set_node local_symbols)) { set ok false } else { (print "") }
        } else { if (== stmt.node_type ParseNodeType.PNODE_IF) {
            let if_node: ASTIf = (parser_get_if parser stmt.node_id)
            let cond_t: Type = (check_expr_node parser if_node.condition if_node.condition_type local_symbols)
            if (!= cond_t.kind TypeKind.TYPE_BOOL) {
                (println "Type error: if condition must be bool")
                set ok false
            } else { (print "") }

            if (>= if_node.then_body 0) {
                if (not (check_block parser if_node.then_body local_symbols expected_return)) { set ok false } else { (print "") }
            } else { (print "") }

            if (>= if_node.else_body 0) {
                if (not (check_block parser if_node.else_body local_symbols expected_return)) { set ok false } else { (print "") }
            } else { (print "") }
        } else { if (== stmt.node_type ParseNodeType.PNODE_WHILE) {
            let while_node: ASTWhile = (parser_get_while parser stmt.node_id)
            let cond_t: Type = (check_expr_node parser while_node.condition while_node.condition_type local_symbols)
            if (!= cond_t.kind TypeKind.TYPE_BOOL) {
                (println "Type error: while condition must be bool")
                set ok false
            } else { (print "") }

            if (>= while_node.body 0) {
                if (not (check_block parser while_node.body local_symbols expected_return)) { set ok false } else { (print "") }
            } else { (print "") }
        } else { if (== stmt.node_type ParseNodeType.PNODE_RETURN) {
            let ret_node: ASTReturn = (parser_get_return parser stmt.node_id)
            if (not (check_return_statement parser ret_node expected_return local_symbols)) {
                (println "Type error: return type mismatch")
                set ok false
            } else { (print "") }
        } else { if (== stmt.node_type ParseNodeType.PNODE_ASSERT) {
            let a: ASTAssert = (parser_get_assert parser stmt.node_id)
            let cond_t: Type = (check_expr_node parser a.condition a.condition_type local_symbols)
            if (!= cond_t.kind TypeKind.TYPE_BOOL) {
                (println "Type error: assert condition must be bool")
                set ok false
            } else { (print "") }
        } else {
            /* Expression statement */
            let kind: int = (expr_kind_from_pnode stmt.node_type)
            if (>= kind 0) {
                let _t: Type = (check_expr_node parser stmt.node_id kind local_symbols)
                (print "")
            } else {
                (print "")
            }
        } } } } } }

        set i (+ i 1)
    }

    return ok
}

/* =============================================================================
 * AST TYPE CHECKING - Function validation
 * ============================================================================= */

/* Type check a function definition
 * 
 * Validates:
 * 1. Parameters are valid types
 * 2. Function body statements are well-typed
 * 3. All return statements match the declared return type
 * 
 * Returns: true if valid, false if type errors
 */
fn check_function(parser: Parser, func: ASTFunction, symbols: array<Symbol>) -> bool {
    (print "Type checking function ")
    (println func.name)

    let return_type: Type = (type_from_string func.return_type)
    let mut func_symbols: array<Symbol> = symbols

    /* Add parameters as symbols (stored as lets starting at func.param_start) */
    let mut i: int = 0
    while (< i func.param_count) {
        let param_let: ASTLet = (parser_get_let parser (+ func.param_start i))
        let ptype: Type = (type_from_string param_let.var_type)
        let psym: Symbol = (symbol_new param_let.name ptype param_let.is_mut false 0)
        set func_symbols (env_add_symbol (env_new) func_symbols psym)
        set i (+ i 1)
    }

    if (< func.body 0) {
        /* extern fn */
        return true
    } else {
        return (check_block parser func.body func_symbols return_type)
    }
}

/* =============================================================================
 * TYPE CHECKING WRAPPER - Top-level entry point for type checking a program
 * ============================================================================= */

/* Typecheck a parsed program with full AST walking
 * 
 * This version walks through the actual Parser AST and validates:
 * 1. All function signatures are valid
 * 2. Function bodies are well-typed
 * 3. Return types match declarations
 * 4. All identifiers are defined
 * 
 * Args:
 *   parser: The parsed AST from the parser
 * 
 * Returns: 0 for success, 1 for type error
 */
pub fn typecheck_parser(parser: Parser) -> int {
    (println "=== Type Checking (Full AST Walk) ===")
    
    let env: TypeEnvironment = (env_new)
    let mut symbols: array<Symbol> = []
    
    /* Get function count using accessor */
    let func_count: int = (parser_get_function_count parser)
    (print "Type checking ")
    (print (int_to_string func_count))
    (println " functions")
    
    /* Validate we have at least one function */
    if (<= func_count 0) {
        (println "Error: No functions found")
        return 1
    } else {
        (print "")
    }
    
    /* Add built-in functions to symbol table */
    let println_sym: Symbol = (symbol_new "println" (type_void) false true (- 0 1))
    set symbols (env_add_symbol env symbols println_sym)
    
    let print_sym: Symbol = (symbol_new "print" (type_void) false true (- 0 1))
    set symbols (env_add_symbol env symbols print_sym)

    /* Minimal builtins used by nanoc_v05 */
    let system_sym: Symbol = (symbol_new "system" (type_int) false true (- 0 1))
    set symbols (env_add_symbol env symbols system_sym)

    let str_concat_sym: Symbol = (symbol_new "str_concat" (type_string) false true (- 0 1))
    set symbols (env_add_symbol env symbols str_concat_sym)

    let str_equals_sym: Symbol = (symbol_new "str_equals" (type_bool) false true (- 0 1))
    set symbols (env_add_symbol env symbols str_equals_sym)
    
    /* Phase 1: Add all user function signatures to symbol table */
    let mut i: int = 0
    while (< i func_count) {
        let func: ASTFunction = (parser_get_function parser i)
        /* TODO: Add function name to debug output */
        (println "  Registering function...")
        
        let return_type: Type = (type_from_string func.return_type)
        let func_sym: Symbol = (symbol_new func.name return_type false true func.param_count)
        set symbols (env_add_symbol env symbols func_sym)
        set i (+ i 1)
    }
    
    /* Phase 2: Type check each function body */
    set i 0
    while (< i func_count) {
        let func: ASTFunction = (parser_get_function parser i)
        /* TODO: Add function name to debug output */
        (println "  Type checking function...")
        
        let valid: bool = (check_function parser func symbols)
        if (not valid) {
            /* TODO: Add function name to error message */
            (println "Error: Type error in function")
            return 1
        } else {
            (print "")
        }
        set i (+ i 1)
    }
    
    (println " Type checking complete - All functions valid!")
    return 0
}

/* Simplified typecheck for count-based validation */
fn typecheck_with_count(func_count: int) -> int {
    (println "=== Type Checking (Count-based) ===")
    (print "Validating ")
    (print (int_to_string func_count))
    (println " functions")
    
    if (<= func_count 0) {
        (println "Error: No functions found")
        return 1
    } else {
        (println "Type checking complete!")
        return 0
    }
}

/* Wrapper for integration (no parser argument) */
fn typecheck() -> int {
    /* Simplified version - assumes at least one function exists */
    return (typecheck_with_count 1)
}

shadow typecheck {
    assert (== (typecheck) 0)
}

