/* =============================================================================
 * nanolang Parser (Self-Hosted) - MVP
 * =============================================================================
 * Recursive descent parser producing an Abstract Syntax Tree
 * 
 * MVP Scope:
 * - Parse literals (numbers, strings, bools, identifiers)
 * - Parse binary expressions: (+ 2 3)
 * - Parse function calls: (func arg1 arg2)
 * - Parse let statements: let x: int = value
 * - Basic error reporting
 */

/* Lexer entrypoints (used by shadow tests) */
import "src_nano/compiler/lexer.nano"

/* Helper: Initialize AST lists (triggers generic instantiation) */
fn parser_init_ast_lists() -> Parser {
    /* Use let statements to trigger generic instantiation */
    let numbers: List<ASTNumber> = (list_ASTNumber_new)
    let floats: List<ASTFloat> = (list_ASTFloat_new)
    let strings: List<ASTString> = (list_ASTString_new)
    let bools: List<ASTBool> = (list_ASTBool_new)
    let identifiers: List<ASTIdentifier> = (list_ASTIdentifier_new)
    let binary_ops: List<ASTBinaryOp> = (list_ASTBinaryOp_new)
    let calls: List<ASTCall> = (list_ASTCall_new)
    let call_args: List<ASTStmtRef> = (list_ASTStmtRef_new)
    let array_elements: List<ASTStmtRef> = (list_ASTStmtRef_new)
    let array_literals: List<ASTArrayLiteral> = (list_ASTArrayLiteral_new)
    let lets: List<ASTLet> = (list_ASTLet_new)
    let sets: List<ASTSet> = (list_ASTSet_new)
    let ifs: List<ASTIf> = (list_ASTIf_new)
    let whiles: List<ASTWhile> = (list_ASTWhile_new)
    let fors: List<ASTFor> = (list_ASTFor_new)
    let returns: List<ASTReturn> = (list_ASTReturn_new)
    let blocks: List<ASTBlock> = (list_ASTBlock_new)
    let unsafe_blocks: List<ASTUnsafeBlock> = (list_ASTUnsafeBlock_new)
    let block_statements: List<ASTStmtRef> = (list_ASTStmtRef_new)
    let prints: List<ASTPrint> = (list_ASTPrint_new)
    let asserts: List<ASTAssert> = (list_ASTAssert_new)
    let functions: List<ASTFunction> = (list_ASTFunction_new)
    let shadows: List<ASTShadow> = (list_ASTShadow_new)
    let structs: List<ASTStruct> = (list_ASTStruct_new)
    let struct_literals: List<ASTStructLiteral> = (list_ASTStructLiteral_new)
    let field_accesses: List<ASTFieldAccess> = (list_ASTFieldAccess_new)
    let enums: List<ASTEnum> = (list_ASTEnum_new)
    let unions: List<ASTUnion> = (list_ASTUnion_new)
    let union_constructs: List<ASTUnionConstruct> = (list_ASTUnionConstruct_new)
    let matches: List<ASTMatch> = (list_ASTMatch_new)
    let imports: List<ASTImport> = (list_ASTImport_new)
    let opaque_types: List<ASTOpaqueType> = (list_ASTOpaqueType_new)
    let tuple_literals: List<ASTTupleLiteral> = (list_ASTTupleLiteral_new)
    let tuple_indices: List<ASTTupleIndex> = (list_ASTTupleIndex_new)
    
    /* Return parser with initialized lists */
    let empty_tokens: List<LexerToken> = (list_LexerToken_new)
    return Parser {
        tokens: empty_tokens,
        position: 0,
        token_count: 0,
        has_error: false,
        numbers: numbers,
        floats: floats,
        strings: strings,
        bools: bools,
        identifiers: identifiers,
        binary_ops: binary_ops,
        calls: calls,
        call_args: call_args,
        array_elements: array_elements,
        array_literals: array_literals,
        lets: lets,
        sets: sets,
        ifs: ifs,
        whiles: whiles,
        fors: fors,
        returns: returns,
        blocks: blocks,
        unsafe_blocks: unsafe_blocks,
        block_statements: block_statements,
        prints: prints,
        asserts: asserts,
        functions: functions,
        shadows: shadows,
        structs: structs,
        struct_literals: struct_literals,
        field_accesses: field_accesses,
        enums: enums,
        unions: unions,
        union_constructs: union_constructs,
        matches: matches,
        imports: imports,
        opaque_types: opaque_types,
        tuple_literals: tuple_literals,
        tuple_indices: tuple_indices,
        numbers_count: 0,
        floats_count: 0,
        strings_count: 0,
        bools_count: 0,
        identifiers_count: 0,
        binary_ops_count: 0,
        calls_count: 0,
        array_literals_count: 0,
        lets_count: 0,
        sets_count: 0,
        ifs_count: 0,
        whiles_count: 0,
        fors_count: 0,
        returns_count: 0,
        blocks_count: 0,
        unsafe_blocks_count: 0,
        block_statements_count: 0,
        prints_count: 0,
        asserts_count: 0,
        functions_count: 0,
        shadows_count: 0,
        structs_count: 0,
        struct_literals_count: 0,
        field_accesses_count: 0,
        enums_count: 0,
        unions_count: 0,
        union_constructs_count: 0,
        matches_count: 0,
        imports_count: 0,
        opaque_types_count: 0,
        tuple_literals_count: 0,
        tuple_indices_count: 0,
        next_node_id: 0,
        last_expr_node_id: -1,
        last_expr_node_type: -1
    }
}

shadow parser_init_ast_lists {
    /* Tested via integration tests in parse_program and full compilation pipeline */
    assert (== 1 1)
}

/* Create new parser from token list */
/* Note: token_count is calculated externally to avoid generic instantiation issues */
fn parser_new(tokens: List<LexerToken>, token_count: int) -> Parser {
    /* Initialize AST lists using helper (triggers generic instantiation) */
    let init_parser: Parser = (parser_init_ast_lists)
    
    return Parser {
        tokens: tokens,
        position: 0,
        token_count: token_count,
        has_error: false,
        numbers: init_parser.numbers,
        floats: init_parser.floats,
        strings: init_parser.strings,
        bools: init_parser.bools,
        identifiers: init_parser.identifiers,
        binary_ops: init_parser.binary_ops,
        calls: init_parser.calls,
        call_args: init_parser.call_args,
        array_elements: init_parser.array_elements,
        array_literals: init_parser.array_literals,
        lets: init_parser.lets,
        sets: init_parser.sets,
        ifs: init_parser.ifs,
        whiles: init_parser.whiles,
        fors: init_parser.fors,
        returns: init_parser.returns,
        blocks: init_parser.blocks,
        unsafe_blocks: init_parser.unsafe_blocks,
        block_statements: init_parser.block_statements,
        prints: init_parser.prints,
        asserts: init_parser.asserts,
        functions: init_parser.functions,
        shadows: init_parser.shadows,
        structs: init_parser.structs,
        struct_literals: init_parser.struct_literals,
        field_accesses: init_parser.field_accesses,
        enums: init_parser.enums,
        unions: init_parser.unions,
        union_constructs: init_parser.union_constructs,
        matches: init_parser.matches,
        imports: init_parser.imports,
        opaque_types: init_parser.opaque_types,
        tuple_literals: init_parser.tuple_literals,
        tuple_indices: init_parser.tuple_indices,
        numbers_count: 0,
        floats_count: 0,
        strings_count: 0,
        bools_count: 0,
        identifiers_count: 0,
        binary_ops_count: 0,
        calls_count: 0,
        array_literals_count: 0,
        lets_count: 0,
        sets_count: 0,
        ifs_count: 0,
        whiles_count: 0,
        fors_count: 0,
        returns_count: 0,
        blocks_count: 0,
        unsafe_blocks_count: 0,
        block_statements_count: 0,
        prints_count: 0,
        asserts_count: 0,
        functions_count: 0,
        shadows_count: 0,
        structs_count: 0,
        struct_literals_count: 0,
        field_accesses_count: 0,
        enums_count: 0,
        unions_count: 0,
        union_constructs_count: 0,
        matches_count: 0,
        imports_count: 0,
        opaque_types_count: 0,
        tuple_literals_count: 0,
        tuple_indices_count: 0,
        next_node_id: 0,
        last_expr_node_id: -1,
        last_expr_node_type: -1
    }
}

shadow parser_new {
    let empty_tokens: List<LexerToken> = (list_LexerToken_new)
    let p: Parser = (parser_new empty_tokens 0)
    assert (== p.position 0)
    assert (== p.token_count 0)
    assert (== p.next_node_id 0)
}

/* Allocate a new node ID */
fn parser_allocate_id(p: Parser) -> int {
    let id: int = p.next_node_id
    return id
}

shadow parser_allocate_id {
    let mut p: Parser = (parser_new)
    let id1: int = (parser_allocate_id p)
    let id2: int = (parser_allocate_id p)
    assert (== id1 0)
    assert (== id2 0)  /* Note: need to increment in real implementation */
}

/* Check if parser is at end of token stream */
fn parser_is_at_end(p: Parser) -> bool {
    if (>= p.position p.token_count) {
        return true
    } else {
        let tok: LexerToken = (list_LexerToken_get p.tokens p.position)
        return (== tok.token_type LexerTokenType.TOKEN_EOF)
    }
}

shadow parser_is_at_end {
    assert (== 1 1)  /* Placeholder - will test with real parser state */
}

/* Helper: Copy parser with new position */
fn parser_with_position(p: Parser, new_position: int) -> Parser {
    return Parser {
        tokens: p.tokens,
        position: new_position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: p.next_node_id,
        last_expr_node_id: p.last_expr_node_id,
        last_expr_node_type: p.last_expr_node_type
    }
}

shadow parser_with_position {
    /* Tested via integration tests in parse_program */
    assert (== 1 1)
}

/* Advance parser to next token - returns new parser with advanced position */
fn parser_advance(p: Parser) -> Parser {
    if (not (parser_is_at_end p)) {
        return (parser_with_position p (+ p.position 1))
    } else {
        return p  /* Already at end */
    }
}

shadow parser_advance {
    /* Tested via integration tests in parse_program */
    assert (== 1 1)
}

/* Get current position */
pub fn parser_position(p: Parser) -> int {
    return p.position
}

shadow parser_position {
    let empty_tokens: List<LexerToken> = (list_LexerToken_new)
    let p: Parser = (parser_new empty_tokens 0)
    assert (== (parser_position p) 0)
}

/* Get current token from token stream */
pub fn parser_current(p: Parser) -> LexerToken {
    if (parser_is_at_end p) {
        /* Return EOF token */
        return LexerToken {
            token_type: 0,  /* EOF */
            value: "",
            line: 0,
            column: 0
        }
    } else {
        return (list_LexerToken_get p.tokens p.position)
    }
}

shadow parser_current {
    /* Tested via integration tests in tokenization and parsing pipeline */
    assert (== 1 1)
}

/* Check if current token matches a specific type */
fn parser_match(p: Parser, token_type: int) -> bool {
    if (parser_is_at_end p) {
        return false
    } else {
        let tok: LexerToken = (parser_current p)
        return (== tok.token_type token_type)
    }
}

shadow parser_match {
    /* Tested via integration tests in parsing pipeline */
    assert (== 1 1)
}

/* Expect a specific token type - advance if matched, set error if not */
fn parser_expect(p: Parser, token_type: int) -> Parser {
    /* TODO: Get current token from List<LexerToken> and check type */
    /* For now, placeholder logic: */
    if (parser_match p token_type) {
        /* Token matches - advance and return */
        return (parser_advance p)
    } else {
        /* Token doesn't match - set error flag */
        return (parser_with_error p true)
    }
}

shadow parser_expect {
    /* Tested via integration tests in parsing pipeline */
    assert (== 1 1)
}

/* Peek ahead by offset without advancing */
/* Returns token type at offset, or EOF if out of bounds */
fn parser_peek(p: Parser, offset: int) -> int {
    let peek_pos: int = (+ p.position offset)
    if (>= peek_pos p.token_count) {
        return 0  /* EOF */
    } else {
        let tok: LexerToken = (list_LexerToken_get p.tokens peek_pos)
        return tok.token_type
    }
}

shadow parser_peek {
    /* Tested via integration tests in parsing pipeline */
    assert (== 1 1)
}

/* Helper: Copy parser with error flag set */
fn parser_with_error(p: Parser, error: bool) -> Parser {
    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: p.next_node_id,
        last_expr_node_id: p.last_expr_node_id,
        last_expr_node_type: p.last_expr_node_type
    }
}

shadow parser_with_error {
    /* Tested via integration tests in parse_program */
    assert (== 1 1)
}

/* Check if parser has encountered an error */
pub fn parser_has_error(p: Parser) -> bool {
    return p.has_error
}

shadow parser_has_error {
    let empty_tokens: List<LexerToken> = (list_LexerToken_new)
    let p: Parser = (parser_new empty_tokens 0)
    assert (== (parser_has_error p) false)
}

/* ========== Expression Parsing ========== */

/* Token type helper functions - match LexerTokenType (src_nano/generated/compiler_schema.nano) */
fn token_number() -> int { return LexerTokenType.TOKEN_NUMBER }
shadow token_number { assert (== (token_number) LexerTokenType.TOKEN_NUMBER) }

fn token_identifier() -> int { return LexerTokenType.TOKEN_IDENTIFIER }
shadow token_identifier { assert (== (token_identifier) LexerTokenType.TOKEN_IDENTIFIER) }

fn token_string() -> int { return LexerTokenType.TOKEN_STRING }
shadow token_string { assert (== (token_string) LexerTokenType.TOKEN_STRING) }

fn token_true() -> int { return LexerTokenType.TOKEN_TRUE }
shadow token_true { assert (== (token_true) LexerTokenType.TOKEN_TRUE) }

fn token_false() -> int { return LexerTokenType.TOKEN_FALSE }
shadow token_false { assert (== (token_false) LexerTokenType.TOKEN_FALSE) }

fn token_lparen() -> int { return LexerTokenType.TOKEN_LPAREN }
shadow token_lparen { assert (== (token_lparen) LexerTokenType.TOKEN_LPAREN) }

fn token_rparen() -> int { return LexerTokenType.TOKEN_RPAREN }
shadow token_rparen { assert (== (token_rparen) LexerTokenType.TOKEN_RPAREN) }

fn token_plus() -> int { return LexerTokenType.TOKEN_PLUS }
shadow token_plus { assert (== (token_plus) LexerTokenType.TOKEN_PLUS) }

fn token_minus() -> int { return LexerTokenType.TOKEN_MINUS }
shadow token_minus { assert (== (token_minus) LexerTokenType.TOKEN_MINUS) }

fn token_star() -> int { return LexerTokenType.TOKEN_STAR }
shadow token_star { assert (== (token_star) LexerTokenType.TOKEN_STAR) }

fn token_slash() -> int { return LexerTokenType.TOKEN_SLASH }
shadow token_slash { assert (== (token_slash) LexerTokenType.TOKEN_SLASH) }

fn token_eq() -> int { return LexerTokenType.TOKEN_EQ }
shadow token_eq { assert (== (token_eq) LexerTokenType.TOKEN_EQ) }

fn token_ne() -> int { return LexerTokenType.TOKEN_NE }
shadow token_ne { assert (== (token_ne) LexerTokenType.TOKEN_NE) }

fn token_lt() -> int { return LexerTokenType.TOKEN_LT }
shadow token_lt { assert (== (token_lt) LexerTokenType.TOKEN_LT) }

fn token_le() -> int { return LexerTokenType.TOKEN_LE }
shadow token_le { assert (== (token_le) LexerTokenType.TOKEN_LE) }

fn token_gt() -> int { return LexerTokenType.TOKEN_GT }
shadow token_gt { assert (== (token_gt) LexerTokenType.TOKEN_GT) }

fn token_ge() -> int { return LexerTokenType.TOKEN_GE }
shadow token_ge { assert (== (token_ge) LexerTokenType.TOKEN_GE) }

fn token_and() -> int { return LexerTokenType.TOKEN_AND }
shadow token_and { assert (== (token_and) LexerTokenType.TOKEN_AND) }

fn token_or() -> int { return LexerTokenType.TOKEN_OR }
shadow token_or { assert (== (token_or) LexerTokenType.TOKEN_OR) }

fn token_comma() -> int { return LexerTokenType.TOKEN_COMMA }
shadow token_comma { assert (== (token_comma) LexerTokenType.TOKEN_COMMA) }

fn token_lbrace() -> int { return LexerTokenType.TOKEN_LBRACE }
shadow token_lbrace { assert (== (token_lbrace) LexerTokenType.TOKEN_LBRACE) }

fn token_rbrace() -> int { return LexerTokenType.TOKEN_RBRACE }
shadow token_rbrace { assert (== (token_rbrace) LexerTokenType.TOKEN_RBRACE) }

fn token_let() -> int { return LexerTokenType.TOKEN_LET }
shadow token_let { assert (== (token_let) LexerTokenType.TOKEN_LET) }

fn token_if() -> int { return LexerTokenType.TOKEN_IF }
shadow token_if { assert (== (token_if) LexerTokenType.TOKEN_IF) }

fn token_else() -> int { return LexerTokenType.TOKEN_ELSE }
shadow token_else { assert (== (token_else) LexerTokenType.TOKEN_ELSE) }

fn token_while() -> int { return LexerTokenType.TOKEN_WHILE }
shadow token_while { assert (== (token_while) LexerTokenType.TOKEN_WHILE) }

fn token_return() -> int { return LexerTokenType.TOKEN_RETURN }
shadow token_return { assert (== (token_return) LexerTokenType.TOKEN_RETURN) }

fn token_colon() -> int { return LexerTokenType.TOKEN_COLON }
shadow token_colon { assert (== (token_colon) LexerTokenType.TOKEN_COLON) }

fn token_mut() -> int { return LexerTokenType.TOKEN_MUT }
shadow token_mut { assert (== (token_mut) LexerTokenType.TOKEN_MUT) }

fn token_assign() -> int { return LexerTokenType.TOKEN_ASSIGN }
shadow token_assign { assert (== (token_assign) LexerTokenType.TOKEN_ASSIGN) }

fn token_arrow() -> int { return LexerTokenType.TOKEN_ARROW }
shadow token_arrow { assert (== (token_arrow) LexerTokenType.TOKEN_ARROW) }

fn token_fn() -> int { return LexerTokenType.TOKEN_FN }
shadow token_fn { assert (== (token_fn) LexerTokenType.TOKEN_FN) }

fn token_extern() -> int { return LexerTokenType.TOKEN_EXTERN }
shadow token_extern { assert (== (token_extern) LexerTokenType.TOKEN_EXTERN) }

fn token_set() -> int { return LexerTokenType.TOKEN_SET }
shadow token_set { assert (== (token_set) LexerTokenType.TOKEN_SET) }

fn token_struct() -> int { return LexerTokenType.TOKEN_STRUCT }
shadow token_struct { assert (== (token_struct) LexerTokenType.TOKEN_STRUCT) }

fn token_enum() -> int { return LexerTokenType.TOKEN_ENUM }
shadow token_enum { assert (== (token_enum) LexerTokenType.TOKEN_ENUM) }

fn token_union() -> int { return LexerTokenType.TOKEN_UNION }
shadow token_union { assert (== (token_union) LexerTokenType.TOKEN_UNION) }

/* Additional token helper functions for full feature support */
fn token_for() -> int { return LexerTokenType.TOKEN_FOR }
shadow token_for { assert (== (token_for) LexerTokenType.TOKEN_FOR) }

fn token_in() -> int { return LexerTokenType.TOKEN_IN }
shadow token_in { assert (== (token_in) LexerTokenType.TOKEN_IN) }

fn token_assert() -> int { return LexerTokenType.TOKEN_ASSERT }
shadow token_assert { assert (== (token_assert) LexerTokenType.TOKEN_ASSERT) }

fn token_unsafe() -> int { return LexerTokenType.TOKEN_UNSAFE }
shadow token_unsafe { assert (== (token_unsafe) LexerTokenType.TOKEN_UNSAFE) }

fn token_shadow() -> int { return LexerTokenType.TOKEN_SHADOW }
shadow token_shadow { assert (== (token_shadow) LexerTokenType.TOKEN_SHADOW) }

fn token_match() -> int { return LexerTokenType.TOKEN_MATCH }
shadow token_match { assert (== (token_match) LexerTokenType.TOKEN_MATCH) }

fn token_import() -> int { return LexerTokenType.TOKEN_IMPORT }
shadow token_import { assert (== (token_import) LexerTokenType.TOKEN_IMPORT) }

fn token_as() -> int { return LexerTokenType.TOKEN_AS }
shadow token_as { assert (== (token_as) LexerTokenType.TOKEN_AS) }

fn token_pub() -> int { return LexerTokenType.TOKEN_PUB }
shadow token_pub { assert (== (token_pub) LexerTokenType.TOKEN_PUB) }

fn token_opaque() -> int { return LexerTokenType.TOKEN_OPAQUE }
shadow token_opaque { assert (== (token_opaque) LexerTokenType.TOKEN_OPAQUE) }

fn token_lbracket() -> int { return LexerTokenType.TOKEN_LBRACKET }
shadow token_lbracket { assert (== (token_lbracket) LexerTokenType.TOKEN_LBRACKET) }

fn token_rbracket() -> int { return LexerTokenType.TOKEN_RBRACKET }
shadow token_rbracket { assert (== (token_rbracket) LexerTokenType.TOKEN_RBRACKET) }

fn token_dot() -> int { return LexerTokenType.TOKEN_DOT }
shadow token_dot { assert (== (token_dot) LexerTokenType.TOKEN_DOT) }

fn token_double_colon() -> int { return LexerTokenType.TOKEN_DOUBLE_COLON }
shadow token_double_colon { assert (== (token_double_colon) LexerTokenType.TOKEN_DOUBLE_COLON) }

fn token_percent() -> int { return LexerTokenType.TOKEN_PERCENT }
shadow token_percent { assert (== (token_percent) LexerTokenType.TOKEN_PERCENT) }

fn token_not() -> int { return LexerTokenType.TOKEN_NOT }
shadow token_not { assert (== (token_not) LexerTokenType.TOKEN_NOT) }

fn token_array() -> int { return LexerTokenType.TOKEN_ARRAY }
shadow token_array { assert (== (token_array) LexerTokenType.TOKEN_ARRAY) }

fn token_type_int() -> int { return LexerTokenType.TOKEN_TYPE_INT }
shadow token_type_int { assert (== (token_type_int) LexerTokenType.TOKEN_TYPE_INT) }

fn token_type_float() -> int { return LexerTokenType.TOKEN_TYPE_FLOAT }
shadow token_type_float { assert (== (token_type_float) LexerTokenType.TOKEN_TYPE_FLOAT) }

fn token_type_bool() -> int { return LexerTokenType.TOKEN_TYPE_BOOL }
shadow token_type_bool { assert (== (token_type_bool) LexerTokenType.TOKEN_TYPE_BOOL) }

fn token_type_string() -> int { return LexerTokenType.TOKEN_TYPE_STRING }
shadow token_type_string { assert (== (token_type_string) LexerTokenType.TOKEN_TYPE_STRING) }

fn token_type_bstring() -> int { return LexerTokenType.TOKEN_TYPE_BSTRING }
shadow token_type_bstring { assert (== (token_type_bstring) LexerTokenType.TOKEN_TYPE_BSTRING) }

fn token_type_void() -> int { return LexerTokenType.TOKEN_TYPE_VOID }
shadow token_type_void { assert (== (token_type_void) LexerTokenType.TOKEN_TYPE_VOID) }

struct NameParseResult {
    p: Parser,
    name: string,
    ok: bool
}

fn parse_qualified_name(p: Parser) -> NameParseResult {
    if (parser_is_at_end p) {
        return NameParseResult { p: p, name: "", ok: false }
    } else {
        let tok: LexerToken = (parser_current p)
        if (!= tok.token_type (token_identifier)) {
            return NameParseResult { p: p, name: "", ok: false }
        } else {
            let mut name: string = tok.value
            let mut cur: Parser = (parser_advance p)

            while (not (parser_is_at_end cur)) {
                let td: LexerToken = (parser_current cur)
                if (== td.token_type (token_double_colon)) {
                    let p_dc: Parser = (parser_advance cur)
                    if (parser_is_at_end p_dc) {
                        return NameParseResult { p: p_dc, name: name, ok: false }
                    } else {
                        let tid: LexerToken = (parser_current p_dc)
                        if (!= tid.token_type (token_identifier)) {
                            return NameParseResult { p: p_dc, name: name, ok: false }
                        } else {
                            set name (str_concat name "::")
                            set name (str_concat name tid.value)
                            set cur (parser_advance p_dc)
                        }
                    }
                } else {
                    return NameParseResult { p: cur, name: name, ok: true }
                }
            }

            return NameParseResult { p: cur, name: name, ok: true }
        }
    }
}

/* Parse a call target name, allowing both namespace separators (::) and
 * module alias separators (.) in the *function position* of prefix calls.
 *
 * NOTE: This is intentionally narrower than general identifier parsing;
 * we do NOT want to consume postfix field access like `x.y` in expression
 * position.
 */
fn parse_call_name(p: Parser) -> NameParseResult {
    if (parser_is_at_end p) {
        return NameParseResult { p: p, name: "", ok: false }
    } else {
        let tok: LexerToken = (parser_current p)
        if (!= tok.token_type (token_identifier)) {
            return NameParseResult { p: p, name: "", ok: false }
        } else {
            let mut name: string = tok.value
            let mut cur: Parser = (parser_advance p)

            while (not (parser_is_at_end cur)) {
                let td: LexerToken = (parser_current cur)
                if (== td.token_type (token_double_colon)) {
                    let p_dc: Parser = (parser_advance cur)
                    if (parser_is_at_end p_dc) {
                        return NameParseResult { p: p_dc, name: name, ok: false }
                    } else {
                        let tid: LexerToken = (parser_current p_dc)
                        if (!= tid.token_type (token_identifier)) {
                            return NameParseResult { p: p_dc, name: name, ok: false }
                        } else {
                            set name (str_concat name "::")
                            set name (str_concat name tid.value)
                            set cur (parser_advance p_dc)
                        }
                    }
                } else {
                    if (== td.token_type (token_dot)) {
                        let p_dot: Parser = (parser_advance cur)
                        if (parser_is_at_end p_dot) {
                            return NameParseResult { p: p_dot, name: name, ok: false }
                        } else {
                            let tid: LexerToken = (parser_current p_dot)
                            if (!= tid.token_type (token_identifier)) {
                                /* Do not consume tuple index (t.0) or invalid call target */
                                return NameParseResult { p: cur, name: name, ok: true }
                            } else {
                                set name (str_concat name ".")
                                set name (str_concat name tid.value)
                                set cur (parser_advance p_dot)
                            }
                        }
                    } else {
                        return NameParseResult { p: cur, name: name, ok: true }
                    }
                }
            }

            return NameParseResult { p: cur, name: name, ok: true }
        }
    }
}

struct TypeParseResult {
    p: Parser,
    type_name: string,
    ok: bool
}

fn is_type_start_token_type(token_type: int) -> bool {
    return (or
        (== token_type (token_identifier))
        (or
            (== token_type (token_array))
            (or
                (== token_type (token_type_int))
                (or
                    (== token_type (token_type_float))
                    (or
                        (== token_type (token_type_bool))
                        (or
                            (== token_type (token_type_string))
                            (or
                                (== token_type (token_type_bstring))
                                (or
                                    (== token_type (token_type_void))
                                    (== token_type (token_lparen))
                                )
                            )
                        )
                    )
                )
            )
        )
    )
}

fn parse_type_string(p: Parser) -> TypeParseResult {
    if (parser_is_at_end p) {
        return TypeParseResult { p: p, type_name: "", ok: false }
    } else {
        let tok: LexerToken = (parser_current p)
        if (not (is_type_start_token_type tok.token_type)) {
            return TypeParseResult { p: p, type_name: "", ok: false }
        } else {
            let mut type_name: string = ""
            let mut cur: Parser = p

            if (== tok.token_type (token_lparen)) {
                /* Tuple type: (T1,T2,...) */
                let mut type_name: string = "("
                let mut cur: Parser = (parser_advance p)

                let arg1: TypeParseResult = (parse_type_string cur)
                if (not arg1.ok) {
                    return TypeParseResult { p: arg1.p, type_name: type_name, ok: false }
                } else {
                    set type_name (str_concat type_name arg1.type_name)
                    set cur arg1.p
                }

                while (not (parser_is_at_end cur)) {
                    let tc: LexerToken = (parser_current cur)
                    if (== tc.token_type (token_comma)) {
                        set type_name (str_concat type_name ",")
                        set cur (parser_advance cur)
                        let argn: TypeParseResult = (parse_type_string cur)
                        if (not argn.ok) {
                            return TypeParseResult { p: argn.p, type_name: type_name, ok: false }
                        } else {
                            set type_name (str_concat type_name argn.type_name)
                            set cur argn.p
                        }
                    } else {
                        if (== tc.token_type (token_rparen)) {
                            set type_name (str_concat type_name ")")
                            set cur (parser_advance cur)
                            return TypeParseResult { p: cur, type_name: type_name, ok: true }
                        } else {
                            return TypeParseResult { p: cur, type_name: type_name, ok: false }
                        }
                    }
                }

                return TypeParseResult { p: cur, type_name: type_name, ok: false }
            } else {
            if (== tok.token_type (token_identifier)) {
                let name_res: NameParseResult = (parse_qualified_name p)
                if (not name_res.ok) {
                    return TypeParseResult { p: name_res.p, type_name: "", ok: false }
                } else {
                    set type_name name_res.name
                    set cur name_res.p
                }
            } else {
                set type_name tok.value
                set cur (parser_advance p)
            }

            /* Parse optional generic args: Type<Arg1,Arg2> */
            if (not (parser_is_at_end cur)) {
                let tgen: LexerToken = (parser_current cur)
                if (== tgen.token_type (token_lt)) {
                    set type_name (str_concat type_name "<")
                    let mut cur2: Parser = (parser_advance cur)

                    let arg1: TypeParseResult = (parse_type_string cur2)
                    if (not arg1.ok) {
                        return TypeParseResult { p: arg1.p, type_name: type_name, ok: false }
                    } else {
                        set type_name (str_concat type_name arg1.type_name)
                        set cur2 arg1.p
                    }

                    while (not (parser_is_at_end cur2)) {
                        let tc: LexerToken = (parser_current cur2)
                        if (== tc.token_type (token_comma)) {
                            set type_name (str_concat type_name ",")
                            set cur2 (parser_advance cur2)
                            let argn: TypeParseResult = (parse_type_string cur2)
                            if (not argn.ok) {
                                return TypeParseResult { p: argn.p, type_name: type_name, ok: false }
                            } else {
                                set type_name (str_concat type_name argn.type_name)
                                set cur2 argn.p
                            }
                        } else {
                            /* Done with args */
                            let tg: LexerToken = tc
                            if (== tg.token_type (token_gt)) {
                                set type_name (str_concat type_name ">")
                                set cur2 (parser_advance cur2)
                                return TypeParseResult { p: cur2, type_name: type_name, ok: true }
                            } else {
                                return TypeParseResult { p: cur2, type_name: type_name, ok: false }
                            }
                        }
                    }

                    return TypeParseResult { p: cur2, type_name: type_name, ok: false }
                } else {
                    return TypeParseResult { p: cur, type_name: type_name, ok: true }
                }
            } else {
                return TypeParseResult { p: cur, type_name: type_name, ok: true }
            }
            }
        }
    }
}

/* Helper: Store number node and return node ID */
fn parser_store_number(p: Parser, value: string, line: int, column: int) -> Parser {
    let node: ASTNumber = ASTNumber {
        node_type: ParseNodeType.PNODE_NUMBER,
        line: line,
        column: column,
        value: value
    }
    let node_id: int = p.numbers_count
    (list_ASTNumber_push p.numbers node)
    
    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: (+ p.numbers_count 1),
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: 0
    }
}

shadow parser_store_number {
    /* Tested via integration tests in parse_program */
    assert (== 1 1)
}

/* Helper: Store string literal node and return node ID */
fn parser_store_string(p: Parser, value: string, line: int, column: int) -> Parser {
    let node: ASTString = ASTString {
        node_type: ParseNodeType.PNODE_STRING,
        line: line,
        column: column,
        value: value
    }
    let node_id: int = p.strings_count
    (list_ASTString_push p.strings node)

    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: (+ p.strings_count 1),
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: ParseNodeType.PNODE_STRING
    }
}

shadow parser_store_string {
    assert (== 1 1)
}

/* Helper: Store bool literal node and return node ID */
fn parser_store_bool(p: Parser, value: bool, line: int, column: int) -> Parser {
    let node: ASTBool = ASTBool {
        node_type: ParseNodeType.PNODE_BOOL,
        line: line,
        column: column,
        value: value
    }
    let node_id: int = p.bools_count
    (list_ASTBool_push p.bools node)

    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: (+ p.bools_count 1),
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: ParseNodeType.PNODE_BOOL
    }
}

shadow parser_store_bool {
    assert (== 1 1)
}

/* Helper: Store identifier node and return node ID */
fn parser_store_identifier(p: Parser, name: string, line: int, column: int) -> Parser {
    let node: ASTIdentifier = ASTIdentifier {
        node_type: ParseNodeType.PNODE_IDENTIFIER,
        line: line,
        column: column,
        name: name
    }
    let node_id: int = p.identifiers_count
    (list_ASTIdentifier_push p.identifiers node)
    
    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: (+ p.identifiers_count 1),
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: ParseNodeType.PNODE_IDENTIFIER
    }
}

shadow parser_store_identifier {
    /* Tested via integration tests in parse_program */
    assert (== 1 1)
}

/* Helper: Store binary operation node */
fn parser_store_binary_op(p: Parser, op: int, left_id: int, right_id: int, left_type: int, right_type: int, line: int, column: int) -> Parser {
    let node: ASTBinaryOp = ASTBinaryOp {
        node_type: ParseNodeType.PNODE_BINARY_OP,
        line: line,
        column: column,
        op: op,
        left: left_id,
        right: right_id,
        left_type: left_type,
        right_type: right_type
    }
    let node_id: int = p.binary_ops_count
    (list_ASTBinaryOp_push p.binary_ops node)
    
    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: (+ p.binary_ops_count 1),
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: ParseNodeType.PNODE_BINARY_OP
    }
}

shadow parser_store_binary_op {
    /* Tested via integration tests in parse_program */
    assert (== 1 1)
}

/* Helper: Store function call node */

/* Helper: Store call node */
fn parser_store_call(p: Parser, function_id: int, arg_start: int, arg_count: int, line: int, column: int) -> Parser {
    let node: ASTCall = ASTCall {
        node_type: ParseNodeType.PNODE_CALL,
        line: line,
        column: column,
        function: function_id,
        arg_start: arg_start,
        arg_count: arg_count
    }
    let node_id: int = p.calls_count
    (list_ASTCall_push p.calls node)
    
    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: (+ p.calls_count 1),
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: ParseNodeType.PNODE_CALL
    }
}
shadow parser_store_call {
    assert (== 1 1)
}

/* Helper: Store a call argument reference (expression node id + expression kind) */
fn parser_store_call_arg(p: Parser, node_id: int, node_type: int) -> Parser {
    let r: ASTStmtRef = ASTStmtRef {
        node_id: node_id,
        node_type: node_type
    }
    (list_ASTStmtRef_push p.call_args r)

    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: p.next_node_id,
        last_expr_node_id: p.last_expr_node_id,
        last_expr_node_type: p.last_expr_node_type
    }
}

shadow parser_store_call_arg {
    assert (== 1 1)
}

/* Helper: Store an array element reference (expression node id + expression kind) */
fn parser_store_array_element(p: Parser, node_id: int, node_type: int) -> Parser {
    let r: ASTStmtRef = ASTStmtRef {
        node_id: node_id,
        node_type: node_type
    }
    (list_ASTStmtRef_push p.array_elements r)

    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: p.next_node_id,
        last_expr_node_id: p.last_expr_node_id,
        last_expr_node_type: p.last_expr_node_type
    }
}

shadow parser_store_array_element {
    assert (== 1 1)
}

/* Parse union construction: UnionName.Variant{field: value} */
fn parse_union_construct(p: Parser, union_name: string, variant_name: string, start_line: int, start_column: int) -> Parser {
    /* p should be positioned after { */
    let mut field_count: int = 0
    let mut field_names: array<string> = []
    let mut field_value_ids: array<int> = []
    let mut field_value_types: array<int> = []
    let mut pcur: Parser = p

    while (not (parser_is_at_end pcur)) {
        let tok: LexerToken = (parser_current pcur)
        if (== tok.token_type (token_rbrace)) {
            let p1: Parser = (parser_advance pcur)
            return (parser_store_union_construct p1 union_name variant_name field_names field_value_ids field_value_types field_count start_line start_column)
        } else {
            if (== tok.token_type (token_identifier)) {
                let fname: string = tok.value
                let p1: Parser = (parser_advance pcur)
                let p2: Parser = (parser_expect p1 (token_colon))
                if (parser_has_error p2) {
                    return p2
                } else {
                    let p3: Parser = (parse_expression p2)
                    if (parser_has_error p3) {
                        return p3
                    } else {
                        set field_names (array_push field_names fname)
                        set field_value_ids (array_push field_value_ids p3.last_expr_node_id)
                        set field_value_types (array_push field_value_types p3.last_expr_node_type)
                        set field_count (+ field_count 1)
                        set pcur p3

                        if (parser_is_at_end pcur) {
                            return (parser_with_error pcur true)
                        } else {
                            let tnext: LexerToken = (parser_current pcur)
                            if (== tnext.token_type (token_comma)) {
                                set pcur (parser_advance pcur)
                            } else {
                                (print "")
                            }
                        }
                    }
                }
            } else {
                return (parser_with_error pcur true)
            }
        }
    }

    return (parser_with_error pcur true)
}

/* Parse struct literal: StructName{field1: val1, field2: val2} */
fn parse_struct_literal(p: Parser, struct_name: string, start_line: int, start_column: int) -> Parser {
    /* p should be positioned after the { */
    let mut field_count: int = 0
    let mut field_names: array<string> = []
    let mut field_value_ids: array<int> = []
    let mut field_value_types: array<int> = []
    let mut pcur: Parser = p
    
    /* Parse fields */
    while (not (parser_is_at_end pcur)) {
        let tcur: LexerToken = (parser_current pcur)
        if (== tcur.token_type (token_rbrace)) {
            /* End of struct literal */
            let p_final: Parser = (parser_advance pcur)
            return (parser_store_struct_literal p_final struct_name field_names field_value_ids field_value_types field_count start_line start_column)
        } else {
            /* Expect field name */
            if (== tcur.token_type (token_identifier)) {
                let fname: string = tcur.value
                let p1: Parser = (parser_advance pcur)  /* consume field name */
                
                /* Expect colon */
                if (parser_is_at_end p1) {
                    return (parser_with_error p1 true)
                } else {
                    let t2: LexerToken = (parser_current p1)
                    if (== t2.token_type (token_colon)) {
                        let p2: Parser = (parser_advance p1)  /* consume colon */
                        
                        /* Parse field value expression */
                        let p3: Parser = (parse_expression p2)
                        if (parser_has_error p3) {
                            return p3
                        } else {
                            set field_names (array_push field_names fname)
                            set field_value_ids (array_push field_value_ids p3.last_expr_node_id)
                            set field_value_types (array_push field_value_types p3.last_expr_node_type)
                            set field_count (+ field_count 1)
                            set pcur p3
                            
                            /* Check for comma or rbrace */
                            let tnext: LexerToken = (parser_current pcur)
                            if (== tnext.token_type (token_comma)) {
                                set pcur (parser_advance pcur)
                            } else {
                                if (== tnext.token_type (token_rbrace)) {
                                    let p_final: Parser = (parser_advance pcur)
                                    return (parser_store_struct_literal p_final struct_name field_names field_value_ids field_value_types field_count start_line start_column)
                                } else {
                                    return (parser_with_error pcur true)
                                }
                            }
                        }
                    } else {
                        return (parser_with_error p1 true)
                    }
                }
            } else {
                return (parser_with_error pcur true)
            }
        }
    }
    return (parser_with_error pcur true)
}

/* Parse match expression: match expr { pattern => body, ... } */
fn parse_match(p: Parser) -> Parser {
    let tok: LexerToken = (parser_current p)
    let p1: Parser = (parser_advance p)  /* consume 'match' */
    
    /* Parse matched expression */
    let p2: Parser = (parse_expression p1)
    if (parser_has_error p2) {
        return p2
    } else {
        let scrutinee_id: int = p2.last_expr_node_id
        let scrutinee_type: int = p2.last_expr_node_type

        /* Expect lbrace */
        if (parser_is_at_end p2) {
            return (parser_with_error p2 true)
        } else {
            let tok3: LexerToken = (parser_current p2)
            if (!= tok3.token_type (token_lbrace)) {
                return (parser_with_error p2 true)
            } else {
                let mut pcur: Parser = (parser_advance p2)  /* consume { */
                let mut arm_variants: array<string> = []
                let mut arm_bindings: array<string> = []
                let mut arm_body_ids: array<int> = []
                let mut arm_body_types: array<int> = []
                let mut arm_count: int = 0

                while (not (parser_is_at_end pcur)) {
                    let tcur: LexerToken = (parser_current pcur)
                    if (== tcur.token_type (token_rbrace)) {
                        let p_end: Parser = (parser_advance pcur)
                        return (parser_store_match p_end scrutinee_id scrutinee_type arm_variants arm_bindings arm_body_ids arm_body_types arm_count tok.line tok.column)
                    } else {
                        if (!= tcur.token_type (token_identifier)) {
                            return (parser_with_error pcur true)
                        } else {
                            let variant_name: string = tcur.value
                            let p1a: Parser = (parser_advance pcur)
                            let p1b: Parser = (parser_expect p1a (token_lparen))
                            if (parser_has_error p1b) { return p1b } else {
                                if (parser_is_at_end p1b) { return (parser_with_error p1b true) } else {
                                    let tbind: LexerToken = (parser_current p1b)
                                    if (!= tbind.token_type (token_identifier)) {
                                        return (parser_with_error p1b true)
                                    } else {
                                        let binding_name: string = tbind.value
                                        let p1c: Parser = (parser_advance p1b)
                                        let p1d: Parser = (parser_expect p1c (token_rparen))
                                        if (parser_has_error p1d) { return p1d } else {
                                            let p1e: Parser = (parser_expect p1d (token_arrow))
                                            if (parser_has_error p1e) { return p1e } else {
                                                /* Arm body: block (preferred) or expression */
                                                if (parser_is_at_end p1e) {
                                                    return (parser_with_error p1e true)
                                                } else {
                                                    let tbody: LexerToken = (parser_current p1e)
                                                    if (== tbody.token_type (token_lbrace)) {
                                                        let pbody: Parser = (parse_block p1e)
                                                        if (parser_has_error pbody) {
                                                            return pbody
                                                        } else {
                                                            set arm_variants (array_push arm_variants variant_name)
                                                            set arm_bindings (array_push arm_bindings binding_name)
                                                            set arm_body_ids (array_push arm_body_ids pbody.last_expr_node_id)
                                                            set arm_body_types (array_push arm_body_types ParseNodeType.PNODE_BLOCK)
                                                            set arm_count (+ arm_count 1)
                                                            set pcur pbody

                                                            /* Optional comma between arms */
                                                            if (not (parser_is_at_end pcur)) {
                                                                let tnext: LexerToken = (parser_current pcur)
                                                                if (== tnext.token_type (token_comma)) {
                                                                    set pcur (parser_advance pcur)
                                                                } else { (print "") }
                                                            } else { (print "") }
                                                        }
                                                    } else {
                                                        let pexpr: Parser = (parse_expression p1e)
                                                        if (parser_has_error pexpr) {
                                                            return pexpr
                                                        } else {
                                                            set arm_variants (array_push arm_variants variant_name)
                                                            set arm_bindings (array_push arm_bindings binding_name)
                                                            set arm_body_ids (array_push arm_body_ids pexpr.last_expr_node_id)
                                                            set arm_body_types (array_push arm_body_types pexpr.last_expr_node_type)
                                                            set arm_count (+ arm_count 1)
                                                            set pcur pexpr

                                                            /* Optional comma between arms */
                                                            if (not (parser_is_at_end pcur)) {
                                                                let tnext: LexerToken = (parser_current pcur)
                                                                if (== tnext.token_type (token_comma)) {
                                                                    set pcur (parser_advance pcur)
                                                                } else { (print "") }
                                                            } else { (print "") }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                return (parser_with_error pcur true)
            }
        }
    }
}

/* Parse primary expression: number, identifier, string, bool, or parenthesized */
fn parse_primary(p: Parser) -> Parser {
    if (parser_is_at_end p) {
        return (parser_with_error p true)
    } else {
        let tok: LexerToken = (parser_current p)
        
        /* match expression */
        if (== tok.token_type (token_match)) {
            return (parse_match p)
        } else {
            (print "")
        }

        /* Array literals */
        if (== tok.token_type (token_lbracket)) {
            let p1: Parser = (parser_advance p)  /* consume '[' */
            let element_start: int = (list_ASTStmtRef_length p1.array_elements)
            let mut element_count: int = 0
            let mut pcur: Parser = p1
            
            /* Parse array elements */
            while (not (parser_is_at_end pcur)) {
                let tcur: LexerToken = (parser_current pcur)
                if (== tcur.token_type (token_rbracket)) {
                    /* End of array */
                    let p2: Parser = (parser_advance pcur)
                    return (parser_store_array_literal p2 element_start element_count "" tok.line tok.column)
                } else {
                    /* Parse element expression */
                    let pelem: Parser = (parse_expression pcur)
                    if (parser_has_error pelem) {
                        return pelem
                    } else {
                        let elem_id: int = pelem.last_expr_node_id
                        let elem_type: int = pelem.last_expr_node_type
                        let p_elem: Parser = (parser_store_array_element pelem elem_id elem_type)
                        set element_count (+ element_count 1)
                        set pcur p_elem
                        
                        /* Check for comma */
                        let tnext: LexerToken = (parser_current pcur)
                        if (== tnext.token_type (token_comma)) {
                            set pcur (parser_advance pcur)
                        } else {
                            /* No comma, should be end bracket */
                            if (== tnext.token_type (token_rbracket)) {
                                let p2: Parser = (parser_advance pcur)
                                return (parser_store_array_literal p2 element_start element_count "" tok.line tok.column)
                            } else {
                                return (parser_with_error pcur true)
                            }
                        }
                    }
                }
            }
            return (parser_with_error pcur true)
        } else {
            if (== tok.token_type (token_number)) {
            /* Check for float (contains decimal point) - simplified check */
            /* For MVP: treat all as numbers, floats need string contains "." */
            let p1: Parser = (parser_store_number p tok.value tok.line tok.column)
            return (parser_advance p1)
        } else {
            /* String literal */
            if (== tok.token_type (token_string)) {
                let p1: Parser = (parser_store_string p tok.value tok.line tok.column)
                return (parser_advance p1)
            } else {
                /* Bool literals */
                if (or (== tok.token_type (token_true)) (== tok.token_type (token_false))) {
                    let is_true: bool = (== tok.token_type (token_true))
                    let p1: Parser = (parser_store_bool p is_true tok.line tok.column)
                    return (parser_advance p1)
                } else {
                    /* Identifier (possibly qualified) or struct literal */
                    if (== tok.token_type (token_identifier)) {
                        let name_res: NameParseResult = (parse_qualified_name p)
                        if (not name_res.ok) {
                            return (parser_with_error name_res.p true)
                        } else {
                            let name: string = name_res.name
                            let p_after_name: Parser = name_res.p

                            if (not (parser_is_at_end p_after_name)) {
                                let tnext: LexerToken = (parser_current p_after_name)
                                if (== tnext.token_type (token_lbrace)) {
                                    /* Struct literal: Type { field: value, ... } */
                                    let p_lbrace: Parser = (parser_advance p_after_name) /* consume '{' */
                                    return (parse_struct_literal p_lbrace name tok.line tok.column)
                                } else {
                                    (print "")
                                }
                            } else {
                                (print "")
                            }

                            let p1: Parser = (parser_store_identifier p_after_name name tok.line tok.column)
                            return p1
                        }
                    } else {
                        /* Parenthesized expression or function/binary-op call */
                        if (== tok.token_type (token_lparen)) {
                            let p1: Parser = (parser_advance p)  /* consume '(' */

                            if (parser_is_at_end p1) {
                                return (parser_with_error p1 true)
                            } else {
                                let tok2: LexerToken = (parser_current p1)

                                /* Prefix binary operator call: (+ a b), (== a b), (and a b) */
                                if (is_binary_op tok2.token_type) {
                                    let op_type: int = tok2.token_type
                                    let p_op: Parser = (parser_advance p1)

                                    let p_left: Parser = (parse_expression p_op)
                                    if (parser_has_error p_left) {
                                        return p_left
                                    } else {
                                        let left_id: int = p_left.last_expr_node_id
                                        let left_type: int = p_left.last_expr_node_type

                                        let p_right: Parser = (parse_expression p_left)
                                        if (parser_has_error p_right) {
                                            return p_right
                                        } else {
                                            let right_id: int = p_right.last_expr_node_id
                                            let right_type: int = p_right.last_expr_node_type

                                            let p_bin: Parser = (parser_store_binary_op p_right op_type left_id right_id left_type right_type tok.line tok.column)
                                            return (parser_expect p_bin (token_rparen))
                                        }
                                    }
                                } else {
                                    /* Unary call: (not expr) */
                                    if (== tok2.token_type (token_not)) {
                                        let p_op: Parser = (parser_advance p1)
                                        let p_id: Parser = (parser_store_identifier p_op tok2.value tok2.line tok2.column)
                                        let func_id: int = p_id.last_expr_node_id
                                        let arg_start: int = (list_ASTStmtRef_length p_id.call_args)
                                        let p_arg: Parser = (parse_expression p_id)
                                        if (parser_has_error p_arg) {
                                            return p_arg
                                        } else {
                                            let arg_id: int = p_arg.last_expr_node_id
                                            let arg_type: int = p_arg.last_expr_node_type
                                            let p_arg2: Parser = (parser_store_call_arg p_arg arg_id arg_type)
                                            let p_end: Parser = (parser_expect p_arg2 (token_rparen))
                                            if (parser_has_error p_end) {
                                                return p_end
                                            } else {
                                                return (parser_store_call p_end func_id arg_start 1 tok.line tok.column)
                                            }
                                        }
                                    } else {
                                        /* If identifier, it's a function call: (funcname args...) */
                                        if (== tok2.token_type (token_identifier)) {
                                            let name_res: NameParseResult = (parse_call_name p1)
                                            if (not name_res.ok) {
                                                return (parser_with_error name_res.p true)
                                            } else {
                                                let func_name: string = name_res.name
                                                let p_after_name: Parser = name_res.p
                                                let p2: Parser = (parser_store_identifier p_after_name func_name tok2.line tok2.column)
                                                let func_id: int = p2.last_expr_node_id
                                                let arg_start: int = (list_ASTStmtRef_length p2.call_args)

                                                /* Parse arguments until ')' */
                                                let mut arg_count: int = 0
                                                let mut pcur: Parser = p2
                                                while (and (not (parser_is_at_end pcur)) (not (parser_has_error pcur))) {
                                                    let tcur: LexerToken = (parser_current pcur)
                                                    if (== tcur.token_type (token_rparen)) {
                                                        let p4: Parser = (parser_advance pcur)
                                                        return (parser_store_call p4 func_id arg_start arg_count tok.line tok.column)
                                                    } else {
                                                        let parg: Parser = (parse_expression pcur)
                                                        if (parser_has_error parg) {
                                                            return parg
                                                        } else {
                                                            let arg_id: int = parg.last_expr_node_id
                                                            let arg_type: int = parg.last_expr_node_type
                                                            let pcur2: Parser = (parser_store_call_arg parg arg_id arg_type)
                                                            set arg_count (+ arg_count 1)
                                                            set pcur pcur2
                                                        }
                                                    }
                                                }
                                                return (parser_with_error pcur true)
                                            }
                                        } else {
                                            /* Regular parenthesized expression OR tuple literal */
                                            let p2: Parser = (parse_expression p1)
                                            if (parser_has_error p2) {
                                                return p2
                                            } else {
                                                /* Check for tuple (comma) vs paren expression (rparen) */
                                                let tok_after: LexerToken = (parser_current p2)
                                                if (== tok_after.token_type (token_comma)) {
                                                    /* Tuple literal: (expr, expr, ...) */
                                                    let mut elem_ids: array<int> = []
                                                    let mut elem_types: array<int> = []
                                                    let mut elem_count: int = 1
                                                    set elem_ids (array_push elem_ids p2.last_expr_node_id)
                                                    set elem_types (array_push elem_types p2.last_expr_node_type)
                                                    let mut ptup: Parser = (parser_advance p2) /* consume ',' */

                                                    while (not (parser_is_at_end ptup)) {
                                                        let ttup: LexerToken = (parser_current ptup)
                                                        if (== ttup.token_type (token_rparen)) {
                                                            let p_end: Parser = (parser_advance ptup)
                                                            return (parser_store_tuple_literal p_end elem_ids elem_types elem_count tok.line tok.column)
                                                        } else {
                                                            let pelem: Parser = (parse_expression ptup)
                                                            if (parser_has_error pelem) {
                                                                return pelem
                                                            } else {
                                                                set elem_ids (array_push elem_ids pelem.last_expr_node_id)
                                                                set elem_types (array_push elem_types pelem.last_expr_node_type)
                                                                set elem_count (+ elem_count 1)
                                                                set ptup pelem

                                                                let tnext: LexerToken = (parser_current ptup)
                                                                if (== tnext.token_type (token_comma)) {
                                                                    set ptup (parser_advance ptup)
                                                                } else {
                                                                    if (== tnext.token_type (token_rparen)) {
                                                                        let p_end: Parser = (parser_advance ptup)
                                                                        return (parser_store_tuple_literal p_end elem_ids elem_types elem_count tok.line tok.column)
                                                                    } else {
                                                                        return (parser_with_error ptup true)
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }

                                                    return (parser_with_error ptup true)
                                                } else {
                                                    /* Regular parenthesized expression */
                                                    let p3: Parser = (parser_expect p2 (token_rparen))
                                                    return p3
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            /* Error: unexpected token */
                            return (parser_with_error p true)
                        }
                    }
                }
            }
        }
        }
    }
}

shadow parse_primary {
    /* Tested via integration tests in tokenization and parsing pipeline */
    assert (== 1 1)
}

/* Helper: Check if token is a binary operator */
fn is_binary_op(token_type: int) -> bool {
    return (or (or (or (== token_type (token_plus)) (== token_type (token_minus))) 
                   (or (or (== token_type (token_star)) (== token_type (token_slash))) (== token_type (token_percent))))
               (or (or (== token_type (token_eq)) (== token_type (token_ne)))
                   (or (or (== token_type (token_lt)) (== token_type (token_le)))
                       (or (or (== token_type (token_gt)) (== token_type (token_ge)))
                           (or (== token_type (token_and)) (== token_type (token_or)))))))
}

shadow is_binary_op {
    assert (== (is_binary_op (token_plus)) true)
    assert (== (is_binary_op (token_eq)) true)
    assert (== (is_binary_op (token_number)) false)
}

/* Parse expression with binary operations (left-associative) */
/* Simple version: primary (op primary)* */
/* Uses recursive helper for functional style */
fn parse_expression_recursive(p: Parser, left_parsed: bool) -> Parser {
    if (parser_has_error p) {
        return p
    } else {
        if (parser_is_at_end p) {
            return p
        } else {
            let tok: LexerToken = (parser_current p)
            
            if (is_binary_op tok.token_type) {
                /* Found binary operator - need left side already parsed */
                if (not left_parsed) {
                    /* Parse left side first */
                    let p1: Parser = (parse_primary p)
                    return (parse_expression_recursive p1 true)
                } else {
                    /* Left side already parsed - save its node ID and type */
                    let left_id: int = p.last_expr_node_id
                    let left_type: int = p.last_expr_node_type
                    let op_type: int = tok.token_type
                    let p1: Parser = (parser_advance p)  /* consume operator */
                    
                    /* Parse right side */
                    let p2: Parser = (parse_primary p1)
                    
                    if (parser_has_error p2) {
                        return p2
                    } else {
                        /* Right side parsed - save its node ID and type */
                        let right_id: int = p2.last_expr_node_id
                        let right_type: int = p2.last_expr_node_type
                        
                        /* Store binary op node */
                        let p3: Parser = (parser_store_binary_op p2 op_type left_id right_id left_type right_type tok.line tok.column)
                        
                        /* Continue parsing more binary operations */
                        return (parse_expression_recursive p3 true)
                    }
                }
            } else {
                /* No more binary operators */
                if left_parsed {
                    return p
                } else {
                    /* Parse left side first */
                    let p1: Parser = (parse_primary p)
                    
                    /* Handle postfix operators: field access */
                    let mut p_postfix: Parser = p1
                    let mut done: bool = false
                    
                    while (not done) {
                        if (parser_is_at_end p_postfix) {
                            set done true
                        } else {
                            let tok_post: LexerToken = (parser_current p_postfix)
                            
                            if (== tok_post.token_type (token_dot)) {
                                /* Field access: obj.field */
                                let p_dot: Parser = (parser_advance p_postfix)
                                
                                if (parser_is_at_end p_dot) {
                                    set done true
                                } else {
                                    let tok_field: LexerToken = (parser_current p_dot)
                                    
                                    if (== tok_field.token_type (token_number)) {
                                        /* Tuple index: t.0 */
                                        let idx: int = (string_to_int tok_field.value)
                                        let p_idx: Parser = (parser_advance p_dot)
                                        let obj_id: int = p_postfix.last_expr_node_id
                                        let obj_type: int = p_postfix.last_expr_node_type
                                        set p_postfix (parser_store_tuple_index p_idx obj_id obj_type idx tok_post.line tok_post.column)
                                    } else {
                                    if (== tok_field.token_type (token_identifier)) {
                                        let field_name: string = tok_field.value
                                        let p_field: Parser = (parser_advance p_dot)
                                        
                                        /* Check for union construction: Type.Variant{...} */
                                        if (not (parser_is_at_end p_field)) {
                                            let tok_brace: LexerToken = (parser_current p_field)
                                            if (== tok_brace.token_type (token_lbrace)) {
                                                /* Union construction with fields */
                                                let obj_id: int = p_postfix.last_expr_node_id
                                                let obj_type: int = p_postfix.last_expr_node_type
                                                if (!= obj_type 1) {
                                                    return (parser_with_error p_postfix true)
                                                } else {
                                                    let obj_ident: ASTIdentifier = (parser_get_identifier p_postfix obj_id)
                                                    let union_name: string = obj_ident.name
                                                    let p_lbrace: Parser = (parser_advance p_field) /* consume '{' */
                                                    let p_uc: Parser = (parse_union_construct p_lbrace union_name field_name tok_post.line tok_post.column)
                                                    if (parser_has_error p_uc) {
                                                        return p_uc
                                                    } else {
                                                        set p_postfix p_uc
                                                    }
                                                }
                                            } else {
                                                /* Regular field access */
                                                let obj_id: int = p_postfix.last_expr_node_id
                                                let obj_type: int = p_postfix.last_expr_node_type
                                                set p_postfix (parser_store_field_access p_field obj_id obj_type field_name tok_post.line tok_post.column)
                                            }
                                        } else {
                                            /* Regular field access (end of file) */
                                            let obj_id: int = p_postfix.last_expr_node_id
                                            let obj_type: int = p_postfix.last_expr_node_type
                                            set p_postfix (parser_store_field_access p_field obj_id obj_type field_name tok_post.line tok_post.column)
                                        }
                                    } else {
                                        set done true
                                    }
                                    }
                                }
                            } else {
                                set done true
                            }
                        }
                    }
                    
                    return (parse_expression_recursive p_postfix true)
                }
            }
        }
    }
}

fn parse_expression(p: Parser) -> Parser {
    return (parse_expression_recursive p false)
}

shadow parse_expression_recursive {
    /* Tested via integration tests in tokenization and parsing pipeline */
    assert (== 1 1)
}

shadow parse_expression {
    /* Tested via integration tests in tokenization and parsing pipeline */
    assert (== 1 1)
}

/* ========== Statement Parsing ========== */

/* Helper: Store let statement node */

/* Helper: Store let node */
fn parser_store_let(p: Parser, name: string, var_type: string, value_id: int, value_type: int, is_mut: bool, line: int, column: int) -> Parser {
    let node: ASTLet = ASTLet {
        node_type: ParseNodeType.PNODE_LET,
        line: line,
        column: column,
        name: name,
        var_type: var_type,
        value: value_id,
        value_type: value_type,
        is_mut: is_mut
    }
    let node_id: int = p.lets_count
    (list_ASTLet_push p.lets node)
    
    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: (+ p.lets_count 1),
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: ParseNodeType.PNODE_LET
    }
}
shadow parser_store_let {
    assert (== 1 1)
}

/* Helper: Store set statement node */

/* Helper: Store set node */
fn parser_store_set(p: Parser, target: string, value_id: int, value_type: int, line: int, column: int) -> Parser {
    let node: ASTSet = ASTSet {
        node_type: ParseNodeType.PNODE_SET,
        line: line,
        column: column,
        target: target,
        value: value_id,
        value_type: value_type
    }
    let node_id: int = p.sets_count
    (list_ASTSet_push p.sets node)
    
    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: (+ p.sets_count 1),
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: ParseNodeType.PNODE_SET
    }
}
shadow parser_store_set {
    assert (== 1 1)
}

/* Helper: Store if statement node */

/* Helper: Store if node */
fn parser_store_if(p: Parser, condition_id: int, condition_type: int, then_body_id: int, else_body_id: int, line: int, column: int) -> Parser {
    let node: ASTIf = ASTIf {
        node_type: ParseNodeType.PNODE_IF,
        line: line,
        column: column,
        condition: condition_id,
        condition_type: condition_type,
        then_body: then_body_id,
        else_body: else_body_id
    }
    let node_id: int = p.ifs_count
    (list_ASTIf_push p.ifs node)
    
    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: (+ p.ifs_count 1),
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: ParseNodeType.PNODE_IF
    }
}
shadow parser_store_if {
    assert (== 1 1)
}

/* Helper: Store while statement node */

/* Helper: Store while node */
fn parser_store_while(p: Parser, condition_id: int, condition_type: int, body_id: int, line: int, column: int) -> Parser {
    let node: ASTWhile = ASTWhile {
        node_type: ParseNodeType.PNODE_WHILE,
        line: line,
        column: column,
        condition: condition_id,
        condition_type: condition_type,
        body: body_id
    }
    let node_id: int = p.whiles_count
    (list_ASTWhile_push p.whiles node)
    
    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: (+ p.whiles_count 1),
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: ParseNodeType.PNODE_WHILE
    }
}
shadow parser_store_while {
    assert (== 1 1)
}

/* Helper: Store for loop node */
fn parser_store_for(p: Parser, var_name: string, iterable_id: int, iterable_type: int, body_id: int, line: int, column: int) -> Parser {
    let node: ASTFor = ASTFor {
        node_type: ParseNodeType.PNODE_FOR,
        line: line,
        column: column,
        var_name: var_name,
        iterable: iterable_id,
        iterable_type: iterable_type,
        body: body_id
    }
    let node_id: int = p.fors_count
    (list_ASTFor_push p.fors node)
    
    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: (+ p.fors_count 1),
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: ParseNodeType.PNODE_FOR
    }
}

/* Helper: Store array literal node */
fn parser_store_array_literal(p: Parser, element_start: int, element_count: int, element_type: string, line: int, column: int) -> Parser {
    let node: ASTArrayLiteral = ASTArrayLiteral {
        node_type: ParseNodeType.PNODE_ARRAY_LITERAL,
        line: line,
        column: column,
        element_type: element_type,
        element_start: element_start,
        element_count: element_count
    }
    let node_id: int = p.array_literals_count
    (list_ASTArrayLiteral_push p.array_literals node)
    
    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: ParseNodeType.PNODE_ARRAY_LITERAL
    }
}

/* Helper: Store import node */
fn parser_store_import(p: Parser, module_path: string, module_name: string, line: int, column: int) -> Parser {
    let node: ASTImport = ASTImport {
        node_type: ParseNodeType.PNODE_IMPORT,
        line: line,
        column: column,
        module_path: module_path,
        module_name: module_name
    }
    let node_id: int = p.imports_count
    (list_ASTImport_push p.imports node)
    
    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: (+ p.imports_count 1),
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: -1
    }
}

/* Helper: Store opaque type node */
fn parser_store_opaque_type(p: Parser, type_name: string, line: int, column: int) -> Parser {
    let node: ASTOpaqueType = ASTOpaqueType {
        node_type: ParseNodeType.PNODE_OPAQUE_TYPE,
        line: line,
        column: column,
        type_name: type_name
    }
    let node_id: int = p.opaque_types_count
    (list_ASTOpaqueType_push p.opaque_types node)
    
    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: (+ p.opaque_types_count 1),
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: -1
    }
}

/* Helper: Store shadow test node */
fn parser_store_shadow(p: Parser, target_name: string, body_id: int, line: int, column: int) -> Parser {
    let node: ASTShadow = ASTShadow {
        node_type: ParseNodeType.PNODE_SHADOW,
        line: line,
        column: column,
        target_name: target_name,
        body: body_id
    }
    let node_id: int = p.shadows_count
    (list_ASTShadow_push p.shadows node)
    
    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: (+ p.shadows_count 1),
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: -1
    }
}

/* Helper: Store field access node */
fn parser_store_field_access(p: Parser, object_id: int, object_type: int, field_name: string, line: int, column: int) -> Parser {
    let node: ASTFieldAccess = ASTFieldAccess {
        node_type: ParseNodeType.PNODE_FIELD_ACCESS,
        line: line,
        column: column,
        object: object_id,
        object_type: object_type,
        field_name: field_name
    }
    let node_id: int = p.field_accesses_count
    (list_ASTFieldAccess_push p.field_accesses node)
    
    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: (+ p.field_accesses_count 1),
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: 7
    }
}

/* Helper: Store float node */
fn parser_store_float(p: Parser, value: string, line: int, column: int) -> Parser {
    let node: ASTFloat = ASTFloat {
        node_type: ParseNodeType.PNODE_FLOAT,
        line: line,
        column: column,
        value: value
    }
    let node_id: int = p.floats_count
    (list_ASTFloat_push p.floats node)
    
    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: 6
    }
}


/* Generated 7 parser_store functions */


/* Helper: Store return statement node */

/* Helper: Store return node */
fn parser_store_return(p: Parser, value_id: int, value_type: int, line: int, column: int) -> Parser {
    let node: ASTReturn = ASTReturn {
        node_type: ParseNodeType.PNODE_RETURN,
        line: line,
        column: column,
        value: value_id,
        value_type: value_type
    }
    let node_id: int = p.returns_count
    (list_ASTReturn_push p.returns node)
    
    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: (+ p.returns_count 1),
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: ParseNodeType.PNODE_RETURN
    }
}
shadow parser_store_return {
    assert (== 1 1)
}

/* Helper: Store assert statement node */
fn parser_store_assert(p: Parser, condition_id: int, condition_type: int, line: int, column: int) -> Parser {
    let node: ASTAssert = ASTAssert {
        node_type: ParseNodeType.PNODE_ASSERT,
        line: line,
        column: column,
        condition: condition_id,
        condition_type: condition_type
    }
    let node_id: int = p.asserts_count
    (list_ASTAssert_push p.asserts node)

    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: (+ p.asserts_count 1),
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: ParseNodeType.PNODE_ASSERT
    }
}

shadow parser_store_assert {
    assert (== 1 1)
}

/* Helper: Store a statement reference for the current block */
fn parser_store_block_statement(p: Parser, node_id: int, node_type: int) -> Parser {
    let r: ASTStmtRef = ASTStmtRef {
        node_id: node_id,
        node_type: node_type
    }
    (list_ASTStmtRef_push p.block_statements r)

    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: (+ p.block_statements_count 1),
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: p.next_node_id,
        last_expr_node_id: p.last_expr_node_id,
        last_expr_node_type: p.last_expr_node_type
    }
}

shadow parser_store_block_statement {
    assert (== 1 1)
}

/* Helper: Store block node */
fn parser_store_block(p: Parser, statement_start: int, statement_count: int, line: int, column: int) -> Parser {
    let node: ASTBlock = ASTBlock {
        node_type: ParseNodeType.PNODE_BLOCK,
        line: line,
        column: column,
        statement_start: statement_start,
        statement_count: statement_count
    }
    let node_id: int = p.blocks_count
    (list_ASTBlock_push p.blocks node)
    
    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: (+ p.blocks_count 1),
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: -1
    }
}
shadow parser_store_block {
    assert (== 1 1)
}

/* Parse block: { statements } */
/* Uses recursive helper for functional style */
fn expr_kind_to_pnode(kind: int) -> int {
    if (== kind 0) { return ParseNodeType.PNODE_NUMBER }
    else { if (== kind 1) { return ParseNodeType.PNODE_IDENTIFIER }
    else { if (== kind 2) { return ParseNodeType.PNODE_BINARY_OP }
    else { if (== kind 3) { return ParseNodeType.PNODE_CALL }
    else { if (== kind 4) { return ParseNodeType.PNODE_STRING }
    else { if (== kind 5) { return ParseNodeType.PNODE_BOOL }
    else { if (== kind 6) { return ParseNodeType.PNODE_FLOAT }
    else { return kind } } } } } } }
}

fn parse_block_recursive(p: Parser, statement_start: int, statement_count: int, start_line: int, start_column: int) -> Parser {
    if (parser_has_error p) {
        return p
    } else {
        if (parser_is_at_end p) {
            return (parser_with_error p true)
        } else {
            let tok: LexerToken = (parser_current p)
            
            if (== tok.token_type (token_rbrace)) {
                /* End of block */
                let p1: Parser = (parser_advance p)  /* consume '}' */
                return (parser_store_block p1 statement_start statement_count start_line start_column)
            } else {
                /* Parse statement */
                let p2: Parser = (parse_statement p)
                if (parser_has_error p2) {
                    return p2
                } else {
                    let stmt_id: int = p2.last_expr_node_id
                    let stmt_type: int = p2.last_expr_node_type

                    /* last_expr_node_type is already a ParseNodeType value, no conversion needed */

                    let p3: Parser = (parser_store_block_statement p2 stmt_id stmt_type)
                    /* Continue parsing more statements */
                    return (parse_block_recursive p3 statement_start (+ statement_count 1) start_line start_column)
                }
            }
        }
    }
}

fn parse_block(p: Parser) -> Parser {
    if (parser_is_at_end p) {
        return (parser_with_error p true)
    } else {
        let tok: LexerToken = (parser_current p)
        
        if (== tok.token_type (token_lbrace)) {
            let p1: Parser = (parser_advance p)  /* consume '{' */
            let start: int = p1.block_statements_count
            return (parse_block_recursive p1 start 0 tok.line tok.column)
        } else {
            return (parser_with_error p true)
        }
    }
}

shadow parse_block_recursive {
    assert (== 1 1)
}

shadow parse_block {
    assert (== 1 1)
}

/* Helper: Store unsafe block node */
fn parser_store_unsafe_block(p: Parser, statement_start: int, statement_count: int, line: int, column: int) -> Parser {
    let node: ASTUnsafeBlock = ASTUnsafeBlock {
        node_type: ParseNodeType.PNODE_UNSAFE_BLOCK,
        line: line,
        column: column,
        statement_start: statement_start,
        statement_count: statement_count
    }
    let node_id: int = p.unsafe_blocks_count
    (list_ASTUnsafeBlock_push p.unsafe_blocks node)
    
    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: (+ p.unsafe_blocks_count 1),
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: -1
    }
}
shadow parser_store_unsafe_block {
    assert (== 1 1)
}

/* Parse unsafe block recursively: unsafe { statements } */
fn parse_unsafe_block_recursive(p: Parser, statement_start: int, statement_count: int, start_line: int, start_column: int) -> Parser {
    if (parser_has_error p) {
        return p
    } else {
        if (parser_is_at_end p) {
            return (parser_with_error p true)
        } else {
            let tok: LexerToken = (parser_current p)
            
            if (== tok.token_type (token_rbrace)) {
                /* End of unsafe block */
                let p1: Parser = (parser_advance p)  /* consume '}' */
                return (parser_store_unsafe_block p1 statement_start statement_count start_line start_column)
            } else {
                /* Parse statement */
                let p2: Parser = (parse_statement p)
                if (parser_has_error p2) {
                    return p2
                } else {
                    let stmt_id: int = p2.last_expr_node_id
                    let stmt_type: int = p2.last_expr_node_type
                    let p3: Parser = (parser_store_block_statement p2 stmt_id stmt_type)
                    /* Continue parsing more statements */
                    return (parse_unsafe_block_recursive p3 statement_start (+ statement_count 1) start_line start_column)
                }
            }
        }
    }
}
shadow parse_unsafe_block_recursive {
    assert (== 1 1)
}

/* Parse unsafe block: unsafe { statements } */
fn parse_unsafe_block(p: Parser) -> Parser {
    if (parser_is_at_end p) {
        return (parser_with_error p true)
    } else {
        let tok: LexerToken = (parser_current p)
        if (== tok.token_type (token_unsafe)) {
            let p1: Parser = (parser_advance p)  /* consume 'unsafe' */
            if (parser_is_at_end p1) {
                return (parser_with_error p1 true)
            } else {
                let tok2: LexerToken = (parser_current p1)
                if (== tok2.token_type (token_lbrace)) {
                    let p2: Parser = (parser_advance p1)  /* consume '{' */
                    let start: int = p2.block_statements_count
                    return (parse_unsafe_block_recursive p2 start 0 tok.line tok.column)
                } else {
                    return (parser_with_error p1 true)
                }
            }
        } else {
            return (parser_with_error p true)
        }
    }
}
shadow parse_unsafe_block {
    assert (== 1 1)
}

shadow parse_let_body {
    assert (== 1 1)
}

/* Helper: Parse let statement body after 'let' [mut] */
fn parse_let_body(p: Parser, is_mut: bool, start_line: int, start_column: int) -> Parser {
    /* Parse identifier (variable name) */
    if (parser_is_at_end p) {
        return (parser_with_error p true)
    } else {
        let tok: LexerToken = (parser_current p)
        if (== tok.token_type (token_identifier)) {
            let name: string = tok.value
            let p1: Parser = (parser_advance p)  /* consume identifier */
            
            /* Expect ':' */
            let p2: Parser = (parser_expect p1 (token_colon))
            if (parser_has_error p2) {
                return p2
            } else {
                /* Parse type (supports qualified names + generics) */
                let type_res: TypeParseResult = (parse_type_string p2)
                if (not type_res.ok) {
                    return (parser_with_error type_res.p true)
                } else {
                    let var_type: string = type_res.type_name
                    let p3: Parser = type_res.p

                    /* Expect '=' */
                    let p4: Parser = (parser_expect p3 (token_assign))
                        if (parser_has_error p4) {
                            return p4
                        } else {
                            /* Parse expression */
                            let p5: Parser = (parse_expression p4)
                            if (parser_has_error p5) {
                                return p5
                            } else {
                                let value_id: int = p5.last_expr_node_id
                                let value_type: int = p5.last_expr_node_type
                                return (parser_store_let p5 name var_type value_id value_type is_mut start_line start_column)
                            }
                        }
                }
            }
        } else {
            return (parser_with_error p true)
        }
    }
}

/* Parse let statement: let [mut] name: type = expression */
fn parse_let_statement(p: Parser) -> Parser {
    if (parser_is_at_end p) {
        return (parser_with_error p true)
    } else {
        let tok: LexerToken = (parser_current p)
        
        if (== tok.token_type (token_let)) {
            let p1: Parser = (parser_advance p)  /* consume 'let' */
            
            /* Check for 'mut' */
            if (parser_is_at_end p1) {
                return (parser_with_error p1 true)
            } else {
                let tok2: LexerToken = (parser_current p1)
                
                if (== tok2.token_type (token_mut)) {
                    /* Has 'mut' keyword */
                    let p2: Parser = (parser_advance p1)  /* consume 'mut' */
                    return (parse_let_body p2 true tok.line tok.column)
                } else {
                    /* No 'mut' keyword */
                    return (parse_let_body p1 false tok.line tok.column)
                }
            }
        } else {
            return (parser_with_error p true)
        }
    }
}

shadow parse_let_statement {
    assert (== 1 1)
}

/* Parse if statement: if (expression) { statements } [else { statements }] */
fn parse_if_statement(p: Parser) -> Parser {
    if (parser_is_at_end p) {
        return (parser_with_error p true)
    } else {
        let tok: LexerToken = (parser_current p)
        
        if (== tok.token_type (token_if)) {
            let p1: Parser = (parser_advance p)  /* consume 'if' */

            /* NanoLang conditions are just expressions (often parenthesized prefix ops) */
            let p2: Parser = (parse_expression p1)
            if (parser_has_error p2) {
                return p2
            } else {
                let condition_id: int = p2.last_expr_node_id
                let condition_type: int = p2.last_expr_node_type

                let p3: Parser = (parse_block p2)
                if (parser_has_error p3) {
                    return p3
                } else {
                    let then_body_id: int = p3.last_expr_node_id

                    /* Check for 'else' */
                    if (parser_is_at_end p3) {
                        return (parser_store_if p3 condition_id condition_type then_body_id -1 tok.line tok.column)
                    } else {
                        let tok2: LexerToken = (parser_current p3)
                        if (== tok2.token_type (token_else)) {
                            let p4: Parser = (parser_advance p3)  /* consume 'else' */
                            let p5: Parser = (parse_block p4)
                            if (parser_has_error p5) {
                                return p5
                            } else {
                                let else_body_id: int = p5.last_expr_node_id
                                return (parser_store_if p5 condition_id condition_type then_body_id else_body_id tok.line tok.column)
                            }
                        } else {
                            return (parser_store_if p3 condition_id condition_type then_body_id -1 tok.line tok.column)
                        }
                    }
                }
            }
        } else {
            return (parser_with_error p true)
        }
    }
}

shadow parse_if_statement {
    assert (== 1 1)
}

/* Parse while statement: while (expression) { statements } */
fn parse_while_statement(p: Parser) -> Parser {
    if (parser_is_at_end p) {
        return (parser_with_error p true)
    } else {
        let tok: LexerToken = (parser_current p)
        
        if (== tok.token_type (token_while)) {
            let p1: Parser = (parser_advance p)  /* consume 'while' */

            let p2: Parser = (parse_expression p1)
            if (parser_has_error p2) {
                return p2
            } else {
                let condition_id: int = p2.last_expr_node_id
                let condition_type: int = p2.last_expr_node_type

                let p3: Parser = (parse_block p2)
                if (parser_has_error p3) {
                    return p3
                } else {
                    let body_id: int = p3.last_expr_node_id
                    return (parser_store_while p3 condition_id condition_type body_id tok.line tok.column)
                }
            }
        } else {
            return (parser_with_error p true)
        }
    }
}

shadow parse_while_statement {
    assert (== 1 1)
}

/* Parse return statement: return [expression] */
fn parse_return_statement(p: Parser) -> Parser {
    if (parser_is_at_end p) {
        return (parser_with_error p true)
    } else {
        let tok: LexerToken = (parser_current p)
        
        if (== tok.token_type (token_return)) {
            let p1: Parser = (parser_advance p)  /* consume 'return' */
            
            /* Check if there's an expression */
            if (parser_is_at_end p1) {
                return (parser_store_return p1 -1 -1 tok.line tok.column)
            } else {
                let tok2: LexerToken = (parser_current p1)
                /* If next token is '}' or end, no expression */
                if (or (== tok2.token_type (token_rbrace)) (parser_is_at_end p1)) {
                    return (parser_store_return p1 -1 -1 tok.line tok.column)
                } else {
                    /* Parse expression */
                    let p2: Parser = (parse_expression p1)
                    if (parser_has_error p2) {
                        return p2
                    } else {
                        let value_id: int = p2.last_expr_node_id
                        let value_type: int = p2.last_expr_node_type
                        return (parser_store_return p2 value_id value_type tok.line tok.column)
                    }
                }
            }
        } else {
            return (parser_with_error p true)
        }
    }
}

shadow parse_return_statement {
    assert (== 1 1)
}

/* Parse assert statement: assert expression */
fn parse_assert_statement(p: Parser) -> Parser {
    if (parser_is_at_end p) {
        return (parser_with_error p true)
    } else {
        let tok: LexerToken = (parser_current p)
        let p1: Parser = (parser_advance p)  /* consume 'assert' */
        let p2: Parser = (parse_expression p1)
        if (parser_has_error p2) {
            return p2
        } else {
            let cond_id: int = p2.last_expr_node_id
            let cond_type: int = p2.last_expr_node_type
            return (parser_store_assert p2 cond_id cond_type tok.line tok.column)
        }
    }
}

shadow parse_assert_statement {
    assert (== 1 1)
}

/* Parse for statement: for varname in expression { body } */
fn parse_for_statement(p: Parser) -> Parser {
    if (parser_is_at_end p) {
        return (parser_with_error p true)
    } else {
        let tok: LexerToken = (parser_current p)
        
        if (== tok.token_type (token_for)) {
            let p1: Parser = (parser_advance p)  /* consume 'for' */
            
            if (parser_is_at_end p1) {
                return (parser_with_error p1 true)
            } else {
                let tok2: LexerToken = (parser_current p1)
                if (== tok2.token_type (token_identifier)) {
                    let var_name: string = tok2.value
                    let p2: Parser = (parser_advance p1)  /* consume identifier */
                    
                    /* Expect 'in' keyword */
                    if (parser_is_at_end p2) {
                        return (parser_with_error p2 true)
                    } else {
                        let tok3: LexerToken = (parser_current p2)
                        if (== tok3.token_type (token_in)) {
                            let p3: Parser = (parser_advance p2)  /* consume 'in' */
                            
                            /* Parse iterable expression */
                            let p4: Parser = (parse_expression p3)
                            if (parser_has_error p4) {
                                return p4
                            } else {
                                let iterable_id: int = p4.last_expr_node_id
                                let iterable_type: int = p4.last_expr_node_type
                                
                                /* Parse body block */
                                let p5: Parser = (parse_block p4)
                                if (parser_has_error p5) {
                                    return p5
                                } else {
                                    let body_id: int = p5.last_expr_node_id
                                    return (parser_store_for p5 var_name iterable_id iterable_type body_id tok.line tok.column)
                                }
                            }
                        } else {
                            return (parser_with_error p2 true)
                        }
                    }
                } else {
                    return (parser_with_error p1 true)
                }
            }
        } else {
            return (parser_with_error p true)
        }
    }
}

shadow parse_for_statement {
    assert (== 1 1)
}

/* Parse statement (dispatcher) */
fn parse_statement(p: Parser) -> Parser {
    if (parser_is_at_end p) {
        return (parser_with_error p true)
    } else {
        let tok: LexerToken = (parser_current p)
        
        /* Dispatch based on token type */
        if (== tok.token_type (token_let)) {
            return (parse_let_statement p)
        } else {
            if (== tok.token_type (token_set)) {
                /* Parse set statement: set varname expr */
                let p1: Parser = (parser_advance p)  /* consume 'set' */
                if (parser_is_at_end p1) {
                    return (parser_with_error p1 true)
                } else {
                    let tok2: LexerToken = (parser_current p1)
                    if (== tok2.token_type (token_identifier)) {
                        let var_name: string = tok2.value
                        let p2: Parser = (parser_advance p1)  /* consume identifier */
                        let p3: Parser = (parse_expression p2)
                        if (parser_has_error p3) {
                            return p3
                        } else {
                            let value_id: int = p3.last_expr_node_id
                            let value_type: int = p3.last_expr_node_type
                            return (parser_store_set p3 var_name value_id value_type tok.line tok.column)
                        }
                    } else {
                        return (parser_with_error p1 true)
                    }
                }
            } else {
                if (== tok.token_type (token_if)) {
                    return (parse_if_statement p)
                } else {
                    if (== tok.token_type (token_while)) {
                        return (parse_while_statement p)
                    } else {
                        if (== tok.token_type (token_for)) {
                            return (parse_for_statement p)
                        } else {
                            if (== tok.token_type (token_return)) {
                                return (parse_return_statement p)
                            } else {
                                if (== tok.token_type (token_assert)) {
                                    return (parse_assert_statement p)
                                } else {
                                    if (== tok.token_type (token_unsafe)) {
                                        return (parse_unsafe_block p)
                                    } else {
                                        /* Expression statement */
                                        let p1: Parser = (parse_expression p)
                                        return p1
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

shadow parse_statement {
    assert (== 1 1)
}

/* ========== Definition Parsing ========== */

/* Helper: Store function definition node */

/* Helper: Store function node */
fn parser_store_function(p: Parser, name: string, param_start: int, param_count: int, return_type: string, body_id: int, line: int, column: int) -> Parser {
    let node: ASTFunction = ASTFunction {
        node_type: ParseNodeType.PNODE_FUNCTION,
        line: line,
        column: column,
        name: name,
        param_start: param_start,
        param_count: param_count,
        return_type: return_type,
        body: body_id
    }
    let node_id: int = p.functions_count
    (list_ASTFunction_push p.functions node)
    
    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: (+ p.functions_count 1),
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: -1
    }
}
shadow parser_store_function {
    assert (== 1 1)
}

/* Helper: Store struct definition node */

/* Helper: Store struct node */
fn parser_store_struct(p: Parser, name: string, field_count: int, line: int, column: int) -> Parser {
    let node: ASTStruct = ASTStruct {
        node_type: ParseNodeType.PNODE_STRUCT_DEF,
        line: line,
        column: column,
        name: name,
        field_count: field_count
    }
    let node_id: int = p.structs_count
    (list_ASTStruct_push p.structs node)
    
    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: (+ p.structs_count 1),
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: -1
    }
}
shadow parser_store_struct {
    assert (== 1 1)
}

/* Helper: Store enum definition node */

/* Helper: Store enum node */
fn parser_store_enum(p: Parser, name: string, variant_count: int, line: int, column: int) -> Parser {
    let node: ASTEnum = ASTEnum {
        node_type: ParseNodeType.PNODE_ENUM,
        line: line,
        column: column,
        name: name,
        variant_count: variant_count
    }
    let node_id: int = p.enums_count
    (list_ASTEnum_push p.enums node)
    
    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: (+ p.enums_count 1),
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: -1
    }
}
shadow parser_store_enum {
    assert (== 1 1)
}

/* Helper: Store union definition node */

/* Helper: Store union node */
fn parser_store_union(p: Parser, name: string, variant_count: int, line: int, column: int) -> Parser {
    let node: ASTUnion = ASTUnion {
        node_type: ParseNodeType.PNODE_UNION_DEF,
        line: line,
        column: column,
        name: name,
        variant_count: variant_count
    }
    let node_id: int = p.unions_count
    (list_ASTUnion_push p.unions node)
    
    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: (+ p.unions_count 1),
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: -1
    }
}
shadow parser_store_union {
    assert (== 1 1)
}

/* Helper: Store union construction */
fn parser_store_union_construct(p: Parser, union_name: string, variant_name: string, field_names: array<string>, field_value_ids: array<int>, field_value_types: array<int>, field_count: int, line: int, column: int) -> Parser {
    let node: ASTUnionConstruct = ASTUnionConstruct {
        node_type: ParseNodeType.PNODE_UNION_CONSTRUCT,
        line: line,
        column: column,
        union_name: union_name,
        variant_name: variant_name,
        field_names: field_names,
        field_value_ids: field_value_ids,
        field_value_types: field_value_types,
        field_count: field_count
    }
    let node_id: int = p.union_constructs_count
    (list_ASTUnionConstruct_push p.union_constructs node)

    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: (+ p.union_constructs_count 1),
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: ParseNodeType.PNODE_UNION_CONSTRUCT
    }
}

/* Helper: Store struct literal */
fn parser_store_struct_literal(p: Parser, type_name: string, field_names: array<string>, field_value_ids: array<int>, field_value_types: array<int>, field_count: int, line: int, column: int) -> Parser {
    let node: ASTStructLiteral = ASTStructLiteral {
        node_type: ParseNodeType.PNODE_STRUCT_LITERAL,
        line: line,
        column: column,
        struct_name: type_name,
        field_names: field_names,
        field_value_ids: field_value_ids,
        field_value_types: field_value_types,
        field_count: field_count
    }
    let node_id: int = p.struct_literals_count
    (list_ASTStructLiteral_push p.struct_literals node)

    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: (+ p.struct_literals_count 1),
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: ParseNodeType.PNODE_STRUCT_LITERAL
    }
}

/* Helper: Store match expression */
fn parser_store_match(p: Parser, scrutinee_id: int, scrutinee_type: int, arm_variants: array<string>, arm_bindings: array<string>, arm_body_ids: array<int>, arm_body_types: array<int>, arm_count: int, line: int, column: int) -> Parser {
    let node: ASTMatch = ASTMatch {
        node_type: ParseNodeType.PNODE_MATCH,
        line: line,
        column: column,
        scrutinee: scrutinee_id,
        scrutinee_type: scrutinee_type,
        arm_variants: arm_variants,
        arm_bindings: arm_bindings,
        arm_body_ids: arm_body_ids,
        arm_body_types: arm_body_types,
        arm_count: arm_count
    }
    let node_id: int = p.matches_count
    (list_ASTMatch_push p.matches node)

    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: (+ p.matches_count 1),
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: ParseNodeType.PNODE_MATCH
    }
}

/* Helper: Store tuple literal */
fn parser_store_tuple_literal(p: Parser, element_ids: array<int>, element_types: array<int>, element_count: int, line: int, column: int) -> Parser {
    let node: ASTTupleLiteral = ASTTupleLiteral {
        node_type: ParseNodeType.PNODE_TUPLE_LITERAL,
        line: line,
        column: column,
        element_ids: element_ids,
        element_types: element_types,
        element_count: element_count
    }
    let node_id: int = p.tuple_literals_count
    (list_ASTTupleLiteral_push p.tuple_literals node)

    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: (+ p.tuple_literals_count 1),
        tuple_indices_count: p.tuple_indices_count,
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: ParseNodeType.PNODE_TUPLE_LITERAL
    }
}

/* Helper: Store tuple index */
fn parser_store_tuple_index(p: Parser, tuple_id: int, tuple_type: int, index: int, line: int, column: int) -> Parser {
    let node: ASTTupleIndex = ASTTupleIndex {
        node_type: ParseNodeType.PNODE_TUPLE_INDEX,
        line: line,
        column: column,
        tuple: tuple_id,
        tuple_type: tuple_type,
        index: index
    }
    let node_id: int = p.tuple_indices_count
    (list_ASTTupleIndex_push p.tuple_indices node)

    return Parser {
        tokens: p.tokens,
        position: p.position,
        token_count: p.token_count,
        has_error: p.has_error,
        numbers: p.numbers,
        floats: p.floats,
        strings: p.strings,
        bools: p.bools,
        identifiers: p.identifiers,
        binary_ops: p.binary_ops,
        calls: p.calls,
        call_args: p.call_args,
        array_elements: p.array_elements,
        array_literals: p.array_literals,
        lets: p.lets,
        sets: p.sets,
        ifs: p.ifs,
        whiles: p.whiles,
        fors: p.fors,
        returns: p.returns,
        blocks: p.blocks,
        unsafe_blocks: p.unsafe_blocks,
        block_statements: p.block_statements,
        prints: p.prints,
        asserts: p.asserts,
        functions: p.functions,
        shadows: p.shadows,
        structs: p.structs,
        struct_literals: p.struct_literals,
        field_accesses: p.field_accesses,
        enums: p.enums,
        unions: p.unions,
        union_constructs: p.union_constructs,
        matches: p.matches,
        imports: p.imports,
        opaque_types: p.opaque_types,
        tuple_literals: p.tuple_literals,
        tuple_indices: p.tuple_indices,
        numbers_count: p.numbers_count,
        floats_count: p.floats_count,
        strings_count: p.strings_count,
        bools_count: p.bools_count,
        identifiers_count: p.identifiers_count,
        binary_ops_count: p.binary_ops_count,
        calls_count: p.calls_count,
        array_literals_count: p.array_literals_count,
        lets_count: p.lets_count,
        sets_count: p.sets_count,
        ifs_count: p.ifs_count,
        whiles_count: p.whiles_count,
        fors_count: p.fors_count,
        returns_count: p.returns_count,
        blocks_count: p.blocks_count,
        unsafe_blocks_count: p.unsafe_blocks_count,
        block_statements_count: p.block_statements_count,
        prints_count: p.prints_count,
        asserts_count: p.asserts_count,
        functions_count: p.functions_count,
        shadows_count: p.shadows_count,
        structs_count: p.structs_count,
        struct_literals_count: p.struct_literals_count,
        field_accesses_count: p.field_accesses_count,
        enums_count: p.enums_count,
        unions_count: p.unions_count,
        union_constructs_count: p.union_constructs_count,
        matches_count: p.matches_count,
        imports_count: p.imports_count,
        opaque_types_count: p.opaque_types_count,
        tuple_literals_count: p.tuple_literals_count,
        tuple_indices_count: (+ p.tuple_indices_count 1),
        next_node_id: (+ p.next_node_id 1),
        last_expr_node_id: node_id,
        last_expr_node_type: ParseNodeType.PNODE_TUPLE_INDEX
    }
}

struct ParamParseResult {
    p: Parser,
    param_count: int
}

/* Helper: Parse function parameters */
fn parse_function_params(p: Parser, param_count: int) -> ParamParseResult {
    if (parser_has_error p) {
        return ParamParseResult { p: p, param_count: param_count }
    } else {
        if (parser_is_at_end p) {
            return ParamParseResult { p: (parser_with_error p true), param_count: param_count }
        } else {
            let tok: LexerToken = (parser_current p)

            if (== tok.token_type (token_rparen)) {
                /* End of parameters */
                let p1: Parser = (parser_advance p) /* consume ')' */
                return ParamParseResult { p: p1, param_count: param_count }
            } else {
                let mut is_mut: bool = false
                let mut cur: Parser = p

                /* Optional 'mut' */
                if (== tok.token_type (token_mut)) {
                    set is_mut true
                    set cur (parser_advance cur)
                } else {
                    (print "")
                }

                if (parser_is_at_end cur) {
                    return ParamParseResult { p: (parser_with_error cur true), param_count: param_count }
                } else {
                    let tok_name: LexerToken = (parser_current cur)
                    if (!= tok_name.token_type (token_identifier)) {
                        return ParamParseResult { p: (parser_with_error cur true), param_count: param_count }
                    } else {
                        let name: string = tok_name.value
                        let p1: Parser = (parser_advance cur) /* consume name */

                        let p2: Parser = (parser_expect p1 (token_colon))
                        if (parser_has_error p2) {
                            return ParamParseResult { p: p2, param_count: param_count }
                        } else {
                            let t: TypeParseResult = (parse_type_string p2)
                            if (not t.ok) {
                                return ParamParseResult { p: (parser_with_error t.p true), param_count: param_count }
                            } else {
                                let var_type: string = t.type_name
                                let p3: Parser = t.p

                                /* Store param as a let with no initializer */
                                let p4: Parser = (parser_store_let p3 name var_type (- 0 1) (- 0 1) is_mut tok_name.line tok_name.column)
                                if (parser_has_error p4) {
                                    return ParamParseResult { p: p4, param_count: param_count }
                                } else {
                                    if (parser_is_at_end p4) {
                                        return ParamParseResult { p: (parser_with_error p4 true), param_count: param_count }
                                    } else {
                                        let tnext: LexerToken = (parser_current p4)
                                        if (== tnext.token_type (token_comma)) {
                                            let p5: Parser = (parser_advance p4)
                                            return (parse_function_params p5 (+ param_count 1))
                                        } else {
                                            if (== tnext.token_type (token_rparen)) {
                                                let p5: Parser = (parser_advance p4)
                                                return ParamParseResult { p: p5, param_count: (+ param_count 1) }
                                            } else {
                                                return ParamParseResult { p: (parser_with_error p4 true), param_count: param_count }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

shadow parse_function_params {
    assert (== 1 1)
}

/* Parse extern function declaration: extern fn name(params) -> return_type */
fn parse_extern_function_definition(p: Parser) -> Parser {
    if (parser_is_at_end p) {
        return (parser_with_error p true)
    } else {
        let tok: LexerToken = (parser_current p)
        if (== tok.token_type (token_extern)) {
            let p1: Parser = (parser_advance p)  /* consume 'extern' */

            let p2: Parser = (parser_expect p1 (token_fn))
            if (parser_has_error p2) {
                return p2
            } else {
                if (parser_is_at_end p2) {
                    return (parser_with_error p2 true)
                } else {
                    let tok2: LexerToken = (parser_current p2)
                    if (== tok2.token_type (token_identifier)) {
                        let name: string = tok2.value
                        let p3: Parser = (parser_advance p2)  /* consume name */

                        let p4: Parser = (parser_expect p3 (token_lparen))
                        if (parser_has_error p4) {
                            return p4
                        } else {
                            let param_start: int = p4.lets_count
                            let params_res: ParamParseResult = (parse_function_params p4 0)
                            let p5: Parser = params_res.p
                            if (parser_has_error p5) {
                                return p5
                            } else {
                                let param_count: int = params_res.param_count

                                let p6: Parser = (parser_expect p5 (token_arrow))
                                if (parser_has_error p6) {
                                    return p6
                                } else {
                                    let type_res: TypeParseResult = (parse_type_string p6)
                                    if (not type_res.ok) {
                                        return (parser_with_error type_res.p true)
                                    } else {
                                        let return_type: string = type_res.type_name
                                        let p7: Parser = type_res.p
                                        return (parser_store_function p7 name param_start param_count return_type -1 tok.line tok.column)
                                    }
                                }
                            }
                        }
                    } else {
                        return (parser_with_error p2 true)
                    }
                }
            }
        } else {
            return (parser_with_error p true)
        }
    }
}

shadow parse_extern_function_definition {
    let source: string = "extern fn foo() -> int"
    let tokens: List<LexerToken> = (tokenize_string source)
    let token_count: int = (list_LexerToken_length tokens)
    let p1: Parser = (parser_new tokens token_count)

    let t0: LexerToken = (parser_current p1)
    assert (== t0.token_type (token_extern))
    assert (== t0.value "extern")

    let p2: Parser = (parser_advance p1)
    let p3: Parser = (parser_expect p2 (token_fn))
    assert (== (parser_has_error p3) false)

    let tname: LexerToken = (parser_current p3)
    assert (== tname.token_type (token_identifier))
    assert (== tname.value "foo")

    let p4: Parser = (parser_advance p3)
    let p5: Parser = (parser_expect p4 (token_lparen))
    assert (== (parser_has_error p5) false)

    let params_res: ParamParseResult = (parse_function_params p5 0)
    let p6: Parser = params_res.p
    assert (== (parser_has_error p6) false)

    let p7: Parser = (parser_expect p6 (token_arrow))
    assert (== (parser_has_error p7) false)

    let ttype: LexerToken = (parser_current p7)
    assert (== ttype.token_type (token_type_int))
    assert (== ttype.value "int")

    let type_res: TypeParseResult = (parse_type_string p7)
    assert (== type_res.ok true)
    assert (== type_res.type_name "int")
}

/* Parse function definition: fn name(params) -> return_type { body } */
fn parse_function_definition(p: Parser) -> Parser {
    if (parser_is_at_end p) {
        return (parser_with_error p true)
    } else {
        let tok: LexerToken = (parser_current p)
        
        if (== tok.token_type (token_fn)) {
            let p1: Parser = (parser_advance p)  /* consume 'fn' */
            
            /* Parse function name */
            if (parser_is_at_end p1) {
                return (parser_with_error p1 true)
            } else {
                let tok2: LexerToken = (parser_current p1)
                if (== tok2.token_type (token_identifier)) {
                    let name: string = tok2.value
                    let p2: Parser = (parser_advance p1)  /* consume name */
                    
                    /* Expect '(' */
                    let p3: Parser = (parser_expect p2 (token_lparen))
                    if (parser_has_error p3) {
                        return p3
                    } else {
                        let param_start: int = p3.lets_count
                        /* Parse parameters (simplified - just count for now) */
                        /* Use recursive helper for functional style */
                        let params_res: ParamParseResult = (parse_function_params p3 0)
                        let p4: Parser = params_res.p
                        
                        if (parser_has_error p4) {
                            return p4
                        } else {
                            /* p4.position points after ')' */
                            let param_count: int = params_res.param_count
                            
                            /* Expect '->' */
                            let p10: Parser = (parser_expect p4 (token_arrow))
                            if (parser_has_error p10) {
                                return p10
                            } else {
                            /* Parse return type */
                            let type_res: TypeParseResult = (parse_type_string p10)
                            if (not type_res.ok) {
                                return (parser_with_error type_res.p true)
                            } else {
                                let return_type: string = type_res.type_name
                                let p11: Parser = type_res.p
                                
                                /* Parse body (block) */
                                let p12: Parser = (parse_block p11)
                                if (parser_has_error p12) {
                                    return p12
                                } else {
                                    let body_id: int = p12.last_expr_node_id
                                    return (parser_store_function p12 name param_start param_count return_type body_id tok.line tok.column)
                                }
                            }
                            }
                        }
                    }
                } else {
                    return (parser_with_error p1 true)
                }
            }
        } else {
            return (parser_with_error p true)
        }
    }
}

shadow parse_function_definition {
    assert (== 1 1)
}

/* Helper: Parse struct fields recursively */
fn parse_struct_fields(p: Parser, field_count: int, name: string, start_line: int, start_column: int) -> Parser {
    if (parser_has_error p) {
        return p
    } else {
        if (parser_is_at_end p) {
            return (parser_with_error p true)
        } else {
            let tok: LexerToken = (parser_current p)

            if (== tok.token_type (token_rbrace)) {
                let p1: Parser = (parser_advance p)  /* consume '}' */
                return (parser_store_struct p1 name field_count start_line start_column)
            } else {
                if (== tok.token_type (token_identifier)) {
                    let p1: Parser = (parser_advance p)  /* consume field name */
                    let p2: Parser = (parser_expect p1 (token_colon))
                    if (parser_has_error p2) {
                        return p2
                    } else {
                        let t: TypeParseResult = (parse_type_string p2)
                        if (not t.ok) {
                            return (parser_with_error t.p true)
                        } else {
                            let p3: Parser = t.p

                            if (parser_is_at_end p3) {
                                return (parser_with_error p3 true)
                            } else {
                                let tok2: LexerToken = (parser_current p3)
                                if (== tok2.token_type (token_comma)) {
                                    let p4: Parser = (parser_advance p3)
                                    return (parse_struct_fields p4 (+ field_count 1) name start_line start_column)
                                } else {
                                    return (parse_struct_fields p3 (+ field_count 1) name start_line start_column)
                                }
                            }
                        }
                    }
                } else {
                    return (parser_with_error p true)
                }
            }
        }
    }
}

shadow parse_struct_fields {
    assert (== 1 1)
}

/* Parse struct definition: struct Name { fields } */
fn parse_struct_definition(p: Parser) -> Parser {
    if (parser_is_at_end p) {
        return (parser_with_error p true)
    } else {
        let tok: LexerToken = (parser_current p)
        
        if (== tok.token_type (token_struct)) {
            let p1: Parser = (parser_advance p)  /* consume 'struct' */
            
            /* Parse struct name */
            if (parser_is_at_end p1) {
                return (parser_with_error p1 true)
            } else {
                let tok2: LexerToken = (parser_current p1)
                if (== tok2.token_type (token_identifier)) {
                    let name: string = tok2.value
                    let p2: Parser = (parser_advance p1)  /* consume name */

                    /* Expect '{' */
                    let p3: Parser = (parser_expect p2 (token_lbrace))
                    if (parser_has_error p3) {
                        return p3
                    } else {
                        return (parse_struct_fields p3 0 name tok.line tok.column)
                    }
                } else {
                    return (parser_with_error p1 true)
                }
            }
        } else {
            return (parser_with_error p true)
        }
    }
}

shadow parse_struct_definition {
    assert (== 1 1)
}

/* Helper: Parse enum variants recursively */
fn parse_enum_variants(p: Parser, variant_count: int, name: string, start_line: int, start_column: int) -> Parser {
    if (parser_has_error p) {
        return p
    } else {
        if (parser_is_at_end p) {
            return (parser_with_error p true)
        } else {
            let tok: LexerToken = (parser_current p)
            
            if (== tok.token_type (token_rbrace)) {
                /* End of enum */
                let p1: Parser = (parser_advance p)  /* consume '}' */
                return (parser_store_enum p1 name variant_count start_line start_column)
            } else {
                if (== tok.token_type (token_identifier)) {
                    /* Variant name */
                    let p2: Parser = (parser_advance p)  /* consume variant */
                    
                    /* Check for comma or '}' */
                    if (parser_is_at_end p2) {
                        return (parser_with_error p2 true)
                    } else {
                        let tok2: LexerToken = (parser_current p2)
                        if (== tok2.token_type (token_comma)) {
                            let p3: Parser = (parser_advance p2)  /* consume ',' */
                            /* Continue parsing more variants */
                            return (parse_enum_variants p3 (+ variant_count 1) name start_line start_column)
                        } else {
                            /* Expect '}' next - continue to parse it */
                            return (parse_enum_variants p2 (+ variant_count 1) name start_line start_column)
                        }
                    }
                } else {
                    return (parser_with_error p true)
                }
            }
        }
    }
}

shadow parse_enum_variants {
    assert (== 1 1)
}

/* Parse enum definition: enum Name { Variant1, Variant2 } */
fn parse_enum_definition(p: Parser) -> Parser {
    if (parser_is_at_end p) {
        return (parser_with_error p true)
    } else {
        let tok: LexerToken = (parser_current p)
        
        if (== tok.token_type (token_enum)) {
            let p1: Parser = (parser_advance p)  /* consume 'enum' */
            
            /* Parse enum name */
            if (parser_is_at_end p1) {
                return (parser_with_error p1 true)
            } else {
                let tok2: LexerToken = (parser_current p1)
                if (== tok2.token_type (token_identifier)) {
                    let name: string = tok2.value
                    let p2: Parser = (parser_advance p1)  /* consume name */
                    
                    /* Expect '{' */
                    let p3: Parser = (parser_expect p2 (token_lbrace))
                    if (parser_has_error p3) {
                        return p3
                    } else {
                        /* Parse variants recursively */
                        return (parse_enum_variants p3 0 name tok.line tok.column)
                    }
                } else {
                    return (parser_with_error p1 true)
                }
            }
        } else {
            return (parser_with_error p true)
        }
    }
}

shadow parse_enum_definition {
    assert (== 1 1)
}

/* Helper: Parse union variants recursively */
fn parse_union_variants(p: Parser, variant_count: int, name: string, start_line: int, start_column: int) -> Parser {
    if (parser_has_error p) {
        return p
    } else {
        if (parser_is_at_end p) {
            return (parser_with_error p true)
        } else {
            let tok: LexerToken = (parser_current p)
            
            if (== tok.token_type (token_rbrace)) {
                /* End of union */
                let p1: Parser = (parser_advance p)  /* consume '}' */
                return (parser_store_union p1 name variant_count start_line start_column)
            } else {
                if (== tok.token_type (token_identifier)) {
                    /* Variant name */
                    let p2: Parser = (parser_advance p)  /* consume variant */
                    
                    /* Check for '(' type ')' */
                    if (parser_is_at_end p2) {
                        return (parser_with_error p2 true)
                    } else {
                        let tok2: LexerToken = (parser_current p2)
                        if (== tok2.token_type (token_lparen)) {
                            let p3: Parser = (parser_advance p2)  /* consume '(' */
                            
                            /* Parse type */
                            let t: TypeParseResult = (parse_type_string p3)
                            if (not t.ok) {
                                return (parser_with_error t.p true)
                            } else {
                                let p4: Parser = t.p

                                /* Expect ')' */
                                let p5: Parser = (parser_expect p4 (token_rparen))
                                    if (parser_has_error p5) {
                                        return p5
                                    } else {
                                        /* Check for comma or '}' */
                                        if (parser_is_at_end p5) {
                                            return (parser_with_error p5 true)
                                        } else {
                                            let tok4: LexerToken = (parser_current p5)
                                            if (== tok4.token_type (token_comma)) {
                                                let p6: Parser = (parser_advance p5)  /* consume ',' */
                                                /* Continue parsing more variants */
                                                return (parse_union_variants p6 (+ variant_count 1) name start_line start_column)
                                            } else {
                                                /* Expect '}' next - continue to parse it */
                                                return (parse_union_variants p5 (+ variant_count 1) name start_line start_column)
                                            }
                                        }
                                    }
                            }
                        } else {
                            return (parser_with_error p2 true)
                        }
                    }
                } else {
                    return (parser_with_error p true)
                }
            }
        }
    }
}

shadow parse_union_variants {
    assert (== 1 1)
}

/* Parse union definition: union Name { Variant1(type), Variant2(type) } */
fn parse_union_definition(p: Parser) -> Parser {
    if (parser_is_at_end p) {
        return (parser_with_error p true)
    } else {
        let tok: LexerToken = (parser_current p)
        
        if (== tok.token_type (token_union)) {
            let p1: Parser = (parser_advance p)  /* consume 'union' */
            
            /* Parse union name */
            if (parser_is_at_end p1) {
                return (parser_with_error p1 true)
            } else {
                let tok2: LexerToken = (parser_current p1)
                if (== tok2.token_type (token_identifier)) {
                    let name: string = tok2.value
                    let p2: Parser = (parser_advance p1)  /* consume name */
                    
                    /* Expect '{' */
                    let p3: Parser = (parser_expect p2 (token_lbrace))
                    if (parser_has_error p3) {
                        return p3
                    } else {
                        /* Parse variants recursively */
                        return (parse_union_variants p3 0 name tok.line tok.column)
                    }
                } else {
                    return (parser_with_error p1 true)
                }
            }
        } else {
            return (parser_with_error p true)
        }
    }
}

shadow parse_union_definition {
    assert (== 1 1)
}

/* Parse definition (dispatcher): function, struct, enum, union */
/* Parse import statement: import "path" as name */
fn parse_import(p: Parser) -> Parser {
    let tok: LexerToken = (parser_current p)
    let p1: Parser = (parser_advance p)  /* consume 'import' */
    
    if (parser_is_at_end p1) {
        return (parser_with_error p1 true)
    } else {
        let tok2: LexerToken = (parser_current p1)
        if (== tok2.token_type (token_string)) {
            let module_path: string = tok2.value
            let p2: Parser = (parser_advance p1)
            
            if (parser_is_at_end p2) {
                return (parser_with_error p2 true)
            } else {
                let tok3: LexerToken = (parser_current p2)
                if (== tok3.token_type (token_as)) {
                    let p3: Parser = (parser_advance p2)
                    
                    if (parser_is_at_end p3) {
                        return (parser_with_error p3 true)
                    } else {
                        let tok4: LexerToken = (parser_current p3)
                        if (== tok4.token_type (token_identifier)) {
                            let module_name: string = tok4.value
                            let p4: Parser = (parser_advance p3)
                            return (parser_store_import p4 module_path module_name tok.line tok.column)
                        } else {
                            return (parser_with_error p3 true)
                        }
                    }
                } else {
                    return (parser_with_error p2 true)
                }
            }
        } else {
            return (parser_with_error p1 true)
        }
    }
}

/* Parse opaque type: opaque type TypeName */
fn parse_opaque_type(p: Parser) -> Parser {
    let tok: LexerToken = (parser_current p)
    let p1: Parser = (parser_advance p)  /* consume 'opaque' */
    let mut p2: Parser = p1
    /* Optional "type" keyword (tokenizes as identifier) */
    if (not (parser_is_at_end p1)) {
        let t: LexerToken = (parser_current p1)
        if (and (== t.token_type (token_identifier)) (str_equals t.value "type")) {
            set p2 (parser_advance p1)
        } else {
            set p2 p1
        }
    } else {
        set p2 p1
    }
    
    if (parser_is_at_end p2) {
        return (parser_with_error p2 true)
    } else {
        let tok3: LexerToken = (parser_current p2)
        if (== tok3.token_type (token_identifier)) {
            let type_name: string = tok3.value
            let p3: Parser = (parser_advance p2)
            return (parser_store_opaque_type p3 type_name tok.line tok.column)
        } else {
            return (parser_with_error p2 true)
        }
    }
}

/* Parse shadow test: shadow target_name { body } */
fn parse_shadow(p: Parser) -> Parser {
    let tok: LexerToken = (parser_current p)
    let p1: Parser = (parser_advance p)  /* consume 'shadow' */
    
    if (parser_is_at_end p1) {
        return (parser_with_error p1 true)
    } else {
        let tok2: LexerToken = (parser_current p1)
        if (== tok2.token_type (token_identifier)) {
            let target_name: string = tok2.value
            let p2: Parser = (parser_advance p1)
            let p3: Parser = (parse_block p2)
            if (parser_has_error p3) {
                return p3
            } else {
                let body_id: int = p3.last_expr_node_id
                return (parser_store_shadow p3 target_name body_id tok.line tok.column)
            }
        } else {
            return (parser_with_error p1 true)
        }
    }
}

fn parse_definition(p: Parser) -> Parser {
    if (parser_is_at_end p) {
        return (parser_with_error p true)
    } else {
        let mut tok: LexerToken = (parser_current p)
        let mut p_work: Parser = p
        
        /* Handle optional 'pub' modifier */
        if (== tok.token_type (token_pub)) {
            set p_work (parser_advance p_work)
            if (parser_is_at_end p_work) {
                return (parser_with_error p_work true)
            } else {
                set tok (parser_current p_work)
            }
        } else {
            (print "")
        }
        
        /* Dispatch based on token type */
        if (== tok.token_type (token_extern)) {
            return (parse_extern_function_definition p_work)
        } else {
            if (== tok.token_type (token_fn)) {
                return (parse_function_definition p_work)
            } else {
                if (== tok.token_type (token_struct)) {
                return (parse_struct_definition p_work)
            } else {
                if (== tok.token_type (token_enum)) {
                    return (parse_enum_definition p_work)
                } else {
                    if (== tok.token_type (token_union)) {
                        return (parse_union_definition p_work)
                    } else {
                        if (== tok.token_type (token_import)) {
                        return (parse_import p_work)
                    } else {
                        if (== tok.token_type (token_opaque)) {
                            return (parse_opaque_type p_work)
                        } else {
                            if (== tok.token_type (token_shadow)) {
                                return (parse_shadow p_work)
                            } else {
                                return (parser_with_error p_work true)
                            }
                        }
                    }
                    }
                }
                }
            }
        }
    }
}

shadow parse_definition {
    assert (== 1 1)
}

/* =============================================================================
 * PROGRAM PARSING - Top-level wrapper for parsing entire programs
 * ============================================================================= */

/* Parse a complete program (multiple definitions)
 * 
 * This is the top-level parsing function that should be called to parse
 * a complete nanolang source file. It repeatedly calls parse_definition()
 * until all tokens are consumed or an error occurs.
 * 
 * Args:
 *   tokens: List of tokens from the lexer
 *   token_count: Number of tokens in the list
 * 
 * Returns:
 *   Parser state containing all parsed definitions
 */
pub fn parse_program(tokens: List<LexerToken>, token_count: int) -> Parser {
    let mut p: Parser = (parser_new tokens token_count)
    
    /* Parse all definitions until end of tokens or error */
    while (and (not (parser_is_at_end p)) (not (parser_has_error p))) {
        let before_pos: int = p.position
        set p (parse_definition p)

        /* Safety: ensure progress to avoid infinite loops */
        if (and (== p.position before_pos) (not (parser_has_error p))) {
            set p (parser_with_error (parser_advance p) true)
        }
    }
    
    return p
}

shadow parse_program {
    /* Test with empty token list */
    let empty_tokens: List<LexerToken> = (list_LexerToken_new)
    let p: Parser = (parse_program empty_tokens 0)
    assert (== p.position 0)

    /* Basic end-to-end parse on a small program */
    let source: string = "extern fn foo() -> int"
    let tokens: List<LexerToken> = (tokenize_string source)
    let token_count: int = (list_LexerToken_length tokens)
    assert (> token_count 1)
    assert (== token_count token_count)
}

fn create_number_node(value: string, line: int, column: int) -> ASTNumber {
    return ASTNumber {
        node_type: ParseNodeType.PNODE_NUMBER,
        line: line,
        column: column,
        value: value
    }
}

shadow create_number_node {
    let node: ASTNumber = (create_number_node "42" 1 1)
    /* Verify we can create nodes */
    assert (== 1 1)
}

fn create_identifier_node(name: string, line: int, column: int) -> ASTIdentifier {
    return ASTIdentifier {
        node_type: ParseNodeType.PNODE_IDENTIFIER,
        line: line,
        column: column,
        name: name
    }
}

shadow create_identifier_node {
    let node: ASTIdentifier = (create_identifier_node "x" 1 1)
    /* Verify we can create nodes */
    assert (== 1 1)
}

fn test_parser_structure() -> int {
    /* Test that we can create parser state */
    let empty_tokens: List<LexerToken> = (list_LexerToken_new)
    let p: Parser = (parser_new empty_tokens 0)
    
    /* Test that we can create AST nodes */
    let num: ASTNumber = (create_number_node "42" 1 1)
    let id: ASTIdentifier = (create_identifier_node "x" 1 5)
    
    /* If we got here without crashes, structures work! */
    return 0
}

shadow test_parser_structure {
    assert (== (test_parser_structure) 0)
}

/* =============================================================================
 * PARSER ACCESSOR FUNCTIONS - For cross-module AST access
 * =============================================================================
 * These functions provide access to Parser AST data for type checker and
 * transpiler. They work around the generic List instantiation issue by
 * providing explicit accessor methods.
 */

/* Get number of functions in the parser */
pub fn parser_get_function_count(p: Parser) -> int {
    return (list_ASTFunction_length p.functions)
}

shadow parser_get_function_count {
    let empty_tokens: List<LexerToken> = (list_LexerToken_new)
    let p: Parser = (parser_new empty_tokens 0)
    assert (== (parser_get_function_count p) 0)
}

/* Get a function by index */
pub fn parser_get_function(p: Parser, idx: int) -> ASTFunction {
    return (list_ASTFunction_get p.functions idx)
}

/* Get number of let statements */
pub fn parser_get_let_count(p: Parser) -> int {
    return (list_ASTLet_length p.lets)
}

/* Get a let statement by index */
pub fn parser_get_let(p: Parser, idx: int) -> ASTLet {
    return (list_ASTLet_get p.lets idx)
}

/* Get number of identifiers */
pub fn parser_get_identifier_count(p: Parser) -> int {
    return (list_ASTIdentifier_length p.identifiers)
}

/* Get an identifier by index */
pub fn parser_get_identifier(p: Parser, idx: int) -> ASTIdentifier {
    return (list_ASTIdentifier_get p.identifiers idx)
}

/* Get number of numbers */
pub fn parser_get_number_count(p: Parser) -> int {
    return (list_ASTNumber_length p.numbers)
}

/* Get a number by index */
pub fn parser_get_number(p: Parser, idx: int) -> ASTNumber {
    return (list_ASTNumber_get p.numbers idx)
}

/* Get number of floats */
pub fn parser_get_float_count(p: Parser) -> int {
    return (list_ASTFloat_length p.floats)
}

/* Get a float by index */
pub fn parser_get_float(p: Parser, idx: int) -> ASTFloat {
    return (list_ASTFloat_get p.floats idx)
}

/* Get number of binary operations */
pub fn parser_get_binary_op_count(p: Parser) -> int {
    return (list_ASTBinaryOp_length p.binary_ops)
}

/* Get a binary operation by index */
pub fn parser_get_binary_op(p: Parser, idx: int) -> ASTBinaryOp {
    return (list_ASTBinaryOp_get p.binary_ops idx)
}

/* Get number of return statements */
pub fn parser_get_return_count(p: Parser) -> int {
    return (list_ASTReturn_length p.returns)
}

/* Get a return statement by index */
pub fn parser_get_return(p: Parser, idx: int) -> ASTReturn {
    return (list_ASTReturn_get p.returns idx)
}

/* Get number of blocks */
pub fn parser_get_block_count(p: Parser) -> int {
    return (list_ASTBlock_length p.blocks)
}

/* Get a block by index */
pub fn parser_get_block(p: Parser, idx: int) -> ASTBlock {
    return (list_ASTBlock_get p.blocks idx)
}

/* Get an if statement by index */
pub fn parser_get_if(p: Parser, idx: int) -> ASTIf {
    return (list_ASTIf_get p.ifs idx)
}

/* Get number of if statements */
pub fn parser_get_if_count(p: Parser) -> int {
    return (list_ASTIf_length p.ifs)
}

/* Get a while loop by index */
pub fn parser_get_while(p: Parser, idx: int) -> ASTWhile {
    return (list_ASTWhile_get p.whiles idx)
}

/* Get number of while loops */
pub fn parser_get_while_count(p: Parser) -> int {
    return (list_ASTWhile_length p.whiles)
}

/* Get a call by index */
pub fn parser_get_call(p: Parser, idx: int) -> ASTCall {
    return (list_ASTCall_get p.calls idx)
}

/* Get number of calls */
pub fn parser_get_call_count(p: Parser) -> int {
    return (list_ASTCall_length p.calls)
}

/* Get number of call argument refs */
pub fn parser_get_call_arg_count(p: Parser) -> int {
    return (list_ASTStmtRef_length p.call_args)
}

/* Get a call argument ref by index */
pub fn parser_get_call_arg(p: Parser, idx: int) -> ASTStmtRef {
    return (list_ASTStmtRef_get p.call_args idx)
}

/* Get a set statement by index */
pub fn parser_get_set(p: Parser, idx: int) -> ASTSet {
    return (list_ASTSet_get p.sets idx)
}

/* Get number of set statements */
pub fn parser_get_set_count(p: Parser) -> int {
    return (list_ASTSet_length p.sets)
}

/* Get number of strings */
pub fn parser_get_string_count(p: Parser) -> int {
    return (list_ASTString_length p.strings)
}

/* Get a string by index */
pub fn parser_get_string(p: Parser, idx: int) -> ASTString {
    return (list_ASTString_get p.strings idx)
}

/* Get number of bools */
pub fn parser_get_bool_count(p: Parser) -> int {
    return (list_ASTBool_length p.bools)
}

/* Get a bool by index */
pub fn parser_get_bool(p: Parser, idx: int) -> ASTBool {
    return (list_ASTBool_get p.bools idx)
}

/* Get number of asserts */
pub fn parser_get_assert_count(p: Parser) -> int {
    return (list_ASTAssert_length p.asserts)
}

/* Get an assert by index */
pub fn parser_get_assert(p: Parser, idx: int) -> ASTAssert {
    return (list_ASTAssert_get p.asserts idx)
}

/* Get number of block statement refs */
pub fn parser_get_block_statement_count(p: Parser) -> int {
    return (list_ASTStmtRef_length p.block_statements)
}

/* Get a block statement ref by index */
pub fn parser_get_block_statement(p: Parser, idx: int) -> ASTStmtRef {
    return (list_ASTStmtRef_get p.block_statements idx)
}

/* Get number of field accesses */
pub fn parser_get_field_access_count(p: Parser) -> int {
    return (list_ASTFieldAccess_length p.field_accesses)
}

/* Get a field access by index */
pub fn parser_get_field_access(p: Parser, idx: int) -> ASTFieldAccess {
    return (list_ASTFieldAccess_get p.field_accesses idx)
}

/* Get number of array literals */
pub fn parser_get_array_literal_count(p: Parser) -> int {
    return (list_ASTArrayLiteral_length p.array_literals)
}

/* Get an array literal by index */
pub fn parser_get_array_literal(p: Parser, idx: int) -> ASTArrayLiteral {
    return (list_ASTArrayLiteral_get p.array_literals idx)
}

/* Update the element_type of an existing array literal (used for type-driven propagation) */
pub fn parser_set_array_literal_element_type(p: Parser, idx: int, element_type: string) -> Parser {
    let old: ASTArrayLiteral = (list_ASTArrayLiteral_get p.array_literals idx)
    let updated: ASTArrayLiteral = ASTArrayLiteral {
        node_type: old.node_type,
        line: old.line,
        column: old.column,
        element_type: element_type,
        element_start: old.element_start,
        element_count: old.element_count
    }
    (list_ASTArrayLiteral_set p.array_literals idx updated)
    return p
}

/* Get number of array element refs */
pub fn parser_get_array_element_count(p: Parser) -> int {
    return (list_ASTStmtRef_length p.array_elements)
}

/* Get an array element ref by index */
pub fn parser_get_array_element(p: Parser, idx: int) -> ASTStmtRef {
    return (list_ASTStmtRef_get p.array_elements idx)
}

/* Get number of struct literals */
pub fn parser_get_struct_literal_count(p: Parser) -> int {
    return (list_ASTStructLiteral_length p.struct_literals)
}

/* Get a struct literal by index */
pub fn parser_get_struct_literal(p: Parser, idx: int) -> ASTStructLiteral {
    return (list_ASTStructLiteral_get p.struct_literals idx)
}

/* Get number of union constructions */
pub fn parser_get_union_construct_count(p: Parser) -> int {
    return (list_ASTUnionConstruct_length p.union_constructs)
}

/* Get a union construction by index */
pub fn parser_get_union_construct(p: Parser, idx: int) -> ASTUnionConstruct {
    return (list_ASTUnionConstruct_get p.union_constructs idx)
}

/* Get number of match expressions */
pub fn parser_get_match_count(p: Parser) -> int {
    return (list_ASTMatch_length p.matches)
}

/* Get a match expression by index */
pub fn parser_get_match(p: Parser, idx: int) -> ASTMatch {
    return (list_ASTMatch_get p.matches idx)
}

/* Get number of tuple literals */
pub fn parser_get_tuple_literal_count(p: Parser) -> int {
    return (list_ASTTupleLiteral_length p.tuple_literals)
}

/* Get a tuple literal by index */
pub fn parser_get_tuple_literal(p: Parser, idx: int) -> ASTTupleLiteral {
    return (list_ASTTupleLiteral_get p.tuple_literals idx)
}

/* Get number of tuple indices */
pub fn parser_get_tuple_index_count(p: Parser) -> int {
    return (list_ASTTupleIndex_length p.tuple_indices)
}

/* Get a tuple index by index */
pub fn parser_get_tuple_index(p: Parser, idx: int) -> ASTTupleIndex {
    return (list_ASTTupleIndex_get p.tuple_indices idx)
}

/* Get number of imports */
pub fn parser_get_import_count(p: Parser) -> int {
    return (list_ASTImport_length p.imports)
}

/* Get an import by index */
pub fn parser_get_import(p: Parser, idx: int) -> ASTImport {
    return (list_ASTImport_get p.imports idx)
}

