/* =============================================================================
 * Compiler Extern Functions - C Integration Layer
 * =============================================================================
 * These extern functions expose the C compiler's functionality to nanolang.
 * This allows a nanolang program to orchestrate compilation using the proven
 * C implementation.
 * 
 * This is the bridge for Option 3: Use C compiler internals to build Stage 1.
 */

/* Note: Using int for handles since opaque types don't transpile correctly yet */

/* =============================================================================
 * PHASE 1: LEXING
 * ============================================================================= */

/* Tokenize source code into tokens
 * Returns handle to token list (NULL/0 on error)
 */
extern fn nl_compiler_tokenize(source: string) -> int

/* Get number of tokens */
extern fn nl_compiler_token_count(tokens: int) -> int

/* Free token list */
extern fn nl_compiler_free_tokens(tokens: int) -> void

/* =============================================================================
 * PHASE 2: PARSING
 * ============================================================================= */

/* Parse tokens into AST
 * Returns handle to AST (NULL/0 on error)
 */
extern fn nl_compiler_parse(tokens: int, token_count: int) -> int

/* Free AST */
extern fn nl_compiler_free_ast(ast: int) -> void

/* =============================================================================
 * PHASE 3: TYPE CHECKING
 * ============================================================================= */

/* Create environment for type checking */
extern fn nl_compiler_create_env() -> int

/* Process imports and load modules */
extern fn nl_compiler_process_imports(ast: int, env: int, input_file: string) -> int

/* Type check AST
 * Returns 1 on success, 0 on error
 */
extern fn nl_compiler_typecheck(ast: int, env: int) -> int

/* Free environment */
extern fn nl_compiler_free_env(env: int) -> void

/* =============================================================================
 * PHASE 4: SHADOW TESTS
 * ============================================================================= */

/* Run shadow tests
 * Returns 1 on success, 0 on error
 */
extern fn nl_compiler_run_shadow_tests(ast: int, env: int) -> int

/* =============================================================================
 * PHASE 5: CODE GENERATION
 * ============================================================================= */

/* Transpile AST to C code
 * Returns C code as string (empty string on error)
 */
extern fn nl_compiler_transpile(ast: int, env: int) -> string

/* =============================================================================
 * PHASE 6: COMPILATION
 * ============================================================================= */

/* Compile C code to executable
 * Returns 0 on success, non-zero on error
 */
extern fn nl_compiler_compile_c(
    c_code: string,
    output_file: string,
    verbose: int
) -> int

/* =============================================================================
 * ALL-IN-ONE COMPILATION
 * ============================================================================= */

/* High-level compilation function that does everything
 * Returns 0 on success, non-zero on error
 */
extern fn nl_compiler_compile_file(
    input_file: string,
    output_file: string,
    verbose: int,
    keep_c: int
) -> int
